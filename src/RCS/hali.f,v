head	1.32;
access;
symbols
	pre_mrcs:1.31
	healthdept_2018:1.31
	pre_getangas:1.25
	GPL2010:1.25
	pre_GPL2010:1.24
	pre_var_equation:1.24
	pre_fftwrings:1.23
	pre_opfiles:1.23
	src:1.23
	best-code:1.23
	x-named-regs:1.22
	x:1.22
	v13-00:1.22
	pre_GPL:1.20
	prec_CA:1.16
	noindx:1.14
	Bproc:1.14
	oct21:1.7
	last77:1.6;
locks; strict;
comment	@c @;


1.32
date	2025.11.10.22.33.19;	author dean;	state Exp;
branches;
next	1.31;

1.31
date	2018.10.03.14.34.07;	author leith;	state Exp;
branches;
next	1.30;

1.30
date	2014.07.31.14.21.57;	author leith;	state Exp;
branches;
next	1.29;

1.29
date	2012.03.21.16.30.34;	author leith;	state Exp;
branches;
next	1.28;

1.28
date	2012.03.19.16.19.12;	author leith;	state Exp;
branches;
next	1.27;

1.27
date	2012.03.15.14.05.49;	author leith;	state Exp;
branches;
next	1.26;

1.26
date	2012.03.15.13.49.21;	author leith;	state Exp;
branches;
next	1.25;

1.25
date	2010.06.24.13.25.53;	author leith;	state Exp;
branches;
next	1.24;

1.24
date	2008.06.18.15.04.02;	author leith;	state Exp;
branches;
next	1.23;

1.23
date	2006.03.17.14.43.45;	author leith;	state Exp;
branches;
next	1.22;

1.22
date	2005.10.17.20.48.47;	author leith;	state Exp;
branches;
next	1.21;

1.21
date	2005.10.17.18.39.11;	author leith;	state Exp;
branches;
next	1.20;

1.20
date	2004.06.18.16.30.53;	author leith;	state Exp;
branches;
next	1.19;

1.19
date	2004.05.06.20.46.14;	author pawel;	state Exp;
branches;
next	1.18;

1.18
date	2004.02.27.20.02.25;	author pawel;	state Exp;
branches;
next	1.17;

1.17
date	2004.02.27.19.41.53;	author pawel;	state Exp;
branches;
next	1.16;

1.16
date	2003.02.24.16.57.35;	author leith;	state Exp;
branches;
next	1.15;

1.15
date	2003.02.20.19.40.16;	author leith;	state Exp;
branches;
next	1.14;

1.14
date	2000.07.12.19.22.00;	author leith;	state Exp;
branches;
next	1.13;

1.13
date	2000.07.12.16.35.44;	author leith;	state Exp;
branches;
next	1.12;

1.12
date	2000.02.22.16.18.55;	author bimal;	state Exp;
branches;
next	1.11;

1.11
date	2000.02.22.15.56.25;	author bimal;	state Exp;
branches;
next	1.10;

1.10
date	2000.02.18.15.38.09;	author bimal;	state Exp;
branches;
next	1.9;

1.9
date	2000.02.16.20.39.47;	author bimal;	state Exp;
branches;
next	1.8;

1.8
date	99.12.07.15.52.21;	author leith;	state Exp;
branches;
next	1.7;

1.7
date	99.06.03.20.50.53;	author pawel;	state Exp;
branches;
next	1.6;

1.6
date	99.03.01.14.46.11;	author pawel;	state Exp;
branches;
next	1.5;

1.5
date	97.10.31.19.32.53;	author hedget;	state Exp;
branches;
next	1.4;

1.4
date	97.10.17.15.18.56;	author pawel;	state Exp;
branches;
next	1.3;

1.3
date	97.10.09.14.29.33;	author pawel;	state Exp;
branches;
next	1.2;

1.2
date	95.04.12.14.49.36;	author pawel;	state Exp;
branches;
next	1.1;

1.1
date	95.03.17.20.15.37;	author mladjadj;	state Exp;
branches;
next	;


desc
@part of apca command
@


1.32
log
@*** empty log message ***
@
text
@C **********************************************************************
C
C HALI.F
C              RESTRICTION OF THE INTERPOLATION FIELD 10/13/89
C              QUADRATIC INTERPOLATION                07/09/93
C              OPFILEC                                02/24/03 al
C              CHKMIRROR                              06/18/08 al
C              HALI_P INSERTED                        03/21/12 al
C **********************************************************************
C=*                                                                    *
C=* This file is part of:   SPIDER - Modular Image Processing System.  *
C=* SPIDER System Authors:  Joachim Frank & ArDean Leith               *
C=* Copyright 1985-2010  Health Research Inc.,                         *
C=* Riverview Center, 150 Broadway, Suite 560, Menands, NY 12204.      *
C=* Email: spider@@wadsworth.org                                        *
C=*                                                                    *
C=* SPIDER is free software; you can redistribute it and/or            *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* SPIDER is distributed in the hope that it will be useful,          *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* merchantability or fitness for a particular purpose.  See the GNU  *
C=* General Public License for more details.                           *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program. If not, see <http://www.gnu.org/licenses> *
C=*                                                                    *
C **********************************************************************
C
C HALI
C
C23456789012345678901234567890123456789012345678901234567890123456789012
C--*********************************************************************

        SUBROUTINE HALI(ASKMIRROR)

        INCLUDE 'CMBLOCK.INC'
        INCLUDE 'CMLIMIT.INC'

        LOGICAL                :: ASKMIRROR

        INTEGER, ALLOCATABLE   :: NUMR(:,:)

        CHARACTER(LEN=MAXNAM)  :: FINPAT 
        CHARACTER(LEN=1)       :: MODE,ASK
        LOGICAL                :: NORM
        LOGICAL                :: CHKMIRROR

        LOGICAL                :: FOUROK = .FALSE.

        CHARACTER(LEN=1)       :: NULL = CHAR(0)

        INTEGER,PARAMETER      :: INPIC  = 21
        INTEGER,PARAMETER      :: LUNDOC = 80   
        INTEGER,PARAMETER      :: LUNXM  = 0  ! SELFILE NOT ALLOWED

        NILMAX = NIMAX

C       OPEN INPUT IMAGE(S)
        MAXIM = 0
        CALL OPFILES(0,INPIC,LUNDOC,LUNXM, 
     &             .TRUE.,FINPAT,NLET, 'O',
     &             IFORM,NX,NY,NZ,MAXIM,
     &             'INPUT FILE TEMPLATE (E.G. PIC****)~',
     &             FOUROK,INUMBR,NILMAX, 
     &             NDUM,NIMA,IMGNUM, IRTFLG) 
        IF (IRTFLG .NE. 0) RETURN

        !CLOSE(LUNIN) bug?? july 2014
        CLOSE(INPIC)

C       NIMA - TOTAL NUMBER OF IMAGES
        IF (NIMA > 0)  THEN
           WRITE(NOUT,2001) NIMA
2001       FORMAT('  Number of images: ',I5)
        ELSE
           CALL ERRT(101,'NO IMAGES',NDUM)
           GOTO 9999
        ENDIF
	
        MR    = 5
        NRAD  = MIN(NX/2-1, NY/2-1)
        NR    = NRAD
        ISKIP = -1    ! TRAP FOR OLD STYLE INPUT

        CALL RDPRI3S(MR,NR,ISKIP,NOT_USED,
     &       'FIRST, LAST RING, & RING SKIP,',IRTFLG)
        IF (IRTFLG .NE. 0)  GOTO 9999

        IF (ISKIP < 0) THEN
            CALL RDPRI1S(ISKIP,NOT_USED,'RING SKIP',IRTFLG)
            IF (IRTFLG .NE. 0)  GOTO 9999
        ENDIF
        ISKIP = MAX(1,ISKIP)

	IF (MR <= 0) THEN
	   CALL ERRT(101,'FIRST RING MUST BE > 0',NE)
	   GOTO 9999

	ELSEIF (NR < MR)  THEN 
	   CALL ERRT(102,'LAST RING MUST BE > ',MR)
	   GOTO 9999

	ELSEIF (NR >= NRAD)  THEN 
	   CALL ERRT(102,'LAST RING MUST BE < ',NRAD)
	   GOTO 9999
        ENDIF

        CALL  RDPRMC(ASK,NA,.TRUE.,
     &               'ANALYZE FULL OR HALF RING? (F/H)',
     &                NULL,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9999

        IF (ASK == 'F')  THEN
           MODE = 'F'
        ELSEIF (ASK == 'H')  THEN
           MODE = 'H'
        ELSE
	   CALL ERRT(101,'INVALID RESPONSE',NRAD)
	   GOTO 9999
        ENDIF

        CALL RDPRMC(ASK,NA,.TRUE.,'NORMALIZE UNDER MASK? (N/Y)',
     &              NULL,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9999
        NORM = (ASK == 'Y')   

        JACUP = 0   ! UNKNOWN PURPOSE al

        CALL RDPRI2S(NKMAX,MAXIT,NOT_USED,
     &          'NUMBER OF GROUPS, MAX. NUMBER OF ITERATIONS',IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9999

C       FIND TOTAL NUMBER OF RINGS
        NRING = 0
        DO I=MR,NR,ISKIP
           NRING = NRING + 1
        ENDDO

        ALLOCATE(NUMR(3,NRING), STAT=IRTFLG)
        IF (IRTFLG .NE. 0) THEN 
           CALL ERRT(46,'HALI; NUMR',3*NRING)
           GOTO 9999
        ENDIF

C       FILL RINGS POINTER
        NRING = 0
        DO I=MR,NR,ISKIP
           NRING         = NRING + 1
           NUMR(1,NRING) = I
        ENDDO

        CHKMIRROR = .FALSE.
        IF (ASKMIRROR) THEN
C          MUST ASK IF WANT TO CHECK MIRROR
           CALL RDPRMC(ASK,NA,.TRUE.,
     &          'CHECK MIRRORED POSITIONS? (N/Y)',NULL,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9999
           CHKMIRROR = (ASK(1:1)  == 'Y'  .OR. 
     &                  ASK(1:1) .NE. '0') 
        ENDIF
  
C       CALCULATION OF ACTUAL DIMENSION OF AN IMAGE TO BE INTERPOLATED
C       2*(No. OF RINGS)+(0'TH ELEMENT)+2*(MARGIN OF 1)

        NRA  = MIN(((NX-1)/2)*2+1, ((NY-1)/2)*2+1, 2*NR+3)
        LSAM = NX
        LROW = NY
        NX   = NRA
        NY   = NRA
        CALL ALPRBS(NUMR,NRING,LCIRC,MODE)

        MAXRIN = NUMR(3,NRING)

        CALL HALI_P(INUMBR,NX,NY,LSAM,LROW,NIMA,NRING,LCIRC,
     &        MAXRIN,JACUP,NUMR,NKMAX,MAXIT,MODE,CHKMIRROR,NORM,NOUT,
     &        FINPAT,NLET)
     
9999    IF (ALLOCATED(NUMR)) DEALLOCATE(NUMR)

        END

C ++********************************************************************
C                                                                      
C HALI_P.F                                                                   
C              OPFILEC                                02/24/03 al
C              FINPAT PARAMETER                       06/18/08 al
C                                                        
C **********************************************************************
C=*                                                                    *
C=* This file is part of:   SPIDER - Modular Image Processing System.  *
C=* SPIDER System Authors:  Joachim Frank & ArDean Leith               *
C=* Copyright 1985-2010  Health Research Inc.,                         *
C=* Riverview Center, 150 Broadway, Suite 560, Menands, NY 12204.      *
C=* Email: spider@@wadsworth.org                                        *
C=*                                                                    *
C=* SPIDER is free software; you can redistribute it and/or            *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* SPIDER is distributed in the hope that it will be useful,          *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* merchantability or fitness for a particular purpose.  See the GNU  *
C=* General Public License for more details.                           *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program. If not, see <http://www.gnu.org/licenses> *
C=*                                                                    *
C **********************************************************************
C                                                                      
C  HALI_P                                                                    
C                                                                      
C  PURPOSE:                                                            
C                                                                      
C  PARAMETERS:                                                         
C 
C23456789012345678901234567890123456789012345678901234567890123456789012
C***********************************************************************

        SUBROUTINE HALI_P(ILIST,NX,NY,LSAM,LROW,NIMA,NRING,
     &      LCIRC,MAXRIN,JACUP,NUMR,NKMAX,MAXIT,MODE,
     &      MIRROR,NORM,NOUT, FINPAT,NLET)

C       BUFIN,ROT,CIRNEW,TEMP,DIST,EC,CIROLD,CIRSEED,ES,E,IP,IQ
C       ARE AUTOMATIC ARRAYS

        INCLUDE 'CMLIMIT.INC'

        REAL, ALLOCATABLE    :: X(:,:),CIRC(:,:)
        INTEGER              :: MAXRIN,MAXRI,NUMR(3,NRING)
        REAL                 :: BUFIN(LSAM),CIROLD(LCIRC),CIRNEW(LCIRC)
	INTEGER              :: KLIST(1)
        DOUBLE PRECISION     :: TEMP(MAXRIN,2),ENER,TOTMIN,TOTMIM,SOLD
        DOUBLE PRECISION     :: SNEW,EAV,EC(NIMA)
        DIMENSION            :: DIST(NIMA),ROT(NIMA)
        DIMENSION            :: ILIST(NIMA),DLIST(5)

        CHARACTER(LEN=*)     :: FINPAT
        CHARACTER(LEN=MAXNAM):: FINPIC,FINP,OUTDOC,OUTPAT
        CHARACTER(LEN=MAXNAM):: MSG
        INTEGER              :: NLET

        COMMON  /MXR/  MAXRI  ! DANGER USED IN ANG( FUNCTION al

        LOGICAL              :: CH_ANG,NORM
        CHARACTER*1          :: MODE
        LOGICAL              :: MIRROR,NEWFILE

        INTEGER,PARAMETER    :: INPIC  = 22
        INTEGER,PARAMETER    :: LUNDOC = 80   

C  --------------------------------------------
C       USED ONLY IN  HKMC
        INTEGER*2            :: IP(NIMA),IQ(NKMAX)
        DIMENSION            :: CIRSEED(LCIRC,NKMAX)
        DOUBLE PRECISION     :: E(NKMAX),ES(NKMAX)
C  --------------------------------------------

        MAXRI = MAXRIN

        LQ  = LROW/2+1
        LR1 = (NY-1)/2
        LR2 = LQ+LR1
        LR1 = LQ-LR1
        LQ  = LSAM/2+1
        LS1 = (NX-1)/2
        LS2 = LQ+LS1
        LS1 = LQ-LS1

        ALLOCATE(X(NX,NY), 
     &           CIRC(LCIRC,NIMA), STAT=IRTFLG)
        IF (IRTFLG .NE. 0) THEN 
           MWANT = NX*NY + LCIRC*NIMA
           CALL ERRT(46,'AP C; X & CIRC',MWANT)
           RETURN
        ENDIF

        DO K1=1,NIMA
           CALL FILGET(FINPAT,FINPIC,NLET,ILIST(K1),IRTFLG)
           IF (IRTFLG .NE. 0) THEN
              CALL ERRT(101,'FILE DOES NOT EXIST',NE)
              GOTO 9999
           ENDIF

           MAXIM = 0
           CALL OPFILEC(0,.FALSE.,FINPIC,INPIC,'O',IFORM,
     &                  NXT,NYT,NSL,
     &                  MAXIM,'DUMMY',.FALSE.,IRTFLG)
          IF (IRTFLG .NE. 0) GOTO 9999

           DO K2=LR1,LR2
              CALL REDLIN(INPIC,BUFIN,LSAM,K2)
              DO K3=LS1,LS2
                 X(K3-LS1+1,K2-LR1+1) = BUFIN(K3)
              ENDDO
           ENDDO
           CLOSE(INPIC)

C          NORMALIZE IF REQUESTED                                       
           IF (NORM) CALL NORMAS(X,-NX/2,NX/2,-NY/2,NY/2,
     &                          NUMR,NUMR(1,NRING))

           CALL ALRQ(X,NX,NY,NUMR,CIRC(1,K1),LCIRC,NRING,MODE,K1)

           CALL FOURING(CIRC(1,K1),LCIRC,NUMR,NRING,EC(K1),MODE)
        ENDDO

C       BUILD FIRST AVERAGE

C       DIST  IS USED HERE FOR THE RANDOM CHOOSING OF IMAGES
        DIST = 0.0

        CALL RANDOM_NUMBER(CIID)
        IMI = MIN(NIMA,MAX(1,INT(CIID*NIMA+0.5)))

        CIROLD    = CIRC(:,IMI)
        ROT(IMI)  = 1.0
        DIST(IMI) = 1.0
        SOLD      = 0.0D0
        EAV       = EC(IMI)

        DO KTN=2,NIMA

804        CALL RANDOM_NUMBER(CIID) 
           M = MIN(NIMA, MAX(1,INT(CIID*(NIMA-KTN+1)+0.5)))

           IMI = 0
           DO I=1,NIMA
              IF (DIST(I) .NE. 1.0)  THEN
                 IMI = IMI + 1
                 IF (IMI .EQ. M)  GOTO  810
              ENDIF
           ENDDO
           GOTO  804

810        IMI       = I
           DIST(IMI) = 1.0

           CALL CROSRNG(CIROLD,CIRC(1,IMI),LCIRC,NRING,TEMP,TEMP(1,2),
     &                  MAXRIN,JACUP,NUMR,TOTMIN,TOT,MODE)
	   IF (MIRROR)  THEN
              CALL CROSRMG(CIROLD,CIRC(1,IMI),LCIRC,NRING,
     &                     TEMP,TEMP(1,2),
     &                     MAXRIN,JACUP,NUMR,TOTMIM,TMT,MODE)
              IF (TMT > TOT)  THEN
                 ROT(IMI) = -TMT
                 SOLD     = SOLD+EAV+EC(IMI)-2.0*TOTMIM

                 CALL UPDTM(CIROLD,CIRC(1,IMI),LCIRC,NRING,NUMR,TOT,
     &                      MAXRIN,KTN)
                 GOTO 151
              ENDIF
           ENDIF

           ROT(IMI) = TOT
           SOLD     = SOLD + EAV + EC(IMI) - 2.0 * TOTMIN

           CALL UPDTC(CIROLD,CIRC(1,IMI),LCIRC,NRING,NUMR,TOT,
     &                 MAXRIN,KTN)

 151       EAV = ENER(CIROLD,LCIRC,NRING,NUMR,MODE)
            
        ENDDO


        CIRNEW = CIROLD
        ROT = 0.0

C       WRITE(NOUT,*)    SOLD*FLOAT(NIMA)/(NIMA-1)
C       WRITE(NOUT,2001) (ANG(ROT(J),MODE),J=1,NIMA)

C       ITERATIONS TO GET BETTER APPROXIMATION

        ITER = 0

901     CONTINUE
        ITER   = ITER+1
        CH_ANG = .FALSE.
        SNEW   = 0.0D0
C
        DO IMI=1,NIMA
           CALL CROSRNG(CIROLD,CIRC(1,IMI),LCIRC,NRING,TEMP,TEMP(1,2),
     &            MAXRIN,JACUP,NUMR,TOTMIN,TOT,MODE)

	   IF (MIRROR)  THEN
              CALL CROSRMG(CIROLD,CIRC(1,IMI),LCIRC,NRING,TEMP,
     &                      TEMP(1,2),MAXRIN,JACUP,NUMR,TOTMIM,TMT,MODE)
              IF (TMT .GT. TOT)  THEN
                 IF (ROT(IMI) .NE. -TMT) THEN
                    CH_ANG   = .TRUE.
                    ROT(IMI) = -TMT
                 ENDIF
                 CALL UPDTM(CIRNEW,CIRC(1,IMI),LCIRC,NRING,NUMR,
     &                  TMT,MAXRIN,IMI)
                 TOTMIN = TOTMIM
                 GOTO  152
              ENDIF
           ENDIF

           IF (ROT(IMI) .NE. TOT) THEN
              CH_ANG   = .TRUE.
              ROT(IMI) = TOT
           ENDIF
           CALL UPDTC(CIRNEW,CIRC(1,IMI),LCIRC,NRING,NUMR,TOT,
     &                MAXRIN,IMI)
152        SNEW      = SNEW+EAV+EC(IMI)-2.0*TOTMIN
           DIST(IMI) = EAV+EC(IMI)-2.0*TOTMIN
        ENDDO

        WRITE(NOUT,2020) ITER,SNEW
2020    FORMAT('  Iteration #',I3,'  Sum of distances=',1PD13.6)

        IF (SNEW.LE.SOLD .AND. CH_ANG)  THEN
           CIROLD = CIRNEW
           EAV    = ENER(CIROLD,LCIRC,NRING,NUMR,MODE)
           SOLD   = SNEW
           GOTO 901
        ENDIF

cc        IF (VERBOSE)
cc     &    WRITE(NOUT,2001) (SIGN(ANG(ABS(ROT(J)),MODE),ROT(J)),J=1,NIMA)
cc2001    FORMAT(8(1X,F8.3))

        CALL SEEDS(CIRSEED,CIRC,DIST,NKMAX,LCIRC,IP,NIMA,NOUT)

        CALL HKMC(CIRSEED,CIRC,CIRNEW,NKMAX,LCIRC,IP,IQ,ES,EC,E,
     &             DIST,ROT,NRING,TEMP,MAXRIN,JACUP,NUMR,MAXIT,
     &             NIMA,MODE,SNEW,NOUT,MIRROR)

        NMAX = 0
        CALL FILSEQP(OUTPAT,NLET,KLIST,NMAX,NIXX,
     &          'GROUP SELECTION FILE TEMPLATE',IRTFLG)

C                  123456789 123456789 123456789 123456789 123456789
        MSG = '         FILE#'

	DO II=1,NKMAX
C           MAKE GROUP SELECTION FILENAME 
	    CALL FILGET(OUTPAT,OUTDOC,NLET,II,IRTFLG)

C           OPEN GROUP SELECTION OUTPUT DOC FILE 
            CALL OPENDOC(OUTDOC,.TRUE.,NLET,LUNDOC,LUNDOCO,.FALSE.,
     &                   ' ',
     &                   .FALSE.,.FALSE.,.TRUE.,NEWFILE,IRTFLG)
            IF (IRTFLG .NE. 0)  GOTO 9999

            CALL LUNDOCPUTCOM(LUNDOCO,MSG,IRTFLG)

	    KEY = 0
	    DO IIII=1,NIMA
		IF (IP(IIII) == II) THEN
	    	   KEY      = KEY + 1
		   DLIST(1) = ILIST(IIII)
                   CALL LUNDOCWRTDAT(LUNDOC,KEY,DLIST,1,IRTFLG)

		   !CALL SAVDN1(LUNDOCO,FINP,DLIST,NLS,III-1,IAP)
		ENDIF
	   ENDDO
	   CLOSE(LUNDOC)
	ENDDO

C       OPEN ALIGNMENT OUTPUT DOC FILE 
        CALL OPENDOC(OUTDOC,.TRUE.,NLET,LUNDOC,LUNDOCO,.TRUE.,
     &                   'ROTATIONAL ALIGNMENT DOC FILE',
     &              .FALSE.,.FALSE.,.TRUE.,NEWFILE,IRTFLG)
        IF (IRTFLG .NE. 0)  GOTO 9999

C            123456789 123456789 123456789 123456789 123456789
        MSG='         FILE#         ANGLE      DIST/MIR         GROUP'
        CALL LUNDOCPUTCOM(LUNDOCO,MSG,IRTFLG)

        I = 0
        DO IMI=1,NIMA
           I = I + 1
712        IF (ILIST(I) == -1)  THEN
              I = I + 1
              GOTO 712
           ENDIF
   
           DLIST(1) = ILIST(I)
           DLIST(2) = ANG(ABS(ROT(IMI)),MODE)  ! FUNCTION CALL
           DLIST(3) = SIGN(DIST(IMI),ROT(IMI))
           DLIST(4) = IP(IMI)

           CALL LUNDOCWRTDAT(LUNDOC,IMI,DLIST,4,IRTFLG)
        ENDDO
        CLOSE(LUNDOC)

9999    IF (ALLOCATED(X))     DEALLOCATE(X)
        IF (ALLOCATED(CIRC))  DEALLOCATE(CIRC)

        END


C       ---------------------- UPDTM ------------------------------

        SUBROUTINE UPDTM(CIRC1,CIRC2,LCIRC,NRING,NUMR,TOT,MAXRIN,IS)

        DIMENSION  :: CIRC1(LCIRC),CIRC2(LCIRC)
        INTEGER    :: NUMR(3,NRING),MAXRIN
        COMPLEX    :: C

        PI2 = 8.0D0*DATAN(1.0D0)

c$omp   parallel do private(i,j,nsirt,arg,c)
        DO I=1,NRING
           NSIRT = NUMR(3,I)

           CIRC1(NUMR(2,I)) =
     &        (CIRC1(NUMR(2,I))*(IS-1)+CIRC2(NUMR(2,I)))/REAL(IS)

           CIRC1(NUMR(2,I)+1) =
     &        (CIRC1(NUMR(2,I)+1)*(IS-1)+CIRC2(NUMR(2,I)+1)*
     &        COS(PI2*(TOT-1.0)/2.0
     &        *REAL(NSIRT)/REAL(MAXRIN)))/REAL(IS)

           DO J=3,NSIRT,2
              ARG = PI2*(TOT-1.0)*REAL(J/2)/REAL(MAXRIN)

              C   = CMPLX(CIRC2(NUMR(2,I)+J-1),-CIRC2(NUMR(2,I)+J))*
     &              CMPLX(COS(ARG),SIN(ARG))

              CIRC1(NUMR(2,I)+J-1) =
     &              (CIRC1(NUMR(2,I)+J-1)*(IS-1)+REAL(C))/REAL(IS)

              CIRC1(NUMR(2,I)+J) =
     &              (CIRC1(NUMR(2,I)+J)*(IS-1)+AIMAG(C))/REAL(IS)
           ENDDO
        ENDDO

        END
@


1.31
log
@email_health_dept
@
text
@d15 1
a15 1
C=* Email: spider@@health.ny.gov                                        *
d196 1
a196 1
C=* Email: spider@@health.ny.gov                                        *
@


1.30
log
@!CLOSE(LUNIN) bug?? j
@
text
@d15 1
a15 1
C=* Email: spider@@wadsworth.org                                        *
d196 1
a196 1
C=* Email: spider@@wadsworth.org                                        *
@


1.29
log
@combined hali & hali_p  ,  rewrite hali.f
@
text
@d70 2
a71 1
        CLOSE(LUNIN)
@


1.28
log
@bad iii - > key
@
text
@d1 182
d220 1
a220 1
        SUBROUTINE HALI_P(ILIST,NSAM,NROW,LSAM,LROW,NIMA,NRING,
a229 1
        PARAMETER  (NLIST=5)
d236 1
a236 1
        DIMENSION            :: ILIST(NIMA),DLIST(NLIST)
d254 3
a256 3
        INTEGER*2                         :: IP(NIMA),IQ(NKMAX)
        DIMENSION                         :: CIRSEED(LCIRC,NKMAX)
        DOUBLE PRECISION                  :: E(NKMAX),ES(NKMAX)
d262 1
a262 1
        LR1 =( NROW-1)/2
d266 1
a266 1
        LS1 = (NSAM-1)/2
d270 1
a270 1
        ALLOCATE(X(NSAM,NROW), 
d273 1
a273 1
           MWANT = NSAM*NROW + LCIRC*NIMA
d287 1
a287 1
     &                  NSAMT,NROWT,NSL,
d289 1
a289 1
          IF (IRTFLG .NE. 0)   GOTO 9999
d300 1
a300 1
           IF (NORM) CALL NORMAS(X,-NSAM/2,NSAM/2,-NROW/2,NROW/2,
d303 1
a303 1
           CALL ALRQ(X,NSAM,NROW,NUMR,CIRC(1,K1),LCIRC,NRING,MODE,K1)
d464 1
a464 1
     &                   'CLASSIFICATION & ALIGNMENT DOC FILE',
d478 2
a479 1
           ENDIF   
d481 1
a481 1
           DLIST(2) = ANG(ABS(ROT(IMI)),MODE)
d484 1
@


1.27
log
@output file formating of doc file comment
@
text
@d271 1
a271 1
	    	   KEY      = III + 1
@


1.26
log
@modernized, output formatting
@
text
@d254 1
a254 1
        MSG = '            FILE#'
d266 1
a266 1
            CALL LUNDOCPUTCOM(NICDOCO,MSG,IRTFLG)
d271 3
a273 3
	    	    KEY      = III + 1
		    DLIST(1) = ILIST(IIII)
                    CALL LUNDOCWRTDAT(LUNDOC,KEY,DLIST,1,IRTFLG)
d275 1
a275 1
		    !CALL SAVDN1(LUNDOCO,FINP,DLIST,NLS,III-1,IAP)
d287 3
a289 3
C              123456789 123456789 123456789 123456789 123456789
        MSG = '            FILE#       ANGLE     DIST/MIR     GROUP'
        CALL LUNDOCPUTCOM(NICDOCO,MSG,IRTFLG)
d302 1
a302 1
           CALL LUNDOCWRTDAT(LUNDOCO,IMI,DLIST,4,IRTFLG)
@


1.25
log
@GPL_2010
@
text
@d39 2
a40 2
     &      LCIRC,MAXRIN,JACUP,NUMR,NKMAX,MAXIT,MODE,MIRROR,NORM,NOUT,
     &      FINPAT,NLET)
d47 1
a47 1
        REAL, ALLOCATABLE, DIMENSION(:,:) :: X,CIRC
d49 12
a60 11
        INTEGER                           :: MAXRIN,MAXRI,NUMR(3,NRING)
        DIMENSION  BUFIN(LSAM),CIROLD(LCIRC),CIRNEW(LCIRC)
	INTEGER                           :: KLIST(1)
        DOUBLE PRECISION                  :: TEMP(MAXRIN,2),
     &          ENER,TOTMIN,TOTMIM,SOLD,SNEW,EAV,EC(NIMA)
        DIMENSION                         :: DIST(NIMA),ROT(NIMA)
        DIMENSION                         :: ILIST(NIMA),DLIST(NLIST)

        CHARACTER(LEN=*)                  :: FINPAT
        CHARACTER(LEN=MAXNAM)             :: FINPIC,FINP
        INTEGER                           :: NLET
d64 6
a69 2
        LOGICAL*1                         :: CH_ANG,NORM
        CHARACTER*1                       :: MODE,MIRROR
a77 2
        DATA  INPIC/77/,NDOC/55/

d80 8
a87 8
        LQ=LROW/2+1
        LR1=(NROW-1)/2
        LR2=LQ+LR1
        LR1=LQ-LR1
        LQ=LSAM/2+1
        LS1=(NSAM-1)/2
        LS2=LQ+LS1
        LS1=LQ-LS1
d89 2
a90 1
        ALLOCATE(X(NSAM,NROW), CIRC(LCIRC,NIMA), STAT=IRTFLG)
d93 1
a93 1
           CALL ERRT(46,'AP C, X & CIRC',MWANT)
d98 3
a100 3
           CALL FILGET(FINPAT,FINPIC,NLET,ILIST(K1),INTFLAG)
           IF (INTFLAG .NE. 0) THEN
              CALL ERRT(18,'AP C ',NE)
d160 1
a160 1
	   IF (MIRROR .EQ. 'M')  THEN
d164 1
a164 1
              IF (TMT .GT. TOT)  THEN
d204 1
a204 1
	   IF (MIRROR .EQ. 'M')  THEN
d230 1
a230 1
2020    FORMAT(' Iteration #',I3,'  Sum of distances=',1PD13.6)
d239 3
a241 2
        WRITE(NOUT,2001) (SIGN(ANG(ABS(ROT(J)),MODE),ROT(J)),J=1,NIMA)
2001    FORMAT(8(1X,F8.3))
d244 1
d250 5
a254 2
        CALL FILSEQP(FINPAT,NLET,KLIST,NMAX,NIXX,
     &          'OBJECT OUTPUT FILENAME TEMPLATE',IRTFLG)
d257 12
a268 3
	    CALL FILGET(FINPAT,FINP,NLET,II,IRTFLG)
	    III = 0
	    NLS = 2
d270 6
a275 6
		IF (IP(IIII) .EQ. II) THEN
	    	    III      = III + 1
		    DLIST(1) = III
		    DLIST(2) = ILIST(IIII)
		    IAP      = 0
		    CALL SAVDN1(NDOC,FINP,DLIST,NLS,III-1,IAP)
d278 1
a278 1
	CLOSE(NDOC)
d281 10
d293 3
a295 3
           I = I+1
712        IF (ILIST(I) .EQ. -1)  THEN
              I = I+1
d298 5
a302 6
           DLIST(1) = IMI
           DLIST(2) = ILIST(I)
           DLIST(3) = ANG(ABS(ROT(IMI)),MODE)
           DLIST(4) = SIGN(DIST(IMI),ROT(IMI))
           DLIST(5) = IP(IMI)
           CALL SAVD(NDOC,DLIST,NLIST,IRTFLG)
d304 1
a304 2
        CALL SAVDC
        CLOSE(NDOC)
d306 2
a307 2
9999    IF (ALLOCATED(X))      DEALLOCATE(X)
        IF (ALLOCATED(CIRC))   DEALLOCATE(CIRC)
@


1.24
log
@combined ap ca & ap cm, cosmetic
@
text
@a7 2
C=* FROM: SPIDER - MODULAR IMAGE PROCESSING SYSTEM.   AUTHOR: J.FRANK  *
C=* Copyright (C) 1985-2008  Health Research Inc.                      *
d9 5
a13 2
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *   
C=* ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
d15 1
a15 3
C=* Email:  spider@@wadsworth.org                                       *
C=*                                                                    *
C=* This program is free software; you can redistribute it and/or      *
d20 1
a20 1
C=* This program is distributed in the hope that it will be useful,    *
d22 1
a22 1
C=* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
a23 1
C=*                                                                    *
d25 1
a25 3
C=* along with this program; if not, write to the                      *
C=* Free Software Foundation, Inc.,                                    *
C=* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.      *
@


1.23
log
@DLIST(2) = IIII
@
text
@d5 2
a6 1
C                                                                      
d9 1
a9 1
C=* Copyright (C) 1985-2005  Health Research Inc.                      *
a38 2
C IMAGE_PROCESSING_ROUTINE
C                                                                      
d43 2
a44 1
     &      LCIRC,MAXRIN,JACUP,NUMR,NKMAX,MAXIT,MODE,MIRROR,NORM,NOUT)
d49 2
d53 1
a53 1
        INTEGER    MAXRIN,MAXRI,NUMR(3,NRING)
d55 2
a56 2
	INTEGER*4  KLIST(1)
        DOUBLE PRECISION  TEMP(MAXRIN,2),
d58 2
a59 2
        DIMENSION  DIST(NIMA),ROT(NIMA)
        DIMENSION  ILIST(NIMA),DLIST(NLIST)
d61 3
a63 2
        CHARACTER*80  FINPIC,FINPAT,FINP
        COMMON  /F_SPEC/  FINPAT,FINPIC,NLET,FINP
d65 4
a68 1
        COMMON  /MXR/  MAXRI
a69 3
        LOGICAL*1   CH_ANG,NORM
        CHARACTER*1  MODE,MIRROR
        CHARACTER*8  ZEIT
d71 4
a74 4
C  Used only in  HKMC
        INTEGER*2        IP(NIMA),IQ(NKMAX)
        DIMENSION         CIRSEED(LCIRC,NKMAX)
        DOUBLE PRECISION  E(NKMAX),ES(NKMAX)
d76 1
d79 1
a79 1
        MAXRI=MAXRIN
d90 1
a90 1
        ALLOCATE (X(NSAM,NROW),CIRC(LCIRC,NIMA), STAT=IRTFLG)
d92 2
a93 1
           CALL ERRT(46,'AP CA, X & CIRC',IER)
d98 1
a98 1
           CALL  FILGET(FINPAT,FINPIC,NLET,ILIST(K1),INTFLAG)
d100 2
a101 3
              DEALLOCATE(X)
              CALL ERRT(18,'AP CA ',NE)
              RETURN
d108 1
a108 4
          IF (IRTFLG .NE. 0)  THEN
              DEALLOCATE(X)
              RETURN
           ENDIF
d113 1
a113 1
                 X(K3-LS1+1,K2-LR1+1)=BUFIN(K3)
d133 1
a133 1
        IMI       = MIN0(NIMA,MAX0(1,INT(CIID*NIMA+0.5)))
d144 1
a144 1
           M = MIN0(NIMA,MAX0(1,INT(CIID*(NIMA-KTN+1)+0.5)))
d158 1
a158 1
           CALL  CROSRNG(CIROLD,CIRC(1,IMI),LCIRC,NRING,TEMP,TEMP(1,2),
d160 1
a160 1
	   IF (MIRROR.EQ.'M')  THEN
d169 2
a170 2
     &                   MAXRIN,KTN)
                 GOTO  151
d173 1
d175 1
a175 1
           SOLD     = SOLD+EAV+EC(IMI)-2.0*TOTMIN
d180 1
a180 1
 151       EAV  = ENER(CIROLD,LCIRC,NRING,NUMR,MODE)
d185 2
a186 2
           CIRNEW = CIROLD
           ROT = 0.0
d188 2
a189 2
C       WRITE(NOUT,*)  SOLD*FLOAT(NIMA)/(NIMA-1)
C       WRITE(NOUT,2001)  (ANG(ROT(J),MODE),J=1,NIMA)
d197 1
a197 1
        CH_ANG =. FALSE.
d204 1
a204 1
	   IF (MIRROR.EQ.'M')  THEN
d214 1
a214 1
                 TOTMIN=TOTMIM
d250 1
d284 2
a285 1
        DEALLOCATE(X,CIRC)
d290 1
a290 1

d294 3
a296 3
        DIMENSION  CIRC1(LCIRC),CIRC2(LCIRC)
        INTEGER    NUMR(3,NRING),MAXRIN
        COMPLEX    C
@


1.22
log
@GPL License fixed
@
text
@d256 1
a256 1
		    DLIST(2) = IIII
@


1.21
log
@HRI GPL License used
@
text
@a6 1
C * SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK       *
d10 1
a10 1
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *  
a29 6

C * COPYRIGHT (C)1985, 1999. HEALTH RESEARCH INCORPORATED (HRI),       *
C * ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C * THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HRI AND ARE NOT   *
C * TO BE DISCLOSED TO OTHERS OR USED FOR PURPOSES OTHER THAN INTENDED *
C * WITHOUT WRITTEN APPROVAL OF HRI.                                   *
@


1.20
log
@terminology for object output template, & much cosmetic
@
text
@d8 24
@


1.19
log
@ap cm
m
@
text
@d52 2
a53 2
        INTEGER*2  IP(NIMA),IQ(NKMAX)
        DIMENSION  CIRSEED(LCIRC,NKMAX)
d77 2
a78 1
           IF (IRTFLG .NE. 0) THEN
a79 1
              DEALLOCATE (X,CIRC)     
d87 2
a88 4
          
           IF (IRTFLG .NE. 0)  THEN
              CALL ERRT(4,'AP CA ',NE)
              DEALLOCATE (X,CIRC)
d106 1
a106 1
           CALL FOURING (CIRC(1,K1),LCIRC,NUMR,NRING,EC(K1),MODE)
a111 1

d115 1
a115 1
        IMI = MIN0(NIMA,MAX0(1,INT(CIID*NIMA+0.5)))
d117 1
a117 1
        CIROLD = CIRC(:,IMI)
d142 15
a156 6
	   IF(MIRROR.EQ.'M')  THEN
           CALL  CROSRMG(CIROLD,CIRC(1,IMI),LCIRC,NRING,TEMP,TEMP(1,2),
     &                  MAXRIN,JACUP,NUMR,TOTMIM,TMT,MODE)
            IF(TMT.GT.TOT)  THEN
             ROT(IMI) = -TMT
             SOLD     = SOLD+EAV+EC(IMI)-2.0*TOTMIM
d158 1
a158 1
             CALL UPDTM(CIROLD,CIRC(1,IMI),LCIRC,NRING,NUMR,TOT,
a159 5
             GOTO  151
            ENDIF
           ENDIF
             ROT(IMI) = TOT
             SOLD     = SOLD+EAV+EC(IMI)-2.0*TOTMIN
a160 2
             CALL UPDTC(CIROLD,CIRC(1,IMI),LCIRC,NRING,NUMR,TOT,
     &                 MAXRIN,KTN)
d174 2
a175 1
        ITER=0
d177 3
a179 3
        ITER=ITER+1
        CH_ANG=.FALSE.
        SNEW=0.0D0
d181 2
a182 3
        DO    IMI=1,NIMA
           CALL  CROSRNG
     &           (CIROLD,CIRC(1,IMI),LCIRC,NRING,TEMP,TEMP(1,2),
d184 14
a197 12
	   IF(MIRROR.EQ.'M')  THEN
           CALL  CROSRMG(CIROLD,CIRC(1,IMI),LCIRC,NRING,TEMP,TEMP(1,2),
     &                  MAXRIN,JACUP,NUMR,TOTMIM,TMT,MODE)
            IF(TMT.GT.TOT)  THEN
             IF(ROT(IMI) .NE. -TMT)  THEN
              CH_ANG=.TRUE.
              ROT(IMI)=-TMT
             ENDIF
        CALL  UPDTM(CIRNEW,CIRC(1,IMI),LCIRC,NRING,NUMR,TMT,MAXRIN,IMI)
             TOTMIN=TOTMIM
             GOTO  152
            ENDIF
d199 4
a202 3
           IF (ROT(IMI) .NE. TOT)  THEN
              CH_ANG=.TRUE.
              ROT(IMI)=TOT
d204 4
a207 3
        CALL  UPDTC(CIRNEW,CIRC(1,IMI),LCIRC,NRING,NUMR,TOT,MAXRIN,IMI)
152        SNEW=SNEW+EAV+EC(IMI)-2.0*TOTMIN
           DIST(IMI)=EAV+EC(IMI)-2.0*TOTMIN
d212 2
a213 1
        IF(SNEW.LE.SOLD.AND.CH_ANG)  THEN
d215 3
a217 3
           EAV  = ENER(CIROLD,LCIRC,NRING,NUMR,MODE)
           SOLD = SNEW
           GOTO  901
d223 4
a226 4
        CALL  SEEDS(CIRSEED,CIRC,DIST,NKMAX,LCIRC,IP,NIMA,NOUT)
        CALL  HKMC
     &    (CIRSEED,CIRC,CIRNEW,NKMAX,LCIRC,IP,IQ,ES,EC,E,DIST,ROT,NRING,
     &          TEMP,MAXRIN,JACUP,NUMR,MAXIT,NIMA,MODE,SNEW,NOUT,MIRROR)
d229 2
a230 2
        CALL  FILSEQP(FINPAT,NLET,KLIST,NMAX,NIXX,
     &                'SELECTION FILENAME (ex: SEL***)',IRTFLG)
d233 2
a234 2
	    III=0
	    NLS=2
d236 5
a240 5
		IF(IP(IIII).EQ.II) THEN
	    	    III=III+1
		    DLIST(1)=III
		    DLIST(2)=IIII
		    IAP=0
d247 6
a252 6
        I=0
        DO    IMI=1,NIMA
           I=I+1
712        IF(ILIST(I).EQ.-1)  THEN
              I=I+1
              GOTO  712
d254 6
a259 6
           DLIST(1)=IMI
           DLIST(2)=ILIST(I)
           DLIST(3)=ANG(ABS(ROT(IMI)),MODE)
           DLIST(4)=SIGN(DIST(IMI),ROT(IMI))
           DLIST(5)=IP(IMI)
           CALL  SAVD(NDOC,DLIST,NLIST,IRTFLG)
d261 1
a261 1
        CALL  SAVDC
d264 1
a264 1
        DEALLOCATE (X,CIRC)
d268 1
a268 1
        SUBROUTINE  UPDTM(CIRC1,CIRC2,LCIRC,NRING,NUMR,TOT,MAXRIN,IS)
d270 3
d275 10
a284 2
        COMPLEX  C
        PI2=8.0D0*DATAN(1.0D0)
d286 16
a301 18
c$omp parallel do private(i,j,nsirt,arg,c)
        DO    I=1,NRING
           NSIRT=NUMR(3,I)
           CIRC1(NUMR(2,I))=
     &     (CIRC1(NUMR(2,I))*(IS-1)+CIRC2(NUMR(2,I)))/REAL(IS)
           CIRC1(NUMR(2,I)+1)=
     &     (CIRC1(NUMR(2,I)+1)*(IS-1)+CIRC2(NUMR(2,I)+1)*
     &     COS(PI2*(TOT-1.0)/2.0
     &     *REAL(NSIRT)/REAL(MAXRIN)))/REAL(IS)

           DO    J=3,NSIRT,2
              ARG=PI2*(TOT-1.0)*REAL(J/2)/REAL(MAXRIN)
              C=CMPLX(CIRC2(NUMR(2,I)+J-1),-CIRC2(NUMR(2,I)+J))*
     &        CMPLX(COS(ARG),SIN(ARG))
              CIRC1(NUMR(2,I)+J-1)=
     &        (CIRC1(NUMR(2,I)+J-1)*(IS-1)+REAL(C))/REAL(IS)
              CIRC1(NUMR(2,I)+J)=
     &        (CIRC1(NUMR(2,I)+J)*(IS-1)+AIMAG(C))/REAL(IS)
d304 1
@


1.18
log
@*** empty log message ***
@
text
@d27 1
a27 1
     &      LCIRC,MAXRIN,JACUP,NUMR,NKMAX,MAXIT,MODE,NORM,NOUT)
d38 1
a38 1
     &          ENER,TOTMIN,SOLD,SNEW,EAV,EC(NIMA)
d48 1
a48 1
        CHARACTER*1  MODE
d115 1
a115 4
c$omp   parallel do private(imi)
        DO IMI=1,NIMA
           DIST(IMI) = 0.0
        ENDDO
d120 1
a120 4
        DO    I=1,LCIRC
           CIROLD(I) = CIRC(I,IMI)
        ENDDO

d123 1
a123 1
        SOLD      = 0.0
d125 1
d145 14
a158 2
           ROT(IMI) = TOT
           SOLD     = SOLD+EAV+EC(IMI)-2.0*TOTMIN
d160 1
a160 1
           CALL UPDTC(CIROLD,CIRC(1,IMI),LCIRC,NRING,NUMR,TOT,
d162 2
a163 1
           EAV  = ENER(CIROLD,LCIRC,NRING,NUMR,MODE)
d167 2
a168 8
        DO I=1,LCIRC
           CIRNEW(I) = CIROLD(I)
        ENDDO

c$omp   parallel do private(imi)
        DO IMI=1,NIMA
           ROT(IMI) = 0.0
        ENDDO
d170 2
a171 2
C       WRITE(NOUT,  *,SOLD*FLOAT(NIMA)/(NIMA-1)
C       WRITE(NOUT,  2001,(ANG(ROT(J),MODE),J=1,NIMA)
d179 1
a179 1
        SNEW=0.0
d185 13
d202 2
a203 1
           SNEW=SNEW+EAV+EC(IMI)-2.0*TOTMIN
a204 1
        CALL  UPDTC(CIRNEW,CIRC(1,IMI),LCIRC,NRING,NUMR,TOT,MAXRIN,IMI)
d210 1
a210 3
           DO I=1,LCIRC
              CIROLD(I) = CIRNEW(I)
           ENDDO
d216 1
a216 1
        WRITE(NOUT,2001) (ANG(ROT(J),MODE),J=1,NIMA)
d222 1
a222 1
     &          TEMP,MAXRIN,JACUP,NUMR,MAXIT,NIMA,MODE,SNEW,NOUT)
d252 2
a253 2
           DLIST(3)=ANG(ROT(IMI),MODE)
           DLIST(4)=DIST(IMI)
d262 29
@


1.17
log
@selection files added
@
text
@a209 16
        I=0
        DO    IMI=1,NIMA
           I=I+1
712        IF(ILIST(I).EQ.-1)  THEN
              I=I+1
              GOTO  712
           ENDIF   
           DLIST(1)=IMI
           DLIST(2)=ILIST(I)
           DLIST(3)=ANG(ROT(IMI),MODE)
           DLIST(4)=DIST(IMI)
           DLIST(5)=IP(IMI)
           CALL  SAVD(NDOC,DLIST,NLIST,IRTFLG)
        ENDDO
        CALL  SAVDC
        CLOSE(NDOC)
d228 18
a245 1
	ENDDO	
@


1.16
log
@opfilec
@
text
@d32 1
a32 1
        REAL, ALLOCATABLE, DIMENSION(:,:) :: X,CIRC      
d36 1
d42 2
a43 2
        CHARACTER*80  FINPIC,FINPAT
        COMMON  /F_SPEC/  FINPAT,FINPIC,NLET
a223 1

d226 20
@


1.15
log
@opfilec
@
text
@d4 1
d26 1
a26 1
        SUBROUTINE  HALI_P(ILIST,NSAM,NROW,LSAM,LROW,NIMA,NRING,
a31 4
        INCLUDE 'CMLIMIT.INC' 
        CHARACTER(LEN=MAXNAM) ::  FINPIC,FINPIC
        COMMON  /F_SPEC/  FINPAT,FINPIC,NLET
 
d33 3
a35 3
        PARAMETER         (NLIST=5)
        INTEGER           MAXRIN,MAXRI,NUMR(3,NRING)
        DIMENSION         BUFIN(LSAM),CIROLD(LCIRC),CIRNEW(LCIRC)
d37 6
a42 3
     &                    ENER,TOTMIN,SOLD,SNEW,EAV,EC(NIMA)
        DIMENSION         DIST(NIMA),ROT(NIMA)
        DIMENSION         ILIST(NIMA),DLIST(NLIST)
d46 1
a46 1
        LOGICAL*1  CH_ANG,NORM
a48 1

d68 3
a70 10
        ALLOCATE (X(NSAM,NROW), STAT=IRTFLG)
        IF (IRTFLG.NE.0) THEN 
           CALL ERRT(46,'AP CA, X',IER)
           RETURN
        ENDIF

        ALLOCATE (CIRC(LCIRC,NIMA), STAT=IRTFLG)
        IF (IRTFLG.NE.0) THEN 
           CALL ERRT(46,'AP CA, CIRC',IER)
           DEALLOCATE (X)
d74 1
a74 1
        DO    K1=1,NIMA
d84 2
a85 1
     &                 NSAMT,NROWT,NSL,MAXIM,'DUMMY',.FALSE.,IRTFLG)
d93 3
a95 3
           DO    K2=LR1,LR2
              CALL  REDLIN(INPIC,BUFIN,LSAM,K2)
              DO    K3=LS1,LS2
d101 5
a105 1
C          Normalize if requested                                       
d107 1
a107 5
           IF(NORM)  CALL NORMAS(X,-NSAM/2,NSAM/2,-NROW/2,NROW/2,
     &                          NUMR,NUMR(1,NRING))
           CALL  ALRQ(X,NSAM,NROW,NUMR,CIRC(1,K1),LCIRC,NRING,MODE,K1)
           CALL  FOURING
     &     (CIRC(1,K1),LCIRC,NUMR,NRING,EC(K1),MODE)
d114 1
a114 1
c$omp parallel do private(imi)
d125 1
d150 3
a152 2
           SOLD = SOLD+EAV+EC(IMI)-2.0*TOTMIN
           CALL  UPDTC(CIROLD,CIRC(1,IMI),LCIRC,NRING,NUMR,TOT,
d162 2
a163 2
c$omp parallel do private(imi)
        DO    IMI=1,NIMA
d170 1
a170 1
C       Iterations to get better approximation
d190 3
a192 2
        WRITE(NOUT,2020)  ITER,SNEW
2020    FORMAT('  Iteration #',I3,'  Sum of distances=',1PD13.6)
d194 2
a195 2
           DO    I=1,LCIRC
              CIROLD(I)=CIRNEW(I)
d197 2
a198 2
           EAV=ENER(CIROLD,LCIRC,NRING,NUMR,MODE)
           SOLD=SNEW
d201 1
d204 1
d223 1
d227 1
@


1.14
log
@random equation changed
@
text
@a21 1
C        0         2         3         4         5         6         7
d31 4
d36 3
a38 3
        PARAMETER  (NLIST=5)
        INTEGER    MAXRIN,MAXRI,NUMR(3,NRING)
        DIMENSION  BUFIN(LSAM),CIROLD(LCIRC),CIRNEW(LCIRC)
d40 3
a42 5
     &          ENER,TOTMIN,SOLD,SNEW,EAV,EC(NIMA)
        DIMENSION  DIST(NIMA),ROT(NIMA)
        DIMENSION  ILIST(NIMA),DLIST(NLIST)
        CHARACTER*80  FINPIC
        CHARACTER*80  FINPAT
a43 1
        COMMON  /F_SPEC/  FINPAT,FINPIC,NLET
d49 1
d91 2
a92 2
           CALL OPFIL(.FALSE.,FINPIC,INPIC,'O',NSAMT,NROWT,NSL,
     &                   MAXIM,'DUMMY',.FALSE.,IRTFLG)
d108 1
a108 1
C  Normalize if requested                                       
@


1.13
log
@rot not full or randomly filled
@
text
@d138 1
a138 1
           M = MIN0(NIMA,MAX0(1,INT(CIID*NIMA+0.5)))
@


1.12
log
@replace rand_p function with random_number subroutine call
@
text
@d14 1
a15 1
C                                                                      
a28 2


d56 1
a56 1
C
d58 1
a58 1
C
d106 1
a106 1
C
d108 1
a108 1
C
d115 5
a119 15
C
C  Build first average
C
        CALL  TIME(ZEIT)
        ISEED=MOD(ICHAR(ZEIT(4:4))+100*ICHAR(ZEIT(5:5))+
     &  1000*ICHAR(ZEIT(7:7))+10000*ICHAR(ZEIT(8:8)),340189)
C
C  TWO ESTIMATIONS OF INITIAL AVERAGE ARE USED
C  ONLY ONE !!
C
C       DO  880  ICR=1,1
        ICR=1
C
C  DIST  IS USED HERE FOR THE RANDOM CHOOSING OF IMAGES
C
d121 2
a122 2
        DO    IMI=1,NIMA
           DIST(IMI)=0.0
d126 1
a126 1
        IMI=MIN0(NIMA,MAX0(1,INT(CIID*NIMA+0.5)))
a127 2
C        IMI=MIN0(NIMA,MAX0(1,INT(RAND_P(ISEED)*NIMA+0.5)))

d129 1
a129 1
           CIROLD(I)=CIRC(I,IMI)
d131 5
a135 5
        ROT(IMI)=1.0
        SOLD=0.0
        EAV=EC(IMI)
        DO    KTN=2,NIMA

d137 2
a138 2
804           CALL RANDOM_NUMBER(CIID) 
              M=MIN0(NIMA,MAX0(1,INT(CIID+0.5)))
d140 1
a140 2
C804        M=MIN0(NIMA,MAX0(1,INT(RAND_P(ISEED)+0.5)))
           IMI=0
d142 4
a145 4
              IF(DIST(I).EQ.1.0)  GOTO  809
              IMI=IMI+1
              IF(IMI.EQ.M)  GOTO  810
809           CONTINUE
d147 1
d149 4
a152 6
           GOTO  804
810        IMI=I
           DIST(IMI)=1.0
C
           CALL  CROSRNG
     &          (CIROLD,CIRC(1,IMI),LCIRC,NRING,TEMP,TEMP(1,2),
d154 10
a163 4
           ROT(IMI)=TOT
           SOLD=SOLD+EAV+EC(IMI)-2.0*TOTMIN
        CALL  UPDTC(CIROLD,CIRC(1,IMI),LCIRC,NRING,NUMR,TOT,MAXRIN,KTN)
           EAV=ENER(CIROLD,LCIRC,NRING,NUMR,MODE)
d165 1
a165 12
C
        IF(ICR.EQ.1)  THEN
           DO    I=1,LCIRC
              CIRNEW(I)=CIROLD(I)
           ENDDO
        ELSE
           CALL  CROSRNG
     &           (CIROLD,CIRNEW,LCIRC,NRING,TEMP,TEMP(1,2),
     &            MAXRIN,JACUP,NUMR,TOTMIN,TOT,MODE)
           CALL  UPDTC(CIROLD,CIRNEW,LCIRC,NRING,NUMR,TOT,MAXRIN,2)
           EAV=ENER(CIROLD,LCIRC,NRING,NUMR,MODE)
        ENDIF
d168 1
a168 1
           ROT(IMI)=0.0
d170 1
a170 1
880     CONTINUE
d173 3
a175 3
C
C  Iterations to get better approximation
C
d186 1
a186 1
           IF(ROT(IMI).NE.TOT)  THEN
@


1.11
log
@numbered do loop
@
text
@d136 6
a141 2
        IMI=MIN0(NIMA,MAX0(1,INT(RAND_P(ISEED)*NIMA+0.5)))
C
d149 6
a154 2
C
804        M=MIN0(NIMA,MAX0(1,INT(RAND_P(ISEED)+0.5)))
@


1.10
log
@*** empty log message ***
@
text
@d148 1
a148 1
           DO  809  I=1,NIMA
d152 3
a154 1
809        CONTINUE
@


1.9
log
@adapted for dynamical memory allocation
@
text
@d31 1
a31 1
C       WORK,BUFIN,ROT,CIRNEW,TEMP,DIST,EC,CIROLD,CIRSEED,ES,E,IP,IQ
@


1.8
log
@header
@
text
@a0 1

d2 3
a4 3
C                                                                      *
C                                                                      *
C                                                                      *
d13 10
a22 8
C                                                                      *
C                                                                      *
C                                                                      *
C  PURPOSE:                                                            *
C                                                                      *
C  PARAMETERS:                                                         *
C                                                                      *
C        0         2         3         4         5         6         7 *
d26 25
a50 22
    	SUBROUTINE  HALI_P(BUF,ILIST,NSAM,NROW,LSAM,LROW,NIMA,
     &	  NRING,LCIRC,MAXRIN,JACUP,NUMR,
     &	  CIRC,X,WORK,BUFIN,ROT,CIRNEW,TEMP,DIST,EC,CIROLD,
     &	  CIRSEED,ES,E,IP,IQ,NKMAX,MAXIT,
     &		MODE,NORM,NOUT)

	PARAMETER  (NLIST=5)
	INTEGER    MAXRIN,MAXRI
	DIMENSION  X(NSAM,NROW),WORK(*),BUFIN(LSAM)
	DIMENSION  CIRC(LCIRC,NIMA),CIROLD(LCIRC),CIRNEW(LCIRC)
	INTEGER    NUMR(3,NRING)
	DOUBLE PRECISION  TEMP(MAXRIN,2),
     &		ENER,TOTMIN,SOLD,SNEW,EAV,EC(NIMA)
	DIMENSION  DIST(NIMA),ROT(NIMA)
	DIMENSION  ILIST(NIMA),DLIST(NLIST),BUF(1024)
	CHARACTER*80  FINPIC
	CHARACTER*80  FINPAT
	COMMON  /F_SPEC/  FINPAT,FINPIC,NLET
	COMMON  /MXR/  MAXRI
	LOGICAL*1  CH_ANG,NORM
	CHARACTER*1  MODE
	CHARACTER*8  ZEIT
d53 3
a55 3
	INTEGER*2  IP(NIMA),IQ(NKMAX)
	DIMENSION  CIRSEED(LCIRC,NKMAX)
	DOUBLE PRECISION  E(NKMAX),ES(NKMAX)
d57 1
a57 1
	DATA  INPIC/77/,NDOC/55/
d59 1
a59 1
	MAXRI=MAXRIN
d61 47
a107 23
	LQ=LROW/2+1
	LR1=(NROW-1)/2
	LR2=LQ+LR1
	LR1=LQ-LR1
	LQ=LSAM/2+1
	LS1=(NSAM-1)/2
	LS2=LQ+LS1
	LS1=LQ-LS1
	DO    K1=1,NIMA
	CALL  FILGET(FINPAT,FINPIC,NLET,ILIST(K1),INTFLAG)
	CALL  OPENFB(BUF,FINPIC,INPIC,NSAMT,NROWT,'O',NF,NSL)
	IF(NF.NE.2)  THEN
	WRITE(NOUT,2032)  FINPIC
2032	FORMAT(' File not found ',A80,/,' Operation abandoned')
	RETURN
	ENDIF
	DO    K2=LR1,LR2
 	CALL  REDLIN(INPIC,BUFIN,LSAM,K2)
	DO    K3=LS1,LS2
	 X(K3-LS1+1,K2-LR1+1)=BUFIN(K3)
	ENDDO
	ENDDO
	CLOSE(INPIC)
d111 6
a116 6
	IF(NORM)  CALL NORMAS(X,-NSAM/2,NSAM/2,-NROW/2,NROW/2,
     &				NUMR,NUMR(1,NRING))
	CALL  ALRQ(X,NSAM,NROW,NUMR,CIRC(1,K1),LCIRC,NRING,MODE,K1)
	CALL  FOURING
     &	(CIRC(1,K1),LCIRC,NUMR,NRING,EC(K1),MODE)
	ENDDO
d120 3
a122 3
	CALL  TIME(ZEIT)
	ISEED=MOD(ICHAR(ZEIT(4:4))+100*ICHAR(ZEIT(5:5))+
     &	1000*ICHAR(ZEIT(7:7))+10000*ICHAR(ZEIT(8:8)),340189)
d124 2
a125 2
C  Two estimations of initial average are used
C  Only one !!
d127 2
a128 2
C	DO  880  ICR=1,1
	ICR=1
d130 1
a130 1
C  DIST  is used here for the random choosing of images
d133 44
a176 44
	DO    IMI=1,NIMA
	 DIST(IMI)=0.0
	ENDDO
	IMI=MIN0(NIMA,MAX0(1,INT(RAND_P(ISEED)*NIMA+0.5)))
C
	DO    I=1,LCIRC
	 CIROLD(I)=CIRC(I,IMI)
	ENDDO
	ROT(IMI)=1.0
	SOLD=0.0
	EAV=EC(IMI)
	DO    KTN=2,NIMA
C
804	M=MIN0(NIMA,MAX0(1,INT(RAND_P(ISEED)+0.5)))
	IMI=0
	DO  809  I=1,NIMA
	IF(DIST(I).EQ.1.0)  GOTO  809
	IMI=IMI+1
	IF(IMI.EQ.M)  GOTO  810
809	CONTINUE
	GOTO  804
810	IMI=I
	DIST(IMI)=1.0
C
	CALL  CROSRNG
     &		(CIROLD,CIRC(1,IMI),LCIRC,NRING,TEMP,TEMP(1,2),
     &			MAXRIN,JACUP,NUMR,TOTMIN,TOT,MODE)
	ROT(IMI)=TOT
 	SOLD=SOLD+EAV+EC(IMI)-2.0*TOTMIN
 	CALL  UPDTC(CIROLD,CIRC(1,IMI),LCIRC,NRING,NUMR,TOT,MAXRIN,KTN)
 	EAV=ENER(CIROLD,LCIRC,NRING,NUMR,MODE)
	ENDDO
C
	IF(ICR.EQ.1)  THEN
	DO    I=1,LCIRC
	 CIRNEW(I)=CIROLD(I)
	ENDDO
	ELSE
	CALL  CROSRNG
     &		(CIROLD,CIRNEW,LCIRC,NRING,TEMP,TEMP(1,2),
     &			MAXRIN,JACUP,NUMR,TOTMIN,TOT,MODE)
 	CALL  UPDTC(CIROLD,CIRNEW,LCIRC,NRING,NUMR,TOT,MAXRIN,2)
 	EAV=ENER(CIROLD,LCIRC,NRING,NUMR,MODE)
	ENDIF
d178 6
a183 6
	DO    IMI=1,NIMA
	 ROT(IMI)=0.0
	ENDDO
880	CONTINUE
C	WRITE(NOUT,  *,SOLD*FLOAT(NIMA)/(NIMA-1)
C	WRITE(NOUT,  2001,(ANG(ROT(J),MODE),J=1,NIMA)
d187 52
a238 51
	ITER=0
901	CONTINUE
	ITER=ITER+1
	CH_ANG=.FALSE.
	SNEW=0.0
C
	DO    IMI=1,NIMA
	CALL  CROSRNG
     &		(CIROLD,CIRC(1,IMI),LCIRC,NRING,TEMP,TEMP(1,2),
     &			MAXRIN,JACUP,NUMR,TOTMIN,TOT,MODE)
	IF(ROT(IMI).NE.TOT)  THEN
	CH_ANG=.TRUE.
	ROT(IMI)=TOT
	ENDIF
	SNEW=SNEW+EAV+EC(IMI)-2.0*TOTMIN
	DIST(IMI)=EAV+EC(IMI)-2.0*TOTMIN
	CALL  UPDTC(CIRNEW,CIRC(1,IMI),LCIRC,NRING,NUMR,TOT,MAXRIN,IMI)
	ENDDO
	WRITE(NOUT,2020)  ITER,SNEW
2020	FORMAT('  Iteration #',I3,'  Sum of distances=',1PD13.6)
	IF(SNEW.LE.SOLD.AND.CH_ANG)  THEN
	DO    I=1,LCIRC
	 CIROLD(I)=CIRNEW(I)
	ENDDO
	EAV=ENER(CIROLD,LCIRC,NRING,NUMR,MODE)
	SOLD=SNEW
	GOTO  901
	ENDIF
	WRITE(NOUT,2001) (ANG(ROT(J),MODE),J=1,NIMA)
2001	FORMAT(8(1X,F8.3))
	CALL  SEEDS(CIRSEED,CIRC,DIST,NKMAX,LCIRC,IP,NIMA,NOUT)
	CALL  HKMC
     &	  (CIRSEED,CIRC,CIRNEW,NKMAX,LCIRC,IP,IQ,ES,EC,E,DIST,ROT,NRING,
     &		TEMP,MAXRIN,JACUP,NUMR,MAXIT,NIMA,MODE,SNEW,NOUT)
	I=0
	DO    IMI=1,NIMA
	I=I+1
712	IF(ILIST(I).EQ.-1)  THEN
	I=I+1
	GOTO  712
	ENDIF	
	DLIST(1)=IMI
	DLIST(2)=ILIST(I)
	DLIST(3)=ANG(ROT(IMI),MODE)
	DLIST(4)=DIST(IMI)
	DLIST(5)=IP(IMI)
	CALL  SAVD(NDOC,DLIST,NLIST,IRTFLG)
	ENDDO
	CALL  SAVDC
	CLOSE(NDOC)
 	END
@


1.7
log
@OpenMP
@
text
@d1 24
d30 1
@


1.6
log
@ff
@
text
@d79 1
a79 1
c$doacross local(imi)
d124 1
a124 1
c$doacross local(imi)
@


1.5
log
@modified intrinsic function call for f90 compatibility
@
text
@d7 1
a7 1
	INTEGER*2  MAXRIN,MAXRI
d10 1
a10 1
	INTEGER*2  NUMR(3,NRING)
a28 1
CNO_SAVE
@


1.4
log
@R
@
text
@d84 1
a84 1
	IMI=MIN0(NIMA,MAX0(1,JNINT(RAND_P(ISEED)*NIMA+0.5)))
d94 1
a94 1
804	M=MIN0(NIMA,MAX0(1,JNINT(RAND_P(ISEED)+0.5)))
@


1.3
log
@*** empty log message ***
@
text
@d43 1
a43 1
	CALL  OPENFB(BUF,FINPIC,INPIC,NSAMT,NROWT,'R',NF,NSL)
@


1.2
log
@nosave, mp
@
text
@d41 1
a41 1
	DO  60  K1=1,NIMA
d49 1
a49 1
	DO  61  K2=LR1,LR2
d51 4
a54 2
	DO  61  K3=LS1,LS2
61	X(K3-LS1+1,K2-LR1+1)=BUFIN(K3)
d64 1
a64 1
60	CONTINUE
d81 3
a83 2
	DO  803  IMI=1,NIMA
803	DIST(IMI)=0.0
d86 3
a88 2
	DO  801  I=1,LCIRC
801	CIROLD(I)=CIRC(I,IMI)
d92 1
a92 1
	DO  802  KTN=2,NIMA
d112 1
a112 1
802	CONTINUE
d115 3
a117 2
	DO  881  I=1,LCIRC
881	CIRNEW(I)=CIROLD(I)
d126 3
a128 2
	DO  885  IMI=1,NIMA
885	ROT(IMI)=0.0
d141 1
a141 1
	DO  812  IMI=1,NIMA
d152 1
a152 1
812	CONTINUE
d156 3
a158 2
	DO  814  I=1,LCIRC
814	CIROLD(I)=CIRNEW(I)
d170 1
a170 1
	DO  711  IMI=1,NIMA
d181 2
a182 1
711	CALL  SAVD(NDOC,DLIST,NLIST,IRTFLG)
@


1.1
log
@part of apca command
@
text
@d29 1
d73 2
a74 1
	DO  880  ICR=1,1
d78 1
d120 1
@
