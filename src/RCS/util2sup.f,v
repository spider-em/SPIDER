head	1.23;
access;
symbols
	pre_getangas:1.15
	GPL2010:1.14
	pre_GPL2010:1.13
	pre_var_equation:1.13
	pre_fftwrings:1.13
	pre_opfiles:1.13
	src:1.13
	best-code:1.13
	x-named-regs:1.13
	x:1.13
	v13-00:1.13
	pre_GPL:1.12
	prec_CA:1.10
	noindx:1.7
	Bproc:1.4
	oct21:1.3
	last77:1.3;
locks; strict;
comment	@c @;


1.23
date	2014.10.02.13.45.49;	author leith;	state Exp;
branches;
next	1.22;

1.22
date	2014.10.02.13.38.23;	author leith;	state Exp;
branches;
next	1.21;

1.21
date	2014.04.18.15.24.16;	author leith;	state Exp;
branches;
next	1.20;

1.20
date	2013.04.17.13.43.18;	author leith;	state Exp;
branches;
next	1.19;

1.19
date	2012.11.05.16.24.29;	author leith;	state Exp;
branches;
next	1.18;

1.18
date	2012.11.01.18.53.17;	author leith;	state Exp;
branches;
next	1.17;

1.17
date	2011.07.29.18.27.31;	author leith;	state Exp;
branches;
next	1.16;

1.16
date	2011.07.27.16.06.51;	author leith;	state Exp;
branches;
next	1.15;

1.15
date	2010.10.22.16.51.31;	author leith;	state Exp;
branches;
next	1.14;

1.14
date	2010.06.24.13.27.12;	author leith;	state Exp;
branches;
next	1.13;

1.13
date	2005.10.17.20.57.17;	author leith;	state Exp;
branches;
next	1.12;

1.12
date	2004.11.19.22.27.26;	author cyang;	state Exp;
branches;
next	1.11;

1.11
date	2003.10.30.19.53.27;	author leith;	state Exp;
branches;
next	1.10;

1.10
date	2003.03.24.21.27.17;	author leith;	state Exp;
branches;
next	1.9;

1.9
date	2003.02.24.15.53.51;	author leith;	state Exp;
branches;
next	1.8;

1.8
date	2003.02.19.21.10.26;	author leith;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.03.17.57.13;	author leith;	state Exp;
branches;
next	1.6;

1.6
date	2001.04.18.18.15.22;	author leith;	state Exp;
branches;
next	1.5;

1.5
date	2000.12.27.19.50.44;	author leith;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.24.19.10.46;	author leith;	state Exp;
branches;
next	1.3;

1.3
date	99.03.18.18.33.15;	author leith;	state Exp;
branches;
next	1.2;

1.2
date	99.03.08.14.28.31;	author leith;	state Exp;
branches;
next	1.1;

1.1
date	99.03.08.13.27.58;	author leith;	state Exp;
branches;
next	;


desc
@split out of util2
@


1.23
log
@==, OVERWRITING logic for simple files fixed
@
text
@
C++*********************************************************************
C
C UTIL2SUP.F   NEW                              8/1/97    ArDean Leith  
C              REWRITTEN                        MAR 99    ArDean Leith
C              USED REDVOL                      DEC 2000  ArDean Leith
C              USED OPFILEC                     FEB 2003  ArDean Leith
C              ADDFAC                           MAR 2003  ArDean Leith
C              GETNEWSTAK PARAMS.               OCT 2010  ArDean Leith
C              REAL * FOURIER ALLOWED           JUL 2011  ArDean Leith
C              LUN23 != 23 CLOSURE              APR 2014  ArDean Leith
C
C **********************************************************************
C=*                                                                    *
C=* This file is part of:   SPIDER - Modular Image Processing System.  *
C=* SPIDER System Authors:  Joachim Frank & ArDean Leith               *
C=* Copyright 1985-2014  Health Research Inc.,                         *
C=* Riverview Center, 150 Broadway, Suite 560, Menands, NY 12204.      *
C=* Email: spider@@wadsworth.org                                        *
C=*                                                                    *
C=* SPIDER is free software; you can redistribute it and/or            *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* SPIDER is distributed in the hope that it will be useful,          *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* merchantability or fitness for a particular purpose.  See the GNU  *
C=* General Public License for more details.                           *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program. If not, see <http://www.gnu.org/licenses> *
C=*                                                                    *
C **********************************************************************
C
C  UTIL2SUP(PROMPT1,PROMPT2,PROMPT3, LUN1,LUN2,LUN3, SIGN)
C
C  PARAMETERS:      
C
C23456789012345678901234567890123456789012345678901234567890123456789012
C--*********************************************************************

        SUBROUTINE UTIL2SUP(PROMPT1,PROMPT2,PROMPT3,
     &                      LUN1,LUN2,LUN3,
     &                      SIGN) 

	INCLUDE 'CMBLOCK.INC'
        INCLUDE 'CMLIMIT.INC' 

        CHARACTER (LEN=*)      :: PROMPT1,PROMPT2,PROMPT3
        INTEGER                :: LUN1,LUN2,LUN3
        REAL                   :: SIGN

        INTEGER                :: LUNA,LUNB,LUNOUT
        CHARACTER(LEN=MAXNAM)  :: FILNAM1,FILNAM2,FILNAM3

        CHARACTER (LEN=1)      :: NULL = CHAR(0)
        REAL, ALLOCATABLE      :: VOLBUF(:)
        LOGICAL                :: ASKNAME,MUSTGET,WANTNEXT
        LOGICAL                :: BARE1,BARE2,ISBARE

C       IN CASE LUN1,... ARE CONSTANTS

        LUNA   = LUN1
        LUNB   = LUN2
        LUNOUT = LUN3

        IPVOL  = 0

        CALL FILERD(FILNAM1,NLETI,NULL,PROMPT1,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9999

        CALL FILERD(FILNAM2,NLETI,NULL,PROMPT2,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9999

        BARE1 = ISBARE(FILNAM1)
        BARE2 = ISBARE(FILNAM2)

          
        IF (SIGN >= 1000) THEN
           CALL RDPRM2S(FACT1,FACT2,NOT_USED,
     &                  'FACTORS FOR FIRST & SECOND FILES',IRTFLG)
	   IF (IRTFLG .NE. 0) GOTO 9999
        ENDIF

        IF (.NOT.(BARE1 .OR. BARE2)) THEN

           MAXIM1 = 0
           MAXIM2 = 0
           MAXIM3 = 0

C          NOT A STACKS OPERATION, OPEN FIRST INPUT FILE ON LUNA
           CALL OPFILEC(0,.FALSE.,FILNAM1,LUNA,'O',IFORM1,
     &                  NX,NY,NZ,
     &                 MAXIM1,PROMPT1,.TRUE.,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9998

C          ALLOCATE SPACE IN VOLBUF
           ALLOCATE(VOLBUF(NX*NY*NZ), STAT=IRTFLGT)
           IF (IRTFLGT .NE. 0) THEN
              MWANT = NX*NY*NZ
              CALL ERRT(46,'UTIL2SUP; VOLBUF',MWANT)
              GOTO 9999
           ENDIF

C          LOAD VOLUME FROM FIRST FILE INTO VOLBUF
           CALL REDVOL(LUNA,NX,NY,1,NZ,VOLBUF,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9998

           CLOSE(LUNA)
           ITER = 0

C          OPEN 2ND... INPUT FILE ON LUNB

10         ITER    = ITER + 1
           ASKNAME = (ITER > 1)
           CALL OPFILEC(0,ASKNAME,FILNAM2,LUNB,'O',IFORM2,
     &                NXT,NYT,NZT,MAXIM2,PROMPT2,.TRUE.,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9998
           
           CALL SIZCHK(NULL,NXT,NYT,NZT, 0,
     &                      NX ,NY ,NZ , 0, IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9998

           !IF (IFORM2 .NE. IFORM1) CALL ERRT(40,'UTIL2SUP',NE)

           ! KLUDGE TO ALLOW MANIPULATION OF FOURIER FILES
           IFORMT = IFORM1
           IF ( IFORM1 .NE. IFORM2 .AND.
     &        ((IFORM1 < 0 .AND. IFORM2 > 0) .OR.
     &         (IFORM1 > 0 .AND. IFORM2 < 0))) THEN
              IFORMT = MAX(IFORM1,IFORM2)
           ENDIF
       
           IF (SIGN < 1000) THEN
C             ADD, ETC SECOND FILE TO STORED VOLUME
              CALL ADD(VOLBUF,LUNB,IFORMT,NX,NY,NZ,SIGN)
           ELSE
C             CARRY OUT ADDITION, ETC
              CALL ADDFAC(VOLBUF,LUNB,IFORMT,NX,NY,NZ,SIGN,
     &                    FACT1,FACT2)
           ENDIF

C          CLOSE SECOND FILE (IN CASE OUTPUT IS SAME FILE)
           CLOSE(LUNB)

C          OPEN OUTPUT FILE ON LUNOUT
           ASKNAME = (ITER <= 1)
           CALL OPFILEC(LUNA,ASKNAME,FILNAM3,LUNOUT,'U',IFORM1,
     &                  NX,NY,NZ,MAXIM3,PROMPT3,.TRUE.,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9998

C          PUT SUM,ETC. IN OUTPUT FILE ON LUNOUT
           CALL WRTVOL(LUNOUT,NX,NY, 1,NZ,VOLBUF,IRTFLG)

           CLOSE(LUNOUT)

C          CONTINUE UNTIL '*' IS INPUT
           IF (SIGN < 1000) GOTO 10 

        ELSE
C          STACKS OPERATION

           MAXIM1 = -1
           MAXIM2 = -1
           MAXIM3 = -1
           IMGNUM = 0

C          OPEN FIRST INPUT FILE ON LUNA
           CALL OPFILEC(0,.FALSE.,FILNAM1,LUNA,'O',IFORM1,
     &                 NX,NY,NZ,
     &                 MAXIM1,PROMPT1,.TRUE.,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9998

C          ALLOCATE SPACE IN VOLBUF
           ALLOCATE(VOLBUF(NX*NY*NZ), STAT=IRTFLGT)
           IF (IRTFLGT .NE. 0) THEN
              CALL ERRT(46,'UTIL2SUP; VOLBUF',NX*NY*NZ)
              GOTO 9999
           ENDIF

C          OPEN SECOND INPUT FILE ON LUNB (IF NECESSARY)
           IF (FILNAM2 == FILNAM1) THEN
              LUNB = LUNA
           ELSE
              CALL OPFILEC(0,.FALSE.,FILNAM2,LUNB,'O',IFORM2,
     &              NXT,NYT,NZT,MAXIM2,PROMPT2,.TRUE.,IRTFLG)
              IF (IRTFLG .NE. 0) GOTO 9998

              CALL SIZCHK(NULL,NXT,NYT,NZT, 0,
     &                         NX ,NY ,NZ , 0, IRTFLG)
              IF (IRTFLG .NE. 0) GOTO 9998

              !IF (IFORM2 .NE. IFORM1)  CALL ERRT(40,'UTIL2SUP',NE)
           ENDIF

C          FIND TOTAL NUMBER OF COMMON IMAGES IN STACKS
           IF (MAXIM1 > 0) NIMAGE = MAXIM1
           IF (MAXIM2 > 0) NIMAGE = MAXIM2
           IF (MAXIM1 > 0 .AND. MAXIM2 > 0)
     &         NIMAGE = MIN(MAXIM1,MAXIM2)
 
C          FIND OUTPUT STACK NAME
           CALL FILERD(FILNAM3,NLETI,NULL,PROMPT2,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9998

C          OPEN OUTPUT STACK ON LUNOUT (IF NECESSARY)
           IF (FILNAM3 == FILNAM2) THEN
              LUNOUT = LUNB
           ELSEIF (FILNAM3 == FILNAM1) THEN
              LUNOUT = LUNA
           ELSE
C             OUTPUT IS DIFFERENT STACK FROM EITHER INPUT
              CALL OPFILEC(LUNA,.FALSE.,FILNAM3,LUNOUT,'U',IFORM1,
     &              NX,NY,NZ,MAXIM3,PROMPT3,.TRUE.,IRTFLG)
              IF (IRTFLG .NE. 0) GOTO 9998
           ENDIF

C          IF FIRST FILE IS NOT A STACK CAN SKIP TO NEXTIMAGE
           WANTNEXT = (MAXIM1 < 0)
 
C          IF FIRST FILE IS STACK MUSTGET SPECIFIED IMGNUM
           MUSTGET = .NOT. WANTNEXT 

 
20         IMGNUM = IMGNUM + 1
           IF (VERBOSE) WRITE(NOUT,*) ' '

C          GET IMGNUM FROM FIRST INPUT
           CALL GETOLDSTACK(LUNA,NX,IMGNUM,.TRUE.,.FALSE.,
     &                     .TRUE.,IRTFLG)
           IF (IRTFLG > 0 .AND. IMGNUM <= 1) GOTO 9998
           IF (IRTFLG > 0) GOTO 9998
        
C          LOAD VOLUME FROM FIRST INPUT FILE INTO VOLBUF 
           CALL REDVOL(LUNA,NX,NY,1,NZ,VOLBUF,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9998

C          WHAT HAPPENS IF STACK + STACK BUT ONE STACKED IMAGE
C          NOT PRESENT?? CURRENTLY PART OF STACK COULD BE 
C          INCONSISTENT WITH PREVIOUS PART OF STACK SINCE IT WILL
C          HALT ON ERROR!!!!!!!!!!!!!!al

           CALL GETOLDSTACK(LUNB,NX,IMGNUM,WANTNEXT,MUSTGET,
     &                     .TRUE.,IRTFLG)
           IF (IRTFLG > 0) GOTO 9998

           ! KLUDGE TO ALLOW MANIPULATION OF FOURIER FILES
           IFORMT = IFORM1
           IF ( IFORM1 .NE. IFORM2 .AND.
     &        ((IFORM1 < 0 .AND. IFORM2 > 0) .OR.
     &         (IFORM1 > 0 .AND. IFORM2 < 0))) THEN
              IFORMT = MAX(IFORM1,IFORM2)
           ENDIF

           IF (SIGN < 1000) THEN
C             CARRY OUT ADDITION, ETC
              CALL ADD(VOLBUF,LUNB,IFORMT,NX,NY,NZ,SIGN)
           ELSE
C             CARRY OUT ADDITION, ETC
              CALL ADDFAC(VOLBUF,LUNB,IFORMT,NX,NY,NZ,SIGN,
     &                    FACT1,FACT2)
           ENDIF

c          STACK OPERATION, POINT TO NEXT STACKED IMAGE
           CALL GETNEWSTACK(LUNA,LUNOUT,.FALSE.,NX,IMGNUM,IRTFLG)
           IF (IRTFLG .GT. 0) GOTO 9998

C          PUT SUM,ETC. IN OUTPUT FILE ON LUNOUT
           CALL WRTVOL(LUNOUT,NX,NY, 1,NZ,VOLBUF,IRTFLG)

C          CONTINUE UNTIL LAST STACKED IMAGE REACHED, DO NOT CLOSE 

           IF (IMGNUM < NIMAGE) GOTO 20
        ENDIF


C       DEALLOCATE VOLBUF
9998    IF (ALLOCATED(VOLBUF)) DEALLOCATE(VOLBUF)

9999    CLOSE(LUN1)
        CLOSE(LUN2)
        CLOSE(LUN3)


        RETURN
        END


C++*********************************************************************
C
C UTIL2SUPL.F    FROM UTIL2SUP                  OCT 2012  ArDean Leith  
C                IMAGE/STACK SERIES SUPPORT     OCT 2012  ArDean Leith
C                OVERWRITING LOGIC              OCT 2014  ArDean Leith
C
C **********************************************************************
C
C  UTIL2SUPL(PROMPT1,PROMPT2,PROMPT3,SIGN, USEFACTORS)
C
C  PARAMETERS:      
C
C23456789012345678901234567890123456789012345678901234567890123456789012
C--*********************************************************************

      SUBROUTINE UTIL2SUPL(PROMPT1,PROMPT2,PROMPT3,
     &                     SIGN) 

      IMPLICIT NONE
      INCLUDE 'CMBLOCK.INC'
      INCLUDE 'CMLIMIT.INC' 

      CHARACTER (LEN=*)      :: PROMPT1,PROMPT2,PROMPT3
      INTEGER                :: IT
      REAL                   :: SIGN

      CHARACTER(LEN=MAXNAM)  :: FILPAT1,FILPAT2,FILPAT3

      REAL,    ALLOCATABLE   :: VOLBUF(:,:,:),VOLBUF1(:,:,:)
      INTEGER, ALLOCATABLE   :: ILIST1(:),ILIST2(:),ILIST3(:)
      LOGICAL                :: ISBAREIN,ISBAREOUT
      INTEGER                :: LOCAT1,LOCAT2,LOCAT3
      INTEGER                :: LOCAST1,LOCAST2,LOCAST3
      INTEGER                :: NILMAX,NDUM
      INTEGER                :: MAXIM1,MAXIM2,MAXIM3,NOT_USED
      INTEGER                :: NLET1, NLET2, NLET3
      INTEGER                :: ITYPE1,ITYPE2,ITYPE3,ITYPE
      INTEGER                :: NINDX1,NINDX2,NINDX3
      INTEGER                :: NLIST1,NLIST2,NLIST3
      LOGICAL                :: ISTACK1,ISTACK2,ISTACK3
      INTEGER                :: IMGNUM1,IMGNUM2,IMGNUM3
      INTEGER                :: NX, NY, NZ
      INTEGER                :: NX2,NY2,NZ2
      INTEGER                :: I,ITER, LUNCP,ILOC,MWANT,IRTFLG
      INTEGER                :: LUN2T,LUN3T
      REAL                   :: FACT1,FACT2
      LOGICAL                :: BARE1,BARE2,BARE3
      LOGICAL                :: SAME1,SAME2,SAME3
      LOGICAL                :: OVERWRITE1,OVERWRITE2
      LOGICAL                :: ISOPEN 

      CHARACTER (LEN=1)      :: NULL = CHAR(0)

      LOGICAL                :: FOUROK
      LOGICAL, PARAMETER     :: ASKNAME  = .TRUE.
      LOGICAL, PARAMETER     :: ASKNAME3 = .FALSE.

      INTEGER, PARAMETER     :: LUN1    = 21
      INTEGER, PARAMETER     :: LUN2    = 22
      INTEGER                :: LUN3    = 23
      INTEGER, PARAMETER     :: LUNDOC  = 81
      INTEGER, PARAMETER     :: LUNDOC2 = 82
      INTEGER, PARAMETER     :: LUNDOC3 = 83
      INTEGER, PARAMETER     :: LUNXM1  = 84
      INTEGER, PARAMETER     :: LUNXM2  = 85
      INTEGER, PARAMETER     :: LUNXM3  = 86

      LUN3 = 23

      NILMAX  = NIMAXPLUS      ! FROM CMLIMIT
      ALLOCATE(ILIST1(NILMAX),
     &         ILIST2(NILMAX),
     &         ILIST3(NILMAX),
     &         STAT=IRTFLG)
      IF (IRTFLG .NE. 0) THEN
          CALL ERRT(46,'UTIL2SUPL; ILIST1....',3*NILMAX)
          RETURN
      ENDIF

      FOUROK = .TRUE.
      IF (SIGN >= 1000) THEN
         FOUROK = .FALSE.
      ENDIF
 
C     OPEN FIRST INPUT IMAGE(S)
      CALL OPFILES(0,LUN1,LUNDOC,LUNXM1, ASKNAME,
     &             FILPAT1,NLET1, 'O',
     &             ITYPE1,NX,NY,NZ,MAXIM1,
     &             PROMPT1,
     &             FOUROK, ILIST1,NILMAX, 
     &             NOT_USED,NLIST1,IMGNUM1, IRTFLG) 
      IF (IRTFLG .NE. 0) RETURN
      LOCAT1  = INDEX(FILPAT1,'@@')
      LOCAST1 = INDEX(FILPAT1,'*')
      ISTACK1 = (MAXIM1 > 0)                     ! USING A STACK
      BARE1   = (LOCAT1 > 0 .AND. LOCAST1 == 0)  ! BARESTACK
      SAME1   = (LOCAST1 == 0 .AND. .NOT. BARE1) ! IMAGE IS CONSTANT
      !write(6,*)'1 same1:',LOCAST1,BARE1,SAME1

      IF (NLIST1 > 0) ILIST2 = ILIST1            ! COPY STACK FOR ILIST2

      !write(6,*)'1 maxim,nlist,num:',maxim1,nlist1,imgnum1,filpat1(:11)
      !write(6,*) ' opened lun1:',lun1,filpat1(1:20)

C     OPEN SECOND INPUT IMAGE(S)
      CALL OPFILES(0,LUN2,LUNDOC,LUNXM2, ASKNAME,
     &             FILPAT2,NLET2, 'O',
     &             ITYPE2,NX2,NY2,NZ2,MAXIM2,
     &             PROMPT2,
     &             FOUROK, ILIST2,NILMAX, 
     &             NOT_USED,NLIST2,IMGNUM2, IRTFLG) 
      IF (IRTFLG .NE. 0) GOTO 9999
      LOCAT2  = INDEX(FILPAT2,'@@')
      LOCAST2 = INDEX(FILPAT2,'*')
      ISTACK2 = (MAXIM2 > 0)                     ! USING A STACK
      BARE2   = (LOCAT2 > 0 .AND. LOCAST2 == 0)  ! BARESTACK
      SAME2   = (LOCAST2 == 0 .AND. .NOT. BARE2) ! IMAGE IS CONSTANT

c     write(6,*)' 2 maxim,nlist,num:', maxim2,nlist2,imgnum2,filpat2(:11)
c     write(6,*)' 2 at2,ast2,stk2,bar2,sam2:',
c     &              locat2,locast2,istack2,bare2,same2
c     write(6,*) ' opened lun2:',lun2,filpat2(1:20)
           
      CALL SIZCHK(NULL,NX, NY, NZ, ITYPE1, 
     &                 NX2,NY2,NZ2,ITYPE2, IRTFLG)
      IF (IRTFLG .NE. 0) GOTO 9999

      IF (SIGN >= 1000.0) THEN
         CALL RDPRM2S(FACT1,FACT2,NOT_USED,
     &                'FACTORS FOR FIRST & SECOND FILES',IRTFLG)
         IF (IRTFLG .NE. 0) GOTO 9999
      ENDIF

C     FIND OUTPUT IMAGE NAME
      CALL FILERD(FILPAT3,NLET3,NULL,PROMPT3,IRTFLG)
      IF ( IRTFLG .NE. 0 ) GOTO 9999

      LOCAT3     = INDEX(FILPAT3,'@@')
      LOCAST3    = INDEX(FILPAT3,'*')
      ISTACK3    = (LOCAT3 > 0)                     ! USING A STACK
      BARE3      = (LOCAT3 > 0 .AND. LOCAST3 == 0)  ! BARESTACK
      SAME3      = (LOCAST3 == 0 .AND. .NOT. BARE3) ! IMAGE IS CONSTANT

      OVERWRITE1 = .FALSE.
      OVERWRITE2 = .FALSE.

      IF (LOCAT3 == 0 .AND. LOCAST3 == 0 .AND.
     &    NLET3 == NLET1  .AND.
     &    FILPAT3(1:NLET3) == FILPAT1(1:NLET1) .AND.
     &    NLIST3 == NLIST1) THEN
C         SIMPLE OUTPUT FILE 
       
         OVERWRITE1 = .TRUE.  

C        DUPLICATE FILE NAME!
         WRITE(NOUT,*) ' WARNING - OVERWRITING INPUT FILE: ', 
     &                   FILPAT1(1:NLET1)
         LUN3   = LUN1
         NLIST3 = NLIST1

       ELSEIF(LOCAT3 == 0 .AND. LOCAST3 == 0 .AND.
     &    NLET3 == NLET2  .AND.
     &    FILPAT3(1:NLET3) == FILPAT2(1:NLET2) .AND.
     &    NLIST3 == NLIST2) THEN
C         SIMPLE OUTPUT FILE 
       
         OVERWRITE2 = .TRUE.  
 
C        DUPLICATE FILE NAME!
         WRITE(NOUT,*) ' WARNING - OVERWRITING INPUT FILE: ', 
     &                   FILPAT2(1:NLET2)
         LUN3   = LUN2
         NLIST3 = NLIST2

      ELSE

C        OPEN OUTPUT IMAGE(S)
         ITYPE3  = ITYPE1       ! IMAGE TYPE
         MAXIM3  = -1           ! ALLOW BARE STACK
         IMGNUM3 = IMGNUM1      ! IMAGE # WANTED
         LUNCP   = LUN1

         CALL OPFILES(LUNCP,LUN3,LUNDOC,LUNXM3,ASKNAME3,
     &             FILPAT3,NLET3, 'U',
     &             ITYPE3,NX,NY,NZ,MAXIM3,
     &             FILPAT3,
     &             FOUROK, ILIST3,NILMAX, 
     &             NOT_USED,NLIST3,IMGNUM3, IRTFLG) 
C        IRTFLG = -2, FILE ALREADY OPEN
         IF (IRTFLG .NE. 0 .AND. IRTFLG .NE. -2) GOTO 9999

C        write(6,*) 'filpat3:',nlist3,filpat3(1:10)
C        write(6,*) 'ilist3:',imgnum3,'::',ilist3(1:nlist3)

         IF (NLET3 == NLET1  .AND.
     &       FILPAT3(1:NLET3) == FILPAT1(1:NLET1) .AND.
     &       NLIST3 == NLIST1) THEN
       
            OVERWRITE1 = .TRUE.  
            DO I=1,NLIST3
               IF (ILIST1(I) .NE. ILIST3(I)) THEN
                  OVERWRITE1 = .FALSE.
                  EXIT
               ENDIF
            ENDDO

C           write(6,*) ' nlet1,nlet3,nlist1,nlist3:',nlet1,nlet3,nlist1,nlist3
            IF (OVERWRITE1) THEN
C              DUPLICATE FILE NAME!
               WRITE(NOUT,*) ' WARNING - OVERWRITING INPUT FILE: ', 
     &                        FILPAT1(1:NLET1)
               LUN3   = LUN1
               NLIST3 = NLIST1
            ENDIF

         ELSEIF (NLET3 == NLET2  .AND.
     &           FILPAT3(1:NLET3) == FILPAT2(1:NLET2) .AND.
     &           NLIST3 == NLIST2) THEN

c           write(6,*) ' nlet2,nlet3,nlist2,nlist3:',nlet2,nlet3,nlist2,nlist3
      
            OVERWRITE2 = .TRUE.  
            DO I=1,NLIST2
               IF (ILIST2(I) .NE. ILIST3(I)) THEN
                  OVERWRITE2 = .FALSE.
                  EXIT
               ENDIF
            ENDDO

            IF (OVERWRITE2) THEN
C              DUPLICATE FILE NAME!
               WRITE(NOUT,*) ' WARNING - OVERWRITING INPUT FILE: ', 
     &                       FILPAT2(1:NLET2)
               LUN3   = LUN2
               NLIST3 = NLIST2
            ENDIF
         ENDIF
      ENDIF

      !write(6,*) ' opened lun3:',lun3,filpat3(1:20)
      !write(6,*)'3 maxim,nlist,num:',maxim3,nlist3,imgnum3,filpat3(:11)
      !write(6,*) ' now lun3:',lun3,nlet2,nlet3,overwrite2


C     ALLOCATE SPACE IN VOLBUF
      ALLOCATE(VOLBUF(NX,NY,NZ), STAT=IRTFLG)
      IF (IRTFLG .NE. 0) THEN
          MWANT = NX*NY*NZ
          CALL ERRT(46,'UTIL2SUPL; VOLBUF',MWANT)
          GOTO 9999
      ENDIF

      IF (SAME1) THEN 
C        LOAD VOLUME FROM FIRST FILE INTO VOLBUF
         ALLOCATE(VOLBUF1(NX,NY,NZ), STAT=IRTFLG)
         IF (IRTFLG .NE. 0) THEN
            CALL ERRT(46,'UTIL2SUPL; VOLBUF1',MWANT)
            GOTO 9999
         ENDIF

         CALL REDVOL(LUN1,NX,NY,1,NZ,VOLBUF1,IRTFLG)
         IF (IRTFLG .NE. 0) GOTO 9999
         CLOSE(LUN1)
      ENDIF

      ! KLUDGE TO ALLOW MANIPULATION OF FOURIER FILES
      ITYPE = ITYPE1
      IF ( ITYPE1 .NE. ITYPE2 .AND.
     &   ((ITYPE1 < 0 .AND. ITYPE2 > 0) .OR.
     &    (ITYPE1 > 0 .AND. ITYPE2 < 0))) THEN
           ITYPE = MAX(ITYPE1,ITYPE2)
      ENDIF

      ITER       = 0
      NINDX1     = 1
      NINDX2     = 1
      NINDX3     = 1

        LUN2T = LUN2
        IF (SAME2 .OR. OVERWRITE2) THEN
C          DO NOT OPEN NEXT SECOND INPUT FILE 
           LUN2T = 0
        ENDIF
        LUN3T = LUN3
        IF (OVERWRITE1 .OR. OVERWRITE2) THEN
C          DO NOT OPEN NEXT THIRD INPUT FILE 
           LUN3T = 0
        ENDIF


      DO 
        !write(6,*)'4 num,indx:',imgnum1,nindx1,nindx2,nindx3

        ITER = ITER + 1

C       LOAD VOLUME FROM FIRST FILE INTO VOLBUF
        IF (SAME1) THEN
c          REUSE SAME FIRST INPUT BUFFER
           VOLBUF = VOLBUF1 
        ELSE 
           !write(6,*) ' loading buf1,lun1:',lun1
           CALL REDVOL(LUN1,NX,NY,1,NZ,VOLBUF,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9999

           IF (.NOT. ISTACK1 .AND..NOT. BARE1) CLOSE(LUN1)
        ENDIF

        IF (SIGN < 1000) THEN
C          COMBINE FIRST & SECOND FILE --> VOLBUF
           !write(6,*) ' adding bufs,lun2:',lun2

           CALL ADD(VOLBUF,LUN2, ITYPE, NX,NY,NZ, SIGN)
        ELSE
C          ADD FIRST & SECOND FILE --> VOLBUF WITH FACTORS
           CALL ADDFAC(VOLBUF,LUN2, ITYPE, NX,NY,NZ, SIGN,
     &                 FACT1,FACT2)
        ENDIF

C       CLOSE SECOND FILE (IN CASE OUTPUT IS SAME FILE)
        IF (.NOT. ISTACK2 .AND. 
     &      .NOT. BARE2   .AND. 
     &      .NOT. SAME2)  CLOSE(LUN2)

C       PUT SUM, ETC. IN OUTPUT FILE ON LUN3
        CALL WRTVOL(LUN3,NX,NY, 1,NZ,VOLBUF,IRTFLG)

        IF ((NINDX1 >= NLIST1 .AND. NINDX2 >= NLIST2)) then
           !write(6,*)  'nindx1 >= nlist1:', nindx1,' >= ',nlist1
           !write(6,*)  'nindx2 >= nlist2:', nindx2,' >= ',nlist2
           EXIT      ! END OF INPUT LIST
        ENDIF
      
        !write(6,*) ' same1,overwrite1:',same1,overwrite1
        IF (.NOT. SAME1) THEN
C          OPEN NEXT FIRST INPUT FILE 
 
           CALL NEXTFILE(NINDX1, ILIST1, 
     &                   FOUROK,LUNXM1,
     &                   NLIST1,MAXIM1,   
     &                   LUN1,LUNCP,
     &                   FILPAT1,'O',
     &                   IMGNUM1, IRTFLG) 
c           write(6,'(A,5i6)')
c     &         ' Nextfile  num1,n1,indx1,irtflg:',
c     &                     imgnum1,nlist1,nindx1,irtflg
           IF (IRTFLG < 0)  EXIT      ! END OF INPUT FILES
        ENDIF

c        write(6,*) ' same2,overwrite2:',same2,overwrite2

        IF (.NOT. SAME2) THEN
C          OPEN NEXT SECOND INPUT FILE 
           !write(6,*) ' same2:',same2,nindx2,nlist2,filpat2(1:10)

           CALL NEXTFILE(NINDX2, ILIST2, 
     &                   FOUROK,LUNXM2,
     &                   NLIST2,MAXIM2,   
     &                   LUN2,LUNCP,
     &                   FILPAT2,'O',
     &                   IMGNUM2, IRTFLG) 
c          write(6,'(A,5i6)')
c     &         ' Nextfile 2  num2,n2,indx2,irtflg:',
c     &                     imgnum2,nlist2,nindx2,irtflg
           IF (IRTFLG < 0)  EXIT       ! END OF INPUT FILES
        ENDIF


        !write(6,*) ' same3,overwrite1 2:',same3,overwrite1,overwrite2
        IF (.NOT. SAME3 .AND. 
     &      .NOT. OVERWRITE1 .AND. 
     &      .NOT. OVERWRITE2) THEN
C          OPEN NEXT OUTPUT FILE 
c          write(6,*) ' same3:',same3,nindx3,nlist3,filpat3(1:10)

           CALL NEXTFILE(NINDX3, ILIST3, 
     &                   FOUROK,LUNXM1,
     &                   NLIST3,MAXIM3,   
     &                   LUN3,LUNCP,
     &                   FILPAT3,'N',
     &                   IMGNUM3, IRTFLG) 
c           write(6,'(A,5i6)')
c     &         ' Nextfile 3  num3,n3,indx3,irtflg:',
c     &                     imgnum3,nlist3, nindx3,irtflg
         ENDIF

         IF (IRTFLG == -99) THEN
             CALL ERRT(102,'INSUFFICIENT OUTPUT FILE NAMES',NLIST3)
             EXIT         
         ELSEIF (IRTFLG < 0) THEN
             EXIT         ! END OF INPUT FILES
         ENDIF
         IF (IRTFLG .NE. 0) GOTO 9999    ! ERROR

      ENDDO

9999  IF (ALLOCATED(VOLBUF))    DEALLOCATE(VOLBUF)
      IF (ALLOCATED(ILIST1))    DEALLOCATE(ILIST1)
      IF (ALLOCATED(ILIST2))    DEALLOCATE(ILIST2)
      IF (ALLOCATED(ILIST3))    DEALLOCATE(ILIST3)

      IF (VERBOSE) WRITE(NOUT,*) ' '

      CLOSE(LUN1)
      CLOSE(LUN2)
      CLOSE(LUN3)
      CLOSE(23)        ! IN CASE REDEFINED ABOVE
      CLOSE(LUNDOC)
      CLOSE(LUNXM1)
      CLOSE(LUNXM2)
      CLOSE(LUNXM3)
     
      END

#ifdef NEVER
        !inquire(unit=lun1,opened=isopen, name=filopend)
        !write(6,*) 'isopen1a:',isopen,filopend(1:12)
#endif


@


1.22
log
@==, input file overwrite now works OK for simple files, (no test stacks)
@
text
@d4 8
a11 8
C UTIL2SUP.F     NEW                          8/1/97    ARDEAN LEITH  
C                REWRITTEN                    MAR 99    ARDEAN LEITH
C                USED REDVOL                  DEC 2000  ARDEAN LEITH
C                USED OPFILEC                 FEB 2003  ARDEAN LEITH
C                ADDFAC                       MAR 2003  ARDEAN LEITH
C                GETNEWSTAK PARAMS.           OCT 2010  ARDEAN LEITH
C                REAL * FOURIER ALLOWED       JUL 2011  ARDEAN LEITH
C                LUN23 != 23 CLOSURE          APR 2014  ARDEAN LEITH
d291 3
a293 2
C UTIL2SUPL.F    FROM UTIL2SUP                OCT 2012  ARDEAN LEITH  
C                IMAGE/STACK SERIES SUPPORT   OCT 2012  ARDEAN LEITH
d443 3
a445 3
C        DUPLICATE FILE NAME!!
         WRITE(NOUT,*) ' WARNING OVERWRITING INPUT FILE: ', 
     &                    FILPAT1(1:NLET1)
d457 2
a458 2
C        DUPLICATE FILE NAME!!
         WRITE(NOUT,*) ' WARNING OVERWRITING INPUT FILE: ', 
@


1.21
log
@LUN23 != 23 CLOSURE
@
text
@d79 1
a79 1
        IF (SIGN .GE. 1000) THEN
d114 1
a114 1
10         ITER = ITER + 1
d147 1
a147 1
           ASKNAME = (ITER .LE. 1)
d158 1
a158 1
           IF (SIGN .LT. 1000) GOTO 10 
d390 1
d406 5
a410 4
c      write(6,*)'2 maxim,nlist,num:', maxim2,nlist2,imgnum2,filpat2(:11)
c      write(6,*)'2 at2,ast2,stk2,bar2,sam2:',
c     &             locat2,locast2,istack2,bare2,same2
 
d421 9
a429 21
C     OPEN OUTPUT IMAGE(S)
      ITYPE3  = ITYPE1       ! IMAGE TYPE
      MAXIM3  = -1           ! ALLOW BARE STACK
      IMGNUM3 = IMGNUM1      ! IMAGE # WANTED
      LUNCP   = LUN1

      CALL OPFILES(LUNCP,LUN3,LUNDOC,LUNXM3,ASKNAME,
     &             FILPAT3,NLET3, 'U',
     &             ITYPE3,NX,NY,NZ,MAXIM3,
     &             PROMPT3,
     &             FOUROK, ILIST3,NILMAX, 
     &             NOT_USED,NLIST3,IMGNUM3, IRTFLG) 

C     IRTFLG = -2, FILE ALREADY OPEN
      IF (IRTFLG .NE. 0 .AND. IRTFLG .NE. -2) GOTO 9999
     
      LOCAT3  = INDEX(FILPAT3,'@@')
      LOCAST3 = INDEX(FILPAT3,'*')
      ISTACK3 = (LOCAT3 > 0)                     ! USING A STACK
      BARE3   = (LOCAT3 > 0 .AND. LOCAST3 == 0)  ! BARESTACK
      SAME3   = (LOCAST3 == 0 .AND. .NOT. BARE3) ! IMAGE IS CONSTANT
a430 2
      !write(6,*)'3 maxim,nlist,num:',maxim3,nlist3,imgnum3,filpat3(:11)
    
d434 2
a435 1
      IF (NLET3 == NLET1  .AND.
d438 1
a440 6
         DO I=1,NLIST3
            IF (ILIST1(I) .NE. ILIST3(I)) THEN
               OVERWRITE1 = .FALSE.
               EXIT
            ENDIF
         ENDDO
d442 2
a443 3
         IF (OVERWRITE1) THEN
C           DUPLICATE FILE NAME!!
            WRITE(NOUT,*) ' WARNING OVERWRITING INPUT FILE IN: ', 
d445 2
a446 4
            LUN3   = LUN1
            NLIST3 = NLIST1
         ENDIF
      ENDIF
d448 2
a449 1
      IF (NLET3 == NLET2  .AND.
d452 1
d455 46
a500 4
         DO I=1,NLIST2
            IF (ILIST2(I) .NE. ILIST3(I)) THEN
               OVERWRITE2 = .FALSE.
               EXIT
a501 1
         ENDDO
d503 21
a523 6
         IF (OVERWRITE2) THEN
C           DUPLICATE FILE NAME!!
            WRITE(NOUT,*) ' WARNING OVERWRITING INPUT FILE IN: ', 
     &                    FILPAT2(1:NLET2)
            LUN3   = LUN2
            NLIST3 = NLIST2
d527 5
d623 1
a623 2
           !write(6,*) ' same1:',same1,nindx1,nlist1,filpat1(1:10)

d636 2
a637 1
        !write(6,*) ' same2,overwrite2:',same2,overwrite2
d648 1
a648 1
c           write(6,'(A,5i6)')
d660 1
a660 1
           !write(6,*) ' same3:',same3,nindx3,nlist3,filpat3(1:10)
@


1.20
log
@NX2,NY2,NZ2,ITYPE2,0,IRTFLG) bug on sizchk call
@
text
@d11 1
d17 1
a17 1
C=* Copyright 1985-2011  Health Research Inc.,                         *
d649 1
@


1.19
log
@util2supl overwrite capability
@
text
@d119 2
a120 2
           CALL SIZCHK(UNUSED,NXT,NYT,NZT, 0,
     &                        NX ,NY ,NZ , 0, IRTFLG)
d188 2
a189 2
              CALL SIZCHK(UNUSED,NXT,NYT,NZT, 0,
     &                           NX ,NY ,NZ , 0, IRTFLG)
d409 1
a409 1
     &                 NX2,NY2,NZ2,ITYPE2,0,IRTFLG)
@


1.18
log
@'MU 2'.... added, NX used
@
text
@d49 2
d52 1
d60 1
a60 1
        NULL = CHAR(0)
a61 1
C       IN CASE LUN1,... ARE CONSTANTS
d322 2
a323 1
      INTEGER                :: ITYPE1,ITYPE2,ITYPE3,ITYPE,NLET
d330 2
a331 2
      INTEGER                :: ITER, LUNCP,ILOC,MWANT,IRTFLG
      INTEGER                :: LUN2T
d335 1
d341 2
a342 1
      LOGICAL, PARAMETER     :: ASKNAME = .TRUE.
d346 1
a346 1
      INTEGER, PARAMETER     :: LUN3    = 23
d354 1
d373 1
a373 1
     &             FILPAT1,NLET, 'O',
d392 1
a392 1
     &             FILPAT2,NLET, 'O',
d425 1
a425 1
     &             FILPAT3,NLET, 'U',
d428 1
a428 1
     &             FOUROK, ILIST3,NIMAX, 
a429 1
      IF (IRTFLG .NE. 0) GOTO 9999
d431 3
d442 45
d520 12
a531 1
        !write(6,*)  ' '
d575 1
d587 3
a589 2
c     &         ' Nextfile  num1,indx1,irtflg:',
c     &                     imgnum1,nindx1,irtflg
d592 15
a606 4
        LUN2T = LUN2
        IF (SAME2) THEN
C          DO NOT OPEN NEXT SECOND INPUT FILE 
           LUN2T = 0
a608 9
C       OPEN NEXT SECOND INPUT AND OUTPUT FILE 
        LUNCP = LUN1
        !   write(6,*) ' calling nextfiles:',nindx2,nindx3
        CALL NEXTFILES(NINDX2, NINDX3, ILIST2,ILIST3, 
     &                 FOUROK,LUNDOC,LUNXM2,
     &                 NLIST2,NLIST3,   
     &                 MAXIM2,MAXIM3,   
     &                 LUN2T,LUNCP,LUN3, FILPAT2,FILPAT3,
     &                 IMGNUM2,IMGNUM3, IRTFLG) 
d610 6
d617 10
a626 3
c         write(6,'(A,5i6)')
c     &       ' Nextfiles num2,num3,indx2,indx3,irtflg:',
c     &                   imgnum2,imgnum3,nindx2,nindx3,irtflg
d629 1
a629 1
             CALL ERRT(102,'INSUFFICIENT OUTPUT FILE NAMES',NINDX2)
@


1.17
log
@KLUDGE TO ALLOW MANIPULATION OF FOURIER FILES
@
text
@d34 1
a34 1
C  UTIL2SUP(PROMPT1,PROMPT2,PROMPT3,LUN1,LUN2,LUN3,SIGN)
d90 1
a90 1
     &                  NSAM,NROW,NSLICE,
d95 1
a95 1
           ALLOCATE(VOLBUF(NSAM*NROW*NSLICE), STAT=IRTFLGT)
d97 1
a97 1
              MWANT = NSAM*NROW*NSLICE
d103 1
a103 1
           CALL REDVOL(LUNA,NSAM,NROW,1,NSLICE,VOLBUF,IRTFLG)
d112 1
a112 1
           ASKNAME = (ITER .GT. 1)
d114 1
a114 1
     &                NSAMT,NROWT,NSLICET,MAXIM2,PROMPT2,.TRUE.,IRTFLG)
d117 2
a118 2
           CALL SIZCHK(UNUSED,NSAMT,NROWT,NSLICET, 0,
     &                        NSAM ,NROW ,NSLICE , 0, IRTFLG)
d131 1
a131 1
           IF (SIGN .LT. 1000) THEN
d133 1
a133 1
              CALL ADD(VOLBUF,LUNB,IFORMT,NSAM,NROW,NSLICE,SIGN)
d136 1
a136 1
              CALL ADDFAC(VOLBUF,LUNB,IFORMT,NSAM,NROW,NSLICE,SIGN,
d146 1
a146 1
     &              NSAM,NROW,NSLICE,MAXIM3,PROMPT3,.TRUE.,IRTFLG)
d150 1
a150 5
           ILOC = 1
           DO IREC=1,NROW*NSLICE
              CALL WRTLIN(LUNOUT,VOLBUF(ILOC),NSAM,IREC)
              ILOC = ILOC + NSAM
           ENDDO
d167 1
a167 1
     &                 NSAM,NROW,NSLICE,
d172 1
a172 1
           ALLOCATE(VOLBUF(NSAM*NROW*NSLICE), STAT=IRTFLGT)
d174 1
a174 1
              CALL ERRT(46,'UTIL2SUP; VOLBUF',NSAM*NROW*NSLICE)
d179 1
a179 1
           IF (FILNAM2 .EQ. FILNAM1) THEN
d183 1
a183 1
     &              NSAMT,NROWT,NSLICET,MAXIM2,PROMPT2,.TRUE.,IRTFLG)
d186 2
a187 2
              CALL SIZCHK(UNUSED,NSAMT,NROWT,NSLICET, 0,
     &                           NSAM ,NROW ,NSLICE , 0, IRTFLG)
d194 3
a196 3
           IF (MAXIM1 .GT. 0) NIMAGE = MAXIM1
           IF (MAXIM2 .GT. 0) NIMAGE = MAXIM2
           IF (MAXIM1 .GT. 0 .AND. MAXIM2 .GT. 0)
d204 1
a204 1
           IF (FILNAM3 .EQ. FILNAM2) THEN
d206 1
a206 1
           ELSEIF (FILNAM3 .EQ. FILNAM1) THEN
d211 1
a211 1
     &              NSAM,NROW,NSLICE,MAXIM3,PROMPT3,.TRUE.,IRTFLG)
d216 1
a216 1
           WANTNEXT = (MAXIM1 .LT. 0)
d226 1
a226 1
           CALL GETOLDSTACK(LUNA,NSAM,IMGNUM,.TRUE.,.FALSE.,
d228 2
a229 2
           IF (IRTFLG .GT. 0 .AND. IMGNUM .LE. 1) GOTO 9998
           IF (IRTFLG .GT. 0) GOTO 9998
d232 1
a232 1
           CALL REDVOL(LUNA,NSAM,NROW,1,NSLICE,VOLBUF,IRTFLG)
d240 1
a240 1
           CALL GETOLDSTACK(LUNB,NSAM,IMGNUM,WANTNEXT,MUSTGET,
d242 1
a242 1
           IF (IRTFLG .GT. 0) GOTO 9998
d252 1
a252 1
           IF (SIGN .LT. 1000) THEN
d254 1
a254 1
              CALL ADD(VOLBUF,LUNB,IFORMT,NSAM,NROW,NSLICE,SIGN)
d257 1
a257 1
              CALL ADDFAC(VOLBUF,LUNB,IFORMT,NSAM,NROW,NSLICE,SIGN,
d262 1
a262 1
           CALL GETNEWSTACK(LUNA,LUNOUT,.FALSE.,NSAM,IMGNUM,IRTFLG)
d266 1
a266 5
           ILOC = 1
           DO IREC=1,NROW*NSLICE
              CALL WRTLIN(LUNOUT,VOLBUF(ILOC),NSAM,IREC)
              ILOC = ILOC + NSAM
           ENDDO
d270 1
a270 1
           IF (IMGNUM .LT. NIMAGE) GOTO 20
d284 296
@


1.16
log
@ can mult. real * complex
@
text
@d34 1
a34 1
C  UTIL2SUP(PROMPT1,PROMPT2,PROMPT3,LUN1,LUN2,LUN3,SIGN,FACT1,FACT2)
d41 2
a42 1
        SUBROUTINE UTIL2SUP(PROMPT1,PROMPT2,PROMPT3,LUN1,LUN2,LUN3,
d54 2
a55 1
        LOGICAL     ::    ASKNAME,MUSTGET,WANTNEXT,BARE1,BARE2,ISBARE
d117 12
a128 7
           IF (NSAMT.NE.NSAM.OR.NROWT.NE.NROW.OR.NSLICET.NE.NSLICE)THEN
              CALL ERRT(1,'UTIL2SUP',NE)
              GOTO 9998

           !ELSEIF (IFORM2 .NE. IFORM1) THEN
           !   CALL ERRT(40,'UTIL2SUP',NE)
           !   GOTO 9998
d130 1
a130 1

d133 1
a133 1
              CALL ADD(VOLBUF,LUNB,IFORM1,NSAM,NROW,NSLICE,SIGN)
d136 1
a136 1
              CALL ADDFAC(VOLBUF,LUNB,IFORM1,NSAM,NROW,NSLICE,SIGN,
d190 5
a194 9
              IF (NSAMT.NE.NSAM.OR.NROWT.NE.NROW.OR.NSLICET.NE.NSLICE) 
     &           THEN
                 CALL ERRT(1,'UTIL2SUP',NE)
                 GOTO 9998

              !ELSEIF (IFORM2 .NE. IFORM1)  THEN
              !   CALL ERRT(40,'UTIL2SUP',NE)
              !   GOTO 9998
              ENDIF
d248 8
d258 1
a258 1
              CALL ADD(VOLBUF,LUNB,IFORM1,NSAM,NROW,NSLICE,SIGN)
d261 1
a261 1
              CALL ADDFAC(VOLBUF,LUNB,IFORM1,NSAM,NROW,NSLICE,SIGN,
@


1.15
log
@GETNEWSTAK PARAMS
@
text
@d10 1
d16 1
a16 1
C=* Copyright 1985-2010  Health Research Inc.,                         *
d95 2
a96 1
              CALL ERRT(46,'UTIL2SUP,VOLBUF',NDUM)
d118 4
a121 3
           ELSEIF (IFORM2 .NE. IFORM1) THEN
              CALL ERRT(40,'UTIL2SUP',NE)
              GOTO 9998
d171 1
a171 1
              CALL ERRT(46,'UTIL2SUP,VOLBUF',NDUM)
d187 4
a190 3
              ELSEIF (IFORM2 .NE. IFORM1)  THEN
                 CALL ERRT(40,'UTIL2SUP',NE)
                 GOTO 9998
@


1.14
log
@GPL_2010
@
text
@d4 6
a9 5
C UTIL2SUP.F               NEW              8/1/97       ARDEAN LEITH  
C                          REWRITTEN        MAR 99       ARDEAN LEITH
C                          USED REDVOL      DEC 2000     ARDEAN LEITH
C                          USED OPFILEC     FEB 2003     ARDEAN LEITH
C                          ADDFAC           MAR 2003     ARDEAN LEITH
d46 1
a46 1
        CHARACTER *(*)   PROMPT1,PROMPT2,PROMPT3
a48 1
        COMMON /COMMUN1/      FILNAM1,FILNAM2,FILNAM3
d50 2
a51 2
        CHARACTER (LEN=1)                ::     NULL
        REAL, ALLOCATABLE, DIMENSION(:)  :: VOLBUF
d251 1
a251 1
           CALL GETNEWSTACK(LUNA,LUNOUT,NSAM,IMGNUM,IRTFLG)
@


1.13
log
@GPL License fixed
@
text
@a10 2
C=* FROM: SPIDER - MODULAR IMAGE PROCESSING SYSTEM.   AUTHOR: J.FRANK  *
C=* Copyright (C) 1985-2005  Health Research Inc.                      *
d12 5
a16 2
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *   
C=* ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
d18 1
a18 3
C=* Email:  spider@@wadsworth.org                                       *
C=*                                                                    *
C=* This program is free software; you can redistribute it and/or      *
d23 1
a23 1
C=* This program is distributed in the hope that it will be useful,    *
d25 1
a25 1
C=* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
a26 1
C=*                                                                    *
d28 1
a28 3
C=* along with this program; if not, write to the                      *
C=* Free Software Foundation, Inc.,                                    *
C=* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.      *
@


1.12
log
@Removed MPI
@
text
@d11 23
a33 6
C * SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK       *
C * COPYRIGHT (C)1985, 2003. HEALTH RESEARCH INCORPORATED (HRI),       *
C * ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C * THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HRI AND ARE NOT   *
C * TO BE DISCLOSED TO OTHERS OR USED FOR PURPOSES OTHER THAN INTENDED *
C * WITHOUT WRITTEN APPROVAL OF HRI.                                   *
@


1.11
log
@mpi
@
text
@a40 8
#ifdef USE_MPI     
        include 'mpif.h'
        INTEGER  MYPID, COMM, IERR
        COMM = MPI_COMM_WORLD
        CALL MPI_COMM_RANK(COMM, MYPID, IERR) 
#else
        MYPID = -1
#endif   
a121 21
#ifdef USE_MPI
           IF (ASKNAME) THEN
C             CHECK THE FILENAME TO SEE IF THE OUTPUT IS INLINE
              CALL FILERD(FILNAM3,NLETI,NULL,PROMPT3,IRTFLG)
           ENDIF 
           IF (MYPID .EQ. 0 .OR. FILNAM3(1:1) .EQ. '_') THEN  
              CALL OPFILEC(LUNA,.FALSE.,FILNAM3,LUNOUT,'U',IFORM1,
     &                 NSAM,NROW,NSLICE,MAXIM3,PROMPT3,.TRUE.,IRTFLG)
              IF (IRTFLG .NE. 0) GOTO 9998

C             PUT SUM,ETC. IN OUTPUT FILE ON LUNOUT
              ILOC = 1
              DO IREC=1,NROW*NSLICE
                 CALL WRTLIN(LUNOUT,VOLBUF(ILOC),NSAM,IREC)
                 ILOC = ILOC + NSAM
              ENDDO

              CLOSE(LUNOUT)
           ENDIF
           CALL MPI_BCAST(IBCNT, 1, MPI_INTEGER, 0, COMM, IERR)
#else           
a133 1
#endif
a263 3



@


1.10
log
@'ad f'
@
text
@d41 8
d130 21
d163 1
@


1.9
log
@getnewstack paramaters changed
@
text
@d8 1
d11 6
a16 7
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK        *
C *  COPYRIGHT (C)1981,1987, WADSWORTH CENTER FOR LABORATORIES AND     *
C *    RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201 *
C *    THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR *
C *    LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS *
C *    OR USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN        *
C *    APPROVAL OF THE CENTER FOR LABORATORIES AND RESEARCH.           *
d19 1
a19 1
C  UTIL2SUP(PROMPT1,PROMPT2,PROMPT3,LUN1,LUN2,LUN3,SIGN)
d59 6
d108 8
a115 2
C          ADD, ETC SECOND FILE TO STORED VOLUME
           CALL ADD(VOLBUF,LUNB,IFORM1,NSAM,NROW,NSLICE,SIGN)
d136 1
a136 1
           GOTO 10 
d228 8
a235 2
C          CARRY OUT ADDITION, ETC
           CALL ADD(VOLBUF,LUNB,IFORM1,NSAM,NROW,NSLICE,SIGN)
@


1.8
log
@opfilec
,
opfilec
@
text
@d7 1
d212 1
a212 1
          CALL GETOLDSTACK(LUNB,NSAM,IMGNUM,WANTNEXT,MUSTGET,
d220 1
a220 1
           CALL GETNEWSTACK(LUNOUT,NSAM,IMGNUM,IRTFLG)
@


1.7
log
@redvol parameters changed
@
text
@d29 1
d33 1
a33 1
        CHARACTER (LEN=81) :: FILNAM1,FILNAM2,FILNAM3
d66 3
a68 2
           CALL OPFILE(.FALSE.,FILNAM1,LUNA,'O',IFORM1,NSAM,NROW,NSLICE,
     &                MAXIM1,PROMPT1,.TRUE.,IRTFLG)
d89 2
a90 2
           CALL OPFILE(ASKNAME,FILNAM2,LUNB,'O',IFORM2,
     &              NSAMT,NROWT,NSLICET,MAXIM2,PROMPT2,.TRUE.,IRTFLG)
d109 1
a109 1
           CALL OPFILE(ASKNAME,FILNAM3,LUNOUT,'U',IFORM1,
d134 3
a136 2
           CALL OPFILE(.FALSE.,FILNAM1,LUNA,'O',IFORM1,NSAM,NROW,NSLICE,
     &                MAXIM1,PROMPT1,.TRUE.,IRTFLG)
d150 1
a150 1
              CALL OPFILE(.FALSE.,FILNAM2,LUNB,'O',IFORM2,
d181 1
a181 1
              CALL OPFILE(.FALSE.,FILNAM3,LUNOUT,'U',IFORM1,
@


1.6
log
@N_VERBOSE --> VERBOSE
@
text
@d77 1
a77 1
           CALL REDVOL(LUNA,NSAM,NROW,NSLICE,VOLBUF,IRTFLG)
d200 1
a200 1
           CALL REDVOL(LUNA,NSAM,NROW,NSLICE,VOLBUF,IRTFLG)
@


1.5
log
@used redvol
@
text
@d191 1
a191 1
           IF (N_VERBOSE .EQ. 1) WRITE(NOUT,*) ' '
@


1.4
log
@SP_F90 removed
@
text
@d6 1
a29 3
        CHARACTER *81    FILNAM1,FILNAM2,FILNAM3
        COMMON /COMMUN1/ FILNAM1,FILNAM2,FILNAM3

a30 1
        CHARACTER *1     NULL
d32 2
a33 2
        INCLUDE 'F90ALLOC.INC'
        REAL, DIMENSION(:), POINTER  :: VOLBUF
d35 3
a37 1
        LOGICAL          ASKNAME,MUSTGET,WANTNEXT,BARE1,BARE2,ISBARE
d49 1
a49 1
        IF (IRTFLG .NE. 0) GOTO 9001
d52 1
a52 1
        IF (IRTFLG .NE. 0) GOTO 9000
d57 1
d67 8
a74 1
           IF (IRTFLG .NE. 0) GOTO 9001
d77 2
a78 3

           CALL GETVOLDAT(LUNA,NSAM,NROW,NSLICE,VOLBUF,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9001
d89 1
a89 1
           IF (IRTFLG .NE. 0) GOTO 9000
d93 1
a93 1
              GOTO 9000
d96 1
a96 1
              GOTO 9000
d100 1
a100 1
           CALL ADD(VOLBUF(1),LUNB,IFORM1,NSAM,NROW,NSLICE,SIGN)
d109 1
a109 1
           IF (IRTFLG .NE. 0) GOTO 9000
d134 8
a141 1
           IF (IRTFLG .NE. 0) GOTO 9001
d149 1
a149 1
              IF (IRTFLG .NE. 0) GOTO 9001
d154 1
a154 1
                 GOTO 9001
d157 1
a157 1
                 GOTO 9001
d169 1
a169 1
           IF (IRTFLG .NE. 0) GOTO 9001
d180 1
a180 1
              IF (IRTFLG .NE. 0) GOTO 9001
d196 2
a197 2
           IF (IRTFLG .GT. 0 .AND. IMGNUM .LE. 1) GOTO 9001
           IF (IRTFLG .GT. 0) GOTO 9000
d200 2
a202 3
           CALL GETVOLDAT(LUNA,NSAM,NROW,NSLICE,VOLBUF,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9000

d210 1
a210 1
           IF (IRTFLG .GT. 0) GOTO 9000
d217 1
a217 1
           IF (IRTFLG .GT. 0) GOTO 9000
d233 1
a233 3
9000    CONTINUE

        CALL DEALLOCMEM_R(VOLBUF,IRTFLG)
d235 1
a235 1
9001    CLOSE(LUN1)
@


1.3
log
@changes for dec f90
@
text
@d34 1
a34 1
#ifdef SP_F90
a36 4
#else       
        POINTER          (IPVOL,VOLBUF) 
        DIMENSION        VOLBUF(1)
#endif
d70 1
a70 1
#ifdef SP_F90
a71 3
#else
           CALL GETVOLDAT(LUNA,NSAM,NROW,NSLICE,IPVOL,IRTFLG)
#endif 
d187 1
a187 1
#ifdef SP_F90
a188 4
#else
           CALL GETVOLDAT(LUNA,NSAM,NROW,NSLICE,IPVOL,IRTFLG)
#endif 

d222 1
a222 1
#ifdef SP_F90
a223 3
#else
        CALL DEALLOCMEM_R(IPVOL,IRTFLG)
#endif 
@


1.2
log
@*** empty log message ***
@
text
@d34 4
a37 1

d40 1
d73 4
a76 1
C          LOAD VOLUME FROM FIRST FILE INTO VOLBUF 
d78 1
d101 1
a101 1
           CALL ADD(VOLBUF,LUNB,IFORM1,NSAM,NROW,NSLICE,SIGN)
d194 3
d198 2
d232 6
a237 1
9000    CALL DEALLOCIT(IPVOL,IRTFLG)
@


1.1
log
@Initial revision
@
text
@d4 1
a4 1
C UTIL2SUP.FOR             NEW              8/1/97       ARDEAN LEITH  
d17 1
a17 1
C  UTIL2SUP(PROMPT1,PROMPT2,PROMPT3, LUNA,LUNB,LUNOUT, SIGN)
d47 2
d50 1
a50 1
        IF (IRTFLG .NE. 0) GOTO 9000
d67 1
a67 1
           IF (IRTFLG .NE. 0) GOTO 9000
d71 1
a71 1
           IF (IRTFLG .NE. 0) GOTO 9000
a89 3
           ELSEIF (MAXIM2 .GE. 0) THEN
              CALL ERRT(101,'CAN NOT USE WHOLE STACK HERE',NE)
              GOTO 9000
a103 5
           IF (MAXIM1 .GE. 0) THEN
               CALL ERRT(101,'CAN NOT USE WHOLE STACK HERE',NE)
               GOTO 9000
           ENDIF

d127 1
a127 1
           IF (IRTFLG .NE. 0) GOTO 9000
d135 1
a135 1
              IF (IRTFLG .NE. 0) GOTO 9000
d140 1
a140 1
                 GOTO 9000
d143 1
a143 1
                 GOTO 9000
d155 1
a155 1
           IF (IRTFLG .NE. 0) GOTO 9000
d166 1
a166 1
              IF (IRTFLG .NE. 0) GOTO 9000
d169 7
d182 1
d184 1
a184 1

d194 1
a194 7
C          IF FIRST FILE IS NOT A STACK CAN SKIP TO NEXTIMAGE
           WANTNEXT = (MAXIM1 .LT. 0)
 
C          IF FIRST FILE IS STACK MUSTGET SPECIFIED IMGNUM
           MUSTGET = .NOT. WANTNEXT 

           CALL GETOLDSTACK(LUNB,NSAM,IMGNUM,WANTNEXT,MUSTGET,
d218 6
a223 3
9000    CLOSE(LUNOUT)
        CLOSE(LUNB)
        CLOSE(LUNA)
a224 2
C       DEALLOCATE VOLBUF
        CALL DEALLOCIT(IPVOL,IRTFLG)
a229 38
C----------------------------------------------------------------     
#ifdef NEVER

        IF (MAXIM1 .GT. 0 .OR. MAXIM2 .GT. 0) THEN
C          STACK OPERATION, FIND OUT HOW MANY IMAGES ARE INVOLVED
           NIMAGE = MIN(MAXIM1,MAXIM2)
           IF (MAXIM1 .GT. 0 .AND. MAXIM2 .LE. 0) NIMAGE = MAXIM1
           IF (MAXIM1 .LE. 0 .AND. MAXIM2 .GT. 0) NIMAGE = MAXIM2

           IMGNUM = 1
           DO WHILE (IMGNUM .LE. NIMAGE)

              IF (N_VERBOSE .EQ. 1) WRITE(NOUT,*) ' '
              CALL GETOLDSTACK(LUNA,NSAM,IMGNUM,.TRUE.,.FALSE.,
     &                        .TRUE.,IRTFLG)
              IF (IRTFLG .GT. 0) GOTO 9000

C             WHAT HAPPENS IF STACK + STACK BUT ONE STACKED IMAGE
C             NOT PRESENT?? CURRENTLY PART OF STACK COULD BE 
C             INCONSISTENT WITH PREVIOUS PART OF STACK SINCE IT WILL
C             HALT ON ERROR!!!!!!!!!!!!!!al

C             IF FIRST FILE IS NOT A STACK CAN SKIP TO NEXTIMAGE
              WANTNEXT = (MAXIM1 .LT. 0) 
C             IF FIRST FILE IS STACK MUSTGET SPECIFIED IMGNUM
              MUSTGET = .NOT. WANTNEXT 
              CALL GETOLDSTACK(LUNB,NSAM,IMGNUM,WANTNEXT,MUSTGET,
     &                         .TRUE.,IRTFLG)
              IF (IRTFLG .GT. 0) GOTO 9000

              CALL GETNEWSTACK(LUNOUT,NSAM,IMGNUM,IRTFLG)
              IF (IRTFLG .GT. 0) GOTO 9000

C             DO THE ADDITION
              CALL ADD(VOLBUF,LUNIN,IFORM1,NSAM,NROW,NSLICE,SIGT)

              IMGNUM = IMGNUM + 1
           ENDDO
a230 1
#endif
@
