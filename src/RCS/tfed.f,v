head	1.30;
access;
symbols
	pre_mrcs:1.29
	healthdept_2018:1.29
	pre_getangas:1.15
	pre_GPL2010:1.13
	pre_var_equation:1.13
	pre_fftwrings:1.12
	pre_opfiles:1.12
	src:1.12
	best-code:1.12
	x-named-regs:1.11
	x:1.11
	v13-00:1.11
	pre_GPL:1.10
	prec_CA:1.7
	noindx:1.6;
locks; strict;
comment	@c @;


1.30
date	2025.09.21.15.07.25;	author dean;	state Exp;
branches;
next	1.29;

1.29
date	2013.11.25.14.39.30;	author leith;	state Exp;
branches;
next	1.28;

1.28
date	2013.04.04.15.09.56;	author leith;	state Exp;
branches;
next	1.27;

1.27
date	2013.04.02.18.24.34;	author leith;	state Exp;
branches;
next	1.26;

1.26
date	2013.03.12.14.44.28;	author leith;	state Exp;
branches;
next	1.25;

1.25
date	2013.03.12.12.31.05;	author leith;	state Exp;
branches;
next	1.24;

1.24
date	2013.03.05.20.11.22;	author leith;	state Exp;
branches;
next	1.23;

1.23
date	2013.03.05.19.56.24;	author leith;	state Exp;
branches;
next	1.22;

1.22
date	2013.01.07.15.21.32;	author leith;	state Exp;
branches;
next	1.21;

1.21
date	2012.06.27.16.16.17;	author leith;	state Exp;
branches;
next	1.20;

1.20
date	2012.06.27.14.18.00;	author leith;	state Exp;
branches;
next	1.19;

1.19
date	2012.06.26.19.11.18;	author leith;	state Exp;
branches;
next	1.18;

1.18
date	2012.06.26.14.59.45;	author leith;	state Exp;
branches;
next	1.17;

1.17
date	2012.06.26.14.11.59;	author leith;	state Exp;
branches;
next	1.16;

1.16
date	2012.05.16.18.57.47;	author leith;	state Exp;
branches;
next	1.15;

1.15
date	2010.09.16.20.01.05;	author leith;	state Exp;
branches;
next	1.14;

1.14
date	2010.09.14.19.51.36;	author leith;	state Exp;
branches;
next	1.13;

1.13
date	2009.01.16.14.20.24;	author bbaxter;	state Exp;
branches;
next	1.12;

1.12
date	2006.01.04.19.07.57;	author leith;	state Exp;
branches;
next	1.11;

1.11
date	2005.10.17.16.55.56;	author leith;	state Exp;
branches;
next	1.10;

1.10
date	2004.09.09.12.35.18;	author leith;	state Exp;
branches;
next	1.9;

1.9
date	2004.04.06.15.22.04;	author leith;	state Exp;
branches;
next	1.8;

1.8
date	2003.11.17.22.05.52;	author pawel;	state Exp;
branches;
next	1.7;

1.7
date	2003.03.04.14.20.53;	author leith;	state Exp;
branches;
next	1.6;

1.6
date	2002.11.19.16.25.20;	author leith;	state Exp;
branches;
next	1.5;

1.5
date	2002.11.19.15.55.00;	author leith;	state Exp;
branches;
next	1.4;

1.4
date	2002.08.22.18.06.17;	author leith;	state Exp;
branches;
next	1.3;

1.3
date	2002.06.21.19.30.25;	author bbaxter;	state Exp;
branches;
next	1.2;

1.2
date	2002.05.10.19.46.57;	author pawel;	state Exp;
branches;
next	1.1;

1.1
date	2002.05.10.18.47.50;	author pawel;	state Exp;
branches;
next	;


desc
@@


1.30
log
@C            GETDEFOCUS VERY BUGGY
@
text
@C **********************************************************************
C  TFED.F  
C            IMPROPER PS BUG FIXED               SEP   10 ArDean Leith
C            PROMPTS IMPROVED                    MAY   12 ArDean Leith
C            CTF ED                              JUN   12 ArDean Leith
C            DEF. DOC FILE COMMENTS CHANGED      APR   13 ArDean Leith
C            GETDEFOCUS VERY BUGGY                                                              
C=**********************************************************************
C=* From: SPIDER - MODULAR IMAGE PROCESSING SYSTEM                     *
C=* Copyright (C)2002, Z. Huang & P. A. Penczek                        *
C=* University of Texas - Houston Medical School                       *
C=* Email:  pawel.a.penczek@@uth.tmc.edu                                *
C=*                                                                    *
C=* This program is free software; you can redistribute it and/or      *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* This program is distributed in the hope that it will be useful,    *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
C=* General Public License for more details.                           *
C=*                                                                    *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program; if not, write to the                      *
C=* Free Software Foundation, Inc.,                                    *
C=* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.      *
C=*                                                                    *
C=**********************************************************************
C
C PURPOSE: DETERMINE DEFOCUS & ASTIGMATISM OF  
C          MICROGRAPH FROM 2D POWER SPECTRUM 
C            
C NOTE:    FULL OF BUGS. DEFOCUS IS OK FOR NON-ASTIGMATIC IMAGES
C          ASTIGMATISM IS TOTALLY BUGGY! THIS IS GARBAGE al mar 2013
C
C OPERATIONS:  TFED(), CTFED()
C
C **********************************************************************

      	SUBROUTINE  CTFED()

	INCLUDE 'CMBLOCK.INC'
	INCLUDE 'CMLIMIT.INC'
      	INCLUDE 'F90ALLOC.INC'

      	INTEGER, PARAMETER                :: NT=4 
      	REAL	                          :: DLIST(6)   
      	INTEGER	                          :: NUMBER 
      	REAL	                          :: GETDEFOCUS,LAMBDA,KEV
      	CHARACTER(LEN=1)                  :: NULL = CHAR(0)  
      	REAL, DIMENSION(:,:), ALLOCATABLE :: POW2,FNOI_OUT,BUFIN,BUFWIN
	REAL, DIMENSION(:,:), ALLOCATABLE :: BUFFFT,BUFPWS,BUFPOW
        CHARACTER(LEN=MAXNAM)             :: FILNAM,DOCNAM,FILPAT
        CHARACTER(LEN=90)                 :: COMMENT
        CHARACTER(LEN=60)                 :: FORMOUT

        LOGICAL                           :: ADDEXT,GETNAME,ISOLD
        LOGICAL                           :: APPEND,MESSAGE,NEWFILE

        LOGICAL                           :: ASKNAM = .TRUE.
        LOGICAL                           :: FOUROK = .FALSE.
        LOGICAL                           :: MASKIT = .TRUE.

        character(len=maxnam)             :: filjnk = 'jnkwin'
        character(len=maxnam)             :: filpow = 'jnkpow'

	COMMON /SEARCH_RANGE/ STRT_SRCH,STOP_SRCH,NMB

	REAL, PARAMETER    :: QUADPI = 3.141592653589793238462

	INTEGER, PARAMETER   :: LUNM    = 20
	INTEGER, PARAMETER   :: LUNPOW  = 21
	INTEGER, PARAMETER   :: LUNDOCM = 81
	INTEGER, PARAMETER   :: LUNDOCN = 82
	INTEGER, PARAMETER   :: LUNDOCD = 83
	INTEGER, PARAMETER   :: LUNXM   = 0
	CHARACTER, PARAMETER :: MODE    = ' '

C       DEFOCUSGUESSING3 FOR WEAK DEFOCUS ASTIGMATISM ESTIMATION  
C       DEFOCUSGUESSING2 FOR STRONG ASTIGMATISM ESTIMATION

	STRT_SRCH = 3000.0
      	STOP_SRCH = 200000.0

C       OPEN FIRST MICROGRAPH FILE, NOT FOURIER
        MAXIMM  = 0                       
        NILMAX  = NIMAX         ! INUMBR FROM CMLIMIT
        CALL OPFILES(0,LUNM,LUNDOCM,LUNXM,           
     &             ASKNAM,FILPAT,NLETM, 'O',         
     &             IFORMM,NXM,NYM,NZM,MAXIMM,         
     &             'MICROGRAPH IMAGE',                              
     &             FOUROK, INUMBR,NILMAX,             
     &             NDUM,NGOT1,IMG1, IRTFLG)           
        IF (IRTFLG .NE. 0) RETURN                    
        IF (NZM > 1) THEN
           CALL ERRT(101,'OPERATION DOES NOT WORK ON VOLUMES',NE)
           RETURN
        ENDIF

        NXT    = 500
        IXOVER =  50
        IYOVER = -999
        CALL RDPRI3S(NXT,IXOVER,IYOVER,NOT_USED,
     &             'TILE SIZE, X & Y TILE PERCENT OVERLAP',IRTFLG)
        IF (IRTFLG .NE. 0) RETURN
        IF (IYOVER < 0) IYOVER = IXOVER

        IF (IXOVER < 0 .OR. IXOVER > 99) THEN
           CALL ERRT(102,'X OVERLAP OUT OF RANGE (0..99)',IXOVER)
           RETURN
        ELSEIF (IYOVER < 0 .OR. IYOVER > 99) THEN
           CALL ERRT(102,'Y OVERLAP OUT OF RANGE (0..99)',IYOVER)
           RETURN
        ELSEIF (NXT < 5 .OR. NXT > NXM .OR. NXT > NYM) THEN
           CALL ERRT(102,'TILE SIZE OUT OF RANGE',NXT)
           RETURN
        ENDIF

        IXB =  500
        IYB = -999
        CALL RDPRI2S(IXB,IYB,NOT_USED,'X & Y TILING BORDER',IRTFLG)
        IF (IRTFLG .NE. 0) RETURN
        IF (IYB < 0) IYB = IXB

        IF (IXB < 0 .OR. IXB > NXM) THEN
           CALL ERRT(102,'X BORDER OUT OF RANGE' ,IXB)
           RETURN
        ELSEIF (IYB < 0 .OR. IYB > NYM) THEN
           CALL ERRT(102,'Y BORDER OUT OF RANGE',IYB)
           RETURN
        ENDIF

        ! NORMALIZATION OF % OVERLAP IN X & Y
        ROX  = 100.0 / (100.0 - IXOVER)                  
        ROY  = 100.0 / (100.0 - IYOVER)                  

        ! NO. OF TILES HORIZONTAL DIM.(X)
        XOFF  = FLOAT(IXOVER) * FLOAT(NXT) / 100.0
        IXOFF = NXT - INT(XOFF)
        NPX   = 0
        IXGO  = IXB + 1
        !WRITE(6,*) '  ixover:',ixover,'xoff:',xoff,'ixoff:',ixoff
        !write(6,*)  ' npx,ixgo,ixb:',npx,ixgo,ixb
        DO
           IF ((IXGO + NXT) > (NXM - IXB)) EXIT
           IXGO = IXGO + IXOFF
           NPX  = NPX + 1
        ENDDO

        YOFF  = FLOAT(IYOVER) * FLOAT(NXT) / 100.0
        IYOFF = NXT - INT(YOFF)
        NPY   = 0
        IYGO  = IYB + 1
        DO
           IF ((IYGO + NXT) > (NYM - IYB)) EXIT
           IYGO = IYGO + IYOFF
           NPY  = NPY + 1
        ENDDO
        WRITE(NOUT,'(A,I4, A,I4, A,I4)') 
     &          '  Tiles:',NPX,' x',NPY,'  Size:',NXT

        PS  = 1
        CSM = 2.0
        CALL RDPRM2S(PS,CSM,NOT_USED,
     &      'PIXEL SIZE [A] & SPHERICAL ABERRATION CS [MM]',IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9999
           IF (CS < 0.0001)    CS = 0.0001

C     	CONVERT CS TO [A]
      	CS = CSM * 1.0E07

        KEV = 200.0
        !LAMBDA = 2.508E-02
      	CALL RDPRM1S(KEV,NOT_USED,'ELECTON VOLTAGE [KEV]',IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9999
        LAMBDA = 12.398 / SQRT(KEV*(1022+KEV))
          
        CONTRAST = 0.100 
      	CALL RDPRM1S(CONTRAST,NOT_USED,
     &           'AMPLITUDE CONTRAST RATIO [0-1]',IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9999



        NXLD = NXT + 2 - MOD(NXT,2)
        NMB  = NXT/2  + MOD(NXT,2)

	ALLOCATE(FNOI_OUT(NMB, NT),
     &           BUFIN   (NXM, NXT),
     &           BUFWIN  (NXT, NXT),
     &           BUFFFT  (NXLD,NXT),
     &           BUFPOW  (NXT, NXT),
     &           STAT=IRTFLG)
        IF (IRTFLG .NE. 0)  THEN
           MWANT = NXM*NXT + 2*NXT*NXT + NXLD*NXT + NMB*NT
           CALL ERRT(46,'TFED; BUFIN..',MWANT)
           RETURN
        ENDIF

        IYWINGO = IYB + 1         ! FIRST Y
        IGOT    = 0               ! TILE COUNTER

        DO KY = 1, NPY            ! LOOP OVER ALL TILE ROWS

C          READ IN NXT ROWS
           IYW = 1
           DO IYF = IYWINGO, IYWINGO+NXT-1
              CALL REDLIN(LUNM,BUFIN(1,IYW),NXM, IYF)
              IYW = IYW + 1
           ENDDO

           !call chkfile(filjnk(1:8),66,1, nxm,nxt,1, bufin,irtflg)

           IXW = IXB + 1          ! FIRST X
           DO KX = 1, NPX         ! LOOP OVER ALL HORIZ. TILE ROWS

              BUFWIN(1:NXT, 1:NXT) = BUFIN(IXW:IXW+NXT-1, 1:NXT)
              IXW = IXW + IXOFF

              !call inttochar(igot,filjnk(7:9),nlet,3)
              !call chkfile(filjnk(1:9),66,1,nxt,nxt,1,bufwin,irtflg)

C             CORRECT RAMP INTENSITIES
              CALL RAMP_PB(BUFWIN,NXT,NXT,.FALSE.,NOUT)

C             PAD INTO BUFFFT
              BUFFFT(1:NXT, 1:NXT) = BUFWIN(1:NXT,1:NXT)

              INV = +1   ! FORWARD FFT 
              CALL FMRS_2(BUFFFT,NXT,NXT,INV)
              CALL PW2SR (BUFFFT,NXT,NXT,MODE)

              IGOT = IGOT + 1

              IF (IGOT > 1) THEN
                 BUFPOW(1:NXT, 1:NXT) = BUFPOW(1:NXT, 1:NXT) + 
     &                                  BUFFFT(1:NXT, 1:NXT)
              ELSE
                 BUFPOW(1:NXT, 1:NXT) = BUFFFT(1:NXT, 1:NXT)
              ENDIF
              !call inttochar(igot,filjnk(7:9),nlet,3)
              !call chkfile(filjnk(1:9),66,1,nxt,nxt,1,bufwin,irtflg)

           ENDDO

           IYWINGO = IYWINGO + IYOFF
        ENDDO

        SQRTNT = SQRT(FLOAT(IGOT))     ! Why?? Legacy continued
        BUFPOW = BUFPOW / SQRTNT
        !call chkfile('jnkpow',66,1,nxt,nxt,1,bufpow,irtflg)

        IF (MASKIT) THEN  ! NOT ACTIVATED
           ICX      = NXT/2 + 1          ! X,Y CENTER
           BACKPIX  = BUFPOW(ICX+10,5)   ! PERIPHERAL PIXEL VALUE

           RADMASKI = .95 * NXT          ! POWER SPECTRUM MASK RADIUS (A)  (0 = DON'T MASK)
           RADMASKI = .5 * NXT          ! POWER SPECTRUM MASK RADIUS (A)  (0 = DON'T MASK)

           CIRCF    = 2 * PS / RADMASKI  ! MASK RADIUS (NOW IN 1/PX)
           CIRCI    = CIRCF * NXT        ! COMPUTE MASK RADIUS

C          CENTRAL MASKING
           DO  IY = 1,NXT
              FI1 =  FLOAT(IY-ICX)**2 
              DO  IX = 1,NXT
                 CRAD2 = FI1 + FLOAT(IX-ICX)**2
                 IF (CRAD2 < CIRCI) BUFPOW(IX,IY) = BACKPIX
              ENDDO
	   ENDDO
	ENDIF
        write(NOUT,'(A,F5.0)') '  Central PS mask radius:',CIRCI

C       ESTIMATING DEFOCUS BASED ON OVERALL POWER SPECTRUM
C       SET THE START ANGLE AND STEP TO BE 0.0 AND 180.0.
        BETA0 = 0.0
	BETA1 = 180.0

        !write(6,*) 'CALLING DEFOCUSGUESSING1 -----------:'
	CALL DEFOCUSGUESSING1(BUFPOW,NXT,NXT,NMB,BETA0,BETA1,
     & 		PS,CS,LAMBDA,CONTRAST,AV_DEFO,
     &		ICUT_LOW_FRQ,ICN_SND,NDGREE,FNOI_OUT,NT,XX_CC,NUMBER)
        IF (NUMBER <= 0) GOTO 9999

        FNOI_OUT(1:NUMBER,2:4)= EXP(FNOI_OUT(1:NUMBER,2:4))
        FNOI_OUT(1:NUMBER,1)  = FNOI_OUT(1:NUMBER,1)/2.0/PS/NMB

        FNOI_OUT(1:NUMBER,3) = FNOI_OUT(1:NUMBER,3)-FNOI_OUT(1:NUMBER,2)
        FNOI_OUT(1:NUMBER,4) = FNOI_OUT(1:NUMBER,4)-FNOI_OUT(1:NUMBER,2)

        ADDEXT  = .TRUE.
        GETNAME = .TRUE.
        ISOLD   = .FALSE.
        APPEND  = .FALSE.
        MESSAGE = .TRUE.
        IRTFLG  = -8         ! NO IC USE

        CALL OPENDOC(DOCNAM,ADDEXT,NLET,LUNDOCN,LUNDOCNO,GETNAME,
     &           'DEFOCUS NOISE DOC',ISOLD,APPEND,MESSAGE,
     &            NEWFILE,IRTFLG)

C           123456789 123456789 123456789 123456789 123456789 123456789 
        COMMENT = 
     &     '  Spa. freq.(1/A), Back. noise, Back. subtr. PS,  Env(f)**2'
        CALL LUNDOCPUTCOM(LUNDOCNO,COMMENT(1:69),IRTFLG)

	DO KEY=1,NUMBER
            DLIST(1) = FNOI_OUT(KEY,1)
            DLIST(2) = FNOI_OUT(KEY,2)
            DLIST(3) = FNOI_OUT(KEY,3)
            DLIST(4) = FNOI_OUT(KEY,4)
            CALL LUNDOCWRTDAT(LUNDOCNO,KEY,DLIST,4,IRTFLG)
	ENDDO
	CLOSE(LUNDOCN)

        !write(6,*) 'DEFOCUS FOUND:',AV_DEFO 

	IF ( XX_CC == 9999 .OR. AV_DEFO <= STRT_SRCH) THEN
C           ESTIMATE DEFOCUS OF DIFFICULT CASES
	    XX_CC   = 9999.
	    AST_AGL = 0.0
	    TMP_AMP = 0.0
	    TMP_SUM = 0.0
	ELSE	

           WRITE(NOUT,*) ' ASTIGMATISM CALCULATION NO LONGER DONE'
c          calculation is buggy often crashes. removed mar 2013 al           

        ENDIF

C       ROUGH ESTIMATION OF DEFOCUS IN DIFFICULT CASE AND NO ASTIGMATISM ESTIMATION IN SUCH CASE!
        IF (XX_CC > 1) THEN
            CALL DEFOCUSGUESSING3(BUFPOW,NXT,NXT,NMB,
     & 		       PS,CS,LAMBDA,CONTRAST,AV_DEFO,XX_CC)
	ENDIF
        
        WRITE(NOUT,'(A,F8.1)')'  OVERALL DEFOCUS: ',AV_DEFO

C       OPEN OUTPUT DOC FILE (FOR APPENDING)
        ADDEXT  = .TRUE.
        GETNAME = .TRUE.
        ISOLD   = .FALSE.
        APPEND  = .TRUE.
        MESSAGE = .TRUE.
        IRTFLG  = -8         ! NO IC USE

        LUNRET = LUNDOCD
        CALL OPENDOC(DOCNAM,addext,NLET,LUNDOCD,LUNRET,GETNAME,
     &             'OUTPUT DEFOCUS DOCUMENT',ISOLD,APPEND,MESSAGE,
     &             NEWFILE,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9999

        IF (NEWFILE) THEN

C                     123456789 123456789 123456789 123456789 123456789 123456789 
           COMMENT = 'CONTENTS:   MICROGRAPH DEFOCUS VALUES' 

           CALL LUNDOCPUTCOM(LUNRET,COMMENT(1:37),IRTFLG)
C                     123456789 123456789 123456789 123456789 123456789 123456789012
           COMMENT = '          MICR.  DEFOCUS  CUTOFF'
           CALL LUNDOCPUTCOM(LUNRET,COMMENT(1:35),IRTFLG)
        ENDIF

        KEY = 1
        CALL RDPRI1S(KEY, NOT_USED,
     &     'KEY/IMAGE NUMBER FOR DOC FILE',IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9999
      
        FORMOUT  = '(I7,1X,I2,1X,F7.0,1X,F8.1,1X,F6.3)'
        DLIST(1) = KEY 
        DLIST(2) = AV_DEFO 
        DLIST(3) = XX_CC 
        CALL LUNDOCWRTDATF(LUNRET,KEY,DLIST,3,FORMOUT,IRTFLG)

	CLOSE(LUNDOCD)

C       SAVE AVERAGE POWER SPECTRUM
        IFORM = 1
        MAXIM = 0
        CALL OPFILEC(0,.TRUE.,FILNAM,LUNPOW,'U',IFORM,NXT,NXT,1,
     &               MAXIM,'AVERAGE POWER SPECTRUM',FOUROK,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9999
        CALL WRTVOL(LUNPOW,NXT,NXT,1,1,BUFPOW,IRTFLG)

	CALL REG_SET_NSEL(1,3, AV_DEFO, XX_CC,FLOAT(IGOT),0,0,IRTFLG)

9999    IF (ALLOCATED(POW2))     DEALLOCATE(POW2)
	IF (ALLOCATED(FNOI_OUT)) DEALLOCATE(FNOI_OUT)
	IF (ALLOCATED(BUFIN))    DEALLOCATE(BUFIN)
	IF (ALLOCATED(BUFWIN))   DEALLOCATE(BUFWIN)
	IF (ALLOCATED(BUFFFT))   DEALLOCATE(BUFFFT)
	IF (ALLOCATED(BUFPWS))   DEALLOCATE(BUFPWS)
	IF (ALLOCATED(BUFPOW))   DEALLOCATE(BUFPOW)

        END







C ****************************** TFED ********************************

      	SUBROUTINE  TFED

	INCLUDE 'CMBLOCK.INC'
	INCLUDE 'CMLIMIT.INC'
      	INCLUDE 'F90ALLOC.INC'

      	PARAMETER  (NLIST=5,NT=4)
      	REAL	                          :: DLIST(NLIST)   
      	INTEGER	                          :: NUMBER 
      	LOGICAL	                          :: NEWFILE 
      	REAL	                          :: ASTIGFLAG  
      	LOGICAL	                          :: DOASTIG  ! for debugging 
      	REAL	                          :: GETDEFOCUS,LAMBDA
      	CHARACTER(LEN=1)                  :: NULL = CHAR(0)  
      	REAL, DIMENSION(:,:), ALLOCATABLE :: POW2,TMP_OUT
	REAL, DIMENSION(:),ALLOCATABLE    :: XDEFO
        CHARACTER(LEN=MAXNAM)             :: FILNAM,DOCNAM
        CHARACTER(LEN=80)                 :: COMMENT

	COMMON /SEARCH_RANGE/ STRT_SRCH,STOP_SRCH,NMB

	PARAMETER (QUADPI = 3.141592653589793238462)

	DATA      LUN1/88/
      	DATA      NDOC/88/


C       DEFOCUSGUESSING3 FOR WEAK DEFOCUS ASTIGMATISM ESTIMATION  
C       DEFOCUSGUESSING2 FOR STRONG ASTIGMATISM ESTIMATION

	STRT_SRCH = 3000.0
      	STOP_SRCH = 200000.0
        MAXIM1    = 0

        CALL OPFILEC(0,.TRUE.,FILNAM,LUN1,'O',ITYP,NSAM1,NROW1,NSLIC1,
     &             MAXIM1,'INPUT',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0) THEN
            CALL ERRT(101,',OPENING INPUT FILE',NE)
            RETURN
        ENDIF
        		
	IF (NSAM1 .NE. NROW1) THEN
	    CLOSE(LUN1)
	    CALL ERRT(101,'IMAGE MUST BE SQUARE',NE)
	    RETURN
	ENDIF

        CALL RDPRM2(PS,CS,NOT_USED,
     &      'PIXEL SIZE[A] & SPHERICAL ABERRATION CS [MM]')
           IF (CS < 0.0001)    CS = 0.0001

C     	CONVERT CS TO [A]
      	CS = CS*1.0E07

      	CALL RDPRM(LAMBDA,NOT_USED,'WAVELENGTH LAMBDA [A]')

        ASTIGFLAG = 0
      	CALL RDPRM2S(CONTRAST,ASTIGFLAG,NOT_USED,
     &           'AMPLITUDE CONTRAST RATIO [0-1]',IRTFLG)
        IF (IRTFLG .NE. 0) RETURN
        DOASTIG = (ASTIGFLAG > 0)

        NMB  = NSAM1/2  + MOD(NSAM1,2)

	ALLOCATE(POW2(NSAM1,NROW1),TMP_OUT(NMB,NT),STAT=IRTFLG)
        IF (IRTFLG .NE. 0)  THEN
           MWANT = NSAM1*NROW1 + NMB*NT
           CALL ERRT(46,'TFED; POW2..',MWANT)
           RETURN
        ENDIF

	CALL READV(LUN1,POW2,NSAM1,NROW1,NSAM1,NROW1,NSLIC1)
	CLOSE(LUN1)
	
C       ESTIMATING DEFOCUS BASED ON OVERALL POWER SPECTRUM
C       SET THE START ANGLE AND STEP TO BE 0.0 AND 180.0.
        BETA0 = 0.0
	BETA1 = 180.

	CALL DEFOCUSGUESSING1(POW2,NSAM1,NROW1,NMB,BETA0,BETA1,
     & 		PS,CS,LAMBDA,CONTRAST,AV_DEFO,
     &		ICUT_LOW_FRQ,ICN_SND,NDGREE,TMP_OUT,NT,XX_CC,NUMBER)

        IF (NUMBER .LE. 0) THEN   ! ERROR RETURN al
           GOTO 9999
        ENDIF

        TMP_OUT(1:NUMBER,2:4)= EXP(TMP_OUT(1:NUMBER,2:4))
        TMP_OUT(1:NUMBER,1)  = TMP_OUT(1:NUMBER,1)/2.0/PS/NMB
        TMP_OUT(1:NUMBER,3)  = TMP_OUT(1:NUMBER,3)-TMP_OUT(1:NUMBER,2)
        TMP_OUT(1:NUMBER,4)  = TMP_OUT(1:NUMBER,4)-TMP_OUT(1:NUMBER,2)

        CALL OPENDOC(DOCNAM,.TRUE.,NLET,NDOC,LUNDOC,.TRUE.,
     &           'DEFOCUS DOCUMENT',.FALSE.,.FALSE.,.TRUE.,
     &            NEWFILE,IRTFLG)

C           123456789 123456789 123456789 123456789 123456789 123456789 
        COMMENT = 
     &     '  Spa. freq.(1/A), Back. noise, Back. subtr. PS,  Env(f)**2'
        CALL LUNDOCPUTCOM(LUNDOC,COMMENT(1:69),IRTFLG)

	DO II=1,NUMBER
	    DLIST(1) = II
	    DLIST(2) = TMP_OUT(II,1)
	    DLIST(3) = TMP_OUT(II,2)
	    DLIST(4) = TMP_OUT(II,3)
	    DLIST(5) = TMP_OUT(II,4)
            CALL LUNDOCWRTDAT(LUNDOC,II,DLIST(2),NLIST-1,IRTFLG)
	ENDDO
	CLOSE(NDOC)

	AST_AGL = 0.0
	AST_AMP = 0.0
	AST_DEF = AV_DEFO

	IF (DOASTIG .AND. 
     &      XX_CC .NE. 9999 .AND.
     &      AV_DEFO > STRT_SRCH ) THEN	
           
C          ESTIMATION OF ASTIGMATISM; STEP IS 18 DEGREES  BUGGY!!!!!!
	   X_AV_DEFO = AV_DEFO
  	   IDGREE    = NDGREE
	   CALL AST_CALC(POW2,NSAM1,NROW1,NMB,NT,PS,CS,
     &	     LAMBDA,CONTRAST,X_AV_DEFO,IDGREE,AST_AGL,AST_AMP,AST_DEF)

        ENDIF

C       ROUGH ESTIMATION OF DEFOCUS IN DIFFICULT CASE AND NO ASTIGMATISM ESTIMATION IN SUCH CASE!
        IF (XX_CC > 1) THEN
            CALL DEFOCUSGUESSING3(POW2,NSAM1,NROW1,NMB,
     & 		     PS,CS,LAMBDA,CONTRAST,AV_DEFO,XX_CC)
	ENDIF

	CALL REG_SET_NSEL(1,5,AST_AGL,AST_AMP,AST_DEF,AV_DEFO,
     &                       XX_CC,IRTFLG)

9999    DEALLOCATE(POW2,TMP_OUT)

        END



CC======================================================================

      	SUBROUTINE CTF_SIGNAL1(VALUE, X,LENGTH,
     &			PS, CS, LAMBDA, DEFOCUS, CONTRAST)

C       X IS X COORDINATES!	  
      	IMPLICIT NONE

      	REAL 		QUADPI
      	PARAMETER (QUADPI = 3.1415926535897932384626)
      	REAL		IPS
	COMMON /SEARCH_RANGE/ DZLOW1,DZHIGH1,NMB
      	INTEGER  LENGTH, I,NMB
      	REAL		VALUE(LENGTH),X(LENGTH)
      	REAL	 	PS, CS, LAMBDA, DEFOCUS, CONTRAST, FF
      	REAL		AA, BB, CC,DZLOW1,DZHIGH1
      
	AA = 0.5*QUADPI*CS*LAMBDA**3
      	BB = QUADPI*LAMBDA
      	CC = ATAN(CONTRAST/(1.0-CONTRAST))
      	IPS = 1.0/(2.0*PS*NMB)

      	DO I=1, LENGTH
      	    FF = X(I)*IPS
      	    VALUE(I) = SIN((AA*FF**2-BB*DEFOCUS)*FF**2-CC)
      	ENDDO      
      	END

C=========================================================================

       	SUBROUTINE GET_CTF_ZERO(NUMBER,PS, CS, 
     & 	LAMBDA, DEFOCUS, CONTRAST,IFRQ1,IFRQ2,NZERO,IFIRST,ISECND)

	COMMON /SEARCH_RANGE/ DZLOW1,DZHIGH1,NMB
      	PARAMETER (QUADPI = 3.1415926535897932384626)
       	REAL LAMBDA,DZLOW1,DZHIGH1

       	AA = -0.5*QUADPI*CS*LAMBDA**3
       	BB = QUADPI*LAMBDA
       	BB=BB*DEFOCUS
       	CC = -ATAN(CONTRAST/(1.0-CONTRAST))
	FRQ1=REAL(IFRQ1)/2.0/PS/REAL(NMB)
	FRQ2=REAL(IFRQ2)/2.0/PS/REAL(NMB)
       	TMPN1=AA*FRQ1**4+BB*FRQ1**2+CC
       	TMPN1=TMPN1/QUADPI
       	N1=INT(TMPN1)
	TMPN2=AA*FRQ2**4+BB*FRQ2**2+CC
       	TMPN2=TMPN2/QUADPI
       	N2=INT(TMPN2)
	N=N2-N1+1
	TMP1=4.*AA

	DO II=1,N2
	    TMP2=CC-REAL(II-1)*QUADPI
	    TMP2=SQRT(BB**2-TMP1*TMP2)
	    TMP2=TMP2-BB
	    TMP2=SQRT(TMP2/2.0/AA)
	    NFRQ=INT(TMP2*2.0*PS*NMB)
	ENDDO

	IF(N1.GT.1) THEN
	    DO II=1,N1
		TMP2=CC-REAL(II-1)*QUADPI
		TMP2=SQRT(BB**2-TMP1*TMP2)
		TMP2=TMP2-BB
		TMP2=SQRT(TMP2/2.0/AA)
		NFRQ=INT(TMP2*2.0*PS*NMB)

		IF(II.EQ.1) THEN
		    IFIRST=NFRQ
		ELSEIF(II.EQ.2) THEN
		    ISECND=NFRQ
		ENDIF	
	    ENDDO
	ELSE
CC==FURTHER SEARCH CTF ZERO, FOR THOSE N.LE.0
	    IFIRST=IFRQ1
	    ISECND=0
	ENDIF

	NZERO=N
3000	RETURN
	END

CC===================================================================

 	SUBROUTINE ZH_CRCSE2(BUF,SEC,NSAM,NROW,IR,BETA0,BETA1)

CC==    ROTATIONAL AVERAGE FROM BETA0 TO BETA1!

        DIMENSION BUF(NSAM,NROW), SEC(IR), SNO(IR)

	PARAMETER (QUADPI= 3.1415926535897932384626)
	PARAMETER (DGR_TO_RAD = (QUADPI/180.))

CC==    BEGIN
	XBETA0 = BETA0*DGR_TO_RAD
	XBETA1 = BETA1*DGR_TO_RAD+XBETA0
CC==       
         SEC = 0.0
         SNO = 0.0        
         DO J=1,NROW
            KJ = J-NROW/2-1

            IF (IABS(KJ) .LE. IR-1)  THEN

               DO I=1,NSAM
                  KI = I-NSAM/2-1
                  R  = SQRT(FLOAT(KJ*KJ)+FLOAT(KI*KI))+1.0
                  L  = R

                  IF (L.LE.IR-1) THEN
			ANGLE = ATAN2(REAL(KI),REAL(KJ))
			IF (ANGLE.LT.0.0) ANGLE=ANGLE+2.*QUADPI

			IF(ANGLE.GE.XBETA0.AND.ANGLE.LT.XBETA1) THEN
                     	    XD       = R-L
                     	    SEC(L)   = SEC(L)  + BUF(I,J)*(1.0-XD)
                     	    SEC(L+1) = SEC(L+1)+ BUF(I,J)*XD
                     	    SNO(L)   = SNO(L)  + 1.0-XD
                     	    SNO(L+1) = SNO(L+1)+ XD
			ENDIF
                  ENDIF
               ENDDO
            ENDIF
         ENDDO

         DO I=1,IR
             SEC(I)= SEC(I) / AMAX1(1.0,SNO(I))
         ENDDO

         END

CC=============================================================

	SUBROUTINE PARTI8 (KLMD,NKLMD,KLM2D,N2D,Q2,
     &  K,N2,PLOT1,N,ICUT1,ICUT2,KP)

	REAL Q2(KLM2D,N2D),PLOT1(K,N2)
CC==TT1_Q2,Q,X,RES,CU,S,IU are automatic arrays
	REAL TT1_Q2(KLM2D,N2D)
	DOUBLE PRECISION Q(KLM2D,N2D),X(N2D),RES(KLMD),CU(2,NKLMD),
     &                   S(KLMD)
      	INTEGER IU(2,NKLMD)
      	INTEGER  TMPI,TMPJ
CC==LOW FREQUENCIES REGION RE-FITTING!!!
CC==INTERMDEDIATE REGION FITTING
	ISTART=ICUT1
	ISTOP=ICUT2 
	N_3=N
CC==
	KS=ISTOP-ISTART+1
	L=2
	ISWI=4
	TT1_Q2(1:KS,1:N+1)=Q2(ISTART:ISTOP,1:N+1)
	TT1_Q2(KS+1,1:N-1)=Q2(ISTART,1:N-1)
	TT1_Q2(KS+2,1:N-1)=Q2(ISTOP,1:N-1)
	TT1_Q2(KS+2,N)=1.0
	TT1_Q2(KS+1,N)=1.0
	TT1_Q2(KS+2,N+1)=PLOT1(ISTOP,3) 
	TT1_Q2(KS+1,N+1)=PLOT1(ISTART,3)
   
	CALL LSFIT(KS,L,N2,PLOT1(ISTART,2+(ISWI-3)*2),
     &         KLM2D,N2D,TT1_Q2,N_3,ISWI,
     &         Q,X,RES,CU,S,IU,KLMD,NKLMD,KP)
CC==
	KS=ISTART
	L=1
	ISWI=5
	TT1_Q2(1:KS,1:N+1)=Q2(1:ISTART,1:N+1)
	TT1_Q2(KS+1,1:N-1)=Q2(ISTART,1:N-1)
	TT1_Q2(KS+1,N)=1.0
	TT1_Q2(KS+1,N+1)=PLOT1(ISTART,3)
 
	CALL LSFIT(KS,L,N2,PLOT1(1,2+(ISWI-4)*2),
     &         KLM2D,N2D,TT1_Q2,N_3,ISWI,
     &         Q,X,RES,CU,S,IU,KLMD,NKLMD,KP)		
	END

CC========================================================

     	SUBROUTINE XFIT_ZH(K,N2,N,PLOT,ICUT1,ICUT2)

CCC==INEQUALITY CONSTRAINED LINEAR SQUARE MINIMIZATION
CCC==Q1, Q2=KLM2D*N2D
CC==PLOT=K*4
CC==ENVELOPE FITTING 
	
      	REAL, DIMENSION(:,:), ALLOCATABLE :: Q2
CC==INCREASE ARRAY Q4 FOR DIFFERENT RANK FITTING TO ABV OR UDR 
      	REAL PLOT(K,N2)
	REAL LAMBDA

      	L=2
      	M=K
      	N1=N+1
CC==DEFINE SIZE OF WORKING ARRAYS!
      	KLMD=K+L+M
      	KLM2D=K+L+M+2
      	NKLMD=K+L+M+N
      	N2D=N+2
      	KP=K
CC==FOR N.GT.2 CACULATION, ARRAY SIZE NEED ENLARGED!
      	N_LARG=KLMD*2
      	KLM2D=KLM2D+N_LARG
      	KLMD=KLMD+N_LARG
      	N2D=N2D+N_LARG
      	NKLMD=NKLMD+N_LARG
CC==
      	ALLOCATE(Q2(KLM2D,N2D),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
            CALL ERRT(46,'TFED',NE)
         RETURN
         ENDIF
CC==
	DO I=1,N-1
	    Q2(1:K,I)=PLOT(1:K,1)**I
      	ENDDO

	Q2(1:K,N)=1.0
	Q2(1:K,N+1)=PLOT(1:K,3)
        Q2(K+1:2*K,1:N+1)=Q2(1:K,1:N+1)

	CALL PARTI8 (KLMD,NKLMD,KLM2D,N2D,Q2,
     &  K,N2,PLOT,N,ICUT1,ICUT2,KP)
     	DEALLOCATE(Q2)
	
      	END

CCC=================================

	SUBROUTINE PARTI9(KLMD,NKLMD,KLM2D,N2D,Q2,
     &           K,N2,N,PLOT1,IFIT1,IFIT2,KP)

	REAL Q2(KLM2D,N2D),PLOT1(K,N2)
CC==TT1_Q2,Q,X,RES,CU,S,IU are automatic arrays
	REAL TT1_Q2(KLM2D,N2D)
	DOUBLE PRECISION Q(KLM2D,N2D),X(N2D),RES(KLMD),CU(2,NKLMD),
     &                   S(KLMD)
      	INTEGER IU(2,NKLMD)
      	INTEGER  TMPI,TMPJ
CC==LOW FREQUENCIES REGION RE-FITTING!!!
CC==THIS SUBROUTINE IS FOR THE PURPOSE OF SEARCHING POINT TO CUT LOW FREQUENCY REGION OFF
	ISTART=IFIT1
	ISTOP=IFIT2
	N_3=N
	KS=ISTOP-ISTART+1
	L=0
CC==ENV
	ISWI=1
	TT1_Q2(1:KS,1:N+1)=Q2(ISTART:ISTOP,1:N+1)

	CALL LSFIT(KS,L,N2,PLOT1(ISTART,(ISWI-1)*2+2),
     &         KLM2D,N2D,TT1_Q2,N_3,ISWI,
     &         Q,X,RES,CU,S,IU,KLMD,NKLMD,KP)
CC==BACKGROUND
	ISWI=2
	TT1_Q2(1:KS,1:N+1)=Q2(ISTART:ISTOP,1:N+1)
	CALL LSFIT(KS,L,N2,PLOT1(ISTART,(ISWI-1)*2+2),
     &         KLM2D,N2D,TT1_Q2,N_3,ISWI,
     &         Q,X,RES,CU,S,IU,KLMD,NKLMD,KP)
	END

CC===============================================================

     	SUBROUTINE XFITLINE1(K,N2,PLOT,IFIT1,IFIT2,ICUT)

CCC==Q1, Q2=KLM2D*N2D
CC==PLOT=K*4
      	REAL, DIMENSION(:,:), ALLOCATABLE :: Q2
CC==INCREASE ARRAY Q4 FOR DIFFERENT RANK FITTING TO ABV OR UDR 
      	REAL PLOT(K,N2)
      	
CC==IN THIS CASE, K=NMB
	X_THR=0.000001
	N=2
      	L=0
      	M=K
      	N1=N+1
CC==DEFINE SIZE OF WORKING ARRAYS!
      	KLMD=K+L+M
      	KLM2D=K+L+M+2
      	NKLMD=K+L+M+N
      	N2D=N+2
      	KP=K
CC==FOR N.GT.2 CACULATION, ARRAY SIZE NEED ENLARGED!
      	N_LARG=KLMD*2
      	KLM2D=KLM2D+N_LARG
      	KLMD=KLMD+N_LARG
      	N2D=N2D+N_LARG
      	NKLMD=NKLMD+N_LARG
CC==
      	ALLOCATE(Q2(KLM2D,N2D),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
            CALL ERRT(46,'TFED',NE)
         RETURN
         ENDIF
CC==
	Q2(1:K,1)=PLOT(1:K,1)
	Q2(1:K,2)=1.0
	Q2(1:K,3)=PLOT(1:K,3)
CC==
	CALL PARTI9(KLMD,NKLMD,KLM2D,N2D,Q2,
     &      K,N2,N,PLOT,IFIT1,IFIT2,KP)
CC==SEARCHING THE CUTTING POINT IN THE LOW FREQUENCIES
	PLOT(IFIT1:IFIT2,4)=PLOT(IFIT1:IFIT2,3)-PLOT(IFIT1:IFIT2,2)
	PLOT(IFIT1:IFIT2,4)=PLOT(IFIT1:IFIT2,4)/PLOT(IFIT1:IFIT2,2)

	DO I=IFIT1,IFIT2
	    XX=ABS(PLOT(I,4))
	    IF(XX.LE.X_THR) GOTO 1100
	ENDDO	
1100	ICUT=I

     	DEALLOCATE(Q2)
      	END

CC==============================================================================
     	SUBROUTINE XFITLINE2(K,N2,PLOT,IFIT1,IFIT2,ICUT)

CCC==Q1, Q2=KLM2D*N2D
CC==PLOT=K*4
      	REAL, DIMENSION(:,:), ALLOCATABLE :: Q2
	REAL, DIMENSION(:), ALLOCATABLE :: PLOT1
CC==INCREASE ARRAY Q4 FOR DIFFERENT RANK FITTING TO ABV OR UDR 
      	REAL PLOT(K,N2)	
 
CC==IN THIS CASE, K=NMB
	X_THR=0.000001
	N=2
      	L=0
      	M=K
      	N1=N+1
CC==DEFINE SIZE OF WORKING ARRAYS!
      	KLMD=K+L+M
      	KLM2D=K+L+M+2
      	NKLMD=K+L+M+N
      	N2D=N+2
      	KP=K
CC==FOR N.GT.2 CACULATION, ARRAY SIZE NEED ENLARGED!
      	N_LARG=KLMD*2
      	KLM2D=KLM2D+N_LARG
      	KLMD=KLMD+N_LARG
      	N2D=N2D+N_LARG
      	NKLMD=NKLMD+N_LARG
CC==
	ALLOCATE(PLOT1(K), Q2(KLM2D,N2D),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
            CALL ERRT(46,'TFED, Q2..',KLM2D*N2D)
            RETURN
        ENDIF

CC==
	Q2(1:K,1)=PLOT(1:K,1)
	Q2(1:K,2)=1.0
	Q2(1:K,3)=PLOT(1:K,3)
CC==
	CALL PARTI9(KLMD,NKLMD,KLM2D,N2D,Q2,
     &               K,N2,N,PLOT,IFIT1,IFIT2,KP)

CC==SEARCHING THE CUTTING POINT IN THE LOW FREQUENCIES
	PLOT1(IFIT1:IFIT2)=PLOT(IFIT1:IFIT2,4)-PLOT(IFIT1:IFIT2,3)

	DO II=IFIT1,IFIT2
	    IF(PLOT(II,3).NE.0.0) THEN
		PLOT1(II)=PLOT1(II)/PLOT(II,4)
		XX=ABS(PLOT1(II))
	
		IF(XX.LE.X_THR) GOTO 1100
	    ENDIF
	ENDDO
1100	ICUT=II	
     	DEALLOCATE(Q2,PLOT1)
      	END

CC================================================================

	SUBROUTINE PARTI11 (KLMD,NKLMD,KLM2D,N2D,Q2,
     &  K,N2,PLOT1,N,ICUT1,ICUT2,ICNSTRNT,KP)

	REAL Q2(KLM2D,N2D),PLOT1(K,N2)
CC==TT1_Q2,Q,X,RES,CU,S,IU are automatic arrays
	REAL TT1_Q2(KLM2D,N2D)
	DOUBLE PRECISION Q(KLM2D,N2D),X(N2D),RES(KLMD),CU(2,NKLMD),
     &                   S(KLMD)
      	INTEGER IU(2,NKLMD)
      	INTEGER  TMPI,TMPJ

CC==LOW FREQUENCIES REGION RE-FITTING!!!
	ISTART=ICUT1
	ISTOP=ICUT2 
	N_3=N
	L=2
	KS=ISTOP-ISTART+1
CC==EVN with 2 EQ CONSTRAINTS
	ISWI=3
	TT1_Q2(1:KS,1:N+1)=Q2(ISTART:ISTOP,1:N+1)
CC== EQUALITY CONSTRAINT CONDITION IN TT1_Q2
	TT1_Q2(KS+1,1:N-1)=Q2(ISTART,1:N-1)
	TT1_Q2(KS+2,1:N-1)=Q2(ICNSTRNT,1:N-1)
	TT1_Q2(KS+2,N)=1.0
	TT1_Q2(KS+1,N)=1.0
	TT1_Q2(KS+1,N+1)=PLOT1(ISTART,3) 
	TT1_Q2(KS+2,N+1)=PLOT1(ICNSTRNT,3)
   
	CALL LSFIT(KS,L,N2,PLOT1(ISTART,2+(ISWI-3)*2),
     &         KLM2D,N2D,TT1_Q2,N_3,ISWI,
     &         Q,X,RES,CU,S,IU,KLMD,NKLMD,KP)

      	END

CC=======================================================================

	SUBROUTINE PARTI10 (KLMD,NKLMD,KLM2D,N2D,Q2,
     &  K,N2,PLOT1,N,ICUT1,ICUT2,KP)

	REAL Q2(KLM2D,N2D),PLOT1(K,N2)
CC==TT1_Q2,Q,X,RES,CU,S,IU are automatic arrays
	REAL TT1_Q2(KLM2D,N2D)
	DOUBLE PRECISION Q(KLM2D,N2D),X(N2D),RES(KLMD),CU(2,NKLMD),
     &                   S(KLMD)
      	INTEGER IU(2,NKLMD)
      	INTEGER  TMPI,TMPJ

CC==LOW FREQUENCIES REGION RE-FITTING!!!
	ISTART=ICUT1
	ISTOP=ICUT2 
	N_3=N
	L=1
	KS=ISTOP-ISTART+1
CC==ENV WITH TWO CONSTRAINTS
	ISWI=6
	TT1_Q2(1:KS,1:N+1)=Q2(ISTART:ISTOP,1:N+1)
CC== EQUALITY CONSTRAINT CONDITION IN TT1_Q2
	TT1_Q2(KS+1,1:N-1)=Q2(ISTART,1:N-1)
	TT1_Q2(KS+1,N)=1.0
	TT1_Q2(KS+1,N+1)=PLOT1(ISTART,3)
   
	CALL LSFIT(KS,L,N2,PLOT1(ISTART,2+(ISWI-6)*2),
     &         KLM2D,N2D,TT1_Q2,N_3,ISWI,
     &         Q,X,RES,CU,S,IU,KLMD,NKLMD,KP)

        END

CC======================================================================

     	SUBROUTINE XFIT_BKGND1(K,N2,N,PLOT,ICUT1,ICUT2,
     &                   ICNSTRNT,ICN_SND,
     & 			PS,CS,LAMBDA,CONTRAST,DEFOCUS,IILOOP,NZERO)

CCC==INEQUALITY CONSTRAINED LINEAR SQUARE MINIMIZATION
CCC==Q1, Q2=KLM2D*N2D
CC==PLOT=K*4
      	REAL, DIMENSION(:,:), ALLOCATABLE :: Q2
CC==INCREASE ARRAY Q4 FOR DIFFERENT RANK FITTING TO ABV OR UDR 
      	REAL PLOT(K,N2)
	REAL LAMBDA    	

      	L=1
      	M=K
      	N1=N+1
CC==DEFINE SIZE OF WORKING ARRAYS!
      	KLMD=K+L+M
      	KLM2D=K+L+M+2
      	NKLMD=K+L+M+N
      	N2D=N+2
      	KP=K
CC==FOR N.GT.2 CACULATION, ARRAY SIZE NEED ENLARGED!
      	N_LARG=KLMD*2
      	KLM2D=KLM2D+N_LARG
      	KLMD=KLMD+N_LARG
      	N2D=N2D+N_LARG
      	NKLMD=NKLMD+N_LARG
CC==
      	ALLOCATE(Q2(KLM2D,N2D),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
            CALL ERRT(46,'TFED',NE)
         RETURN
         ENDIF
CC==
	DO I=1,N-1
		Q2(ICUT1:ICUT2,I)=PLOT(ICUT1:ICUT2,1)**I
      	ENDDO
	Q2(ICUT1:ICUT2,N)=1.0
	Q2(ICUT1:ICUT2,N+1)=PLOT(ICUT1:ICUT2,3)

	CALL PARTI15(KLMD,NKLMD,KLM2D,N2D,Q2,
     &  K,N2,PLOT,N,ICUT1,ICUT2,ICNSTRNT,KP)

        PLOT(ICUT1:ICUT2,3)=PLOT(ICUT1:ICUT2,3)-PLOT(ICUT1:ICUT2,2)
        PLOT(ICUT1:ICUT2,4)=PLOT(ICUT1:ICUT2,4)-PLOT(ICUT1:ICUT2,2)

	ISWI=1
      	DZMAX=GETDEFOCUS(PLOT(1,3),PLOT(1,1),K,PS,CS,LAMBDA,
     &		CONTRAST,XSCORE,PLOT(1,4),ICUT1,ICUT2,ISWI)

       	DEFOCUS=DZMAX

	CALL GET_CTF_ZERO(K,PS, CS, 
     & 	LAMBDA, DEFOCUS, CONTRAST,ICUT1,ICUT2,NZERO,IFIRST,ISECND)

	CALL CTF_SIGNAL1(PLOT(1,2), PLOT(1,1),K, PS, CS, 
     &                LAMBDA, DEFOCUS, CONTRAST)

	PLOT(ICUT1:ICUT2,2)=PLOT(ICUT1:ICUT2,2)**2*PLOT(ICUT1:ICUT2,4)
	
     	DEALLOCATE(Q2)
      	END

CC======================================================================

	SUBROUTINE DEFOCUSGUESSING2(POW2,
     & 		NSAM1,NROW1,NMB,XSTART,XSTEP,PS,CS,LAMBDA,CONTRAST,
     &		DEFOCUS,IILOOP,ICUT_LOW_FRQ,ICN_SND,NDGREE)

	DIMENSION POW2(NSAM1,NROW1)
	REAL, DIMENSION(:,:), ALLOCATABLE :: PLOT,TMP
	REAL LAMBDA

CC==ASTIGMATISM ESTIMATION!!!
	ALLOCATE(TMP(NMB,2),STAT=IRTFLG)
  	IF (IRTFLG .NE. 0) THEN
            CALL ERRT(46,'TFED',NE)
            RETURN
         ENDIF
	CALL ZH_CRCSE2(POW2,TMP(1,2),NSAM1,NROW1,NMB,XSTART,XSTEP)
	IPW_ZERO=0

	DO I=1,NMB
 	    TMP(I,1)=I		
 	ENDDO
CC==
      	IF(NMB.LT.5) THEN 
            CALL ERRT(36,'TFED',NE)
            RETURN
      	ENDIF

	DO I=1,NMB
	    IF(TMP(I,2).EQ.0.0) THEN 
	    IPW_ZERO=I
	    ENDIF
	ENDDO

CC==WE FIT A STRAIGHT LINE BELOW PW TO LOCATE POINT CUT OFF LOW FREQUENCY REGION  
	N2=4
	NUMBER=NMB-IPW_ZERO
	
	ALLOCATE(PLOT(NUMBER,N2),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
            CALL ERRT(46,'TFED',NE)
            RETURN
         ENDIF
CC==USING GIVEN POLYNOMIAL TO FIT BACKGROUND AND OVERALL ENVELOPE! 
1100	III=NDGREE
	PLOT(:,1)=TMP(IPW_ZERO+1:NMB,1)-1.0
	PLOT(:,3)=ALOG(TMP(IPW_ZERO+1:NMB,2))

CCC==LOCATE THE FIRST ZERO OF CTF AS CUT-OFF POINT: ICUTB
	IFIT11=ICUT_LOW_FRQ-IPW_ZERO
	IF(IFIT11.LE.0) IFIT11=1
		
	DO II=1,999
	    IFIT11=IFIT11+II-1
	    IFIT2=NUMBER
	    CALL XFITLINE1(NUMBER,N2,PLOT,IFIT11,IFIT2,ICUTB_1)

	    IF(ICUTB_1.GT.IFIT11) GOTO 1200

	ENDDO

1200	IFIT1=IFIT11		
	IFIT2=NUMBER

CC==LOCATE THE HIGHEST PEAK OF CTF AS FIRST CONTROL POINT(EQUALITY CONSTRAINT POINT)

	CALL XFITLINE2(NUMBER,N2,PLOT,IFIT1,IFIT2,ICUTA)
CC=LOCATE THE SECOND CTF ZERO	
	IFIT1=ICUTA
	IFIT2=NUMBER
        CALL XFITLINE1(NUMBER,N2,PLOT,IFIT1,IFIT2,ICUTC)

	IFIT1=ICUTC
	IFIT2=NUMBER
	CALL XFITLINE2(NUMBER,N2,PLOT,IFIT1,IFIT2,ICUTD)

	IFIT1=ICUTD
	IFIT2=NUMBER
	CALL XFITLINE1(NUMBER,N2,PLOT,IFIT1,IFIT2,ICUTE)

	N=III
	ICUT1=ICUTA
	ICUT2=NUMBER
	CALL XFIT_ZH_AST(NUMBER,N2,PLOT,ICUT1,ICUT2)
	
	ICUT1=IFIT11
	N=III
	ICNSTRNT=ICUTC
	IBACK=1
CC==FIT OVERALL EVELOPE FROM ICUTA TO ICUT2
	CALL XFIT_LOW4(NUMBER,N2,PLOT,IFIT11,ICUTA)

	CALL XFIT_LOW5(NUMBER,N2,N,PLOT,ICUTA,ICUT2)

CC==CC==FIT BACKGROUND FROM ICUTB TO ICUT2
	CALL XFIT_LOW2(NUMBER,N2,PLOT,IFIT11,ICUT2,N)

CC==CC==FIT BACKGROUND FROM IBACK TO ICUTB USING SPECIFIC POLYNOMIAL DEGREE 4
	CALL XFIT_LOW10(NUMBER,N2,PLOT,IBACK,IFIT11)

	ICUT1=IFIT11
	CALL XFIT_BKGND1(NUMBER,N2,N,PLOT,ICUT1,ICUT2,ICNSTRNT,ICN_SND,
     & 			PS,CS,LAMBDA,CONTRAST,DEFOCUS,IILOOP,NZERO)
	DEALLOCATE(PLOT,TMP)
	END 
CC==================================================================================

    	SUBROUTINE XFIT_BKGND2(K,N2,N,PLOT,ICUT1,ICUT2,
     & 		PS,CS,LAMBDA,CONTRAST,DEFOCUS,IILOOP)

CCC==INEQUALITY CONSTRAINED LINEAR SQUARE MINIMIZATION
CCC==Q1, Q2=KLM2D*N2D
CC==PLOT=K*4
      	REAL, DIMENSION(:,:), ALLOCATABLE :: Q2
CC==INCREASE ARRAY Q4 FOR DIFFERENT RANK FITTING TO ABV OR UDR 
      	REAL PLOT(K,N2)
	REAL LAMBDA

      	L=0
      	M=K
      	N1=N+1
CC==DEFINE SIZE OF WORKING ARRAYS!
      	KLMD=K+L+M
      	KLM2D=K+L+M+2
      	NKLMD=K+L+M+N
      	N2D=N+2
      	KP=K
CC==FOR N.GT.2 CACULATION, ARRAY SIZE NEED ENLARGED!
      	N_LARG=KLMD*2
      	KLM2D=KLM2D+N_LARG
      	KLMD=KLMD+N_LARG
      	N2D=N2D+N_LARG
      	NKLMD=NKLMD+N_LARG
CC==
      	ALLOCATE(Q2(KLM2D,N2D),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
            CALL ERRT(46,'TFED',NE)
         RETURN
         ENDIF
	
CC==
	DO I=1,N-1
	    Q2(ICUT1:ICUT2,I)=PLOT(ICUT1:ICUT2,1)**I
      	ENDDO

	Q2(ICUT1:ICUT2,N)=1.0
	Q2(ICUT1:ICUT2,N+1)=PLOT(ICUT1:ICUT2,3)

	CALL PARTI10(KLMD,NKLMD,KLM2D,N2D,Q2,
     &  K,N2,PLOT,N,ICUT1,ICUT2,KP)

CC==OUTPUT
	PLOT(ICUT1:ICUT2,2:4)=EXP(PLOT(ICUT1:ICUT2,2:4))
        PLOT(ICUT1:ICUT2,3)=PLOT(ICUT1:ICUT2,3)-PLOT(ICUT1:ICUT2,2)
        PLOT(ICUT1:ICUT2,4)=PLOT(ICUT1:ICUT2,4)-PLOT(ICUT1:ICUT2,2)

	ISWI=1

      	DZMAX=GETDEFOCUS(PLOT(1,3),PLOT(1,1),K,PS,CS,LAMBDA,
     &		CONTRAST,XSCORE,PLOT(1,4),ICUT1,ICUT2,ISWI)

       	DEFOCUS=DZMAX

	CALL CTF_SIGNAL1(PLOT(1,2), PLOT(1,1),K, PS, CS, 
     F  	LAMBDA, DEFOCUS, CONTRAST)

	PLOT(1:K,2)=PLOT(1:K,2)**2*PLOT(1:K,4)
     	DEALLOCATE(Q2)
      	END

CC=============================================================

     	SUBROUTINE XFIT_LOW1(K,N2,PLOT,ICUT1,ICUT2,ICUTD,N)

CCC==Q1, Q2=KLM2D*N2D
CC==PLOT=K*4
      	REAL, DIMENSION(:,:), ALLOCATABLE :: Q2
CC==INCREASE ARRAY Q4 FOR DIFFERENT RANK FITTING TO ABV OR UDR 
      	REAL PLOT(K,N2)
	REAL LAMBDA
CC==BEGIN: FIRST ALLOCATE ARRAYS FOR CALCULATION
      	L=3
      	M=K
      	N1=N+1
CC==DEFINE SIZE OF WORKING ARRAYS!
      	KLMD=K+L+M
      	KLM2D=K+L+M+2
      	NKLMD=K+L+M+N
      	N2D=N+2
      	KP=K
CC==FOR N.GT.2 CACULATION, ARRAY SIZE NEED ENLARGED!
      	N_LARG=KLMD*2
      	KLM2D=KLM2D+N_LARG
      	KLMD=KLMD+N_LARG
      	N2D=N2D+N_LARG
      	NKLMD=NKLMD+N_LARG
CC==
      	ALLOCATE(Q2(KLM2D,N2D),STAT=IRTFLG)
        
	IF (IRTFLG .NE. 0) THEN
            CALL ERRT(46,'TFED',NE)
         RETURN
         ENDIF

CC==
	DO I=1,N-1
	    Q2(1:K,I)=PLOT(1:K,1)**I
      	ENDDO

	Q2(1:K,N)=1.0
	Q2(1:K,N+1)=PLOT(1:K,3)
CC==
        Q2(K+1:2*K,1:N+1)=Q2(1:K,1:N+1)

      !write(6,*) 'in xfit_low1, calling parti13, icutd:',icutd
	CALL PARTI13 (KLMD,NKLMD,KLM2D,N2D,Q2,
     &  K,N2,PLOT,N,ICUT1,ICUT2,ICUTD,KP)
      !write(6,*) 'in xfit_low1, after parti13, icutd:',icutd

     	DEALLOCATE(Q2)
      	END

CC===========================================================
C       alters plot1

	SUBROUTINE PARTI13 (KLMD,NKLMD,KLM2D,N2D,Q2,
     &  K,N2,PLOT1,N,ICUT1,ICUT2,ICUTD,KP)

	REAL Q2(KLM2D,N2D),PLOT1(K,N2)
CC==TT1_Q2,Q,X,RES,CU,S,IU are automatic arrays
	REAL TT1_Q2(KLM2D,N2D)
	DOUBLE PRECISION Q(KLM2D,N2D),X(N2D),RES(KLMD),CU(2,NKLMD),
     &                   S(KLMD)
      	INTEGER IU(2,NKLMD)
      	INTEGER  TMPI,TMPJ

CC==LOW FREQUENCIES REGION RE-FITTING!!!
CC==INTERMDEDIATE REGION FITTING
	ISTART=ICUT1
	ISTOP=ICUT2 
CC====ZHONG HUANG, APR,16,03
	N_3=N
	KS=ISTOP-ISTART+1
	L=3
	ISWI=7
CC=BACKGROUND FITTING WITH THREE EQ CONSTRAINTS
	TT1_Q2(1:KS,1:N+1)=Q2(ISTART:ISTOP,1:N+1)
CC== EQUALITY CONSTRAINT CONDITION IN TT1_Q2

	TT1_Q2(KS+1,1:N-1)=Q2(ISTART,1:N-1)
	TT1_Q2(KS+2,1:N-1)=Q2(ISTOP,1:N-1)
	TT1_Q2(KS+3,1:N-1)=Q2(ICUTD,1:N-1)
	TT1_Q2(KS+1,N)=1.0
	TT1_Q2(KS+2,N)=1.0
	TT1_Q2(KS+3,N)=1.0
	TT1_Q2(KS+1,N+1)=PLOT1(ISTART,3)
	TT1_Q2(KS+2,N+1)=PLOT1(ISTOP,3)
  	TT1_Q2(KS+3,N+1)=PLOT1(ICUTD,3)

	CALL LSFIT(KS,L,N2,PLOT1(ISTART,2+(ISWI-6)*2),
     &         KLM2D,N2D,TT1_Q2,N_3,ISWI,
     &         Q,X,RES,CU,S,IU,KLMD,NKLMD,KP)
		
      	END

CC===============================================================

     	SUBROUTINE XFIT_LOW2(K,N2,PLOT,ICUT1,ICUT2,N)

CCC==Q1, Q2=KLM2D*N2D
CC==PLOT=K*4
      	REAL, DIMENSION(:,:), ALLOCATABLE :: Q2
CC==INCREASE ARRAY Q4 FOR DIFFERENT RANK FITTING TO ABV OR UDR 
      	REAL PLOT(K,N2)
	REAL LAMBDA
	 
CC==BEGIN: FIRST ALLOCATE ARRAYS FOR CALCULATION
      	L=2
      	M=K
      	N1=N+1
CC==DEFINE SIZE OF WORKING ARRAYS!
      	KLMD=K+L+M
      	KLM2D=K+L+M+2
      	NKLMD=K+L+M+N
      	N2D=N+2
      	KP=K
CC==FOR N.GT.2 CACULATION, ARRAY SIZE NEED ENLARGED!
      	N_LARG=KLMD*2
      	KLM2D=KLM2D+N_LARG
      	KLMD=KLMD+N_LARG
      	N2D=N2D+N_LARG
      	NKLMD=NKLMD+N_LARG
CC==
      	ALLOCATE(Q2(KLM2D,N2D),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
            CALL ERRT(46,'TFED',NE)
         RETURN
         ENDIF
	
CC==
	DO I=1,N-1
	    Q2(1:K,I)=PLOT(1:K,1)**I
      	ENDDO

	Q2(1:K,N)=1.0
	Q2(1:K,N+1)=PLOT(1:K,3)

	CALL PARTI12 (KLMD,NKLMD,KLM2D,N2D,Q2,
     &                K,N2,PLOT,N,ICUT1,ICUT2,KP)
     	DEALLOCATE(Q2)
      	END

CC===========================================================

	SUBROUTINE PARTI12 (KLMD,NKLMD,KLM2D,N2D,Q2,
     &  K,N2,PLOT1,N,ICUT1,ICUT2,KP)

	REAL Q2(KLM2D,N2D),PLOT1(K,N2)
CC==TT1_Q2,Q,X,RES,CU,S,IU are automatic arrays
	REAL TT1_Q2(KLM2D,N2D)
	DOUBLE PRECISION Q(KLM2D,N2D),X(N2D),RES(KLMD),CU(2,NKLMD),
     &                   S(KLMD)
      	INTEGER IU(2,NKLMD)
      	INTEGER  TMPI,TMPJ

CC==LOW FREQUENCIES REGION RE-FITTING!!!
CC==INTERMDEDIATE REGION FITTING
	ISTART=ICUT1
	ISTOP=ICUT2 
CC==
	N_3=N
	KS=ISTOP-ISTART+1
	L=1
	ISWI=6
	TT1_Q2(1:KS,1:N+1)=Q2(ISTART:ISTOP,1:N+1)
CC== EQUALITY CONSTRAINT CONDITION IN TT1_Q2
	TT1_Q2(KS+1,1:N-1)=Q2(ISTART,1:N-1)
	TT1_Q2(KS+1,N)=1.0
	TT1_Q2(KS+1,N+1)=PLOT1(ISTART,3)
 
	CALL LSFIT(KS,L,N2,PLOT1(ISTART,2+(ISWI-6)*2),
     &         KLM2D,N2D,TT1_Q2,N_3,ISWI,
     &         Q,X,RES,CU,S,IU,KLMD,NKLMD,KP)		
      	END

CC=================================================================

    	SUBROUTINE XFIT_LOW3(K,N2,PLOT,ICUT1,ICUT2)

CCC==Q1, Q2=KLM2D*N2D
CC==PLOT=K*4
      	REAL, DIMENSION(:,:), ALLOCATABLE :: Q2
CC==INCREASE ARRAY Q4 FOR DIFFERENT RANK FITTING TO ABV OR UDR 
      	REAL PLOT(K,N2)
	REAL LAMBDA

CC==BEGIN: FIRST ALLOCATE ARRAYS FOR CALCULATION
	N=6
      	L=2
      	M=K
      	N1=N+1
CC==DEFINE SIZE OF WORKING ARRAYS!
      	KLMD=K+L+M
      	KLM2D=K+L+M+2
      	NKLMD=K+L+M+N
      	N2D=N+2
      	KP=K
CC==FOR N.GT.2 CACULATION, ARRAY SIZE NEED ENLARGED!
      	N_LARG=KLMD*2
      	KLM2D=KLM2D+N_LARG
      	KLMD=KLMD+N_LARG
      	N2D=N2D+N_LARG
      	NKLMD=NKLMD+N_LARG
CC==
      	ALLOCATE(Q2(KLM2D,N2D),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
            CALL ERRT(46,'TFED',NE)
        RETURN
        ENDIF
CC==
	DO I=1,N-1
	    Q2(1:K,I)=PLOT(1:K,1)**I
      	ENDDO

	Q2(1:K,N)=1.0
	Q2(1:K,N+1)=PLOT(1:K,3)
CC==
	CALL PARTI14 (KLMD,NKLMD,KLM2D,N2D,Q2,
     &  K,N2,PLOT,ICUT1,ICUT2,KP)
     	DEALLOCATE(Q2)
      	END

CC===========================================================

	SUBROUTINE PARTI14 (KLMD,NKLMD,KLM2D,N2D,Q2,
     &  K,N2,PLOT1,ICUT1,ICUT2,KP)

	REAL Q2(KLM2D,N2D),PLOT1(K,N2)
CC==TT1_Q2,Q,X,RES,CU,S,IU are automatic arrays
	REAL TT1_Q2(KLM2D,N2D)
	DOUBLE PRECISION Q(KLM2D,N2D),X(N2D),RES(KLMD),CU(2,NKLMD),
     &                   S(KLMD)
      	INTEGER IU(2,NKLMD)
      	INTEGER  TMPI,TMPJ

CC==LOW FREQUENCIES REGION RE-FITTING!!!
CC==INTERMDEDIATE REGION FITTING
	N=4
	ISTART=ICUT1
	ISTOP=ICUT2 
CC==
	N_3=N
	KS=ISTOP-ISTART+1
	L=1
	ISWI=6
	TT1_Q2(1:KS,1:N+1)=Q2(ISTART:ISTOP,1:N+1)
CC== ONE EQUALITY CONSTRAINT CONDITION IN TT1_Q2
	TT1_Q2(KS+1,1:N-1)=Q2(ISTART,1:N-1)
	TT1_Q2(KS+1,N)=1.0
	TT1_Q2(KS+1,N+1)=PLOT1(ISTART,3) 

	CALL LSFIT(KS,L,N2,PLOT1(ISTART,2+(ISWI-6)*2),
     &         KLM2D,N2D,TT1_Q2,N_3,ISWI,
     &         Q,X,RES,CU,S,IU,KLMD,NKLMD,KP)		
 	END

CC===============================================================================

	SUBROUTINE DEFOCUSGUESSING1(POW2,
     & 		NSAM1,NROW1,NMB,XSTART,XSTEP,PS,CS,
     &		LAMBDA,CONTRAST,AV_DEFO,ICUT_LOW_FRQ,
     &		ICN_SND,NDGREE,TMP_OUT,NT,XX_CC,NUMBER)

        INCLUDE 'CMBLOCK.INC'

	PARAMETER (NMRANK=6)
	DIMENSION POW2(NSAM1,NROW1)
	DIMENSION TMP_OUT(NMB,NT)
	DIMENSION X_DEFO(NMRANK),N_SELECT(NMRANK)

	dimension prev_x_defo(nmrank),prev_n_select(nmrank) !feb 2013 al

	INTEGER   TMP_FIRST(NMRANK),TMP_SECND(NMRANK)                                            
	REAL, DIMENSION(:,:), ALLOCATABLE :: PLOT,TMP
	REAL                              :: LAMBDA,QUADPI

      	PARAMETER (QUADPI = 3.1415926535897932384626)

        integer, save :: idone = 0
	
        NUMBER = 0  ! INITIALIZE FOR DEFAULT RETURN AL

	ALLOCATE(TMP(NMB,2),STAT=IRTFLG)     
	IF (IRTFLG .NE. 0) THEN
            CALL ERRT(46,'TFED, TMP',NMB*2)
            RETURN
         ENDIF
	 
CC==    ICUT_LOW_FRQ
CC==    N_ZERO IS MAXIMUM NZEROS OF CTF CONTROL POINTS FOR ASTIGMATISM ESTIMATION

C       rotational averging, returns tmp(1,2)  1...nmb
	CALL ZH_CRCSE2(POW2,TMP(1,2),NSAM1,NROW1,NMB,XSTART,XSTEP)

        !call chkreal('tmp(1,2)', tmp(1,2),nmb, nmb,1, 1)
        !call chkmaxloc('rotp', tmp(1,2),nmb)

	IPW_ZERO = 0
	DO I=1,NMB
 	   TMP(I,1) = I		
 	ENDDO
CC==
      	IF (NMB .LT. 5) THEN 
            CALL ERRT(101,'TFED, NMB MUST BE > 4',NE)
            RETURN
      	ENDIF

	DO I=1,NMB
	    IF (TMP(I,2) .EQ. 0.0) IPW_ZERO = I ! Finds last zero		
	ENDDO

        !call chkreal('tmp', tmp(1,2),nmb, nmb,1, 1)
        !call chkminloc('tmp', tmp(1,2),nmb)
        !call chkmaxloc('tmp', tmp(1,2),nmb)

CC==    ESTIMATE MINIMUM DEFOCUS BASED ON GIVEN VOLTAGE, CS, AND PIXEL SIZE
	N2        = 4
	TMP1_DEFO = (2.*PS)**2/LAMBDA
	TMP2_DEFO = CONTRAST/(1.0-CONTRAST)
	TMP2_DEFO = ATAN(TMP2_DEFO)*TMP1_DEFO/QUADPI
	TMP3_DEFO = .5*CS*LAMBDA**2/(2.*PS)**2
	DEFO_MIN  = TMP2_DEFO+TMP3_DEFO

	TMP1_DEFO = .5*REAL(NMB-1)/PS/REAL(NMB)
	TMP1_DEFO = TMP1_DEFO*TMP1_DEFO
	TMP2_DEFO = .5/PS
	TMP2_DEFO = TMP2_DEFO*TMP2_DEFO
	DEFO_MAX  = 1.0/(TMP2_DEFO-TMP1_DEFO)/LAMBDA
	DEFO_MAX  = DEFO_MAX+.5*CS*LAMBDA**2*(TMP2_DEFO+TMP1_DEFO)

        !write(6,*) ' guessing1; def range:',DEFO_MIN,defo_max
      
	NUMBER    = NMB - IPW_ZERO
        IF (NUMBER .LE. 0) THEN
           CALL ERRT(101,
     &       'ABNORMAL POWER SPECTRUM, UNABLE TO DETERMINE DEFOCUS',NE)
           RETURN
        ENDIF

	TMP_XX    = NUMBER/3.
	IPT_LOW   = INT(TMP_XX)
	TMP_XX    = NUMBER*2./3.
	IPT_HIGH  = INT(TMP_XX)
	TMP_XX    = NUMBER/2.
	IPT_HALF  = INT(TMP_XX)

	NDGREE    = 0

	ALLOCATE(PLOT(NUMBER,N2),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
           CALL ERRT(46,'TFED, PLOT',NUMBER*N2)
           NUMBER = 0  ! INITIALZE FOR ERROR RETURN al
           RETURN
        ENDIF

	DO III=2,5		
	    PLOT(:,1) = TMP(IPW_ZERO+1:NMB,1)-1.0
	    PLOT(:,3) = ALOG(TMP(IPW_ZERO+1:NMB,2))
	    IFIT1     = 1
	    IFIT2     = NUMBER

C==         LOCATE THE HIGHEST PEAK IN THE POWER SPECTRUM
	    CALL XFITLINE2(NUMBER,N2,PLOT,IFIT1,IFIT2,ICUTL)

	    IFIT11 = ICUTL
	    IFIT2  = NUMBER

CC==        LOCATE THE FIRST ZERO OF CTF AS CUT-OFF POINT: ICUTB
	    CALL XFITLINE1(NUMBER,N2,PLOT,IFIT11,IFIT2,ICUTB)

           ! write(6,'(a,i3,2i6,f10.1)')'gu1; cutlb:',iii,icutl,icutb
           !write(6,*)'GUESSING1 high peak:',iii,icutl,IFIT11,IFIT2,ICUTB

CC==        TO POWER SPECTRUM HAVING WEAK CTF EFFECT IN MEDIUM AND HIGH FREQUENCY
CC==        IPT_HALF IS TO AVOID INCLUDING TOO MUCH USELESS INFORMATION WHEN PIXEL SIZE IS SAMLL OR
CC==        THE MICRPGRAPHS HAVE TOO POOR RESOLUTION

	    IF (ICUTB .GT. IPT_HIGH) THEN
               IFIT2 = IPT_HIGH			
               CALL XFITLINE1(NUMBER,N2,PLOT,IFIT11,IFIT2,ICUTB)
	    ENDIF

	    IF (ICUTB.GT.IPT_LOW.AND.ICUTB.LT.IPT_HIGH) THEN		
               IFIT2 = IPT_HALF
               CALL XFITLINE1(NUMBER,N2,PLOT,IFIT11,IFIT2,ICUTB)
	    ENDIF

CC==        LOCATE HIGHEST PEAK OF CTF AS 1'ST CONTROL POINT(EQUALITY CONSTRAINT POINT)
	    IFIT1 = ICUTB
	    IFIT2 = NUMBER
	    CALL XFITLINE2(NUMBER,N2,PLOT,IFIT1,IFIT2,ICUTA)

CC=         LOCATE THE SECOND CTF ZERO.		
	    IFIT1 = ICUTA
	    IFIT2 = NUMBER
	    CALL XFITLINE1(NUMBER,N2,PLOT,IFIT1,IFIT2,ICUTC)

	    IFIT1 = ICUTC
	    IFIT2 = NUMBER
	    CALL XFITLINE2(NUMBER,N2,PLOT,IFIT1,IFIT2,ICUTD)

	    IFIT1 = ICUTD
	    IFIT2 = NUMBER
	    CALL XFITLINE1(NUMBER,N2,PLOT,IFIT1,IFIT2,ICUTE)

	    ICUT1 = ICUTA
	    ICUT2 = NUMBER
	    N     = III	
	    CALL XFIT_ZH(NUMBER,N2,N,PLOT,ICUT1,ICUT2)

            !write(6,*) 'in GUESSING1 2nd peak:',iii,ICUTa,icutc,icutd,icute

CC==        FIT BACKGROUND FROM ICUTB TO ICUT2	
	    ICUT1    = ICUTB
	    ICNSTRNT = ICUTB
	    IBACK    = 1
	    CALL XFIT_LOW2(NUMBER,N2,PLOT,ICUTB,ICUT2,N)

CC==CC==    FIT BACKGROUND FROM IBACK TO ICUTB USING SPECIFIC POLYNOMIAL DEGREE 4
	    IPT_START = 1
	    IPT_CUT   = ICUTB
	    CALL XFIT_LOW10(NUMBER,N2,PLOT,IPT_START,IPT_CUT)

	    CALL XFIT_BKGND3(NUMBER,N2,N,PLOT,ICUT1,ICUT2,ICNSTRNT)

	    CALL DEFOCUS_EST(NUMBER,N2,N,PLOT,ICUT1,ICUT2,
     & 		PS,CS,LAMBDA,CONTRAST,DEFOX,NZERO,
     &		IFIRST,ISECND)

           !write(6,'(a,i3,2i6,f10.1)')'gu1; cuts:',iii,icut1,icut2,defox

	    N_SELECT (III-1) = NZERO
	    TMP_FIRST(III-1) = IFIRST
	    TMP_SECND(III-1) = ISECND
	    X_DEFO   (III-1) = DEFOX	
	ENDDO

       !write(6,*) 'in GUESSING1 X_DEFO:',X_DEFO
       !write(6,*) 'in GUESSING1 DEFO_MIN,DEFO_MAX:',DEFO_MIN,DEFO_MAX

CC=====GUESSING DEFOCUS FROM THE FOUR TIMES CALCULATION!
C       if (x_defo(ii) .gt. defo_max  processing may
c       result in random segmentation
c       faults later in the run.  I have altered
c       it by guessing at what the author may have meant
c       It no longer crashes but am uncertain it is 
c       correct.  Feb 2013 al

        prev_x_defo   = x_defo  ! added feb 2013 al
        prev_n_select = x_defo  ! added feb 2013 al

        !write(6,'(a,5f10.1)') 'x_defo: ', x_defo(1:4)

C       can not go below min
	DO II=1,4
           IF(X_DEFO  (II) .LT. DEFO_MIN) THEN
              X_DEFO  (II) = DEFO_MIN
              N_SELECT(II) = 1
           ENDIF

C         if (x_defo(ii) .gt. defo_max  processing often 
c         result in random segmentation faults later in the run.  
C         I have altered
c         it by guessing at what the author may have meant
c         It no longer crashes but am uncertain it is 
c         correct.  Feb 2013 al
c         IF (X_DEFO(II) .GT. DEFO_MAX) THEN
c            IF (II .EQ. 1) THEN
c               X_DEFO  (II) = DEFO_MIN 
c               N_SELECT(II) = 1
c            ELSE
c               X_DEFO  (II) = X_DEFO  (II-1)  ! removed feb 2013 al
c               N_SELECT(II) = N_SELECT(II-1)  ! removed feb 2013 al
c            ENDIF
c         ENDIF
 
          IF (X_DEFO(II) .GT. DEFO_MAX) THEN
             !IF (II .EQ. 1) THEN
                X_DEFO  (II) = DEFO_MIN 
                N_SELECT(II) = 1
             !ELSE
             !   X_DEFO  (II) = prev_X_DEFO  (II-1)  
             !   N_SELECT(II) = prev_N_SELECT(II-1)  
             !ENDIF
          ENDIF

           !write(6,*) 'in GUESSING1 X_DEFO(II):',ii,X_DEFO(II)
	ENDDO

        !write(6,'(a,4f10.1)') 'x_defo1:', x_defo(1:4)

CCC=    SELECT POLYNOMIAL DEGREE ACCORDING TO CTF NZEROS!
	IF (X_DEFO(1) .GT. X_DEFO(2)) THEN
	    TMP_FIRST(2) = TMP_FIRST(1)
	    TMP_SECND(2) = TMP_SECND(1)
	    N_SELECT(2)  = N_SELECT(1)	
	    X_DEFO(2)    = X_DEFO(1)
	ENDIF
		
	IF (X_DEFO(2) .GT. X_DEFO(3)) THEN
	    TMP_FIRST(3)= TMP_FIRST(2)
	    TMP_SECND(3)= TMP_SECND(2)
	    N_SELECT(3) = N_SELECT(2)	
	    X_DEFO(3)   = X_DEFO(2)
	ENDIF

	IF (X_DEFO(3) .GT. X_DEFO(4)) THEN
	    AV_DEFO      = X_DEFO(3)
	    ICUT_LOW_FRQ = TMP_FIRST(3)+IPW_ZERO
	    ICN_SND      = TMP_SECND(3)+IPW_ZERO
	    N_TMP        = N_SELECT(3)
	    NDGREE       = N_SELECT(3)-1
	ELSE
	    AV_DEFO      = X_DEFO(4)
	    ICUT_LOW_FRQ = TMP_FIRST(4)+IPW_ZERO
	    ICN_SND      = TMP_SECND(4)+IPW_ZERO
	    N_TMP        = N_SELECT(4)
	    NDGREE       = N_SELECT(4)-1
	ENDIF

CC==    JUDGING WHETHER IT IS TRUE NEAR DEFOCUS:
	X_FST_ITVL = REAL(ICUTA-ICUTB)/REAL(NUMBER)

	IF (N_TMP.LE.2 .AND. X_FST_ITVL.GT..2) THEN

            !write(6,*) 'in GUESSING1 calling ctf_2_zero,icutd:',icutd
            !write(6,*) CS,        LAMBDA, CONTRAST,  PS, NDGREE, AV_DEFO 
c                 2.26E+7   1.967E-2   0.1    1.584   0     454.1
 
	    CALL CTF_2_ZERO(TMP,NMB,NT,NUMBER,N2,TMP_OUT,IPW_ZERO,
     &			CS,LAMBDA,CONTRAST,PS,NDGREE,AV_DEFO
     & 			,ICUTA,ICUTB,ICUTD,DEFO_MIN,DEFO_MAX,XX_CC )
	    RETURN

	ELSEIF (N_TMP.LE.2 .AND. X_FST_ITVL.LT..2) THEN

            !write(6,*) 'in GUESSING1 calling ctf_CORRECT:',N_TMP,X_FST_ITVL
	    CALL CTF_CORRECT(TMP,NMB,NT,NUMBER,N2,TMP_OUT,IPW_ZERO,
     &			CS,LAMBDA,CONTRAST,PS,AV_DEFO
     & 			,ICUTA,ICUTB,ICUTD,DEFO_MIN,DEFO_MAX,XX_CC )

	    IF (AV_DEFO.LT.DEFO_MIN) THEN
               CALL DEFOCUS_GUESSING4(TMP,NMB,NT,NUMBER,N2,TMP_OUT,
     &				IPW_ZERO,CS,LAMBDA,CONTRAST,
     &                          PS,AV_DEFO,DEFO_MIN,DEFO_MAX,XX_CC)
	    ENDIF
	    RETURN
	ENDIF

CC==    WE DO NOT WISH TOO HIGH POLYNOMIAL DEGREE !
	IF (NDGREE .GE. 6) THEN
           NDGREE=6
	ENDIF

      tmp_av_defo = av_defo  ! al feb 2013


CC==    RESET PLOT AND DO DEFOCUS REFINEMENT
	PLOT(:,1) = TMP(IPW_ZERO+1:NMB,1)-1.0
	PLOT(:,3) = ALOG(TMP(IPW_ZERO+1:NMB,2))

CC==    DEFOCUS REFINEMENT
       !write(6,*) 'in guessing1 calling defo_refine:',av_defo

	CALL DEFO_REFINE(PLOT,TMP,TMP_OUT,NMB,
     &    NUMBER,N2,NT,NDGREE,ICUTA,ICUTB,PS,CS,LAMBDA,CONTRAST,
     &    IPW_ZERO,DEFO_MIN,DEFO_MAX,AV_DEFO,XX_CC)
	DEALLOCATE(PLOT,TMP)

        !write(6,'(a,f10.1," --",f10.1)') 'Defocus:',tmp_av_defo, av_defo

	END

CC=====================================================================

     	SUBROUTINE XFIT_BKGND3(K,N2,N,PLOT,ICUT1,ICUT2,ICNSTRNT)

CCC==INEQUALITY CONSTRAINED LINEAR SQUARE MINIMIZATION
CCC==Q1, Q2=KLM2D*N2D
CC==PLOT=K*4

      	REAL, DIMENSION(:,:), ALLOCATABLE :: Q2
CC==INCREASE ARRAY Q4 FOR DIFFERENT RANK FITTING TO ABV OR UDR 
      	REAL PLOT(K,N2)
	 
      	L=2
      	M=K
      	N1=N+1
CC==DEFINE SIZE OF WORKING ARRAYS!
      	KLMD=K+L+M
      	KLM2D=K+L+M+2
      	NKLMD=K+L+M+N
      	N2D=N+2
      	KP=K
CC==FOR N.GT.2 CACULATION, ARRAY SIZE NEED ENLARGED!
      	N_LARG=KLMD*2
      	KLM2D=KLM2D+N_LARG
      	KLMD=KLMD+N_LARG
      	N2D=N2D+N_LARG
      	NKLMD=NKLMD+N_LARG
CC==
      	ALLOCATE(Q2(KLM2D,N2D),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
            CALL ERRT(46,'TFED',NE)
         RETURN
         ENDIF
CC==
	DO I=1,N-1
	    Q2(1:K,I)=PLOT(1:K,1)**I
      	ENDDO
	Q2(1:K,N)=1.0
	Q2(1:K,N+1)=PLOT(1:K,3)
CC==GENERATE Q4 FOR UDR
	CALL PARTI11(KLMD,NKLMD,KLM2D,N2D,Q2,
     &  K,N2,PLOT,N,ICUT1,ICUT2,ICNSTRNT,KP)
	DEALLOCATE(Q2)
	END

CC=============

	SUBROUTINE DEFOCUS_EST(K,N2,N,PLOT,ICUT1,ICUT2,
     & 	    PS,CS,LAMBDA,CONTRAST,DEFOCUS,NZERO,
     &	    IFIRST,ISECND)

C       TMP2 is automatic array
	REAL TMP2(K)
	REAL PLOT(K,N2)
	REAL LAMBDA
	REAL, DIMENSION(:), ALLOCATABLE :: TMP1 

	ALLOCATE(TMP1(K),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
            CALL ERRT(46,'TFED',NE)
            RETURN
         ENDIF

	DO KKK=1,ICUT2
	    XXX   = PLOT(KKK,1)/2./PS/REAL(K)
	    XXXXX = EXP(PLOT(KKK,4))-EXP(PLOT(KKK,2))

	    IF (PLOT(KKK,2) .NE. 0.0) THEN
		PLOT(KKK,2) = EXP(PLOT(KKK,2))
		PLOT(KKK,3) = EXP(PLOT(KKK,3))
		PLOT(KKK,4) = EXP(PLOT(KKK,4))
	    ELSE
		PLOT(KKK,2) = 0.0
		PLOT(KKK,3) = 0.0
		PLOT(KKK,4) = 0.0
	    ENDIF
	ENDDO

        PLOT(1:ICUT2,3) = PLOT(1:ICUT2,3)-PLOT(1:ICUT2,2)
        PLOT(1:ICUT2,4) = PLOT(1:ICUT2,4)-PLOT(1:ICUT2,2)
	TMP2(1:ICUT2)   = PLOT(1:ICUT2,4)
	
	ISWI = 1
      	DZMAX = GETDEFOCUS(PLOT(1,3),PLOT(1,1),K,PS,CS,LAMBDA,
     &		   CONTRAST,XSCORE,PLOT(1,4),ICUT1,ICUT2,ISWI)

CCCC==  OUTPUT RESULT 
       	DEFOCUS = DZMAX

	CALL GET_CTF_ZERO(K,PS, CS, 
     & 	  LAMBDA, DEFOCUS, CONTRAST,ICUT1,ICUT2,NZERO,IFIRST,ISECND)

	CALL CTF_SIGNAL1(TMP1, PLOT(1,1),K, PS, CS, 
     &                  LAMBDA, DEFOCUS, CONTRAST)

     	DEALLOCATE(TMP1)
      	END

CCC=====================================================================

	SUBROUTINE PARTI15(KLMD,NKLMD,KLM2D,N2D,Q2,
     &  K,N2,PLOT1,N,ICUT1,ICUT2,ICNSTRNT,KP)

	REAL Q2(KLM2D,N2D),PLOT1(K,N2)
CC==TT1_Q2,Q,X,RES,CU,S,IU are automatic arrays
	REAL TT1_Q2(KLM2D,N2D)
	DOUBLE PRECISION Q(KLM2D,N2D),X(N2D),RES(KLMD),CU(2,NKLMD),
     &                   S(KLMD)
      	INTEGER IU(2,NKLMD)
      	INTEGER  TMPI,TMPJ

CC==LOW FREQUENCIES REGION RE-FITTING!!!
CC==INTERMDEDIATE REGION FITTING
CC====ZHONG HUANG, APR,16,03
	ISTART=ICUT1
	ISTOP=ICUT2 
	N_3=N
	L=1
	KS=ISTOP-ISTART+1
	ISWI=1
	TT1_Q2(1:KS,1:N+1)=Q2(ISTART:ISTOP,1:N+1)
CC== EQUALITY CONSTRAINT CONDITION IN TT1_Q2
	TT1_Q2(KS+1,1:N-1)=Q2(ICNSTRNT,1:N-1)
	TT1_Q2(KS+1,N)=1.0
	TT1_Q2(KS+1,N+1)=PLOT1(ICNSTRNT,3)
   
	CALL LSFIT(KS,L,N2,PLOT1(ISTART,2+(ISWI-1)*2),
     &         KLM2D,N2D,TT1_Q2,N_3,ISWI,
     & Q,X,RES,CU,S,IU,KLMD,NKLMD,KP)

      	END

CC=====================================================================

    	SUBROUTINE XFIT_LOW4(K,N2,PLOT,ICUT1,ICUT2)

CCC==INEQUALITY CONSTRAINED LINEAR SQUARE MINIMIZATION
CC==FOR LOW FREQUENCIES FITTING,IT GIVES HIGH ORDER FITTING FROM 1 TO ICUT1
CCC==Q1, Q2=KLM2D*N2D
CC==PLOT=K*4
      	REAL, DIMENSION(:,:), ALLOCATABLE :: Q2
CC==INCREASE ARRAY Q4 FOR DIFFERENT RANK FITTING TO ABV OR UDR 
      	REAL PLOT(K,N2)
	REAL LAMBDA
      	
CC==BEGIN: FIRST ALLOCATE ARRAYS FOR CALCULATION
	N=5
      	L=1
      	M=K
      	N1=N+1
CC==DEFINE SIZE OF WORKING ARRAYS!
      	KLMD=K+L+M
      	KLM2D=K+L+M+2
      	NKLMD=K+L+M+N
      	N2D=N+2
      	KP=K
CC==FOR N.GT.2 CACULATION, ARRAY SIZE NEED ENLARGED!
      	N_LARG=KLMD*2
      	KLM2D=KLM2D+N_LARG
      	KLMD=KLMD+N_LARG
      	N2D=N2D+N_LARG
      	NKLMD=NKLMD+N_LARG
CC==
      	ALLOCATE(Q2(KLM2D,N2D),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
            CALL ERRT(46,'TFED',NE)
         RETURN
         ENDIF


CC==
	DO I=1,N-1
		Q2(1:K,I)=PLOT(1:K,1)**I
      	ENDDO

	Q2(1:K,N)=1.0
	Q2(1:K,N+1)=PLOT(1:K,3)
CC==
        Q2(K+1:2*K,1:N+1)=Q2(1:K,1:N+1)
CC==
	CALL PARTI17 (KLMD,NKLMD,KLM2D,N2D,Q2,
     &  K,N2,PLOT,N,ICUT1,ICUT2,KP)
     	DEALLOCATE(Q2)
      	END

CCC=======================================================

     	SUBROUTINE XFIT_ZH_AST(K,N2,PLOT,ICUT1,ICUT2)

CCC==INEQUALITY CONSTRAINED LINEAR SQUARE MINIMIZATION
CCC==Q1, Q2=KLM2D*N2D
CC==PLOT=K*4
	
      	REAL, DIMENSION(:,:), ALLOCATABLE :: Q2
CC==INCREASE ARRAY Q4 FOR DIFFERENT RANK FITTING TO ABV OR UDR 
      	REAL PLOT(K,N2)
	REAL LAMBDA
	 
	N=7
      	L=2
      	M=K
      	N1=N+1
CC==DEFINE SIZE OF WORKING ARRAYS!
      	KLMD=K+L+M
      	KLM2D=K+L+M+2
      	NKLMD=K+L+M+N
      	N2D=N+2
      	KP=K
CC==FOR N.GT.2 CACULATION, ARRAY SIZE NEED ENLARGED!
      	N_LARG=KLMD*2
      	KLM2D=KLM2D+N_LARG
      	KLMD=KLMD+N_LARG
      	N2D=N2D+N_LARG
      	NKLMD=NKLMD+N_LARG
CC==
      	ALLOCATE(Q2(KLM2D,N2D),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
            CALL ERRT(46,'TFED',NE)
         RETURN
         ENDIF
CC==
	DO I=1,N-1
	    Q2(1:K,I)=PLOT(1:K,1)**I
      	ENDDO

	Q2(1:K,N)=1.0
	Q2(1:K,N+1)=PLOT(1:K,3)
CC==
        Q2(K+1:2*K,1:N+1)=Q2(1:K,1:N+1)
CC==GENERATE Q4 FOR UDR
	CALL PARTI8 (KLMD,NKLMD,KLM2D,N2D,Q2,
     &  K,N2,PLOT,N,ICUT1,ICUT2,KP)
     	DEALLOCATE(Q2)
	
      	END

CC===================================================================

	SUBROUTINE PARTI17 (KLMD,NKLMD,KLM2D,N2D,Q2,
     &  K,N2,PLOT1,N,ICUT1,ICUT2,KP)

	REAL Q2(KLM2D,N2D),PLOT1(K,N2)
CC==TT1_Q2,Q,X,RES,CU,S,IU are automatic arrays
	REAL TT1_Q2(KLM2D,N2D)
	DOUBLE PRECISION Q(KLM2D,N2D),X(N2D),RES(KLMD),CU(2,NKLMD),
     &                   S(KLMD)
      	INTEGER IU(2,NKLMD)
      	INTEGER  TMPI,TMPJ

CC==LOW FREQUENCIES REGION RE-FITTING!!!
CC==INTERMDEDIATE REGION FITTING
	ISTART=ICUT1
	ISTOP=ICUT2 
	N_3=N
	KS=ISTOP-ISTART+1
	L=2
	ISWI=4
	TT1_Q2(1:KS,1:N+1)=Q2(ISTART:ISTOP,1:N+1)
CC== EQUALITY CONSTRAINT CONDITION IN TT1_Q2
	TT1_Q2(KS+1,1:N-1)=Q2(ISTART,1:N-1)
	TT1_Q2(KS+2,1:N-1)=Q2(ISTOP,1:N-1)
	TT1_Q2(KS+1,N)=1.0
	TT1_Q2(KS+2,N)=1.0
	TT1_Q2(KS+1,N+1)=PLOT1(ISTART,3)
	TT1_Q2(KS+2,N+1)=PLOT1(ISTOP,4)

	CALL LSFIT(KS,L,N2,PLOT1(ISTART,2+(ISWI-3)*2),
     &         KLM2D,N2D,TT1_Q2,N_3,ISWI,
     &         Q,X,RES,CU,S,IU,KLMD,NKLMD,KP)		
      	END

CCC=================================================================

    	SUBROUTINE XFIT_LOW5(K,N2,N,PLOT,ICUT1,ICUT2)

CCC==INEQUALITY CONSTRAINED LINEAR SQUARE MINIMIZATION
CC==FOR LOW FREQUENCIES FITTING,IT GIVES HIGH ORDER FITTING FROM 1 TO ICUT1
CCC==Q1, Q2=KLM2D*N2D
CC==PLOT=K*4
      	REAL, DIMENSION(:,:), ALLOCATABLE :: Q2
CC==INCREASE ARRAY Q4 FOR DIFFERENT RANK FITTING TO ABV OR UDR 
      	REAL PLOT(K,N2)
	REAL LAMBDA
	 
CC==BEGIN: FIRST ALLOCATE ARRAYS FOR CALCULATION
      	L=1
      	M=K
      	N1=N+1
CC==DEFINE SIZE OF WORKING ARRAYS!
      	KLMD=K+L+M
      	KLM2D=K+L+M+2
      	NKLMD=K+L+M+N
      	N2D=N+2
      	KP=K
CC==FOR N.GT.2 CACULATION, ARRAY SIZE NEED ENLARGED!
      	N_LARG=KLMD*2
      	KLM2D=KLM2D+N_LARG
      	KLMD=KLMD+N_LARG
      	N2D=N2D+N_LARG
      	NKLMD=NKLMD+N_LARG
CC==
      	ALLOCATE(Q2(KLM2D,N2D),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
            CALL ERRT(46,'TFED',NE)
         RETURN
         ENDIF
CC==
	DO I=1,N-1
	    Q2(1:K,I)=PLOT(1:K,1)**I
      	ENDDO

	Q2(1:K,N)=1.0
	Q2(1:K,N+1)=PLOT(1:K,3)
CC==
        Q2(K+1:2*K,1:N+1)=Q2(1:K,1:N+1)
CC==GENERATE Q4 FOR UDR
	CALL PARTI18 (KLMD,NKLMD,KLM2D,N2D,Q2,
     &  K,N2,PLOT,N,ICUT1,ICUT2,KP)
     	DEALLOCATE(Q2)
      	END

CC==========================================================

	SUBROUTINE PARTI18 (KLMD,NKLMD,KLM2D,N2D,Q2,
     &  K,N2,PLOT1,N,ICUT1,ICUT2,KP)

	REAL Q2(KLM2D,N2D),PLOT1(K,N2)
CC==TT1_Q2,Q,X,RES,CU,S,IU are automatic arrays
	REAL TT1_Q2(KLM2D,N2D)
	DOUBLE PRECISION Q(KLM2D,N2D),X(N2D),RES(KLMD),CU(2,NKLMD),
     &                   S(KLMD)
      	INTEGER IU(2,NKLMD)
      	INTEGER  TMPI,TMPJ

CC==LOW FREQUENCIES REGION RE-FITTING!!!
CC==INTERMDEDIATE REGION FITTING
	ISTART=ICUT1
	ISTOP=ICUT2 
CC====ZHONG HUANG, APR,16,03
	N_3=N
	KS=ISTOP-ISTART+1
	L=1
	ISWI=5
	TT1_Q2(1:KS,1:N+1)=Q2(ISTART:ISTOP,1:N+1)
CC== EQUALITY CONSTRAINT CONDITION IN TT1_Q2
	TT1_Q2(KS+1,1:N-1)=Q2(ISTART,1:N-1)
	TT1_Q2(KS+1,N)=1.0
	TT1_Q2(KS+1,N+1)=PLOT1(ISTART,3)
	CALL LSFIT(KS,L,N2,PLOT1(ISTART,2+(ISWI-4)*2),
     &         KLM2D,N2D,TT1_Q2,N_3,ISWI,
     &         Q,X,RES,CU,S,IU,KLMD,NKLMD,KP)		
      	END

CC============================================================

     	SUBROUTINE XFIT_EN(NUMBER,N2,PLOT,
     & 		PS,CS,LAMBDA,CONTRAST,DEFOCUS,IPT1,IPT2,IPT3,IPT4)

CC==RE-FIT CTF ZEROS AND PEAKS AFTER OBTAINING DEFOCUS, AND USE AS CONSTRAINT
CC==POINTS TO GET MORE SMOOTH EVELOPE FUCNTION
CC==ESTIMATE CTF ZERO
	INTEGER, DIMENSION(:), ALLOCATABLE :: FOUR_ZERO,NCON
	REAL PLOT(NUMBER,N2)
	REAL LAMBDA

	N  = 5
	N4 = 4
	ALLOCATE(FOUR_ZERO(N4),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
            CALL ERRT(46,'TFED',N4)
            RETURN
        ENDIF
	N0=0

       !! defocus bad!!!!!!!!!!

       !write(6,*) '88',CS,    LAMBDA, CONTRAST,  PS,  DEFOCUS,  NZERO 
c                     2.26E+7 1.96E-2  0.1     1.58   454.1191  32767        

	CALL GET_CTF_ZERO4(NUMBER,N0,PS, CS, 
     & 	      LAMBDA, DEFOCUS, CONTRAST,NZERO,N4,FOUR_ZERO)

       !write(6,*) '89',CS,  LAMBDA, CONTRAST,  PS,  DEFOCUS,  NZERO 
c89               2.26E+7   1.96E-2  0.1     1.58  22639.0    44
c89               2.26      1.96     0.1     1.58  454.1    1

	IF (NZERO.GE.5) THEN
	    N3 = N4-1
	ELSE
	    N3=NZERO-1
	ENDIF

c       BUG zero allocation here for ncon  feb 2013 al
c       n3 = 0  ,  n4 = 4,  nzero=1
        ntoalloc = n4-1

      !write(6,*) 'in xfit_en, nzero,n3:',nzero,n3,n4,four_zero
      !write(6,*) 'in xfit_en, allocating ncon :',ntoalloc,'==',n3

C	ALLOCATE(NCON(N3),STAT=IRTFLG)
	ALLOCATE(NCON(NTOALLOC),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
            CALL ERRT(46,'TFED, NCON',NTOALLOC)
            RETURN
        ENDIF
	DO II=1,N3
	    III=II+1		
	    IFIT1=FOUR_ZERO(II)
	    IFIT2=FOUR_ZERO(III)
                     
	    IF(II.EQ.1) THEN
		X_FIT=REAL(IFIT2-IFIT1)
		X_FIT=X_FIT/4.0
		IFIT1=INT(X_FIT)+IFIT1
	    ENDIF
		CALL XFITLINE2(NUMBER,N2,PLOT,IFIT1,IFIT2,IFIT3)
		NCON(II)=IFIT3
	ENDDO	
CC==
	IPT1=FOUR_ZERO(2)
	IPT2=FOUR_ZERO(3)
	IPT3=NCON(1)
	IPT4=NCON(2)

	CALL XFIT_EN4(NUMBER,N2,N4,PLOT,NCON,N,NZERO)
	DEALLOCATE(FOUR_ZERO,NCON)
	END			

CC=====================

      	SUBROUTINE GET_CTF_ZERO4(NUMBER,N0,PS, CS, 
     & 	LAMBDA, DEFOCUS, CONTRAST,NZERO,N4,FOUR_ZERO)

	COMMON /SEARCH_RANGE/ DZLOW1,DZHIGH1,NMB
      	PARAMETER (QUADPI = 3.1415926535897932384626)
       	REAL LAMBDA,DZLOW1,DZHIGH1
	INTEGER FOUR_ZERO(N4)
	
       !write(6,*) '04',CS,  LAMBDA, CONTRAST,  PS,  DEFOCUS,  NZERO 
       !write(6,*) '04',DZLOW1,DZHIGH1,NMB 
C                  04  3000.0  200000.0  250   defocus bad!!!!

       !write(6,*) '04',CS,  LAMBDA, CONTRAST,  PS,  DEFOCUS,  NZERO 

CC==GIVE FIRST FOUR CTF ZEROS ACCORDING THE GIVEN DEFOCUS
       	AA    = -0.5*QUADPI*CS*LAMBDA**3
       	BB    = QUADPI*LAMBDA
       	BB    = BB*DEFOCUS             !bad?????
       	CC    = -ATAN(CONTRAST/(1.0-CONTRAST))

	FRQ1  = 0.0
	FRQ2  = REAL(NUMBER+N0) / 2.0 / PS / REAL(NMB)

        !write(6,*) '04, aa,bb,cc,defocus',aa,bb,cc,defocus
        !write(6,*) '04, frq1,2',frq1,frq2

       	TMPN1 = AA*FRQ1**4+BB*FRQ1**2+CC
       	TMPN1 = TMPN1 / QUADPI
       	N1    = INT(TMPN1)

	TMPN2 = AA*FRQ2**4+BB*FRQ2**2+CC   ! bad!!!!!!!!
       	TMPN2 = TMPN2 / QUADPI
       	N2    = INT(TMPN2)

        !write(6,*) '04, TMPN2,1',TMPN2,TMPN1

	N     = N2 - N1 + 1
	TMP1  = 4.*AA

        !write(6,*) '04, n2,n1,n',n2,n1,n 


	DO II=1,N
	    TMP2 = CC - REAL(II-1)*QUADPI
	    TMP2 = SQRT(BB**2-TMP1*TMP2)
	    TMP2 = TMP2-BB
	    TMP2 = SQRT(TMP2/2.0/AA)
	    NFRQ = INT(TMP2*2.0*PS*NMB)

	    IF(II .LE. 4) THEN
		FOUR_ZERO(II) = NFRQ
	    ENDIF

	ENDDO

	IF(N .LT. 4) THEN
	    NN = 4-N
	    DO II=1,NN
		NNN            = 4-II+1
		FOUR_ZERO(NNN) = 0
	    ENDDO
	ENDIF
	NZERO = N

3000	RETURN
	END
CC============================================================================

     	SUBROUTINE XFIT_EN4(K,N2,N3,PLOT,NCON,N,NZERO)

CCC==Q1, Q2=KLM2D*N2D
CC==PLOT=K*4
CC==INCREASE ARRAY Q4 FOR DIFFERENT RANK FITTING TO ABV OR UDR 
      	REAL PLOT(K,N2)
	INTEGER NCON(N3)
CC==BEGIN: FIRST ALLOCATE ARRAYS FOR CALCULATION
	IF(NZERO.GE.5) THEN
	    CALL EN_FIT7(PLOT,N,NCON,K,N2,N3)
	ELSEIF(NZERO.EQ.4) THEN
	    L=3
	    NT_2=3
	    CALL EN_FIT6(PLOT,NT_2,NCON,K,N2,N3,L)
	    NT_1=3
	    CALL EN_FIT5(PLOT,NT_1,NCON,K,N2,N3,L)
	ELSEIF(NZERO.EQ.3) THEN
	    L=2
	    NT_3=3
	    CALL EN_FIT5(PLOT,NT_3,NCON,K,N2,N3,L)
	    IFIT1=1
	    IFIT2=NCON(1)
	    CALL XFITLINE3(K,N2,PLOT,IFIT1,IFIT2)
	ELSEIF(NZERO.LE.2) THEN
	    IF(NCON(1).EQ.0) RETURN
	    CALL EN_FIT8(PLOT,NCON,K,N2,N4)	
	ENDIF
CC--EXTEND ENVELOPE TO LOW FREQUENCIES
		CALL EN_LOW(PLOT,N2,K,NCON,N4) 
      	END

CC===========================================================

	SUBROUTINE PARTI19 (KLMD,NKLMD,KLM2D,N2D,Q2,
     &  K,N2,PLOT1,N,ICUT1,ICUT2,ICUTD,ICUTC,KP)

	REAL Q2(KLM2D,N2D),PLOT1(K,N2)
CC==TT1_Q2,Q,X,RES,CU,S,IU are automatic arrays
	REAL TT1_Q2(KLM2D,N2D)
	DOUBLE PRECISION Q(KLM2D,N2D),X(N2D),RES(KLMD),CU(2,NKLMD),
     &                   S(KLMD)
      	INTEGER IU(2,NKLMD)
      	INTEGER  TMPI,TMPJ

CC==LOW FREQUENCIES REGION RE-FITTING!!!
CC==INTERMDEDIATE REGION FITTING
	ISTART=ICUT1
	ISTOP=ICUT2 
CC====ZHONG HUANG, APR,16,03
	N_3=N
	KS=ISTOP-ISTART+1
	L=4
	ISWI=8
	TT1_Q2(1:KS,1:N+1)=Q2(ISTART:ISTOP,1:N+1)
CC== EQUALITY CONSTRAINT CONDITION IN TT1_Q2
	TT1_Q2(KS+1,1:N-1)=Q2(ISTART,1:N-1)
	TT1_Q2(KS+2,1:N-1)=Q2(ISTOP,1:N-1)
	TT1_Q2(KS+3,1:N-1)=Q2(ICUTD,1:N-1)
	TT1_Q2(KS+4,1:N-1)=Q2(ICUTC,1:N-1)
	TT1_Q2(KS+1,N)=1.0
	TT1_Q2(KS+2,N)=1.0
	TT1_Q2(KS+3,N)=1.0
	TT1_Q2(KS+4,N)=1.0
	TT1_Q2(KS+1,N+1)=PLOT1(ISTART,3)
	TT1_Q2(KS+2,N+1)=PLOT1(ISTOP,3)
  	TT1_Q2(KS+3,N+1)=PLOT1(ICUTD,3)
	TT1_Q2(KS+4,N+1)=PLOT1(ICUTC,3)
CC==
	CALL LSFIT(KS,L,N2,PLOT1(ISTART,2+(ISWI-7)*2),
     &         KLM2D,N2D,TT1_Q2,N_3,ISWI,
     &         Q,X,RES,CU,S,IU,KLMD,NKLMD,KP)		
      	END
CC===================================================================

	SUBROUTINE EN_FIT5(PLOT,N,NCON,K,N2,N4,L)

	REAL, DIMENSION(:,:), ALLOCATABLE :: Q2
	REAL PLOT(K,N2)
	INTEGER NCON(N4)

    	M=K
      	N1=N+1
CC==DEFINE SIZE OF WORKING ARRAYS!
      	KLMD=K+L+M
      	KLM2D=K+L+M+2
      	NKLMD=K+L+M+N
      	N2D=N+2
      	KP=K
CC==FOR N.GT.2 CACULATION, ARRAY SIZE NEED ENLARGED!
      	N_LARG=KLMD*2
      	KLM2D=KLM2D+N_LARG
      	KLMD=KLMD+N_LARG
      	N2D=N2D+N_LARG
      	NKLMD=NKLMD+N_LARG
CC==
      	ALLOCATE(Q2(KLM2D,N2D),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
            CALL ERRT(46,'TFED',NE)
         RETURN
         ENDIF
	
CC==
	DO I=1,N-1
		Q2(1:K,I)=PLOT(1:K,1)**I
      	ENDDO
	
	Q2(1:K,N)=1.0
	Q2(1:K,N+1)=PLOT(1:K,3)
CC==
        Q2(K+1:2*K,1:N+1)=Q2(1:K,1:N+1)
CC==GENERATE Q4 FOR UDR
	ICUT1=NCON(1)
	ICUT2=K-1
	ICON3=NCON(2)
	ICON4=NCON(3)	 
	IF(L.EQ.4) THEN
	    CALL PARTI19 (KLMD,NKLMD,KLM2D,N2D,Q2,
     &  K,N2,PLOT,N,ICUT1,ICUT2,ICON3,ICON4,KP)
	ELSEIF(L.EQ.3) THEN
	    CALL PARTI17 (KLMD,NKLMD,KLM2D,N2D,Q2,
     &  K,N2,PLOT,N,ICUT1,ICON3,KP)
	ELSEIF(L.EQ.2) THEN
	    CALL PARTI20 (KLMD,NKLMD,KLM2D,N2D,Q2,
     &  K,N2,PLOT,N,ICUT1,ICUT2,KP)
	ENDIF	
     	DEALLOCATE(Q2)
	END
CC============================================================

	SUBROUTINE EN_FIT6(PLOT,N,NCON,K,N2,N4,L)

	REAL, DIMENSION(:,:), ALLOCATABLE :: Q2
	REAL PLOT(K,N2)
	INTEGER NCON(N4)

    	M=K
      	N1=N+1
CC==DEFINE SIZE OF WORKING ARRAYS!
      	KLMD=K+L+M
      	KLM2D=K+L+M+2
      	NKLMD=K+L+M+N
      	N2D=N+2
      	KP=K
CC==FOR N.GT.2 CACULATION, ARRAY SIZE NEED ENLARGED!
      	N_LARG=KLMD*2
      	KLM2D=KLM2D+N_LARG
      	KLMD=KLMD+N_LARG
      	N2D=N2D+N_LARG
      	NKLMD=NKLMD+N_LARG
CC==
      	ALLOCATE(Q2(KLM2D,N2D),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
            CALL ERRT(46,'TFED',NE)
         RETURN
         ENDIF

CC==
	DO I=1,N-1
	    Q2(1:K,I)=PLOT(1:K,1)**I
      	ENDDO

	Q2(1:K,N)=1.0
	Q2(1:K,N+1)=PLOT(1:K,3)
CC==
        Q2(K+1:2*K,1:N+1)=Q2(1:K,1:N+1)
CC==GENERATE Q4 FOR UDR
	ICUT1=NCON(1)
	ICUT2=K-1
	ICON3=NCON(2)
	ICON4=NCON(3)	 
	IF(L.EQ.4) THEN
	    CALL PARTI19 (KLMD,NKLMD,KLM2D,N2D,Q2,
     &  K,N2,PLOT,N,ICUT1,ICUT2,ICON3,ICON4,KP)
	ELSEIF(L.EQ.3) THEN
	    CALL PARTI20 (KLMD,NKLMD,KLM2D,N2D,Q2,
     &  K,N2,PLOT,N,ICON3,ICUT2,KP)
	ELSEIF(L.EQ.2) THEN
	    CALL PARTI20 (KLMD,NKLMD,KLM2D,N2D,Q2,
     &  K,N2,PLOT,N,ICUT1,ICUT2,KP)
	ENDIF	
     	DEALLOCATE(Q2)
	END

CCC====================================================================

	SUBROUTINE PARTI20 (KLMD,NKLMD,KLM2D,N2D,Q2,
     &  K,N2,PLOT1,N,ICUT1,ICUT2,KP)

	REAL Q2(KLM2D,N2D),PLOT1(K,N2)
CC==TT1_Q2,Q,X,RES,CU,S,IU are automatic arrays
	REAL TT1_Q2(KLM2D,N2D)
	DOUBLE PRECISION Q(KLM2D,N2D),X(N2D),RES(KLMD),CU(2,NKLMD),
     &                   S(KLMD)
      	INTEGER IU(2,NKLMD)
      	INTEGER  TMPI,TMPJ

CC==LOW FREQUENCIES REGION RE-FITTING!!!
CC==INTERMDEDIATE REGION FITTING
	ISTART=ICUT1
	ISTOP=ICUT2 
CC====ZHONG HUANG, APR,16,03
	N_3=N
	KS=ISTOP-ISTART+1
	L=0
	ISWI=2
	TT1_Q2(1:KS,1:N+1)=Q2(ISTART:ISTOP,1:N+1)
	CALL LSFIT(KS,L,N2,PLOT1(ISTART,2+(ISWI-1)*2),
     &         KLM2D,N2D,TT1_Q2,N_3,ISWI,
     &         Q,X,RES,CU,S,IU,KLMD,NKLMD,KP)		
      	END

CC=======================================================================

	SUBROUTINE EN_FIT7(PLOT,N,NCON,K,N2,N4)

	REAL PLOT(K,N2)
	INTEGER NCON(N4)

	ICUT1=NCON(1)
	ICUT2=K-1
	ICON3=NCON(2)
	ICON4=NCON(3)
	N_2=11
	CALL EN_FIT_THREE(PLOT,N_2,K,N2,ICUT1,ICUT2,ICON4)

	END

CC=======================================================

	SUBROUTINE EN_FIT_TWO(PLOT,N,K,N2,IPT1,IPT2)

	REAL, DIMENSION(:,:), ALLOCATABLE :: Q2
	REAL PLOT(K,N2)
CC==
	L=1
	M=K
      	N1=N+1
CC==DEFINE SIZE OF WORKING ARRAYS!
      	KLMD=K+L+M
      	KLM2D=K+L+M+2	
      	NKLMD=K+L+M+N
      	N2D=N+2
      	KP=K
CC==FOR N.GT.2 CACULATION, ARRAY SIZE NEED ENLARGED!
      	N_LARG=KLMD*2
      	KLM2D=KLM2D+N_LARG
      	KLMD=KLMD+N_LARG
      	N2D=N2D+N_LARG
      	NKLMD=NKLMD+N_LARG
CC==
      	ALLOCATE(Q2(KLM2D,N2D),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
            CALL ERRT(46,'TFED',NE)
         RETURN
         ENDIF
CC==
	DO I=1,N-1
	    Q2(1:K,I)=PLOT(1:K,1)**I
      	ENDDO
	Q2(1:K,N)=1.0
	Q2(1:K,N+1)=PLOT(1:K,3)
CC==
        Q2(K+1:2*K,1:N+1)=Q2(1:K,1:N+1)
CC==GENERATE Q4 FOR UDR
	CALL PARTI21 (KLMD,NKLMD,KLM2D,N2D,Q2,
     &  K,N2,PLOT,N,IPT1,IPT2,KP)
      	DEALLOCATE(Q2)
	END

CC=========================================================

	SUBROUTINE EN_FIT_THREE(PLOT,N,K,N2,IPT1,IPT2,IPT3)

	REAL, DIMENSION(:,:), ALLOCATABLE :: Q2
	REAL PLOT(K,N2)
	 	      	
	L=0
	M=K
      	N1=N+1
CC==DEFINE SIZE OF WORKING ARRAYS!
      	KLMD=K+L+M
      	KLM2D=K+L+M+2	
      	NKLMD=K+L+M+N
      	N2D=N+2
      	KP=K
CC==FOR N.GT.2 CACULATION, ARRAY SIZE NEED ENLARGED!
      	N_LARG=KLMD*2
      	KLM2D=KLM2D+N_LARG
      	KLMD=KLMD+N_LARG
      	N2D=N2D+N_LARG
      	NKLMD=NKLMD+N_LARG
CC==
      	ALLOCATE(Q2(KLM2D,N2D),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
            CALL ERRT(46,'TFED',NE)
         RETURN
         ENDIF
CC==
	DO I=1,N-1
	    Q2(1:K,I)=PLOT(1:K,1)**I
      	ENDDO
	Q2(1:K,N)=1.0
	Q2(1:K,N+1)=PLOT(1:K,3)
CC==
        Q2(K+1:2*K,1:N+1)=Q2(1:K,1:N+1)
CC==GENERATE Q4 FOR UDR
	CALL PARTI20 (KLMD,NKLMD,KLM2D,N2D,Q2,
     &  K,N2,PLOT,N,IPT1,IPT2,KP)
     	DEALLOCATE(Q2)
	END

CC========================================================

	SUBROUTINE PARTI21 (KLMD,NKLMD,KLM2D,N2D,Q2,
     &                      K,N2,PLOT1,N,ICUT1,ICUT2,KP)

	REAL Q2(KLM2D,N2D),PLOT1(K,N2)
CC==TT1_Q2,Q,X,RES,CU,S,IU are automatic arrays
	REAL TT1_Q2(KLM2D,N2D)
	DOUBLE PRECISION Q(KLM2D,N2D),X(N2D),RES(KLMD),CU(2,NKLMD),
     &                   S(KLMD)
      	INTEGER IU(2,NKLMD)
      	INTEGER  TMPI,TMPJ

CC==LOW FREQUENCIES REGION RE-FITTING!!!
CC==INTERMDEDIATE REGION FITTING
	ISTART=ICUT1
	ISTOP=ICUT2 
CC====ZHONG HUANG, APR,16,03
	N_3=N
	KS=ISTOP-ISTART+1
	L=1
	ISWI=5
	TT1_Q2(1:KS,1:N+1)=Q2(ISTART:ISTOP,1:N+1)
CC== EQUALITY CONSTRAINT CONDITION IN TT1_Q2
	TT1_Q2(KS+1,1:N-1)=Q2(ISTOP,1:N-1)
	TT1_Q2(KS+1,N)=1.0
	TT1_Q2(KS+1,N+1)=PLOT1(ISTOP,4)
	CALL LSFIT(KS,L,N2,PLOT1(ISTART,2+(ISWI-4)*2),
     &         KLM2D,N2D,TT1_Q2,N_3,ISWI,
     &         Q,X,RES,CU,S,IU,KLMD,NKLMD,KP)		
      	END

CC===============================================================

	SUBROUTINE EN_LOW(PLOT,N2,K,NCON,N4)

	REAL, DIMENSION(:,:), ALLOCATABLE :: Q2
	REAL    PLOT(K,N2)
	INTEGER NCON(N4)
	N=3
	L=1
    	M=K
      	N1=N+1
CC==DEFINE SIZE OF WORKING ARRAYS!
      	KLMD=K+L+M
      	KLM2D=K+L+M+2
      	NKLMD=K+L+M+N
      	N2D=N+2
      	KP=K
CC==FOR N.GT.2 CACULATION, ARRAY SIZE NEED ENLARGED!
      	N_LARG=KLMD*2
      	KLM2D=KLM2D+N_LARG
      	KLMD=KLMD+N_LARG
      	N2D=N2D+N_LARG
      	NKLMD=NKLMD+N_LARG
CC==
      	ALLOCATE(Q2(KLM2D,N2D),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
            CALL ERRT(46,'TFED',KLM2D*N2D)
         RETURN
         ENDIF
CC==
	DO I=1,N-1
	    Q2(1:K,I)=PLOT(1:K,1)**I
      	ENDDO
	Q2(1:K,N)=1.0
	Q2(1:K,N+1)=PLOT(1:K,3)
CC==
        Q2(K+1:2*K,1:N+1)=Q2(1:K,1:N+1)
CC==GENERATE Q4 FOR UDR
	IPT1=1
	IPT2=NCON(1)   ! is undefined here!!!! 
	CALL PARTI22 (KLMD,NKLMD,KLM2D,N2D,Q2,
     &                K,N2,PLOT,N,IPT1,IPT2,KP)
     	DEALLOCATE(Q2)
	END

CCC====================================================================

	SUBROUTINE PARTI22(KLMD,NKLMD,KLM2D,N2D,Q2,
     &                     K,N2,PLOT1,N,IPT1,IPT2,KP)

	REAL Q2(KLM2D,N2D),PLOT1(K,N2)
CC-TT1_Q2, Q,X,RES,CU,S,and IU are automatic arrays
	REAL TT1_Q2(KLM2D,N2D)
	DOUBLE PRECISION Q(KLM2D,N2D),X(N2D),RES(KLMD),CU(2,NKLMD),
     &                   S(KLMD)
      	INTEGER IU(2,NKLMD)
      	INTEGER  TMPI,TMPJ

CC==LOW FREQUENCIES REGION RE-FITTING!!!
CC==INTERMDEDIATE REGION FITTING
	ISTART = IPT1
	ISTOP  = IPT2 
CC====ZHONG HUANG, APR,16,03
	N_3=N
	KS=ISTOP-ISTART+1
	L=1
	ISWI=5

      !write(6,*)'in parti22, istart,istop,bnd:',istart,istop,k

      !write(6,*)'in parti22, ks,n,klm2d:',ks,n,klm2d

	TT1_Q2(1:KS,1:N+1)=Q2(ISTART:ISTOP,1:N+1)

CC== EQUALITY CONSTRAINT CONDITION IN TT1_Q2
	TT1_Q2(KS+1,1:N-1)= Q2(ISTOP,1:N-1)
	TT1_Q2(KS+1,N)    = 1.0
	TT1_Q2(KS+1,N+1)  = PLOT1(ISTOP,4)

	CALL LSFIT(KS,L,N2,PLOT1(ISTART,2+(ISWI-4)*2),
     &         KLM2D,N2D,TT1_Q2,N_3,ISWI,
     &         Q,X,RES,CU,S,IU,KLMD,NKLMD,KP)		
      	END

CC===============================================================

	SUBROUTINE PARTI23(KLMD,NKLMD,KLM2D,N2D,Q2,
     &                     K,N2,PLOT1,N,IPT1,IPT2,KP)

	REAL Q2(KLM2D,N2D),PLOT1(K,N2)
CC==TT1_Q2,Q,X,RES,CU,S,IU are automatic arrays
	REAL TT1_Q2(KLM2D,N2D)
	DOUBLE PRECISION Q(KLM2D,N2D),X(N2D),RES(KLMD),CU(2,NKLMD),
     &                   S(KLMD)
      	INTEGER IU(2,NKLMD)
      	INTEGER  TMPI,TMPJ

CC==LOW FREQUENCIES REGION RE-FITTING!!!
CC==INTERMDEDIATE REGION FITTING
	ISTART=IPT1
	ISTOP=IPT2 
	N_3=N
	KS=ISTOP-ISTART+1
	L=1
	ISWI=5
	TT1_Q2(1:KS,1:N+1)=Q2(ISTART:ISTOP,1:N+1)
CC== EQUALITY CONSTRAINT CONDITION IN TT1_Q2
	TT1_Q2(KS+1,1:N-1)=Q2(ISTART,1:N-1)
	TT1_Q2(KS+1,N)=1.0
	TT1_Q2(KS+1,N+1)=PLOT1(ISTART,3)
	CALL LSFIT(KS,L,N2,PLOT1(ISTART,2+(ISWI-4)*2),
     &         KLM2D,N2D,TT1_Q2,N_3,ISWI,
     &         Q,X,RES,CU,S,IU,KLMD,NKLMD,KP)		
        END

CC===============================================================

    	SUBROUTINE XFIT_LOW6(K,N2,PLOT,IPT,IPT1,IPT2,IPT3)

CCC==INEQUALITY CONSTRAINED LINEAR SQUARE MINIMIZATION
CC==FOR LOW FREQUENCIES FITTING,IT GIVES HIGH ORDER FITTING FROM 1 TO ICUT1
CCC==Q1, Q2=KLM2D*N2D
CC==PLOT=K*4
      	REAL, DIMENSION(:,:), ALLOCATABLE :: Q2
CC==INCREASE ARRAY Q4 FOR DIFFERENT RANK FITTING TO ABV OR UDR 
      	REAL PLOT(K,N2)
	REAL LAMBDA

CC==BEGIN: FIRST ALLOCATE ARRAYS FOR CALCULATION
	ICUT1=IPT1
	ICUT2=IPT2
	N=4
      	L=0
      	M=K
      	N1=N+1
CC==DEFINE SIZE OF WORKING ARRAYS!
      	KLMD=K+L+M
      	KLM2D=K+L+M+2
      	NKLMD=K+L+M+N
      	N2D=N+2
      	KP=K
CC==FOR N.GT.2 CACULATION, ARRAY SIZE NEED ENLARGED!
      	N_LARG=KLMD*2
      	KLM2D=KLM2D+N_LARG
      	KLMD=KLMD+N_LARG
      	N2D=N2D+N_LARG
      	NKLMD=NKLMD+N_LARG
CC==
      	ALLOCATE(Q2(KLM2D,N2D),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
            CALL ERRT(46,'TFED',NE)
         RETURN
         ENDIF
CC==
	DO I=1,N-1
		Q2(1:K,I)=PLOT(1:K,1)**I
      	ENDDO
	
	Q2(1:K,N)=1.0
	Q2(1:K,N+1)=PLOT(1:K,3)
CC==
C        Q2(K+1:2*K,1:N+1)=Q2(1:K,1:N+1)
CC==GENERATE Q4 FOR UDR
	CALL PARTI24 (KLMD,NKLMD,KLM2D,N2D,Q2,
     &  K,N2,PLOT,ICUT1,ICUT2,KP,N)
     	DEALLOCATE(Q2)
      	END

CC======================================================

	SUBROUTINE PARTI24 (KLMD,NKLMD,KLM2D,N2D,Q2,
     &  K,N2,PLOT1,ICUT1,ICUT2,KP,N)

	REAL Q2(KLM2D,N2D),PLOT1(K,N2)
CC==TT1_Q2,Q,X,RES,CU,S,IU are automatic arrays
	REAL TT1_Q2(KLM2D,N2D)
	DOUBLE PRECISION Q(KLM2D,N2D),X(N2D),RES(KLMD),CU(2,NKLMD),
     &                   S(KLMD)
      	INTEGER IU(2,NKLMD)
      	INTEGER  TMPI,TMPJ

CC==LOW FREQUENCIES REGION RE-FITTING!!!
CC==INTERMDEDIATE REGION FITTING
	ISTART=ICUT1
	ISTOP=ICUT2 
CC==
	N_3=N
	KS=ICUT2-ICUT1+1
	L=0
	ISWI=1
	TT1_Q2(1:KS,1:N+1)=Q2(ISTART:ISTOP,1:N+1)
CC== EQUALITY CONSTRAINT CONDITION IN TT1_Q2
	CALL LSFIT(KS,L,N2,PLOT1(ISTART,2+(ISWI-1)*2),
     &         KLM2D,N2D,TT1_Q2,N_3,ISWI,
     &         Q,X,RES,CU,S,IU,KLMD,NKLMD,KP)		
      	END
CC==============================================================

  	SUBROUTINE XFIT_LOW7(K,N2,PLOT,IPT1,IPT2)

CCC==Q1, Q2=KLM2D*N2D
CC==PLOT=K*4
      	REAL, DIMENSION(:,:), ALLOCATABLE :: Q2
CC==INCREASE ARRAY Q4 FOR DIFFERENT RANK FITTING TO ABV OR UDR 
      	REAL PLOT(K,N2)
	REAL LAMBDA
	 
CC==BEGIN: FIRST ALLOCATE ARRAYS FOR CALCULATION
	ICUT1=IPT1
	ICUT2=IPT2
	N=3
      	L=0
      	M=K
      	N1=N+1
CC==DEFINE SIZE OF WORKING ARRAYS!
      	KLMD=K+L+M
      	KLM2D=K+L+M+2
      	NKLMD=K+L+M+N
      	N2D=N+2
      	KP=K
CC==FOR N.GT.2 CACULATION, ARRAY SIZE NEED ENLARGED!
      	N_LARG=KLMD*2
      	KLM2D=KLM2D+N_LARG
      	KLMD=KLMD+N_LARG
      	N2D=N2D+N_LARG
      	NKLMD=NKLMD+N_LARG
CC==
      	ALLOCATE(Q2(KLM2D,N2D),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
            CALL ERRT(46,'TFED',NE)
         RETURN
         ENDIF
CC==
	DO I=1,N-1
		Q2(1:K,I)=PLOT(1:K,1)**I
      	ENDDO
	Q2(1:K,N)=1.0
	Q2(1:K,N+1)=PLOT(1:K,3)
CC==GENERATE Q4 FOR UDR

	CALL PARTI24 (KLMD,NKLMD,KLM2D,N2D,Q2,
     &  K,N2,PLOT,ICUT1,ICUT2,KP,N)
     	DEALLOCATE(Q2)
      	END

CC======================================================

    	SUBROUTINE XFITLINE3(K,N2,PLOT,IFIT1,IFIT2)
CCC==Q1, Q2=KLM2D*N2D
CC==PLOT=K*4
      	REAL, DIMENSION(:,:), ALLOCATABLE :: Q2
CC==INCREASE ARRAY Q4 FOR DIFFERENT RANK FITTING TO ABV OR UDR 
      	REAL PLOT(K,N2)
	 
CC==IN THIS CASE, K=NMB
	N=2
      	L=0
      	M=K
      	N1=N+1
CC==DEFINE SIZE OF WORKING ARRAYS!
      	KLMD=K+L+M
      	KLM2D=K+L+M+2
      	NKLMD=K+L+M+N
      	N2D=N+2
      	KP=K
CC==FOR N.GT.2 CACULATION, ARRAY SIZE NEED ENLARGED!
      	N_LARG=KLMD*2
      	KLM2D=KLM2D+N_LARG
      	KLMD=KLMD+N_LARG
      	N2D=N2D+N_LARG
      	NKLMD=NKLMD+N_LARG

      	ALLOCATE(Q2(KLM2D,N2D),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
            CALL ERRT(46,'TFED',NE)
         RETURN
         ENDIF

	Q2(1:K,1)=PLOT(1:K,1)
	Q2(1:K,2)=1.0
	Q2(1:K,3)=PLOT(1:K,3)
CC==
	CALL PARTI9(KLMD,NKLMD,KLM2D,N2D,Q2,
     &              K,N2,N,PLOT,IFIT1,IFIT2,KP)
     	DEALLOCATE(Q2)
      	END

CC=================================================================

  	SUBROUTINE XFIT_LOW8(K,N2,PLOT,IPT1,IPT2)
CCC==Q1, Q2=KLM2D*N2D
CC==PLOT=K*4
      	REAL, DIMENSION(:,:), ALLOCATABLE :: Q2
CC==INCREASE ARRAY Q4 FOR DIFFERENT RANK FITTING TO ABV OR UDR 
      	REAL PLOT(K,N2)
	REAL LAMBDA
	 
CC==BEGIN: FIRST ALLOCATE ARRAYS FOR CALCULATION
	ICUT1=IPT1
	ICUT2=IPT2
	N=9
      	L=0
      	M=K
      	N1=N+1
CC==DEFINE SIZE OF WORKING ARRAYS!
      	KLMD=K+L+M
      	KLM2D=K+L+M+2
      	NKLMD=K+L+M+N
      	N2D=N+2
      	KP=K
CC==FOR N.GT.2 CACULATION, ARRAY SIZE NEED ENLARGED!
      	N_LARG=KLMD*2
      	KLM2D=KLM2D+N_LARG
      	KLMD=KLMD+N_LARG
      	N2D=N2D+N_LARG
      	NKLMD=NKLMD+N_LARG

      	ALLOCATE(Q2(KLM2D,N2D),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
            CALL ERRT(46,'TFED',NE)
         RETURN
         ENDIF

	DO I=1,N-1
	    Q2(1:K,I)=PLOT(1:K,1)**I
      	ENDDO
	
	Q2(1:K,N)=1.0
	Q2(1:K,N+1)=PLOT(1:K,3)
CC==GENERATE Q4 FOR UDR
	CALL PARTI25 (KLMD,NKLMD,KLM2D,N2D,Q2,
     &  K,N2,PLOT,ICUT1,ICUT2,KP)
     	DEALLOCATE(Q2)
      	END

CCC========================================================

	SUBROUTINE PARTI25 (KLMD,NKLMD,KLM2D,N2D,Q2,
     &  K,N2,PLOT1,ICUT1,ICUT2,KP)
	REAL Q2(KLM2D,N2D),PLOT1(K,N2)
CC==TT1_Q2,Q,X,RES,CU,S, and IU are automatic arrays 
	REAL TT1_Q2(KLM2D,N2D)
	DOUBLE PRECISION Q(KLM2D,N2D),X(N2D),RES(KLMD),CU(2,NKLMD),
     &                   S(KLMD)
      	INTEGER IU(2,NKLMD)
      	INTEGER  TMPI,TMPJ

CC==LOW FREQUENCIES REGION RE-FITTING!!!
CC==INTERMDEDIATE REGION FITTING
	N=9
	ISTART=ICUT1
	ISTOP=ICUT2 
CC==
	N_3=N
	KS=ICUT2-ICUT1+1
	L=0
	ISWI=1
	TT1_Q2(1:KS,1:N+1)=Q2(ISTART:ISTOP,1:N+1)
CC== EQUALITY CONSTRAINT CONDITION IN TT1_Q2
	CALL LSFIT(KS,L,N2,PLOT1(ISTART,2+(ISWI-1)*2),
     &         KLM2D,N2D,TT1_Q2,N_3,ISWI,
     &         Q,X,RES,CU,S,IU,KLMD,NKLMD,KP)		
      	END

CC==================================================

     	SUBROUTINE RESOLUTION_ANALYZE(NUMBER,N2,N0,PS, CS, 
     & 	LAMBDA, DEFOCUS, CONTRAST,PLOT1,XX_CC)
	COMMON /SEARCH_RANGE/ DZLOW1,DZHIGH1,NMB
      	PARAMETER (QUADPI = 3.1415926535897932384626)
       	REAL LAMBDA,DZLOW1,DZHIGH1
	REAL PLOT1(NUMBER,N2)	
CC==GIVE FIRST FOUR CTF ZEROS ACCORDING THE GIVEN DEFOCUS
	REAL,DIMENSION (:,:),ALLOCATABLE :: TMP_1,X_ITGL
	REAL,DIMENSION (:),ALLOCATABLE :: TMP_2,TMP_3,TMP_NZERO_M,
     &                                    X_CC,X_PEAK
	INTEGER, DIMENSION (:), ALLOCATABLE :: NZERO
	X_CCTHR=0.8
	XX_CC=9999.
	AA = -0.5*QUADPI*CS*LAMBDA**3
       	BB = QUADPI*LAMBDA
       	BB=BB*DEFOCUS
       	CC = -ATAN(CONTRAST/(1.0-CONTRAST))
	FRQ1=0.0
	FRQ2=REAL(NUMBER+N0)/2.0/PS/REAL(NMB)
       	TMPN1=AA*FRQ1**4+BB*FRQ1**2+CC
       	TMPN1=TMPN1/QUADPI
       	N_1=INT(TMPN1)
	TMPN2=AA*FRQ2**4+BB*FRQ2**2+CC
       	TMPN2=TMPN2/QUADPI
       	N_2=INT(TMPN2)
	N_X=N_2-N_1+1

	IF(N_X.LE.1) THEN
	    XX_CC=9999
	    RETURN
	ENDIF
 
	N_XXX=N_X-1
	TMP1=4.*AA

	ALLOCATE(NZERO(N_X),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
            CALL ERRT(46,'TFED',NE)
            RETURN
        ENDIF
	ALLOCATE(TMP_NZERO_M(N_X),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
            CALL ERRT(46,'TFED',NE)
            RETURN
        ENDIF
	ALLOCATE(X_CC(N_X),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
            CALL ERRT(46,'TFED',NE)
            RETURN
        ENDIF
	ALLOCATE(X_PEAK(N_X),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
            CALL ERRT(46,'TFED',NE)
            RETURN
        ENDIF

	DO II=1,N_X
	    TMP2=CC-REAL(II-1)*QUADPI
	    TMP2=SQRT(BB**2-TMP1*TMP2)
	    TMP2=TMP2-BB
	    TMP2=SQRT(TMP2/2.0/AA)
	    NFRQ=INT(TMP2*2.0*PS*NMB)
	    NZERO(II)=NFRQ		
	    TMP3=CC-REAL(II-1)*QUADPI-.5*QUADPI
	    TMP_XX=abs(BB**2-TMP1*TMP3)
	    TMP3=SQRT(TMP_XX)
	    TMP3=TMP3-BB
	    TMP3=SQRT(TMP3/2.0/AA)
	    TMP_NZERO_M(II)=TMP3
	ENDDO
CC		
	ALLOCATE(TMP_1(NUMBER,4),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
            CALL ERRT(46,'TFED',NE)
            RETURN
        ENDIF
	ALLOCATE(TMP_2(NUMBER),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
            CALL ERRT(46,'TFED',NE)
            RETURN
        ENDIF
	ALLOCATE(X_ITGL(N_X,3),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
            CALL ERRT(46,'TFED',NE)
            RETURN
        ENDIF
     	ALLOCATE(TMP_3(NUMBER),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
            CALL ERRT(46,'TFED',NE)
            RETURN
        ENDIF
	TMP_1(:,:)=PLOT1(:,:)
	DO KKK=1,NUMBER
	    XXXXX=EXP(TMP_1(KKK,4))-EXP(TMP_1(KKK,2))
	    IF(TMP_1(KKK,2).NE.0.0) THEN
		TMP_1(KKK,2)=EXP(TMP_1(KKK,2))
		TMP_1(KKK,3)=EXP(TMP_1(KKK,3))
		TMP_1(KKK,4)=EXP(TMP_1(KKK,4))
	    ELSE
		TMP_1(KKK,2)=0.0
		TMP_1(KKK,3)=0.0
		TMP_1(KKK,4)=0.0
	    ENDIF
	ENDDO

	TMP_1(:,3)=TMP_1(:,3)-TMP_1(:,2)
        TMP_1(:,4)=TMP_1(:,4)-TMP_1(:,2)
CC==SEARCHING NZEROS!
	CALL CTF_SIGNAL1(TMP_2,TMP_1(1,1),NUMBER, PS, CS, 
     &                LAMBDA, DEFOCUS, CONTRAST)
	TMP_2(1:NUMBER)=TMP_2(1:NUMBER)**2*TMP_1(1:NUMBER,4)

	DO II=1,NUMBER
	    TMP_3(II)=SQRT(ABS(TMP_1(II,3)))*SQRT(ABS(TMP_2(II)))
	ENDDO

	IF(N_XXX.LE.1) THEN 
CC==WE CAN EXTRACT INFORMATION TO RESOLUTION LIMIT!
	   XX_CC=1.0/(2.*PS)
	   RETURN
	ENDIF

	DO III=1,N_XXX
	    XX=TMP_NZERO_M(III)*PS*2.0*NUMBER
	    I_XX=INT(XX)
	    X_PEAK(III)=TMP_1(I_XX,3)
	    IIII=III+1
	    III_1=NZERO(III)
	    III_2=NZERO(IIII)
	    N_XX=III_2-III_1+1
	    CALL POWER_SUM (TMP_2(III_1),N_XX,X_ITGL(III,1))
	    CALL POWER_SUM (TMP_1(III_1,3),N_XX,X_ITGL(III,2))
	    CALL POWER_SUM (TMP_3(III_1),N_XX,X_ITGL(III,3))
	    CALL CC_TWO_CURVES(TMP_1(III_1,3),
     &		TMP_2(III_1),N_XX,X_CC(III))

	    IF(X_CC(III).GE.X_CCTHR) THEN
CC==WE SET THRESHOLD AS 0.8 
		XX_CC=(TMP_NZERO_M(III)+TMP_NZERO_M(IIII))/2.
	    ENDIF
	
	ENDDO
	DEALLOCATE(TMP_1,NZERO,TMP_2,TMP_3,X_ITGL,TMP_NZERO_M,
     &              X_CC,X_PEAK)
	END

CC===================================================================

	SUBROUTINE CC_TWO_CURVES(TMP_X,TMP_Y,N_XX,X_CC)

	REAL TMP_X(N_XX),TMP_Y(N_XX)

	TMP1=0.0
	TMP2=0.0
	TMP3=0.0
	TMP4=0.0
	TMP5=0.0
CC==
	TMPX=0.0
	TMPY=0.0
	DO II=1,N_XX
	    TMPX=TMPX+TMP_X(II)
	    TMPY=TMPY+TMP_Y(II)
	ENDDO

	IF(TMPX.EQ.0.0.OR.TMPY.EQ.0.0) THEN 
	    X_CC=0
	    RETURN
	ENDIF

	DO II=1,N_XX
	    TMP1=TMP1+TMP_X(II)
	    TMP2=TMP2+TMP_Y(II)
	    TMP3=TMP3+TMP_X(II)*TMP_X(II)
	    TMP4=TMP4+TMP_Y(II)*TMP_Y(II)
	    TMP5=TMP5+SQRT(ABS(TMP_X(II)*TMP_Y(II)))
	ENDDO

	TMP6=REAL(N_XX)
	TMP1=TMP1/TMP6
	TMP2=TMP2/TMP6
	X_CC=TMP5/TMP6
	X_CC=X_CC/SQRT(ABS(TMP1))/SQRT(ABS(TMP2))
	END

CC=========================================================================

	SUBROUTINE CTF_2_ZERO(TMP,NMB,NT,NUMBER,N2,TMP_OUT,
     &		IPW_ZERO,CS,LAMBDA,CONTRAST,PS,NDGREE,AV_DEFO,
     &		ICUTA,ICUTB,ICUTD,DEFO_MIN,DEFO_MAX,XX_CC)

	REAL LAMBDA
	DIMENSION TMP(NMB,2),TMP_OUT(NMB,NT)
	REAL, DIMENSION(:,:), ALLOCATABLE :: PLOT,TMP_PLOT

	ALLOCATE(PLOT(NUMBER,N2),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
            CALL ERRT(46,'TFED',NE)
            RETURN
        ENDIF

	ALLOCATE(TMP_PLOT(NUMBER,N2),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
            CALL ERRT(46,'TFED',NE)
            RETURN
        ENDIF

	PLOT(:,1)=TMP(IPW_ZERO+1:NMB,1)-1.0
	PLOT(:,3)=ALOG(TMP(IPW_ZERO+1:NMB,2))
	N=NDGREE+1
CC==CC==FIT BACKGROUND FROM ICUTB TO ICUT2
	ICUT1=ICUTA
	ICUT2=NUMBER
	CALL XFIT_ZH(NUMBER,N2,N,PLOT,ICUT1,ICUT2)

	N_TEST=NDGREE+1

       !write(6,*) 'in CTF_2_ZERO calling XFIT_LOW1,icutd:',icutd
 
	CALL XFIT_LOW1(NUMBER,N2,PLOT,ICUTA,ICUT2,ICUTD,N_TEST)

	ICUT1=ICUTB
	ICNSTRNT=ICUTB
	IBACK=1
	CALL XFIT_LOW2(NUMBER,N2,PLOT,ICUTB,ICUT2,N)
	CALL XFIT_LOW10(NUMBER,N2,PLOT,IBACK,ICUTB)

	ICUT_LOW=1
	ICUT_HIGH=ICUTB
	CALL XFIT_LOW9(NUMBER,N2,PLOT,ICUT_LOW,ICUT_HIGH)

       !write(6,*) '2zero',CS,       LAMBDA, CONTRAST,  PS,  AV_DEFO 
c                 2.26E+7  1.96E-2   0.1    1.584   454.1


	CALL XFIT_EN(NUMBER,N2,PLOT,
     & 		PS,CS,LAMBDA,CONTRAST,AV_DEFO,IPT1,IPT2,IPT3,IPT4)

	IF (IPT1 .EQ. 0) RETURN
CC====
	CALL XFIT_BKGND3(NUMBER,N2,N,PLOT,ICUT_LOW,ICUT2,ICNSTRNT)
	IFIT_B_STOP=ICUT2
	TMP_PLOT(:,:)=PLOT(:,:)
	TMP_OUT(1:NUMBER,:)=PLOT(:,:)

	CALL DEFOCUS_EST1(NUMBER,N2,N,PLOT,ICUT1,ICUT2,
     & 		PS,CS,LAMBDA,CONTRAST,DEFOCUS)

	IF(DEFOCUS.GT.DEFO_MAX) THEN
	    AV_DEFO=DEFO_MAX
	    XX_CC=9999
	    GO TO 1122
	ELSE
	    AV_DEFO=DEFOCUS
	ENDIF
	N0=0
	CALL RESOLUTION_ANALYZE(NUMBER,N2,N0,PS, CS, 
     & 	         LAMBDA, AV_DEFO, CONTRAST,TMP_PLOT,XX_CC)
1122	DEALLOCATE(PLOT,TMP_PLOT)
	END

CC============================================================================

	SUBROUTINE EN_FIT8(PLOT,NCON,K,N2,N4)

	REAL, DIMENSION(:,:), ALLOCATABLE :: Q2
	REAL PLOT(K,N2)
	INTEGER NCON(N4)

	L=0
	N=5
    	M=K
      	N1=N+1
CC==DEFINE SIZE OF WORKING ARRAYS!
      	KLMD=K+L+M
      	KLM2D=K+L+M+2
      	NKLMD=K+L+M+N
      	N2D=N+2
      	KP=K
CC==FOR N.GT.2 CACULATION, ARRAY SIZE NEED ENLARGED!
      	N_LARG=KLMD*2
      	KLM2D=KLM2D+N_LARG
      	KLMD=KLMD+N_LARG
      	N2D=N2D+N_LARG
      	NKLMD=NKLMD+N_LARG

      	ALLOCATE(Q2(KLM2D,N2D),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
            CALL ERRT(46,'TFED',NE)
         RETURN
         ENDIF

	DO I=1,N-1
		Q2(1:K,I)=PLOT(1:K,1)**I
      	ENDDO

	Q2(1:K,N)=1.0
	Q2(1:K,N+1)=PLOT(1:K,3)
        Q2(K+1:2*K,1:N+1)=Q2(1:K,1:N+1)
CC==GENERATE Q4 FOR UDR
	IF(ICUT1.EQ.0) RETURN

	ICUT1=NCON(1)
	ICUT2=K
	ICON3=NCON(2)
	ICON4=NCON(3)
	 
	CALL PARTI20 (KLMD,NKLMD,KLM2D,N2D,Q2,
     &  K,N2,PLOT,N,ICUT1,ICUT2,KP)
     	DEALLOCATE(Q2)
	END

CCC=============================================================

 	SUBROUTINE XFIT_LOW9(K,N2,PLOT,IPT1,IPT2)

CCC==INEQUALITY CONSTRAINED LINEAR SQUARE MINIMIZATION
CC==FOR LOW FREQUENCIES FITTING,IT GIVES HIGH ORDER FITTING FROM 1 TO ICUT1
CCC==Q1, Q2=KLM2D*N2D
CC==PLOT=K*4
      	REAL, DIMENSION(:,:), ALLOCATABLE :: Q2
CC==INCREASE ARRAY Q4 FOR DIFFERENT RANK FITTING TO ABV OR UDR 
      	REAL PLOT(K,N2)
	REAL LAMBDA
      	
CC==BEGIN: FIRST ALLOCATE ARRAYS FOR CALCULATION
	ICUT1=IPT1
	ICUT2=IPT2
	N=6
      	L=0
      	M=K
      	N1=N+1
CC==DEFINE SIZE OF WORKING ARRAYS!
      	KLMD=K+L+M
      	KLM2D=K+L+M+2
      	NKLMD=K+L+M+N
      	N2D=N+2
      	KP=K
CC==FOR N.GT.2 CACULATION, ARRAY SIZE NEED ENLARGED!
      	N_LARG=KLMD*2
      	KLM2D=KLM2D+N_LARG
      	KLMD=KLMD+N_LARG
      	N2D=N2D+N_LARG
      	NKLMD=NKLMD+N_LARG
CC==
      	ALLOCATE(Q2(KLM2D,N2D),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
            CALL ERRT(46,'TFED',NE)
         RETURN
         ENDIF
CC==
	DO I=1,N-1
		Q2(1:K,I)=PLOT(1:K,1)**I
      	ENDDO

	Q2(1:K,N)=1.0
	Q2(1:K,N+1)=PLOT(1:K,3)

	CALL PARTI24 (KLMD,NKLMD,KLM2D,N2D,Q2,
     &  K,N2,PLOT,ICUT1,ICUT2,KP,N)
     	DEALLOCATE(Q2)
      	END

CC=========================================================================

  	SUBROUTINE XFIT_HIGH_EN(K,N2,PLOT,IPT1,IPT2)

CCC==Q1, Q2=KLM2D*N2D
CC==PLOT=K*4
      	REAL, DIMENSION(:,:), ALLOCATABLE :: Q2
CC==INCREASE ARRAY Q4 FOR DIFFERENT RANK FITTING TO ABV OR UDR 
      	REAL PLOT(K,N2)
	REAL LAMBDA
	
CC==BEGIN: FIRST ALLOCATE ARRAYS FOR CALCULATION
	ICUT1=IPT1
	ICUT2=IPT2
	N=7
      	L=0
      	M=K
      	N1=N+1
CC==DEFINE SIZE OF WORKING ARRAYS!
      	KLMD=K+L+M
      	KLM2D=K+L+M+2
      	NKLMD=K+L+M+N
      	N2D=N+2
      	KP=K
CC==FOR N.GT.2 CACULATION, ARRAY SIZE NEED ENLARGED!
      	N_LARG=KLMD*2
      	KLM2D=KLM2D+N_LARG
      	KLMD=KLMD+N_LARG
      	N2D=N2D+N_LARG
      	NKLMD=NKLMD+N_LARG

	ALLOCATE(Q2(KLM2D,N2D),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
            CALL ERRT(46,'TFED',NE)
         RETURN
         ENDIF
	DO I=1,N-1
	    Q2(1:K,I)=PLOT(1:K,1)**I
      	ENDDO

	Q2(1:K,N)=1.0
	Q2(1:K,N+1)=PLOT(1:K,3)
CC==GENERATE Q4 FOR UDR
	CALL PARTI20 (KLMD,NKLMD,KLM2D,N2D,Q2,
     &  K,N2,PLOT,N,ICUT1,ICUT2,KP)
     	DEALLOCATE(Q2)
      	END

CC===============================================================================

	SUBROUTINE CTF_CORRECT(TMP,NMB,NT,NUMBER,N2,TMP_OUT,
     &	IPW_ZERO,CS,LAMBDA,CONTRAST,PS,AV_DEFO,
     & 	ICUTA,ICUTB,ICUTD,DEFO_MIN,DEFO_MAX ,XX_CC)

CC==THIS SUBROUTINE CORRECT MIS_ESTIMATED DUE TO LONG AND FLAT HIGH FREQUENCY TAIL
	REAL LAMBDA
	DIMENSION TMP(NMB,2),TMP_OUT(NMB,NT)
	REAL, DIMENSION(:,:), ALLOCATABLE :: PLOT,TMP_PLOT

	ALLOCATE(PLOT(NUMBER,N2),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
            CALL ERRT(46,'TFED',NE)
            RETURN
         ENDIF
	
        ALLOCATE(TMP_PLOT(NUMBER,N2),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
            CALL ERRT(46,'TFED',NE)
            RETURN
         ENDIF
	PLOT(:,1)=TMP(IPW_ZERO+1:NMB,1)-1.0
	PLOT(:,3)=ALOG(TMP(IPW_ZERO+1:NMB,2))
	N=NDGREE+1
CC==CC==FIT BACKGROUND FROM ICUTB TO ICUT2
	ICUT1=ICUTB
	X_NUM=REAL(NUMBER)/2.
	ICUT2=INT(X_NUM)
CC==ICUTB is too far!
	IF(ICUT2.LE.ICUT1) THEN
	    XX_CC=9999
	    GO TO 1122
	ENDIF

	CALL FIT_ALL(NUMBER,N2,PLOT)

	TMP_OUT(1:NUMBER,:)=PLOT(:,:)
	TMP_PLOT(:,:)=PLOT(:,:)

	CALL DEFOCUS_EST(NUMBER,N2,N,PLOT,ICUT1,ICUT2,
     & 	PS,CS,LAMBDA,CONTRAST,DEFOCUS,NZERO,
     &	IFIRST,ISECND)

	IF(DEFOCUS.GT.DEFO_MAX) THEN
	    XX_CC=9999
	    GO TO 1122
	ELSE
	    AV_DEFO=DEFOCUS
	ENDIF
	N0=0
	CALL RESOLUTION_ANALYZE(NUMBER,N2,N0,PS,CS, 
     & 	LAMBDA,AV_DEFO,CONTRAST,TMP_PLOT,XX_CC)

1122	DEALLOCATE(PLOT,TMP_PLOT)
	END

CC===================================================================

   	SUBROUTINE FIT_ALL(K,N2,PLOT)
CCC==INEQUALITY CONSTRAINED LINEAR SQUARE MINIMIZATION
CCC==Q1, Q2=KLM2D*N2D
CC==PLOT=K*4
	
      	REAL, DIMENSION(:,:), ALLOCATABLE :: Q2
CC==INCREASE ARRAY Q4 FOR DIFFERENT RANK FITTING TO ABV OR UDR 
      	REAL PLOT(K,N2)
	REAL LAMBDA
	 
	IFIT1=1
	IFIT2=K
	N=6
      	L=0
      	M=K
      	N1=N+1
CC==DEFINE SIZE OF WORKING ARRAYS!
      	KLMD=K+L+M
      	KLM2D=K+L+M+2
      	NKLMD=K+L+M+N
      	N2D=N+2
      	KP=K
CC==FOR N.GT.2 CACULATION, ARRAY SIZE NEED ENLARGED!
      	N_LARG=KLMD*2
      	KLM2D=KLM2D+N_LARG
      	KLMD=KLMD+N_LARG
      	N2D=N2D+N_LARG
      	NKLMD=NKLMD+N_LARG
CC==
      	ALLOCATE(Q2(KLM2D,N2D),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
            CALL ERRT(46,'TFED',NE)
         RETURN
         ENDIF
CC==
	DO I=1,N-1
		Q2(1:K,I)=PLOT(1:K,1)**I
      	ENDDO

	Q2(1:K,N)=1.0
	Q2(1:K,N+1)=PLOT(1:K,3)
        Q2(K+1:2*K,1:N+1)=Q2(1:K,1:N+1)

	CALL PARTI9(KLMD,NKLMD,KLM2D,N2D,Q2,
     &              K,N2,N,PLOT,IFIT1,IFIT2,KP)
     	DEALLOCATE(Q2)
      	END

CC====================================================================

	SUBROUTINE DEFO_REFINE(PLOT,TMP,TMP_OUT,NMB,NUMBER,
     &	     N2,NT,NDGREE,ICUTA,ICUTB,PS,CS,LAMBDA,CONTRAST,IPW_ZERO,
     &       DEFO_MIN,DEFO_MAX,AV_DEFO,XX_CC)

	REAL LAMBDA
	DIMENSION TMP(NMB,2),PLOT(NUMBER,N2),TMP_OUT(NMB,NT)
	REAL, DIMENSION(:,:), ALLOCATABLE :: TMP_PLOT

	ALLOCATE(TMP_PLOT(NUMBER,N2),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
            CALL ERRT(46,'TFED',NE)
            RETURN
        ENDIF
	
	N=NDGREE+1
	ICUT1=ICUTB
	ICUT2=NUMBER

c       ICUTD was undefined until bb set it to 0 in 2009,
c       but that is also wrong since it is 'out of bounds'.
c       So in feb 2013  I set it arbitrarily to 1 since I
c       can not figure out what it should be.  al

C	ICUTD=0             !!!!!!!!!!!!!!!!!!!!!!!!!
	ICUTD=(icut2 - icuta)/3             !al feb 2013

       !write(6,*) 'in DEFO_REFINE calling XFIT_ZH,icut:', icut1,icut2
	CALL XFIT_ZH(NUMBER,N2,N,PLOT,ICUT1,ICUT2)

c       write(6,*) 'in DEFO_REFINE calling XFIT_LOW1,icut:',
c     &             icut1,icut2,icuta,icutd

	CALL XFIT_LOW1(NUMBER,N2,PLOT,ICUTA,ICUT2,ICUTD,N)

	ICUT1=ICUTB
	ICNSTRNT=ICUTB
	IBACK=1

	CALL XFIT_LOW2(NUMBER,N2,PLOT,ICUTB,ICUT2,N)
	CALL XFIT_LOW10(NUMBER,N2,PLOT,IBACK,ICUTB)
	CALL XFIT_EN(NUMBER,N2,PLOT,
     & 	PS,CS,LAMBDA,CONTRAST,AV_DEFO,IPT1,IPT2,IPT3,IPT4)

	IF(ICUTB.GT.IPT2) THEN
	    CALL XFIT_LOW6(NUMBER,N2,PLOT,ICUTB,IPT1,IPT2,IPT3)
	ENDIF

	IF(IPT2.NE.0) THEN
	    CALL XFIT_LOW7(NUMBER,N2,PLOT,IBACK,IPT2)
	    CALL XFIT_LOW7(NUMBER,N2,PLOT,IPT2,ICUT2)
	ENDIF
	
	CALL XFIT_BKGND3(NUMBER,N2,N,PLOT,ICUT1,ICUT2,ICNSTRNT)

	IF(N_TEST.GT.4) THEN
	    CALL XFIT_LOW8(NUMBER,N2,PLOT,IPT2,ICUT2)
	ENDIF

	IF(IPT4.NE.0) THEN 
	    IFIT_B_STRT=IPT4
	    IPT_END=NUMBER
	     CALL XFIT_HIGH_EN(NUMBER,N2,PLOT,IPT4,IPT_END)
	ELSE
	    IFIT_B_STRT=IPT3
	ENDIF

	    IFIT_B_STOP=ICUT2
	    TMP_OUT(1:NUMBER,:)=PLOT(:,:)
	    TMP_PLOT(:,:)=PLOT(:,:)
	    ICUT1=ICUTB
	IF(ICUT1.GT.IPT1) THEN
	    ICUT1=IPT1
	    ICUT2=NUMBER
	ENDIF

	IF(ICUTA.LT.ICUT2/2.0) THEN
	    ICUT1=ICUTA
	ENDIF
CC==TO SMALL PIXEL SIZE MICORGRAPH
	IF(PS.LT.2.) THEN
	    ICUT1=ICUTB 
	    TMP_XX=NUMBER/2.
	    ICUT2=INT(TMP_XX)	    
	ENDIF

	CALL DEFOCUS_EST1(NUMBER,N2,N,PLOT,ICUT1,ICUT2,
     & 		PS,CS,LAMBDA,CONTRAST,DEFOCUS)

	IF(DEFOCUS.GT.DEFO_MAX.OR.DEFOCUS.LT.AV_DEFO*2./3.) THEN
	    PLOT(:,:)=TMP_PLOT(:,:)
	    ICUT1=ICUTB
	    CALL DEFOCUS_EST1(NUMBER,N2,N,PLOT,ICUT1,ICUT2,
     & 		PS,CS,LAMBDA,CONTRAST,DEFOCUS)

		IF(DEFOCUS.GT.DEFO_MAX.OR.DEFOCUS.LT.AV_DEFO*2./3.)THEN
		    XX_CC=9999
		    GO TO 1122
		ENDIF
	ENDIF

	IF(DEFOCUS.GT.DEFO_MIN) THEN
	    AV_DEFO=DEFOCUS
	ELSE 
	    CALL DEFOCUS_GUESSING4(TMP,NMB,NT,NUMBER,N2,TMP_OUT,
     &	              IPW_ZERO,CS,LAMBDA,CONTRAST,PS,AV_DEFO,
     &                 DEFO_MIN,DEFO_MAX ,XX_CC)
			  
	ENDIF

	N0=0
	CALL RESOLUTION_ANALYZE(NUMBER,N2,N0,PS, CS, 
     & 		LAMBDA, AV_DEFO, CONTRAST,TMP_PLOT,XX_CC)		
1122	DEALLOCATE(TMP_PLOT)
	END

CC======================================================================================

   	SUBROUTINE XFIT_LOW10(K,N2,PLOT,ICUT1,ICUT2)
CCC==Q1, Q2=KLM2D*N2D
CC==PLOT=K*4
      	REAL, DIMENSION(:,:), ALLOCATABLE :: Q2
CC==INCREASE ARRAY Q4 FOR DIFFERENT RANK FITTING TO ABV OR UDR 
      	REAL PLOT(K,N2)
	REAL LAMBDA

CC==BEGIN: FIRST ALLOCATE ARRAYS FOR CALCULATION
	N=6
      	L=0
      	M=K
      	N1=N+1
CC==DEFINE SIZE OF WORKING ARRAYS!
      	KLMD=K+L+M
      	KLM2D=K+L+M+2
      	NKLMD=K+L+M+N
      	N2D=N+2
      	KP=K
CC==FOR N.GT.2 CACULATION, ARRAY SIZE NEED ENLARGED!
      	N_LARG=KLMD*2
      	KLM2D=KLM2D+N_LARG
      	KLMD=KLMD+N_LARG
      	N2D=N2D+N_LARG
      	NKLMD=NKLMD+N_LARG
CC==
      	ALLOCATE(Q2(KLM2D,N2D),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
            CALL ERRT(46,'TFED',NE)
         RETURN
         ENDIF
CC==
	DO I=1,N-1
	    Q2(1:K,I)=PLOT(1:K,1)**I
      	ENDDO

	Q2(1:K,N)=1.0
	Q2(1:K,N+1)=PLOT(1:K,3)
CC==
	CALL PARTI26 (KLMD,NKLMD,KLM2D,N2D,Q2,
     &  K,N2,PLOT,ICUT1,ICUT2,KP,N)
     	DEALLOCATE(Q2)
      	END
CC==================================================================
	SUBROUTINE PARTI26 (KLMD,NKLMD,KLM2D,N2D,Q2,
     &  K,N2,PLOT1,ICUT1,ICUT2,KP,N)
	REAL Q2(KLM2D,N2D),PLOT1(K,N2)
CC==TT1_Q2,Q,X,RES,CU,S,IU are automatic arrays
	REAL TT1_Q2(KLM2D,N2D)
	DOUBLE PRECISION Q(KLM2D,N2D),X(N2D),RES(KLMD),CU(2,NKLMD),
     &                   S(KLMD)
      	INTEGER IU(2,NKLMD)

      	INTEGER  TMPI,TMPJ

	ISTART=ICUT1
	ISTOP=ICUT2 

	N_3=N
	KS=ISTOP-ISTART+1
	L=0
	ISWI=1
	TT1_Q2(1:KS,1:N+1)=Q2(ISTART:ISTOP,1:N+1)

	CALL LSFIT(KS,L,N2,PLOT1(ISTART,2+(ISWI-1)*2),
     &         KLM2D,N2D,TT1_Q2,N_3,ISWI,
     &         Q,X,RES,CU,S,IU,KLMD,NKLMD,KP)		
      	END

CC===========================================================================

	SUBROUTINE DEFOCUSGUESSING3(POW2,
     & 		NSAM1,NROW1,NMB,PS,CS,LAMBDA,CONTRAST,AV_DEFO,XX_CC)
	DIMENSION POW2(NSAM1,NROW1)
	REAL, DIMENSION(:,:), ALLOCATABLE :: PLOT,TMP,TMP_X
	REAL, DIMENSION(:), ALLOCATABLE :: X_DEFO
	REAL LAMBDA
	REAL 		QUADPI
      	PARAMETER (QUADPI = 3.1415926535897932384626)

	NMRANK=6

	ALLOCATE(TMP(NMB,2),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
            CALL ERRT(46,'TFED',NE)
            RETURN
        ENDIF
	
	ALLOCATE(X_DEFO(NMRANK),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
            CALL ERRT(46,'TFED',NE)
            RETURN
        ENDIF

CC=======ICUT_LOW_FRQ
CC==N_ZERO IS MAXIMUM NZEROS OF CTF CONTROL POINTS FOR ASTIGMATISM ESTIMATION

	XSTART = 0.0
	XSTEP  = 180.0
	CALL ZH_CRCSE2(POW2,TMP(1,2),NSAM1,NROW1,NMB,XSTART,XSTEP)
	IPW_ZERO=0

	DO I=1,NMB
 	    TMP(I,1)=I		
 	ENDDO
CC==
      	IF(NMB.LT.5) THEN 
            CALL ERRT(36,'TFED',NE)
            RETURN
      	ENDIF

	DO I=1,NMB
	    IF(TMP(I,2).EQ.0.0) THEN 
	    IPW_ZERO=I
	    ENDIF
	ENDDO
CC==ESTIMATE THE MINIMUM DEFOCUS BASED ON GIVEN VOLTAGE, CS, AND PIXEL SIZE
	TMP1_DEFO=(2.*PS)**2/LAMBDA
	TMP2_DEFO=CONTRAST/(1.0-CONTRAST)
	TMP2_DEFO=ATAN(TMP2_DEFO)*TMP1_DEFO/QUADPI
	TMP3_DEFO=.5*CS*LAMBDA**2/(2.*PS)**2
	DEFO_MIN=TMP2_DEFO+TMP3_DEFO

	TMP1_DEFO=.5*REAL(NMB-1)/PS/REAL(NMB)
	TMP1_DEFO=TMP1_DEFO*TMP1_DEFO
	TMP2_DEFO=.5/PS
	TMP2_DEFO=TMP2_DEFO*TMP2_DEFO
	DEFO_MAX=1.0/(TMP2_DEFO-TMP1_DEFO)/LAMBDA
	DEFO_MAX=DEFO_MAX+.5*CS*LAMBDA**2*(TMP2_DEFO+TMP1_DEFO)
CC==WE FIT A STRAIGHT LINE BELOW PW TO LOCATE POINT CUT OFF LOW FREQUENCY REGION         
	N2=4
	NUMBER=NMB-IPW_ZERO
	NDGREE=0
	IBACK=1
CCC=========THRESHOLD OF POWER
        X_TRH1=0.45
	X_TRH2=0.90

	ALLOCATE(PLOT(NUMBER,N2),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
            CALL ERRT(46,'TFED',NE)
            RETURN
        ENDIF
	 ALLOCATE(TMP_X(NUMBER,N2),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
            CALL ERRT(46,'TFED',NE)
            RETURN
         ENDIF
CC==Using power of PSP to cut off low frequencies region (threshold 45%)	
        PLOT(:,3)=TMP(IPW_ZERO+1:NMB,2)
	XX_SUM=SUM(PLOT(:,3))
	XXX_SUM=0.0

	DO II=1,NUMBER
		XXX_SUM=XXX_SUM+PLOT(II,3)/XX_SUM
	    IF(XXX_SUM.GT.X_TRH1) THEN
		ICUT1=II
		GO TO 1101
	    ENDIF
	ENDDO

1101	XXX_SUM=0.0
CC==Using power of PSP to cut off high frequencies region (threshold 90%)
	DO II=1,NUMBER
	    XXX_SUM=XXX_SUM+PLOT(II,3)/XX_SUM
	    
	    IF(XXX_SUM.GT.X_TRH2) THEN
		ICUT2=II
		GO TO 1100
            ENDIF
	ENDDO

1100	AV_DEFO=DEFO_MIN
	DO III=2,5		
	    PLOT(:,1)=TMP(IPW_ZERO+1:NMB,1)-1.0
	    PLOT(:,3)=ALOG(TMP(IPW_ZERO+1:NMB,2))
	    IFIT1=ICUTB
	    IFIT2=NUMBER
	    N=III
	    CALL XFIT_ZH1(NUMBER,N2,N,PLOT,ICUT1,ICUT2)

	    TMP_X(:,:)=PLOT(:,:)
	
	    CALL DEFOCUS_EST1(NUMBER,N2,N,PLOT,ICUT1,ICUT2,
     & 	PS,CS,LAMBDA,CONTRAST,DEFOX)
	    X_DEFO(III-1)=DEFOX

            N0=0
	    CALL RESOLUTION_ANALYZE(NUMBER,N2,N0,PS, CS, 
     & 		LAMBDA, AV_DEFO, CONTRAST,TMP_X,X_CC)
	    IF(AV_DEFO.LT.DEFOX.AND.DEFOX.LT.DEFO_MAX) THEN
		AV_DEFO=DEFOX
		XX_CC=X_CC
	    ENDIF
					
	ENDDO
	DEALLOCATE(PLOT,TMP,X_DEFO,TMP_X)
	END

cc================================================================

    	SUBROUTINE XFIT_ZH1(K,N2,N,PLOT,ICUT1,ICUT2)

CCC==INEQUALITY CONSTRAINED LINEAR SQUARE MINIMIZATION
CCC==Q1, Q2=KLM2D*N2D
CC==PLOT=K*4
CC==ENVELOPE FITTING  NO EQUALITY CONTRAINTS 
	
      	REAL, DIMENSION(:,:), ALLOCATABLE :: Q2
CC==INCREASE ARRAY Q4 FOR DIFFERENT RANK FITTING TO ABV OR UDR 
      	REAL PLOT(K,N2)
	REAL LAMBDA
	      	      			
      	L=0
      	M=K
      	N1=N+1
CC==DEFINE SIZE OF WORKING ARRAYS!
      	KLMD=K+L+M
      	KLM2D=K+L+M+2
      	NKLMD=K+L+M+N
      	N2D=N+2
      	KP=K
CC==FOR N.GT.2 CACULATION, ARRAY SIZE NEED ENLARGED!
      	N_LARG=KLMD*2
      	KLM2D=KLM2D+N_LARG
      	KLMD=KLMD+N_LARG
      	N2D=N2D+N_LARG
      	NKLMD=NKLMD+N_LARG

      	ALLOCATE(Q2(KLM2D,N2D),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
            CALL ERRT(46,'TFED',NE)
            RETURN
         ENDIF

	DO I=1,N-1
	    Q2(1:K,I)=PLOT(1:K,1)**I
      	ENDDO

	Q2(1:K,N)=1.0
	Q2(1:K,N+1)=PLOT(1:K,3)
        Q2(K+1:2*K,1:N+1)=Q2(1:K,1:N+1)

	CALL PARTI28 (KLMD,NKLMD,KLM2D,N2D,Q2,
     &           K,N2,PLOT,N,ICUT1,ICUT2,KP)

	DO I=1,N-1
	    Q2(1:K,I)=PLOT(1:K,1)**I
      	ENDDO

	Q2(1:K,N)=1.0
	Q2(1:K,N+1)=PLOT(1:K,3)
        Q2(K+1:2*K,1:N+1)=Q2(1:K,1:N+1)

	CALL PARTI29 (KLMD,NKLMD,KLM2D,N2D,Q2,
     &  K,N2,PLOT,N,ICUT1,ICUT2,KP)
     	DEALLOCATE(Q2)
      	END

CC=============================================================

	SUBROUTINE PARTI28 (KLMD,NKLMD,KLM2D,N2D,Q2,
     &           K,N2,PLOT1,N,ICUT1,ICUT2,KP)

	REAL Q2(KLM2D,N2D),PLOT1(K,N2)
CC==TT1_Q2,Q,X,RES,CU,S,IU are automatic arrays
	REAL TT1_Q2(KLM2D,N2D)
	DOUBLE PRECISION Q(KLM2D,N2D),X(N2D),RES(KLMD),CU(2,NKLMD),
     &                   S(KLMD)
      	INTEGER IU(2,NKLMD)
      	INTEGER  TMPI,TMPJ
CC==LOW FREQUENCIES REGION RE-FITTING!!!
CC==INTERMDEDIATE REGION FITTING
	ISTART=ICUT1
	ISTOP=ICUT2 
	N_3=N
	KS=ISTOP-ISTART+1
	L=0
	ISWI=2
CC==TT1_02 is destroyed after calling lsfit

	TT1_Q2(1:KS,1:N+1)=Q2(ISTART:ISTOP,1:N+1)
	CALL LSFIT(KS,L,N2,PLOT1(ISTART,2+(ISWI-1)*2),
     &         KLM2D,N2D,TT1_Q2,N_3,ISWI,
     &         Q,X,RES,CU,S,IU,KLMD,NKLMD,KP)

	KS=ISTART
	TT1_Q2(1:KS,1:N+1)=Q2(1:ISTART,1:N+1)

	CALL LSFIT(KS,L,N2,PLOT1(1,2+(ISWI-1)*2),
     &         KLM2D,N2D,TT1_Q2,N_3,ISWI,
     &         Q,X,RES,CU,S,IU,KLMD,NKLMD,KP)

	KS=K-ISTOP+1
	TT1_Q2(1:KS,1:N+1)=Q2(ISTOP:K,1:N+1)

	CALL LSFIT(KS,L,N2,PLOT1(ICUT2,2+(ISWI-1)*2),
     &         KLM2D,N2D,TT1_Q2,N_3,ISWI,
     &         Q,X,RES,CU,S,IU,KLMD,NKLMD,KP)			
      	END

CC=============================================================

	SUBROUTINE PARTI29 (KLMD,NKLMD,KLM2D,N2D,Q2,
     &  K,N2,PLOT1,N,ICUT1,ICUT2,KP)

	REAL Q2(KLM2D,N2D),PLOT1(K,N2)
CC==TT1_Q2,Q,X,RES,CU,S,IU are automatic arrays
	REAL TT1_Q2(KLM2D,N2D)
	DOUBLE PRECISION Q(KLM2D,N2D),X(N2D),RES(KLMD),CU(2,NKLMD),
     &                   S(KLMD)
      	INTEGER IU(2,NKLMD)
      	INTEGER  TMPI,TMPJ

	ISTART=ICUT1
	ISTOP=ICUT2 
	N_3=N	
	ISWI=1
	L=0

	KS=ISTOP-ISTART+1
	TT1_Q2(1:KS,1:N+1)=Q2(ISTART:ISTOP,1:N+1)
	CALL LSFIT(KS,L,N2,PLOT1(ISTART,2+(ISWI-1)*2),
     &         KLM2D,N2D,TT1_Q2,N_3,ISWI,
     &         Q,X,RES,CU,S,IU,KLMD,NKLMD,KP)
	
	
	KS=ISTART	
	TT1_Q2(1:KS,1:N+1)=Q2(1:ISTART,1:N+1)
	CALL LSFIT(KS,L,N2,PLOT1(1,2+(ISWI-1)*2),
     &         KLM2D,N2D,TT1_Q2,N_3,ISWI,
     &         Q,X,RES,CU,S,IU,KLMD,NKLMD,KP)

	KS=K-ISTOP+1
	TT1_Q2(1:KS,1:N+1)=Q2(ISTOP:K,1:N+1)
	CALL LSFIT(KS,L,N2,PLOT1(ISTOP,2+(ISWI-1)*2),
     &         KLM2D,N2D,TT1_Q2,N_3,ISWI,
     &         Q,X,RES,CU,S,IU,KLMD,NKLMD,KP)			
	END

CC=============================================================

	SUBROUTINE DEFOCUS_EST1(K,N2,N,PLOT,ICUT1,ICUT2,
     & 	PS,CS,LAMBDA,CONTRAST,DEFOCUS)
	REAL PLOT(K,N2)
	REAL LAMBDA

	DO KKK=1,ICUT2
	    XXX=PLOT(KKK,1)/2./PS/REAL(K)
	    XXXXX=EXP(PLOT(KKK,4))-EXP(PLOT(KKK,2))
	
	    IF(PLOT(KKK,2).NE.0.0) THEN
		PLOT(KKK,2)=EXP(PLOT(KKK,2))
		PLOT(KKK,3)=EXP(PLOT(KKK,3))
		PLOT(KKK,4)=EXP(PLOT(KKK,4))
	    ELSE
		PLOT(KKK,2)=0.0
		PLOT(KKK,3)=0.0
		PLOT(KKK,4)=0.0
	    ENDIF

	ENDDO

        PLOT(1:ICUT2,3)=PLOT(1:ICUT2,3)-PLOT(1:ICUT2,2)
        PLOT(1:ICUT2,4)=PLOT(1:ICUT2,4)-PLOT(1:ICUT2,2)
	
	ISWI=1
      	DZMAX=GETDEFOCUS(PLOT(1,3),PLOT(1,1),K,PS,CS,LAMBDA,
     &		CONTRAST,XSCORE,PLOT(1,4),ICUT1,ICUT2,ISWI)
CCCC=======OUTPUT RESULT======================================
       	DEFOCUS=DZMAX
 
      	END

CC================================================================

	SUBROUTINE POWER_SUM (TMP_X,N_XX,X_ITGL)

	REAL TMP_X(N_XX)
	X_ITGL=SUM(TMP_X(1:N_XX))
	END

CC====================================================================

	SUBROUTINE DEFOCUS_GUESSING4(TMP,NMB,NT,NUMBER,N2,TMP_OUT,
     &	           IPW_ZERO,CS,LAMBDA,CONTRAST,PS,AV_DEFO,
     &              DEFO_MIN,DEFO_MAX ,XX_CC)

CC==THIS SUBROUTINE CORRECT DEFOCUS MIS_ESTIMATED DUE TO LONG AND FLAT HIGH FREQUENCY TAIL
	REAL LAMBDA
	DIMENSION TMP(NMB,2),TMP_OUT(NMB,NT)
	REAL, DIMENSION(:,:), ALLOCATABLE :: PLOT,TMP_PLOT

        X_TRH1=0.45
	X_TRH2=0.90

	ALLOCATE(PLOT(NUMBER,N2),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
            CALL ERRT(46,'TFED',NE)
            RETURN
         ENDIF
	ALLOCATE(TMP_PLOT(NUMBER,N2),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
            CALL ERRT(46,'TFED',NE)
            RETURN
         ENDIF
      	PLOT(:,3)=TMP(IPW_ZERO+1:NMB,2)
	XX_SUM=SUM(PLOT(:,3))
	XXX_SUM=0.0

	DO II=1,NUMBER
	    XXX_SUM=XXX_SUM+PLOT(II,3)/XX_SUM
	    IF(XXX_SUM.GT.X_TRH1) THEN
		ICUT1=II
		GO TO 1101
	    ENDIF

	ENDDO

1101	XXX_SUM=0.0
CC==Using power of PSP to cut off high frequencies region (threshold 90%)
	DO II=1,NUMBER
	    XXX_SUM=XXX_SUM+PLOT(II,3)/XX_SUM
	    IF(XXX_SUM.GT.X_TRH2) THEN
	    	ICUT2=II
	    	GO TO 1100
	ENDIF

	ENDDO
 
1100	PLOT(:,1)=TMP(IPW_ZERO+1:NMB,1)-1.0
	PLOT(:,3)=ALOG(TMP(IPW_ZERO+1:NMB,2))
	N=NDGREE+1
CC==CC==FIT BACKGROUND FROM ICUTB TO ICUT2

        CALL FIT_ALL(NUMBER,N2,PLOT)

	TMP_OUT(1:NUMBER,:)=PLOT(:,:)
	TMP_PLOT(:,:)=PLOT(:,:)

	CALL DEFOCUS_EST(NUMBER,N2,N,PLOT,ICUT1,ICUT2,
     & 	PS,CS,LAMBDA,CONTRAST,DEFOCUS,NZERO,
     &	IFIRST,ISECND)

	IF(DEFOCUS.GT.DEFO_MAX) THEN
	    XX_CC=9999
	    GO TO 1122
	ELSE
	    AV_DEFO=DEFOCUS
	ENDIF
	N0=0
	CALL RESOLUTION_ANALYZE(NUMBER,N2,N0,PS, CS, 
     & 	LAMBDA, AV_DEFO, CONTRAST,TMP_PLOT,XX_CC)
1122	DEALLOCATE(PLOT,TMP_PLOT)
	END

CC==================================================================================

	SUBROUTINE AST_CALC1(NNLOOP,BETA,XDEFO,AV_DEFO,
     &		AST_AGL,TMP_AMP,TMP_SUM,RATIO)
	REAL XDEFO(NNLOOP)
	PARAMETER (QUADPI = 3.1415926535897932384626)
	TMP_SIN=0.0
	TMP_COS=0.0
	TMP1=BETA/180.0*QUADPI
	TMP_SUM=SUM(XDEFO)/REAL(NNLOOP)

	DO I=1,NNLOOP
	    FREQ=2.0*(I-1+.5)*TMP1
	    TMP_SIN=TMP_SIN+SIN(FREQ)*(XDEFO(I)-TMP_SUM)
	    TMP_COS=TMP_COS+COS(FREQ)*(XDEFO(I)-TMP_SUM)
	ENDDO

	TMP_SIN=2.0*TMP_SIN/REAL(NNLOOP)
	TMP_COS=2.0*TMP_COS/REAL(NNLOOP)
	TMP_AMP=SQRT(TMP_SIN**2+TMP_COS**2)*2
	AST_AGL=ATAN2(TMP_COS,TMP_SIN)

	IF(AST_AGL.LT.0.0) AST_AGL=2.0*QUADPI+AST_AGL

	AST_AGL=AST_AGL*180.0/QUADPI/2.0-90.0
	TMP_SUM=0.0

	DO I=1,NNLOOP
	    TMP_SUM=TMP_SUM+XDEFO(I)-
     &		TMP_AMP/2.0*SIN(2*(REAL(I+.5)*BETA-AST_AGL))
	ENDDO

	TMP_SUM=TMP_SUM/REAL(NNLOOP)
	RATIO=TMP_AMP/AV_DEFO
	END

CC===========================================================================================

	SUBROUTINE AST_CALC(POW2,NSAM1,NROW1,NMB,NT,PS,CS,
     &		LAMBDA,CONTRAST,AV_DEFO,NDGREE,AST_AGL,TMP_AMP,TMP_SUM)

	REAL POW2(NSAM1,NROW1)
	REAL LAMBDA
	REAL, DIMENSION(:,:), ALLOCATABLE :: TMP_OUT
	REAL, DIMENSION(:),   ALLOCATABLE :: XDEFO

	BETA   = 18.
	X_LOOP = 180. / BETA

1122	NNLOOP = INT(X_LOOP)     ! number of angular determinations

	DEFO_CUT1 = .5  * AV_DEFO
	DEFO_CUT2 = 2.0 * AV_DEFO

	ALLOCATE(XDEFO(NNLOOP),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
            CALL ERRT(46,'TFED; XDEFO',NNLOOP)
            RETURN
        ENDIF

	ALLOCATE(TMP_OUT(NMB,NT),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
            CALL ERRT(46,'TFED; TMP_OUT',NMB*NT)
            RETURN
        ENDIF
	
	DO IILOOP=1,NNLOOP
	    TMP1       = REAL(IILOOP-1)
	    TMP2       = REAL(IILOOP)
	    BETA0      = TMP1 * BETA
	    BETA1      = TMP2 * BETA
	    NDGREE_AST = NDGREE

            !write(6,*) 'ast_calc; call GUESSING1 number:',beta1

	    CALL DEFOCUSGUESSING1(POW2,NSAM1,NROW1,NMB,BETA0,BETA1,
     & 		PS,CS,LAMBDA,CONTRAST,DEFOCUS,
     &		ICUT_LOW_FRQ,ICN_SND,NDGREE,TMP_OUT,NT,AST_X_CC,NUMBER)

            !write(6,*) 'after ast_calc; :',number,iiloop

CC==        IN CASE OF VERY STRONG ASTIGMATISM; ADJUST POLYNOMIAL DEGREE
	    IF (BETA .LT. 18.) THEN
C               this can never be used!!!!! al feb 2013

		TMP1       = DEFOCUS / FST_DEFO * REAL(NDGREE)
		NDGREE_AST = INT(TMP1)

	    	IF (NDGREE_AST .LT. 2) NDGREE_AST = 2			  

		CALL DEFOCUSGUESSING2(POW2,NSAM1,NROW1,NMB,BETA0,BETA1
     & 		          ,PS,CS,LAMBDA,CONTRAST,DEFOCUS,IILOOP,
     &		           ICUT_LOW_FRQ,ICN_SND,NDGREE_AST)

	    ENDIF

            write(6,'(A,f6.2,f10.1,/)') 'ast_calc :',beta0,defocus

	    XDEFO(IILOOP) = DEFOCUS
	ENDDO
CC==    CHECK

	DO I=1,NNLOOP
           IF(XDEFO(I) .LT. DEFO_CUT1) THEN
              XDEFO(I) = AV_DEFO
           ELSEIF(XDEFO(I).GT.DEFO_CUT2) THEN
              XDEFO(I) = AV_DEFO
           ENDIF
	ENDDO

	CALL AST_CALC1(NNLOOP,BETA,XDEFO,
     &                 AV_DEFO,AST_AGL,TMP_AMP,TMP_SUM,RATIO)

CC==    FOR STRONG ATIGMATISM ONLY

	IF (RATIO.GT.2 .AND. BETA.GE.18) THEN
           BETA=3.
           GO TO 1122
	ENDIF

	DEALLOCATE(XDEFO,TMP_OUT)
	END

CC===========================================================================

c**************************************************************************
C *  LSFIT.F
C=**********************************************************************
C=* From: SPIDER - MODULAR IMAGE PROCESSING SYSTEM                     *
C=* Copyright (C)2002, Z. Huang & P. A. Penczek                        *
C=*                                                                    *
C=* University of Texas - Houston Medical School                       *
C=*                                                                    *
C=* Email:  pawel.a.penczek@@uth.tmc.edu                                *
C=*                                                                    *
C=* This program is free software; you can redistribute it and/or      *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* This program is distributed in the hope that it will be useful,    *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
C=* General Public License for more details.                           *
C=*                                                                    *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program; if not, write to the                      *
C=* Free Software Foundation, Inc.,                                    *
C=* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.      *
C=*                                                                    *
C **********************************************************************

       SUBROUTINE LSFIT(KS,L,N2,P,KLM2D,N2D,Q1,N,ISWI,
     & 		Q,X,RES,CU,S,IU,KLMD,NKLMD,KP)

C  DRIVER PROGRAM FOR SUBROUTINE CL1.
C                                                                       
C THIS PROGRAM SOLVES A K BY N OVERDETERMINED SYSTEM                    
C                                                                       
C    AX=B                                                               
C                                                                       
C IN THE L1 SENSE SUBJECT TO L EQUALITY CONSTRAINTS                     
C                                                                       
C    CX=D                                                               
C                                                                       
C AND M INEQUALITY CONSTRAINTS                                          
C                                                                       
C    EX.LE.F.                                                           
C                                                                       
C COMPLETE DETAILS OF THE PARAMETERS MAY BE                             
C FOUND IN THE DOCUMENTATION OF THE SUBROUTINE.                         
C                                                                       
C THE ARRAYS ARE CURRENTLY DIMENSIONED TO ALLOW PROBLEMS                
C FOR WHICH K+L+M .LE. 100, N .LE. 10.                                  
C                                                                       
C THE PROGRAM MAY BE TESTED ON THE FOLLOWING DATA.  
                                                                                 
      	DOUBLE PRECISION Q(KLM2D,N2D),TOLER,X(N2D),RES(KLMD),
     & 		CU(2,NKLMD),S(KLMD),TMP
      	DIMENSION IU(2,NKLMD)
      	REAL Q1(KLM2D,N2D),P(KP)
C modified by Zhong Huang, July,12,02                                   
cc==TOLER, ITER, KODE are set in the program;TOLER and ITER are set according to tests
	L=0
      	KODE=0
      	TOLER=.000001 
      	ITER=500
CC==ZHONG HUANG,JULY,12,02;L=0,1,2,3,4,5,6 correspond to different equality constraints

      	M=KS
      	N1=N+1
      	IF(ISWI.EQ.1) THEN                                                       
     		Q(1:KS,1:N1)=DBLE(Q1(1:KS,1:N1))
       		Q(KS+1:2*KS,1:N1)=DBLE(Q1(1:KS,1:N1))                      
      	ELSEIF(ISWI.EQ.2) THEN
       		Q(1:KS,1:N1)=DBLE(Q1(1:KS,1:N1))
       		Q(KS+1:2*KS,1:N1)=-DBLE(Q1(1:KS,1:N1))
      	ELSEIF(ISWI.EQ.3) THEN
       		L=2
       		Q(1:KS+2,1:N1)=DBLE(Q1(1:KS+2,1:N1))
       		Q(KS+3:2+2*KS,1:N1)=DBLE(Q1(1:KS,1:N1))
      	ELSEIF(ISWI.EQ.4) THEN
       		L=2
       		Q(1:KS+2,1:N1)=DBLE(Q1(1:KS+2,1:N1))
       		Q(KS+3:2+2*KS,1:N1)=-DBLE(Q1(1:KS,1:N1))
	ELSEIF(ISWI.EQ.5) THEN
		L=1
       		Q(1:KS+1,1:N1)=DBLE(Q1(1:KS+1,1:N1))
       		Q(KS+2:2*KS+1,1:N1)=-DBLE(Q1(1:KS,1:N1))
	ELSEIF(ISWI.EQ.6) THEN
		L=1
       		Q(1:KS+1,1:N1)=DBLE(Q1(1:KS+1,1:N1))
       		Q(KS+2:2*KS+1,1:N1)=DBLE(Q1(1:KS,1:N1))
	ELSEIF(ISWI.EQ.7) THEN
		L=3
       		Q(1:KS+3,1:N1)=DBLE(Q1(1:KS+3,1:N1))
       		Q(KS+4:2*KS+3,1:N1)=-DBLE(Q1(1:KS,1:N1))
	ELSEIF(ISWI.EQ.8) THEN
		L=4
       		Q(1:KS+4,1:N1)=DBLE(Q1(1:KS+4,1:N1))
       		Q(KS+5:2*KS+4,1:N1)=-DBLE(Q1(1:KS,1:N1))
      	ENDIF
      	CALL CL1(KS, L, M, N, KLMD, KLM2D, NKLMD, N2D, Q,                  
     * KODE, TOLER, ITER, X, RES, ERROR, CU, IU, S) 
                        
CC==CALCULATING THE RESTRAINED RESULTS
	IF (KODE .GT. 0) THEN
            !write(6,*) 'Bad kode:',kode

           RETURN
      	ENDIF
      	DO I=1,KS
           TMP=0.0

           DO J=1,N-1
              TMP=TMP+Q1(I,1)**J*X(J)
           ENDDO

           TMP=TMP+X(N)
           P(I)=SNGL(TMP)
      	ENDDO

      	END      
                                                         
cc=========================================================================

C **********************************************************************
C *  CL1.F
C=**********************************************************************
C=* From: SPIDER - MODULAR IMAGE PROCESSING SYSTEM                     *
C=* Copyright (C)2002, Z. Huang & P. A. Penczek                        *
C=*                                                                    *
C=* University of Texas - Houston Medical School                       *
C=*                                                                    *
C=* Email:  pawel.a.penczek@@uth.tmc.edu                                *
C=*                                                                    *
C=* This program is free software; you can redistribute it and/or      *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* This program is distributed in the hope that it will be useful,    *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
C=* General Public License for more details.                           *
C=*                                                                    *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program; if not, write to the                      *
C=* Free Software Foundation, Inc.,                                    *
C=* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.      *
C=*                                                                    *
C **********************************************************************

CC==Inequality&Equality Constrained Least Square Fitting Program

      SUBROUTINE CL1(K, L, M, N, KLMD, KLM2D, NKLMD, N2D,      
     * Q, KODE, TOLER, ITER, X, RES, ERROR, CU, IU, S)

C THIS SUBROUTINE USES A MODIFICATION OF THE SIMPLEX
C METHOD OF LINEAR PROGRAMMING TO CALCULATE AN L1 SOLUTION
C TO A K BY N SYSTEM OF LINEAR EQUATIONS
C             AX=B
C SUBJECT TO L LINEAR EQUALITY CONSTRAINTS
C             CX=D
C AND M LINEAR INEQUALITY CONSTRAINTS
C             EX.LE.F.
C DESCRIPTION OF PARAMETERS
C K      NUMBER OF ROWS OF THE MATRIX A (K.GE.1).
C L      NUMBER OF ROWS OF THE MATRIX C (L.GE.0).
C M      NUMBER OF ROWS OF THE MATRIX E (M.GE.0).
C N      NUMBER OF COLUMNS OF THE MATRICES A,C,E (N.GE.1).
C KLMD   SET TO AT LEAST K+L+M FOR ADJUSTABLE DIMENSIONS.
C KLM2D  SET TO AT LEAST K+L+M+2 FOR ADJUSTABLE DIMENSIONS.
C NKLMD  SET TO AT LEAST N+K+L+M FOR ADJUSTABLE DIMENSIONS.
C N2D    SET TO AT LEAST N+2 FOR ADJUSTABLE DIMENSIONS
C Q      TWO DIMENSIONAL REAL ARRAY WITH KLM2D ROWS AND
C        AT LEAST N2D COLUMNS.
C        ON ENTRY THE MATRICES A,C AND E, AND THE VECTORS
C        B,D AND F MUST BE STORED IN THE FIRST K+L+M ROWS
C        AND N+1 COLUMNS OF Q AS FOLLOWS
C             A B
C         Q = C D
C             E F
C        THESE VALUES ARE DESTROYED BY THE SUBROUTINE.
C KODE   A CODE USED ON ENTRY TO, AND EXIT
C        FROM, THE SUBROUTINE.
C        ON ENTRY, THIS SHOULD NORMALLY BE SET TO 0.
C        HOWEVER, IF CERTAIN NONNEGATIVITY CONSTRAINTS
C        ARE TO BE INCLUDED IMPLICITLY, RATHER THAN
C        EXPLICITLY IN THE CONSTRAINTS EX.LE.F, THEN KODE
C        SHOULD BE SET TO 1, AND THE NONNEGATIVITY
C        CONSTRAINTS INCLUDED IN THE ARRAYS X AND
C        RES (SEE BELOW).
C        ON EXIT, KODE HAS ONE OF THE
C        FOLLOWING VALUES
C             0- OPTIMAL SOLUTION FOUND,
C             1- NO FEASIBLE SOLUTION TO THE
C                CONSTRAINTS,
C             2- CALCULATIONS TERMINATED
C                PREMATURELY DUE TO ROUNDING ERRORS,
C             3- MAXIMUM NUMBER OF ITERATIONS REACHED.
C TOLER  A SMALL POSITIVE TOLERANCE. EMPIRICAL
C        EVIDENCE SUGGESTS TOLER = 10**(-D*2/3),
C        WHERE D REPRESENTS THE NUMBER OF DECIMAL
C        DIGITS OF ACCURACY AVAILABLE. ESSENTIALLY,
C        THE SUBROUTINE CANNOT DISTINGUISH BETWEEN ZERO
C        AND ANY QUANTITY WHOSE MAGNITUDE DOES NOT EXCEED
C        TOLER. IN PARTICULAR, IT WILL NOT PIVOT ON ANY
C        NUMBER WHOSE MAGNITUDE DOES NOT EXCEED TOLER.
C ITER   ON ENTRY ITER MUST CONTAIN AN UPPER BOUND ON
C        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
C        A SUGGESTED VALUE IS 10*(K+L+M). ON EXIT ITER
C        GIVES THE NUMBER OF SIMPLEX ITERATIONS.
C X      ONE DIMENSIONAL REAL ARRAY OF SIZE AT LEAST N2D.
C        ON EXIT THIS ARRAY CONTAINS A
C        SOLUTION TO THE L1 PROBLEM. IF KODE=1
C        ON ENTRY, THIS ARRAY IS ALSO USED TO INCLUDE
C        SIMPLE NONNEGATIVITY CONSTRAINTS ON THE
C        VARIABLES. THE VALUES -1, 0, OR 1
C        FOR X(J) INDICATE THAT THE J-TH VARIABLE
C        IS RESTRICTED TO BE .LE.0, UNRESTRICTED,
C        OR .GE.0 RESPECTIVELY.
C RES    ONE DIMENSIONAL REAL ARRAY OF SIZE AT LEAST KLMD.
C        ON EXIT THIS CONTAINS THE RESIDUALS B-AX
C        IN THE FIRST K COMPONENTS, D-CX IN THE
C        NEXT L COMPONENTS (THESE WILL BE =0),AND
C        F-EX IN THE NEXT M COMPONENTS. IF KODE=1 ON
C        ENTRY, THIS ARRAY IS ALSO USED TO INCLUDE SIMPLE
C        NONNEGATIVITY CONSTRAINTS ON THE RESIDUALS
C        B-AX. THE VALUES -1, 0, OR 1 FOR RES(I)
C        INDICATE THAT THE I-TH RESIDUAL (1.LE.I.LE.K) IS
C        RESTRICTED TO BE .LE.0, UNRESTRICTED, OR .GE.0
C        RESPECTIVELY.
C ERROR  ON EXIT, THIS GIVES THE MINIMUM SUM OF
C        ABSOLUTE VALUES OF THE RESIDUALS.
C CU     A TWO DIMENSIONAL REAL ARRAY WITH TWO ROWS AND
C        AT LEAST NKLMD COLUMNS USED FOR WORKSPACE.
C IU     A TWO DIMENSIONAL INTEGER ARRAY WITH TWO ROWS AND
C        AT LEAST NKLMD COLUMNS USED FOR WORKSPACE.
C S      INTEGER ARRAY OF SIZE AT LEAST KLMD, USED FOR
C        WORKSPACE.
C IF YOUR FORTRAN COMPILER PERMITS A SINGLE COLUMN OF A TWO
C DIMENSIONAL ARRAY TO BE PASSED TO A ONE DIMENSIONAL ARRAY
C THROUGH A SUBROUTINE CALL, CONSIDERABLE SAVINGS IN
C EXECUTION TIME MAY BE ACHIEVED THROUGH THE USE OF THE
C FOLLOWING SUBROUTINE, WHICH OPERATES ON COLUMN VECTORS.
C     SUBROUTINE COL(V1, V2, XMLT, NOTROW, K)
C THIS SUBROUTINE ADDS TO THE VECTOR V1 A MULTIPLE OF THE
C VECTOR V2 (ELEMENTS 1 THROUGH K EXCLUDING NOTROW).
C     DIMENSION V1(K), V2(K)
C     KEND = NOTROW - 1
C     KSTART = NOTROW + 1
C     IF (KEND .LT. 1) GO TO 20
C     DO 10 I=1,KEND
C        V1(I) = V1(I) + XMLT*V2(I)
C  10 CONTINUE
C     IF(KSTART .GT. K) GO TO 40
C  20 DO 30 I=KSTART,K
C       V1(I) = V1(I) + XMLT*V2(I)
C  30 CONTINUE
C  40 RETURN
C     END
C SEE COMMENTS FOLLOWING STATEMENT LABELLED 440 FOR
C INSTRUCTIONS ON THE IMPLEMENTATION OF THIS MODIFICATION.
      DOUBLE PRECISION XSUM
C      DOUBLE PRECISION DBLE
C      REAL Q, X, Z, CU, SN, ZU, ZV, CUV, RES, XMAX, XMIN,
CC     * ERROR, PIVOT, TOLER, TPIVOT
      DOUBLE PRECISION Q,X,RES,CU,S,Z, SN, ZU, ZV, CUV, XMAX, XMIN,
     * PIVOT, TPIVOT,TOLER
C      REAL ABS
C      INTEGER I, J, K, L, M, N, S, IA, II, IN, IU, JS, KK,
C     * NK, N1, N2, JMN, JPN, KLM, NKL, NK1, N2D, IIMN,
C     * IOUT, ITER, KLMD, KLM1, KLM2, KODE, NKLM, NKL1,
C     * KLM2D, MAXIT, NKLMD, IPHASE, KFORCE, IINEG
C      INTEGER IABS
      DIMENSION Q(KLM2D,N2D), X(N2D), RES(KLMD),
     * CU(2,NKLMD), IU(2,NKLMD), S(KLMD)
C INITIALIZATION.
      MAXIT = 500
      N1 = N + 1
      N2 = N + 2
      NK = N + K
      NK1 = NK + 1
      NKL = NK + L
      NKL1 = NKL + 1
      KLM = K + L + M
      KLM1 = KLM + 1
      KLM2 = KLM + 2
      NKLM = N + KLM
      KFORCE = 1
      ITER = 0
      JS = 1
      IA = 0
C SET UP LABELS IN Q.
      DO 10 J=1,N
         Q(KLM2,J) = J
   10 CONTINUE
      DO 30 I=1,KLM
         Q(I,N2) = N + I
         IF (Q(I,N1).GE.0.) GO TO 30
         DO 20 J=1,N2
            Q(I,J) = -Q(I,J)
   20    CONTINUE
   30 CONTINUE
C SET UP PHASE 1 COSTS.
      IPHASE = 2
      DO 40 J=1,NKLM
         CU(1,J) = 0.
         CU(2,J) = 0.
         IU(1,J) = 0
         IU(2,J) = 0
   40 CONTINUE
      IF (L.EQ.0) GO TO 60
      DO 50 J=NK1,NKL
         CU(1,J) = 1.
         CU(2,J) = 1.
         IU(1,J) = 1
         IU(2,J) = 1
   50 CONTINUE
      IPHASE = 1
   60 IF (M.EQ.0) GO TO 80
      DO 70 J=NKL1,NKLM
         CU(2,J) = 1.
         IU(2,J) = 1
         JMN = J - N
         IF (Q(JMN,N2).LT.0.) IPHASE = 1
   70 CONTINUE
   80 IF (KODE.EQ.0) GO TO 150
      DO 110 J=1,N
         IF (X(J)) 90, 110, 100
   90    CU(1,J) = 1.
         IU(1,J) = 1
         GO TO 110
  100    CU(2,J) = 1.
         IU(2,J) = 1
  110 CONTINUE
      DO 140 J=1,K
         JPN = J + N
         IF (RES(J)) 120, 140, 130
  120    CU(1,JPN) = 1.
         IU(1,JPN) = 1
         IF (Q(J,N2).GT.0.0) IPHASE = 1
         GO TO 140
  130    CU(2,JPN) = 1.
         IU(2,JPN) = 1
         IF (Q(J,N2).LT.0.0) IPHASE = 1
  140 CONTINUE
  150 IF (IPHASE.EQ.2) GO TO 500
C COMPUTE THE MARGINAL COSTS.
  160 DO 200 J=JS,N1
         XSUM = 0.D0
         DO 190 I=1,KLM
            II = Q(I,N2)
            IF (II.LT.0) GO TO 170
            Z = CU(1,II)
            GO TO 180
  170       IINEG = -II
            Z = CU(2,IINEG)
  180       XSUM = XSUM + DBLE(Q(I,J))*DBLE(Z)
C  180       XSUM = XSUM + Q(I,J)*Z
  190    CONTINUE
         Q(KLM1,J) = XSUM
  200 CONTINUE
      DO 230 J=JS,N
         II = Q(KLM2,J)
         IF (II.LT.0) GO TO 210
         Z = CU(1,II)
         GO TO 220
  210    IINEG = -II
         Z = CU(2,IINEG)
  220    Q(KLM1,J) = Q(KLM1,J) - Z
  230 CONTINUE
C DETERMINE THE VECTOR TO ENTER THE BASIS.
  240 XMAX = 0.
      IF (JS.GT.N) GO TO 490
      DO 280 J=JS,N
         ZU = Q(KLM1,J)
         II = Q(KLM2,J)
         IF (II.GT.0) GO TO 250
         II = -II
         ZV = ZU
         ZU = -ZU - CU(1,II) - CU(2,II)
         GO TO 260
  250    ZV = -ZU - CU(1,II) - CU(2,II)
  260    IF (KFORCE.EQ.1 .AND. II.GT.N) GO TO 280
         IF (IU(1,II).EQ.1) GO TO 270
         IF (ZU.LE.XMAX) GO TO 270
         XMAX = ZU
         IN = J
  270    IF (IU(2,II).EQ.1) GO TO 280
         IF (ZV.LE.XMAX) GO TO 280
         XMAX = ZV
         IN = J
  280 CONTINUE
      IF (XMAX.LE.TOLER) GO TO 490
      IF (Q(KLM1,IN).EQ.XMAX) GO TO 300
      DO 290 I=1,KLM2
         Q(I,IN) = -Q(I,IN)
  290 CONTINUE
      Q(KLM1,IN) = XMAX
C DETERMINE THE VECTOR TO LEAVE THE BASIS.
  300 IF (IPHASE.EQ.1 .OR. IA.EQ.0) GO TO 330
      XMAX = 0.
      DO 310 I=1,IA
         Z = ABS(Q(I,IN))
         IF (Z.LE.XMAX) GO TO 310
         XMAX = Z
         IOUT = I
  310 CONTINUE
      IF (XMAX.LE.TOLER) GO TO 330
      DO 320 J=1,N2
         Z = Q(IA,J)
         Q(IA,J) = Q(IOUT,J)
         Q(IOUT,J) = Z
  320 CONTINUE
      IOUT = IA
      IA = IA - 1
      PIVOT = Q(IOUT,IN)
      GO TO 420
  330 KK = 0
      DO 340 I=1,KLM
         Z = Q(I,IN)
         IF (Z.LE.TOLER) GO TO 340
         KK = KK + 1
         RES(KK) = Q(I,N1)/Z
         S(KK) = I
  340 CONTINUE
  350 IF (KK.GT.0) GO TO 360
      KODE = 2
      GO TO 590
  360 XMIN = RES(1)
      IOUT = S(1)
      J = 1
      IF (KK.EQ.1) GO TO 380
      DO 370 I=2,KK
         IF (RES(I).GE.XMIN) GO TO 370
         J = I
         XMIN = RES(I)
         IOUT = S(I)
  370 CONTINUE
      RES(J) = RES(KK)
      S(J) = S(KK)
  380 KK = KK - 1
      PIVOT = Q(IOUT,IN)
      II = Q(IOUT,N2)
      IF (IPHASE.EQ.1) GO TO 400
      IF (II.LT.0) GO TO 390
      IF (IU(2,II).EQ.1) GO TO 420
      GO TO 400
  390 IINEG = -II
      IF (IU(1,IINEG).EQ.1) GO TO 420
c 400 II = IABS(II)
  400 II =  ABS(II) 
      CUV = CU(1,II) + CU(2,II)
      IF (Q(KLM1,IN)-PIVOT*CUV.LE.TOLER) GO TO 420
C BYPASS INTERMEDIATE VERTICES.
      DO 410 J=JS,N1
         Z = Q(IOUT,J)
         Q(KLM1,J) = Q(KLM1,J) - Z*CUV
         Q(IOUT,J) = -Z
  410 CONTINUE
      Q(IOUT,N2) = -Q(IOUT,N2)
      GO TO 350
C GAUSS-JORDAN ELIMINATION.
  420 IF (ITER.LT.MAXIT) GO TO 430
      KODE = 3
      GO TO 590
  430 ITER = ITER + 1
      DO 440 J=JS,N1
         IF (J.NE.IN) Q(IOUT,J) = Q(IOUT,J)/PIVOT
  440 CONTINUE
C IF PERMITTED, USE SUBROUTINE COL OF THE DESCRIPTION
C SECTION AND REPLACE THE FOLLOWING SEVEN STATEMENTS DOWN
C TO AND INCLUDING STATEMENT NUMBER 460 BY..
C     DO 460 J=JS,N1
C        IF(J .EQ. IN) GO TO 460
C        Z = -Q(IOUT,J)
C        CALL COL(Q(1,J), Q(1,IN), Z, IOUT, KLM1)
C 460 CONTINUE
      DO 460 J=JS,N1
         IF (J.EQ.IN) GO TO 460
         Z = -Q(IOUT,J)
         DO 450 I=1,KLM1
            IF (I.NE.IOUT) Q(I,J) = Q(I,J) + Z*Q(I,IN)
  450    CONTINUE
  460 CONTINUE
      TPIVOT = -PIVOT
      DO 470 I=1,KLM1
         IF (I.NE.IOUT) Q(I,IN) = Q(I,IN)/TPIVOT
  470 CONTINUE
      Q(IOUT,IN) = 1./PIVOT
      Z = Q(IOUT,N2)
      Q(IOUT,N2) = Q(KLM2,IN)
      Q(KLM2,IN) = Z
      II = ABS(Z)
      IF (IU(1,II).EQ.0 .OR. IU(2,II).EQ.0) GO TO 240
      DO 480 I=1,KLM2
         Z = Q(I,IN)
         Q(I,IN) = Q(I,JS)
         Q(I,JS) = Z
  480 CONTINUE
      JS = JS + 1
      GO TO 240
C TEST FOR OPTIMALITY.
  490 IF (KFORCE.EQ.0) GO TO 580
      IF (IPHASE.EQ.1 .AND. Q(KLM1,N1).LE.TOLER) GO TO 500
      KFORCE = 0
      GO TO 240
C SET UP PHASE 2 COSTS.
  500 IPHASE = 2
      DO 510 J=1,NKLM
         CU(1,J) = 0.
         CU(2,J) = 0.
  510 CONTINUE
      DO 520 J=N1,NK
         CU(1,J) = 1.
         CU(2,J) = 1.
  520 CONTINUE
      DO 560 I=1,KLM
         II = Q(I,N2)
         IF (II.GT.0) GO TO 530
         II = -II
         IF (IU(2,II).EQ.0) GO TO 560
         CU(2,II) = 0.
         GO TO 540
  530    IF (IU(1,II).EQ.0) GO TO 560
         CU(1,II) = 0.
  540    IA = IA + 1
         DO 550 J=1,N2
            Z = Q(IA,J)
            Q(IA,J) = Q(I,J)
            Q(I,J) = Z
  550    CONTINUE
  560 CONTINUE
      GO TO 160
  570 IF (Q(KLM1,N1).LE.TOLER) GO TO 500
      KODE = 1
      GO TO 590
  580 IF (IPHASE.EQ.1) GO TO 570
C PREPARE OUTPUT.
      KODE = 0
  590 XSUM = 0.D0
      DO 600 J=1,N
         X(J) = 0.
  600 CONTINUE
      DO 610 I=1,KLM
         RES(I) = 0.
  610 CONTINUE
      DO 640 I=1,KLM
         II = Q(I,N2)
         SN = 1.
         IF (II.GT.0) GO TO 620
         II = -II
         SN = -1.
  620    IF (II.GT.N) GO TO 630
         X(II) = SN*Q(I,N1)
         GO TO 640
  630    IIMN = II - N
         RES(IIMN) = SN*Q(I,N1)
         IF (II.GE.N1 .AND. II.LE.NK) XSUM = XSUM +
     *    DBLE(Q(I,N1))
C     *    Q(I,N1)
  640 CONTINUE
      ERROR = XSUM
      RETURN
      END
@


1.29
log
@CHARACTER, PARAMETER :: MODE    = ' ' was undefined
@
text
@d7 1
a7 1
C                                                            
@


1.28
log
@DEF. DOC FILE COMMENTS CHANGED
@
text
@d34 1
a34 2
C NOTE:    LACKS PROPER ERROR RECOVERY al 9/2010 BUGGY!!
C          FULL OF BUGS. DEFOCUS IS OK FOR NON-ASTIGMATIC IMAGES
d72 7
a78 6
	INTEGER, PARAMETER :: LUNM    = 20
	INTEGER, PARAMETER :: LUNPOW  = 21
	INTEGER, PARAMETER :: LUNDOCM = 81
	INTEGER, PARAMETER :: LUNDOCN = 82
	INTEGER, PARAMETER :: LUNDOCD = 83
	INTEGER, PARAMETER :: LUNXM   = 0
@


1.27
log
@reg adef was 0 but some procs need it so is overdef now[D[D[D[D[D[D[D[D[D[D[D[D\
@
text
@d6 1
d58 4
a61 1
        LOGICAL                           :: NEWFILE
d292 9
a300 2
        CALL OPENDOC(DOCNAM,.TRUE.,NLET,LUNDOCN,LUNDOCNO,.TRUE.,
     &           'DEFOCUS NOISE DOC',.FALSE.,.FALSE.,.TRUE.,
d341 10
a350 3
        LUNDOCDO = LUNDOCD
        CALL OPENDOC(DOCNAM,.TRUE.,NLET,LUNDOCD,LUNDOCDO,.TRUE.,
     &             'OUTPUT DEFOCUS DOCUMENT',.FALSE.,.TRUE.,.TRUE.,
d354 1
a354 2
C                  123456789 123456789 123456789 123456789 123456789 123456789 
        COMMENT = 'CONTENTS:   MICROGRAPH DEFOCUS VALUES' 
d356 8
a363 5
        CALL LUNDOCPUTCOM(LUNDOCDO,COMMENT(1:37),IRTFLG)
C          123456789 123456789 123456789 123456789 123456789 123456789 
C                  123456789 123456789 123456789 123456789 123456789 123456789012
        COMMENT = '          Micr.  Defocus  Cutoff'
        CALL LUNDOCPUTCOM(LUNDOCDO,COMMENT(1:35),IRTFLG)
d367 1
a367 1
     &     'KEY/IMAGE NUMBER FOR DOCUMENT FILE',IRTFLG)
d374 1
a374 1
        CALL LUNDOCWRTDATF(LUNDOCDO,KEY,DLIST,3,FORMOUT,IRTFLG)
d386 1
a386 1
	CALL REG_SET_NSEL(1,2, AV_DEFO, XX_CC,0,0,0,IRTFLG)
@


1.26
log
@comment
@
text
@d499 1
a499 1
	AST_DEF = 0.0
d505 1
a505 1
C          ESTIMATION OF ASTIGMATISM; STEP IS 18 DEGREE  BUGGY!!!!!!
@


1.25
log
@no more astig calc
@
text
@d34 2
a35 1
C          MAY GIVES DIFFERENT RESULT WHEN COMPILED WITH -g -O0 
d37 1
a37 2
C       TFED()
C       CTFED()
@


1.24
log
@removed last astig. output traces
@
text
@d67 1
a67 1
	PARAMETER (QUADPI = 3.141592653589793238462)
d162 1
a162 1
     &      'PIXEL SIZE[A] & SPHERICAL ABERRATION CS[MM]',IRTFLG)
d171 1
a171 1
      	CALL RDPRM1S(KEV,NOT_USED,'ELECTON VOLTAGE[KEV]',IRTFLG)
d177 1
a177 1
     &           'AMPLITUDE CONTRAST RATIO[0-1]',IRTFLG)
a316 1
#ifdef NEVER
a317 7
C          ESTIMATION OF ASTIGMATISM; STEP IS 18 DEGREES
	   X_AV_DEFO = AV_DEFO
  	   IDGREE    = NDGREE
	   CALL AST_CALC(BUFPOW,NXT,NXT,NMB,NT,PS,CS,
     &	        LAMBDA,CONTRAST,X_AV_DEFO,IDGREE,
     &          AST_AGL,TMP_AMP,TMP_SUM)
#endif
a326 10
#ifdef NEVER
        WRITE(NOUT,'(A,F8.1, A,F8.1)') 
     &             '  OVERALL DEFOCUS: ',             AV_DEFO,
     &             '  ASTIGMATISM CORRECTED DEFOCUS:',TMP_SUM

        WRITE(NOUT,'(A,F8.1, A,F6.1)') 
     &             '  ASTIGMATISM:     ',             TMP_AMP, 
     &             '  ASTIGMATISM ANGLE:',            AST_AGL 
#endif

a340 9
#ifdef NEVER
        COMMENT = 
     &   '          Micr.  Defocus Astig.Ang Astig.Mag'//
     &   '  Astig.Corr.Def  Cutoff'
        CALL LUNDOCPUTCOM(LUNDOCDO,COMMENT(1:72),IRTFLG)
        FORMOUT  =
     &     '(I7,1X,I2,1X,F7.0,1X,F8.1,1X,F6.1,2X,F8.1,4X,F10.1,5X,F6.3)'
C           123456789 123456789 123456789 123456789 123456789 123456789012
#endif
a350 1

d396 2
d408 1
d434 1
a434 1
     &      'PIXEL SIZE[A] & SPHERICAL ABERRATION CS[MM]')
d440 1
a440 1
      	CALL RDPRM(LAMBDA,NOT_USED,'WAVELENGTH LAMBDA[A]')
d442 5
a446 2
      	CALL RDPRM(CONTRAST,NOT_USED,
     &           'AMPLITUDE CONTRAST RATIO[0-1]')
d497 9
a505 9
C       Estimate defocus of difficult cases
	IF ( XX_CC .EQ. 9999 .OR. AV_DEFO .LE. STRT_SRCH) THEN
	    XX_CC   = 9999.
	    AST_AGL = 0.0
	    TMP_AMP = 0.0
	    TMP_SUM = 0.0
	ELSE	

C          ESTIMATION OF ASTIGMATISM;STEP IS 18 DEGREE
d509 2
a510 1
     &	     LAMBDA,CONTRAST,X_AV_DEFO,IDGREE,AST_AGL,TMP_AMP,TMP_SUM)
d514 1
a514 1
        IF (XX_CC .GT. 1) THEN
d519 2
a520 2
	CALL REG_SET_NSEL(1,5,AST_AGL,TMP_AMP,TMP_SUM,AV_DEFO,
     &                    XX_CC,IRTFLG)
@


1.23
log
@various attempts to fix seg. violatins failed, gave up on astigmatism calc.
@
text
@d316 1
a316 1
           WRITE(NOUT,*) 'ASTIFMATISM CALCULATION NO LONGER DONE'
d344 1
d394 1
a394 2
	CALL REG_SET_NSEL(1,5, AST_AGL,TMP_AMP,TMP_SUM,AV_DEFO,
     &                         XX_CC,IRTFLG)
@


1.22
log
@CS_zero
@
text
@d33 1
a33 1
C NOTE:    LACKS PROPER ERROR RECOVERY al 9/2010
a40 1

d255 2
d276 1
d306 2
d309 1
a309 1
C           Estimate defocus of difficult cases
d316 3
d325 2
d335 1
d343 2
a344 1

d358 1
d363 7
d375 2
a376 5

C       
        FORMOUT  =
     &     '(I7,1X,I2,1X,F7.0,1X,F8.1,1X,F6.1,2X,F8.1,4X,F10.1,5X,F6.3)'
C           123456789 123456789 123456789 123456789 123456789 123456789012
d380 2
a381 5
        DLIST(3) = AST_AGL
        DLIST(4) = TMP_AMP 
        DLIST(5) = TMP_SUM   ! AST. CORRECTED DEFOCUS
        DLIST(6) = XX_CC 
        CALL LUNDOCWRTDATF(LUNDOCDO,KEY,DLIST,6,FORMOUT,IRTFLG)
d527 1
a527 1
C       ESTIMATION OF ASTIGMATISM;STEP IS 18 DEGREE
d637 4
a640 2
CC==ROTATIONAL AVERAGE FROM BETA0 TO BETA1!
        DIMENSION BUF(NSAM,NROW),SEC(IR),SNO(IR)
d643 4
a646 3
CC==BEGIN
	XBETA0=BETA0*DGR_TO_RAD
	XBETA1=BETA1*DGR_TO_RAD+XBETA0
d651 4
a654 2
            KJ=J-NROW/2-1
            IF(IABS(KJ).LE.IR-1)  THEN
d656 8
a663 6
                  KI=I-NSAM/2-1
                  R=SQRT(FLOAT(KJ*KJ)+FLOAT(KI*KI))+1.0
                  L=R
                  IF(L.LE.IR-1) THEN
			ANGLE=ATAN2(REAL(KI),REAL(KJ))
			IF(ANGLE.LT.0.0) ANGLE=ANGLE+2.*QUADPI
d665 5
a669 5
                     	    XD=R-L
                     	    SEC(L)=SEC(L)+BUF(I,J)*(1.0-XD)
                     	    SEC(L+1)=SEC(L+1)+BUF(I,J)*XD
                     	    SNO(L)=SNO(L)+1.0-XD
                     	    SNO(L+1)=SNO(L+1)+XD
d675 3
a677 2
         DO    I=1,IR
             SEC(I)=SEC(I)/AMAX1(1.0,SNO(I))
d679 1
d780 1
a780 1
	SUBROUTINE PARTI9 (KLMD,NKLMD,KLM2D,N2D,Q2,
d851 2
a852 2
	CALL PARTI9 (KLMD,NKLMD,KLM2D,N2D,Q2,
     &  K,N2,N,PLOT,IFIT1,IFIT2,KP)
d906 1
a906 1
	CALL PARTI9 (KLMD,NKLMD,KLM2D,N2D,Q2,
d1272 1
d1275 1
d1281 1
d1306 1
d1319 2
a1320 1
     &         Q,X,RES,CU,S,IU,KLMD,NKLMD,KP)		
d1497 3
d1505 2
d1508 1
a1508 1
        NUMBER = 0  ! INITIALZE FOR DEFAULT RETURN al
d1516 4
a1519 2
CC=======ICUT_LOW_FRQ
CC==N_ZERO IS MAXIMUM NZEROS OF CTF CONTROL POINTS FOR ASTIGMATISM ESTIMATION
d1522 3
d1536 1
a1536 1
	    IF (TMP(I,2) .EQ. 0.0) IPW_ZERO = I 		
d1539 5
a1543 1
CC==ESTIMATE MINIMUM DEFOCUS BASED ON GIVEN VOLTAGE, CS, AND PIXEL SIZE
d1550 1
a1550 1
CC==
d1557 3
a1559 1
CC==         	
d1573 1
a1573 1
CC==
d1579 1
a1579 1
           IRTFLG = 1  ! INITIALZE FOR ERROR RETURN al
d1589 1
a1589 1
C==LOCATE THE HIGHEST PEAK IN THE POWER SPECTRUM
d1592 2
a1593 4
	    IFIT11=ICUTL
	
CC==
	    IFIT2=NUMBER
d1595 1
a1595 1
CC==LOCATE THE FIRST ZERO OF CTF AS CUT-OFF POINT: ICUTB
d1597 11
a1607 6
CC==TO POWER SPECTRUM HAVING WEAK CTF EFFECT IN MEDIUM AND HIGH FREQUENCY
CC==IPT_HALF IS TO AVOID INCLUDING TOO MUCH USELESS INFORMATION WHEN PIXEL SIZE IS SAMLL OR
CC==THE MICRPGRAPHS HAVE TOO POOR RESOLUTION
	    IF (ICUTB.GT.IPT_HIGH) THEN
		IFIT2=IPT_HIGH			
		CALL XFITLINE1(NUMBER,N2,PLOT,IFIT11,IFIT2,ICUTB)
d1611 2
a1612 2
		IFIT2=IPT_HALF
		CALL XFITLINE1(NUMBER,N2,PLOT,IFIT11,IFIT2,ICUTB)
d1614 4
a1617 3
CC==LOCATE THE HIGHEST PEAK OF CTF AS FIRST CONTROL POINT(EQUALITY CONSTRAINT POINT)
	    IFIT1=ICUTB
	    IFIT2=NUMBER
d1619 4
a1622 3
CC=LOCATE THE SECOND CTF ZERO.		
	    IFIT1=ICUTA
	    IFIT2=NUMBER
d1625 2
a1626 2
	    IFIT1=ICUTC
	    IFIT2=NUMBER
d1628 3
a1630 3
CC==
	    IFIT1=ICUTD
	    IFIT2=NUMBER
d1632 4
a1635 4
CC==
	    ICUT1=ICUTA
	    ICUT2=NUMBER
	    N=III	
d1637 7
a1643 4
CC==FIT BACKGROUND FROM ICUTB TO ICUT2	
	    ICUT1=ICUTB
	    ICNSTRNT=ICUTB
	    IBACK=1
d1645 4
a1648 3
CC==CC==FIT BACKGROUND FROM IBACK TO ICUTB USING SPECIFIC POLYNOMIAL DEGREE 4
	    IPT_START=1
	    IPT_CUT=ICUTB
d1650 1
a1650 1
CC=====
d1652 1
a1652 1
CC=====
d1656 7
a1662 4
	    N_SELECT(III-1)=NZERO
	    TMP_FIRST(III-1)=IFIRST
	    TMP_SECND(III-1)=ISECND
	    X_DEFO(III-1)=DEFOX	
d1664 4
d1669 13
d1683 30
a1712 4
		IF(X_DEFO(II).LT.DEFO_MIN) THEN
		    X_DEFO(II)=DEFO_MIN
		    N_SELECT(II)=1
		ENDIF
d1714 1
a1714 9
		IF(X_DEFO(II).GT.DEFO_MAX) THEN
			IF(II.EQ.1) THEN
			    X_DEFO(II)=DEFO_MIN
			    N_SELECT(II)=1
			ELSE
			    X_DEFO(II)=X_DEFO(II-1)
			    N_SELECT(II)=N_SELECT(II-1)
			ENDIF
		ENDIF
d1716 9
a1724 6
CCC=WE SELECT POLYNOMIAL DEGREE ACCORDING TO CTF NZEROS!
	IF (X_DEFO(1).GT.X_DEFO(2)) THEN
	    TMP_FIRST(2)=TMP_FIRST(1)
	    TMP_SECND(2)=TMP_SECND(1)
	    N_SELECT(2)=N_SELECT(1)	
	    X_DEFO(2)=X_DEFO(1)
d1727 5
a1731 5
	IF (X_DEFO(2).GT.X_DEFO(3)) THEN
	    TMP_FIRST(3)=TMP_FIRST(2)
	    TMP_SECND(3)=TMP_SECND(2)
	    N_SELECT(3)=N_SELECT(2)	
	    X_DEFO(3)=X_DEFO(2)
d1734 6
a1739 6
	IF (X_DEFO(3).GT.X_DEFO(4)) THEN
	    AV_DEFO=X_DEFO(3)
	    ICUT_LOW_FRQ=TMP_FIRST(3)+IPW_ZERO
	    ICN_SND=TMP_SECND(3)+IPW_ZERO
	    N_TMP=N_SELECT(3)
	    NDGREE=N_SELECT(3)-1
d1741 5
a1745 5
	    AV_DEFO=X_DEFO(4)
	    ICUT_LOW_FRQ=TMP_FIRST(4)+IPW_ZERO
	    ICN_SND=TMP_SECND(4)+IPW_ZERO
	    N_TMP=N_SELECT(4)
	    NDGREE=N_SELECT(4)-1
d1748 4
a1751 3
CC==JUDGING WHETHER IT IS TRUE NEAR DEFOCUS:
	X_FST_ITVL=REAL(ICUTA-ICUTB)/REAL(NUMBER)
	IF (N_TMP.LE.2.AND.X_FST_ITVL.GT..2) THEN
d1753 4
a1759 1
            IRTFLG = 0 !al
d1762 1
a1762 1
	ELSEIF (N_TMP.LE.2.AND.X_FST_ITVL.LT..2) THEN
d1764 1
d1770 1
a1770 1
		 CALL DEFOCUS_GUESSING4(TMP,NMB,NT,NUMBER,N2,TMP_OUT,
a1773 1
            IRTFLG = 0 !al
d1777 3
a1779 3
CC==WE DO NOT WISH TOO HIGH POLYNOMIAL DEGREE !
	IF (NDGREE.GE.6) THEN
		NDGREE=6
d1782 9
a1790 3
CC==RESET PLOT AND DO DEFOCUS REFINEMENT
	PLOT(:,1)=TMP(IPW_ZERO+1:NMB,1)-1.0
	PLOT(:,3)=ALOG(TMP(IPW_ZERO+1:NMB,2))
a1791 1
CC==DEFOCUS REFINEMENT
d1797 2
a1798 1
        IRTFLG = 0  !al
d1852 1
a1852 1
C TMP2 is automatic array
d1865 2
a1866 2
	    XXX=PLOT(KKK,1)/2./PS/REAL(K)
	    XXXXX=EXP(PLOT(KKK,4))-EXP(PLOT(KKK,2))
d1868 4
a1871 4
	    IF(PLOT(KKK,2).NE.0.0) THEN
		PLOT(KKK,2)=EXP(PLOT(KKK,2))
		PLOT(KKK,3)=EXP(PLOT(KKK,3))
		PLOT(KKK,4)=EXP(PLOT(KKK,4))
d1873 3
a1875 3
		PLOT(KKK,2)=0.0
		PLOT(KKK,3)=0.0
		PLOT(KKK,4)=0.0
d1879 3
a1881 3
        PLOT(1:ICUT2,3)=PLOT(1:ICUT2,3)-PLOT(1:ICUT2,2)
        PLOT(1:ICUT2,4)=PLOT(1:ICUT2,4)-PLOT(1:ICUT2,2)
	TMP2(1:ICUT2)=PLOT(1:ICUT2,4)
d1883 6
a1888 5
	ISWI=1
      	DZMAX=GETDEFOCUS(PLOT(1,3),PLOT(1,1),K,PS,CS,LAMBDA,
     &		CONTRAST,XSCORE,PLOT(1,4),ICUT1,ICUT2,ISWI)
CCCC=======OUTPUT RESULT======================================
       	DEFOCUS=DZMAX
d1891 1
a1891 1
     & 	LAMBDA, DEFOCUS, CONTRAST,ICUT1,ICUT2,NZERO,IFIRST,ISECND)
d1894 1
a1894 1
     &                LAMBDA, DEFOCUS, CONTRAST)
d2166 2
a2167 2
	N=5
	N4=4
d2170 1
a2170 1
            CALL ERRT(46,'TFED',NE)
d2174 6
d2181 8
a2188 3
     & 	LAMBDA, DEFOCUS, CONTRAST,NZERO,N4,FOUR_ZERO)
	IF(NZERO.GE.5) THEN
	    N3=N4-1
d2192 10
a2201 1
	ALLOCATE(NCON(N3),STAT=IRTFLG)
d2203 1
a2203 1
            CALL ERRT(46,'TFED',NE)
d2239 6
d2246 27
a2272 14
       	AA = -0.5*QUADPI*CS*LAMBDA**3
       	BB = QUADPI*LAMBDA
       	BB=BB*DEFOCUS
       	CC = -ATAN(CONTRAST/(1.0-CONTRAST))
	FRQ1=0.0
	FRQ2=REAL(NUMBER+N0)/2.0/PS/REAL(NMB)
       	TMPN1=AA*FRQ1**4+BB*FRQ1**2+CC
       	TMPN1=TMPN1/QUADPI
       	N1=INT(TMPN1)
	TMPN2=AA*FRQ2**4+BB*FRQ2**2+CC
       	TMPN2=TMPN2/QUADPI
       	N2=INT(TMPN2)
	N=N2-N1+1
	TMP1=4.*AA
d2274 5
a2278 5
	    TMP2=CC-REAL(II-1)*QUADPI
	    TMP2=SQRT(BB**2-TMP1*TMP2)
	    TMP2=TMP2-BB
	    TMP2=SQRT(TMP2/2.0/AA)
	    NFRQ=INT(TMP2*2.0*PS*NMB)
d2280 2
a2281 2
	    IF(II.LE.4) THEN
		FOUR_ZERO(II)=NFRQ
d2286 2
a2287 2
	IF(N.LT.4) THEN
	    NN=4-N
d2289 2
a2290 2
		NNN=4-II+1
		FOUR_ZERO(NNN)=0
d2293 1
a2294 1
	NZERO=N
d2645 1
d2647 1
a2647 1
	REAL PLOT(K,N2)
d2668 1
a2668 1
            CALL ERRT(46,'TFED',NE)
d2681 1
a2681 1
	IPT2=NCON(1)
d2683 1
a2683 1
     &  K,N2,PLOT,N,IPT1,IPT2,KP)
d2702 2
a2703 2
	ISTART=IPT1
	ISTOP=IPT2 
d2709 5
d2715 1
d2717 4
a2720 3
	TT1_Q2(KS+1,1:N-1)=Q2(ISTOP,1:N-1)
	TT1_Q2(KS+1,N)=1.0
	TT1_Q2(KS+1,N+1)=PLOT1(ISTOP,4)
d2924 2
a2925 2
	CALL PARTI9 (KLMD,NKLMD,KLM2D,N2D,Q2,
     &  K,N2,N,PLOT,IFIT1,IFIT2,KP)
d3224 3
d3238 5
d3246 1
a3246 1
	IF(IPT1.EQ.0) RETURN
d3265 1
a3265 1
     & 	LAMBDA, AV_DEFO, CONTRAST,TMP_PLOT,XX_CC)
d3521 2
a3522 2
	CALL PARTI9 (KLMD,NKLMD,KLM2D,N2D,Q2,
     &  K,N2,N,PLOT,IFIT1,IFIT2,KP)
a3544 1
	ICUTD=0
d3546 9
d3556 4
d3742 2
a3743 2
	XSTART=0.0
	XSTEP=180.0
d4145 4
a4148 1
	REAL, DIMENSION(:), ALLOCATABLE :: XDEFO
d4150 1
a4150 3
	BETA=18.
	X_LOOP=180./BETA
1122	NNLOOP=INT(X_LOOP)
d4152 2
a4153 2
	DEFO_CUT1=.5*AV_DEFO
	DEFO_CUT2=2.0*AV_DEFO
d4157 1
a4157 1
            CALL ERRT(46,'TFED',NNLOOP)
d4163 1
a4163 1
            CALL ERRT(46,'TFED',NMB*NT)
d4170 2
a4171 2
	    BETA0      = TMP1*BETA
	    BETA1      = TMP2*BETA
d4174 2
d4180 3
a4182 1
CC==IN CASE OF VERY STRONG ASTIGMATIMS;ADJUSTING POLYNOMIAL DEGREE
d4184 4
a4187 2
		TMP1=DEFOCUS/FST_DEFO*REAL(NDGREE)
		NDGREE_AST=INT(TMP1)
d4189 1
a4189 1
	    	IF(NDGREE_AST.LT.2) NDGREE_AST=2			  
d4192 2
a4193 2
     & 		,PS,CS,LAMBDA,CONTRAST,DEFOCUS,IILOOP,
     &		ICUT_LOW_FRQ,ICN_SND,NDGREE_AST)
d4197 3
a4199 1
	    XDEFO(IILOOP)=DEFOCUS
d4201 1
a4201 1
CC==CHECK
d4204 5
a4208 5
		IF(XDEFO(I).LT.DEFO_CUT1) THEN
			XDEFO(I)=AV_DEFO
		ELSEIF(XDEFO(I).GT.DEFO_CUT2) THEN
			XDEFO(I)=AV_DEFO
		ENDIF
d4214 1
a4214 1
CC==FOR STRONG ATIGMATISM ONLY
d4289 1
d4324 2
a4325 1
     * KODE, TOLER, ITER, X, RES, ERROR, CU, IU, S)                         
d4327 3
a4329 1
	IF(KODE.GT.0) THEN
d4333 8
a4340 6
         	TMP=0.0
        DO J=1,N-1
          	TMP=TMP+Q1(I,1)**J*X(J)
        ENDDO
          	TMP=TMP+X(N)
          	P(I)=SNGL(TMP)
d4342 1
@


1.21
log
@formatting
@
text
@d162 2
a163 2
      	CALL RDPRM2S(PS,CSM,NOT_USED,
     &	    'PIXEL SIZE[A] & SPHERICAL ABBERATION CS[MM]',IRTFLG)
d165 1
d445 3
a447 2
      	CALL RDPRM2(PS,CS,NOT_USED,
     &	    'PIXEL SIZE[A] and SPHERICAL ABBERATION CS[MM]')
@


1.20
log
@added central disk mask
@
text
@d158 1
a158 1
     &          ' Tiles:',NPX,' x',NPY,'  Size:',NXT
d267 1
a267 1
        write(NOUT,'(A,F5.0)') ' Central PS mask radius:',CIRCI
@


1.19
log
@avg pow spectrum file added
@
text
@d5 1
d61 1
d186 4
a189 4
     &           BUFIN  (NXM, NXT),
     &           BUFWIN (NXT, NXT),
     &           BUFFFT (NXLD,NXT),
     &           BUFPOW (NXT, NXT),
d192 1
a192 1
           MWANT = NXM*NXT + 2*NXT*NXT + NXLD*NXT
d250 19
d374 1
a374 1
        CALL OPFILEC(0,.TRUE.,FILNAM,LUNPOW,'U',IFORM,NXT,NYT,1,
d377 1
a377 1
        CALL WRTVOL(LUNPOW,NXT,NYT,1,1,BUFPOW,IRTFLG)
@


1.18
log
@output doc file formatting
@
text
@d69 1
a69 1
	INTEGER, PARAMETER :: LUN1    = 21
a186 1
     &           BUFPWS (NXLD,NXT),
d350 8
d361 1
a361 1
9999    IF (ALLOCATED(POW2))    DEALLOCATE(POW2)
d363 5
a367 5
	IF (ALLOCATED(BUFIN))   DEALLOCATE(BUFIN)
	IF (ALLOCATED(BUFWIN))  DEALLOCATE(BUFWIN)
	IF (ALLOCATED(BUFFFT))  DEALLOCATE(BUFFFT)
	IF (ALLOCATED(BUFPWS))  DEALLOCATE(BUFPWS)
	IF (ALLOCATED(BUFPOW))  DEALLOCATE(BUFPOW)
d1316 1
a1316 1
     &  K,N2,PLOT,N,ICUT1,ICUT2,KP)
@


1.17
log
@ctf ed bugs fixed
@
text
@d47 2
a48 2
      	PARAMETER  (NLIST=5,NT=4)
      	REAL	                          :: DLIST(NLIST)   
d52 1
a52 1
      	REAL, DIMENSION(:,:), ALLOCATABLE :: POW2,TMP_OUT,BUFIN,BUFWIN
d55 2
a56 1
        CHARACTER(LEN=80)                 :: COMMENT
d68 6
a73 5
	INTEGER, PARAMETER :: LUNM   = 20
	INTEGER, PARAMETER :: LUN1   = 21
	INTEGER, PARAMETER :: NDOC   = 80
	INTEGER, PARAMETER :: LUNDOC = 81
	INTEGER, PARAMETER :: LUNXM  = 0
d84 1
a84 1
        CALL OPFILES(0,LUNM,LUNDOC,LUNXM,           
d155 1
a155 1
        WRITE(6,'(A,I4, A,I4, A,I4)') 
d183 1
a183 1
	ALLOCATE(TMP_OUT(NMB, NT),
d256 1
a256 1
     &		ICUT_LOW_FRQ,ICN_SND,NDGREE,TMP_OUT,NT,XX_CC,NUMBER)
d259 2
a260 4
        TMP_OUT(1:NUMBER,2:4) = EXP(TMP_OUT(1:NUMBER,2:4))
        TMP_OUT(1:NUMBER,1)   = TMP_OUT(1:NUMBER,1)/2.0/PS/NMB
        TMP_OUT(1:NUMBER,3)   = TMP_OUT(1:NUMBER,3)-TMP_OUT(1:NUMBER,2)
        TMP_OUT(1:NUMBER,4)   = TMP_OUT(1:NUMBER,4)-TMP_OUT(1:NUMBER,2)
d262 4
a265 1
        CALL OPENDOC(DOCNAM,.TRUE.,NLET,NDOC,LUNDOC,.TRUE.,
d272 1
a272 1
        CALL LUNDOCPUTCOM(LUNDOC,COMMENT(1:69),IRTFLG)
d275 5
a279 5
            DLIST(1) = TMP_OUT(KEY,1)
            DLIST(2) = TMP_OUT(KEY,2)
            DLIST(3) = TMP_OUT(KEY,3)
            DLIST(4) = TMP_OUT(KEY,4)
            CALL LUNDOCWRTDAT(LUNDOC,KEY,DLIST,4,IRTFLG)
d281 1
a281 1
	CLOSE(NDOC)
a300 1
            write(6,*) 'xx_cc:',xx_cc,number
d315 2
a316 2
        NOUTANG = LUNDOC
        CALL OPENDOC(DOCNAM,.TRUE.,NLET,LUNDOC,NOUTANG,.TRUE.,
d324 2
a325 2
        CALL LUNDOCPUTCOM(LUNDOC,COMMENT(1:37),IRTFLG)
C           123456789 123456789 123456789 123456789 123456789 123456789 
d327 3
a329 3
     &     '   Micrograph     Defocus     Astig.Ang     Astig.Mag   '//
     &     'Cutoff.Freq'
        CALL LUNDOCPUTCOM(LUNDOC,COMMENT(1:69),IRTFLG)
d336 7
a342 2
        DLIST(1) = AV_DEFO 
        DLIST(2) = TMP_SUM
d345 3
a347 2
        DLIST(5) = XX_CC 
        CALL LUNDOCWRTDAT(LUNDOC,KEY,DLIST,5,IRTFLG)
d349 1
a349 1
	CLOSE(LUNDOC)
d355 1
a355 1
	IF (ALLOCATED(TMP_OUT)) DEALLOCATE(TMP_OUT)
@


1.16
log
@prompts improved,  alloc traps added
@
text
@d3 2
a4 2
C            IMPROPER PS BUG FIXED                 SEP   10 ArDean Leith
C            PROMPTS IMPROVED                      MAY   12 ArDean Leith
d29 1
a29 1
C PURPOSE: DETERMINE DEFOCUS AND ASTIGMATISM OF THE 
d33 4
a36 1
C          GIVES DIFFERENT RESULTS WHEN COMPILED WITH -g -O0 !!
a39 1
C          GIVES DIFFERENT RESULTS WHEN COMPILED WITH  -O0 vs O1+ !!
d41 322
d375 1
a375 1
      	CHARACTER(LEN=1)                  :: NULL   
a386 1
        NULL = CHAR(0)
d388 2
a389 2
C====DEFOCUSGUESSING3 FOR WEAK DEFOCUS ASTIGMATISM ESTIMATION  
C====DEFOCUSGUESSING2 FOR STRONG ASTIGMATISM ESTIMATION
d431 2
a432 2
CC==ESTIMATING DEFOCUS BASED ON OVERALL POWER SPECTRUM
CC==SET THE START ANGLE AND STEP TO BE 0.0 AND 180.0.
d468 1
a468 1
CC==Estimate defocus of difficult cases
d476 1
a476 1
CC==ESTIMATION OF ASTIGMATISM;STEP IS 18 DEGREE
d483 1
a483 1
CC====A ROUGH ESTIMATION OF DEFOCUS IN DIFFICULT CASE AND NO ASTIGMATISM ESTIMATION IN SUCH CASE!
d496 2
d503 1
a503 1
CC==X IS X COORDINATES!	  
@


1.15
log
@using standard optimize now (as befor)
@
text
@d4 1
d55 1
a55 1
        CHARACTER(LEN=70)                 :: COMMENT
d86 1
a86 1
     &	    'PIXEL SIZE [A], SPHERICAL ABBERATION CS [MM]')
d91 1
a91 2
      	CALL RDPRM(LAMBDA,NOT_USED,
     &       'WAVELENGTH LAMBDA [ANGSTROEMS]')
d94 1
a94 1
     &           'AMPLITUDE CONTRAST RATIO [0-1]')
a95 1
CC==*==*==*==*==*==*==*==*==*==*==*==*==*==*==*==*==*==*==*==*
d98 6
a103 2
	ALLOCATE(POW2(NSAM1,NROW1))
	ALLOCATE(TMP_OUT(NMB,NT))
d132 2
a133 2
     &     'Spa. freq.(1/A), Back. noise, Back. subtr. PS,  Env(f)**2'
        CALL LUNDOCPUTCOM(LUNDOC,COMMENT(1:67),IRTFLG)
d146 1
a146 1
	IF ( XX_CC.EQ.9999 .OR. AV_DEFO .LE. STRT_SRCH) THEN
d510 1
a510 1
	ALLOCATE(PLOT1(K),STAT=IRTFLG)
d512 4
a515 9
            CALL ERRT(46,'TFED',NE)
         RETURN
         ENDIF
      	ALLOCATE(Q2(KLM2D,N2D),STAT=IRTFLG)
	
	IF (IRTFLG .NE. 0) THEN
            CALL ERRT(46,'TFED',NE)
         RETURN
         ENDIF
d522 1
a522 1
     &  K,N2,N,PLOT,IFIT1,IFIT2,KP)
@


1.14
log
@IMPROPER PS BUG FIXED
@
text
@a37 1
Cpgi$g opt=0
@


1.13
log
@initialized ICUTD=0, line 2853
@
text
@d2 3
a4 1
C *  ECTF.F                                                                  *
d28 6
a33 3
C   PURPOSE: DETERMINE DEFOCUS AND ASTIGMATISM OF THE 
C		MICROGRAPH FROM 2D POWER SPECTRUM 
C                      *
d35 5
d43 1
d45 1
d47 5
a51 5
      	REAL	DLIST(NLIST)   
      	INTEGER	NUMBER 
      	CHARACTER*80	FILE, BUFFER
      	REAL	GETDEFOCUS,LAMBDA
      	CHARACTER*1   ANS   
d53 4
a56 2
	REAL, DIMENSION(:),ALLOCATABLE :: XDEFO
        CHARACTER *81 FILNAM
d58 1
d60 12
a71 8
	DATA LUN1/88/
      	DATA  NDOC/88/
C====DEFOCUSGUSSING3 FOR WEAK DEFOCUS ASTIGMATISM ESTIMATION  
C====DEFOCUSGUESSING2 FOR STRONG ASTIGMATISM ESTIATION

	STRT_SRCH=3000.0
      	STOP_SRCH=200000.0
        MAXIM1 = 0
d73 5
a77 2
     &             MAXIM1,'INPUT1',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0) CALL ERRT(4,'RADAV, INPUT FILE ',NE)
d79 1
a79 1
	IF(NSAM1.NE.NROW1) THEN
d81 1
a81 1
	    CALL ERRT(1,'RADAV',NE)
d86 2
a87 1
     &	'PIXEL SIZE [A], SPHERICAL ABBERATION CS [MM]')
d92 4
a95 1
     &    'WAVELENGTH LAMBDA(ANGSTROEMS)[A]')
a96 1
      	CALL RDPRM(CONTRAST,NOT_USED,'AMPL. CONTRAST RATIO [0-1]')
d104 2
a105 1
	CLOSE(LUN1)	
d108 5
a112 4
        BETA0=0.0
	BETA1=180.
	CALL DEFOCUSGUESSING1(POW2,NSAM1,NROW1,NMB,BETA0,BETA1
     & 		,PS,CS,LAMBDA,CONTRAST,AV_DEFO,
d115 17
a131 4
	TMP_OUT(1:NUMBER,2:4)=EXP(TMP_OUT(1:NUMBER,2:4))
	TMP_OUT(1:NUMBER,1)=TMP_OUT(1:NUMBER,1)/2.0/PS/NMB
	TMP_OUT(1:NUMBER,3)=TMP_OUT(1:NUMBER,3)-TMP_OUT(1:NUMBER,2)
	TMP_OUT(1:NUMBER,4)=TMP_OUT(1:NUMBER,4)-TMP_OUT(1:NUMBER,2)
d135 5
a139 5
	    DLIST(2)=TMP_OUT(II,1)
	    DLIST(3)=TMP_OUT(II,2)
	    DLIST(4)=TMP_OUT(II,3)
	    DLIST(5)=TMP_OUT(II,4)
	    CALL SAVD(NDOC,DLIST,NLIST,IRTFLG)
a140 2

	CALL SAVDC
d144 7
a150 7
	IF(XX_CC.EQ.9999.OR.AV_DEFO.LE.STRT_SRCH) THEN
	    XX_CC=9999.
	    AST_AGL=0.0
	    TMP_AMP=0.0
	    TMP_SUM=0.0
	    GO TO 1010
	ENDIF	
d152 5
a156 4
	X_AV_DEFO=AV_DEFO
  	IDGREE=NDGREE
	CALL AST_CALC(POW2,NSAM1,NROW1,NMB,NT,PS,CS,
     &	    LAMBDA,CONTRAST,X_AV_DEFO,IDGREE,AST_AGL,TMP_AMP,TMP_SUM)
d159 3
a161 4
1010	IF(XX_CC.GT.1) THEN
	     CALL DEFOCUSGUESSING3(POW2,NSAM1,NROW1,NMB
     & 		,PS,CS,LAMBDA,CONTRAST,AV_DEFO,XX_CC)

d166 3
a168 1
      	DEALLOCATE(POW2,TMP_OUT)
d175 1
d294 1
d296 1
d340 1
d342 1
d344 1
d390 1
d392 1
d424 1
d426 1
d428 1
d478 1
d481 1
d487 2
a488 1
      	REAL PLOT(K,N2)	 
d554 1
d577 1
d579 1
d582 1
d590 1
d685 1
d793 1
d908 1
d935 1
d937 1
d939 1
d995 1
d1015 1
d1017 1
d1019 1
d1026 1
d1062 1
d1064 1
d1067 1
d1075 1
d1104 2
d1110 1
a1110 1
	INTEGER TMP_FIRST(NMRANK),TMP_SECND(NMRANK)                                            
d1112 2
a1113 2
	REAL LAMBDA
	REAL 		QUADPI
d1116 2
d1120 1
a1120 1
            CALL ERRT(46,'TFED',NE)
d1127 2
a1128 1
	IPW_ZERO=0
d1130 1
a1130 1
 	    TMP(I,1)=I		
d1133 2
a1134 2
      	IF(NMB.LT.5) THEN 
            CALL ERRT(36,'TFED',NE)
d1139 1
a1139 1
	    IF(TMP(I,2).EQ.0.0) IPW_ZERO=I 		
d1141 15
a1155 14
CC==ESTIMATE THE MINIMUM DEFOCUS BASED ON GIVEN VOLTAGE, CS, AND PIXEL SIZE
	N2=4
	TMP1_DEFO=(2.*PS)**2/LAMBDA
	TMP2_DEFO=CONTRAST/(1.0-CONTRAST)
	TMP2_DEFO=ATAN(TMP2_DEFO)*TMP1_DEFO/QUADPI
	TMP3_DEFO=.5*CS*LAMBDA**2/(2.*PS)**2
	DEFO_MIN=TMP2_DEFO+TMP3_DEFO
CC==
	TMP1_DEFO=.5*REAL(NMB-1)/PS/REAL(NMB)
	TMP1_DEFO=TMP1_DEFO*TMP1_DEFO
	TMP2_DEFO=.5/PS
	TMP2_DEFO=TMP2_DEFO*TMP2_DEFO
	DEFO_MAX=1.0/(TMP2_DEFO-TMP1_DEFO)/LAMBDA
	DEFO_MAX=DEFO_MAX+.5*CS*LAMBDA**2*(TMP2_DEFO+TMP1_DEFO)
d1157 13
a1169 7
	NUMBER=NMB-IPW_ZERO
	TMP_XX=NUMBER/3.
	IPT_LOW=INT(TMP_XX)
	TMP_XX=NUMBER*2./3.
	IPT_HIGH=INT(TMP_XX)
	TMP_XX=NUMBER/2.
	IPT_HALF=INT(TMP_XX)
d1171 1
a1171 1
	NDGREE=0
d1175 3
a1177 2
            CALL ERRT(46,'TFED',NE)
            RETURN
d1181 5
a1185 4
	    PLOT(:,1)=TMP(IPW_ZERO+1:NMB,1)-1.0
	    PLOT(:,3)=ALOG(TMP(IPW_ZERO+1:NMB,2))
	    IFIT1=1
	    IFIT2=NUMBER
d1193 1
d1199 1
a1199 1
	    IF(ICUTB.GT.IPT_HIGH) THEN
d1204 1
a1204 1
	    IF(ICUTB.GT.IPT_LOW.AND.ICUTB.LT.IPT_HIGH) THEN		
d1267 1
a1267 1
	IF(X_DEFO(1).GT.X_DEFO(2)) THEN
d1274 1
a1274 1
	IF(X_DEFO(2).GT.X_DEFO(3)) THEN
d1281 1
a1281 1
	IF(X_DEFO(3).GT.X_DEFO(4)) THEN
d1297 1
a1297 1
	IF(N_TMP.LE.2.AND.X_FST_ITVL.GT..2) THEN
d1302 1
d1304 2
a1305 1
	ELSEIF(N_TMP.LE.2.AND.X_FST_ITVL.LT..2) THEN
d1311 1
a1311 1
	    IF(AV_DEFO.LT.DEFO_MIN) THEN
d1316 1
d1319 1
d1321 1
a1321 1
	IF(NDGREE.GE.6) THEN
d1324 1
d1328 1
d1334 2
d1345 1
d1382 1
d1384 1
d1388 1
d1447 1
d1585 1
d1607 1
d1609 1
d1611 1
d1670 1
d1689 1
d1691 1
d1694 1
d1701 1
d1753 2
a1754 1
	INTEGER FOUR_ZERO(N4)	
d1839 1
d1978 1
d1980 1
d1983 1
d1991 1
d2006 1
d2008 1
d2010 1
d2013 1
d2020 1
d2022 1
d2024 1
d2026 1
d2064 1
d2070 2
a2071 1
	REAL PLOT(K,N2)	 	      	
d2106 1
d2110 1
a2110 1
     &  K,N2,PLOT1,N,ICUT1,ICUT2,KP)
d2119 1
d2138 1
d2140 1
d2182 1
d2186 1
a2186 1
     & K,N2,PLOT1,N,IPT1,IPT2,KP)
d2195 1
d2214 1
d2218 1
a2218 1
     &  K,N2,PLOT1,N,IPT1,IPT2,KP)
d2227 1
d2245 1
d2247 1
d2249 1
d2298 1
d2300 1
d2303 1
d2311 1
d2328 1
d2330 1
d2375 1
d2377 1
d2417 1
d2419 1
d2465 1
d2467 1
d2477 1
d2494 1
d2496 1
d2648 1
d2681 1
d2683 1
d2749 1
d2751 1
d2753 1
d2757 1
d2800 1
d2802 1
d2804 1
d2851 1
d2853 1
d2855 1
d2899 1
d2901 1
d2905 1
d2956 1
d2958 1
d3006 1
d3008 1
d3111 1
d3113 1
d3182 1
d3184 1
d3312 1
d3314 1
d3316 1
d3372 1
d3374 1
d3377 1
d3414 1
d3416 1
d3419 1
d3453 1
d3455 1
d3495 1
d3569 1
d3571 1
d3605 1
d3607 1
d3610 1
a3623 1

d3625 1
a3625 1
            CALL ERRT(46,'TFED',NE)
a3629 1

d3631 1
a3631 1
            CALL ERRT(46,'TFED',NE)
d3636 5
a3640 5
	    TMP1=REAL(IILOOP-1)
	    TMP2=REAL(IILOOP)
	    BETA0=TMP1*BETA
	    BETA1=TMP2*BETA
	    NDGREE_AST=NDGREE
d3642 2
a3643 2
	    CALL DEFOCUSGUESSING1(POW2,NSAM1,NROW1,NMB,BETA0,BETA1
     & 		,PS,CS,LAMBDA,CONTRAST,DEFOCUS,
d3647 1
a3647 1
	    IF(BETA.LT.18.) THEN
d3672 1
a3672 1
     &	    AV_DEFO,AST_AGL,TMP_AMP,TMP_SUM,RATIO)
d3676 3
a3678 3
	IF(RATIO.GT.2.AND.BETA.GE.18) THEN
		BETA=3.
		GO TO 1122
d3683 1
d3685 1
a3710 1
C=**********************************************************************
d3712 1
d3715 1
d3796 2
a3797 1
      	END                                                               
d3799 1
a3824 1
C=**********************************************************************
d3826 1
d3828 1
d3831 1
@


1.12
log
@overlenght lines fixed
@
text
@d2853 1
@


1.11
log
@Pawels GPL License used
@
text
@a5 1
C=*                                                                    *
a6 1
C=*                                                                    *
a24 1
C **********************************************************************
d256 1
d260 2
a261 1
	DOUBLE PRECISION Q(KLM2D,N2D),X(N2D),RES(KLMD),CU(2,NKLMD),S(KLMD)
d347 1
d351 2
a352 1
	DOUBLE PRECISION Q(KLM2D,N2D),X(N2D),RES(KLMD),CU(2,NKLMD),S(KLMD)
d496 2
a497 1
	DOUBLE PRECISION Q(KLM2D,N2D),X(N2D),RES(KLMD),CU(2,NKLMD),S(KLMD)
d528 2
a529 1
	DOUBLE PRECISION Q(KLM2D,N2D),X(N2D),RES(KLMD),CU(2,NKLMD),S(KLMD)
d843 2
a844 1
	DOUBLE PRECISION Q(KLM2D,N2D),X(N2D),RES(KLMD),CU(2,NKLMD),S(KLMD)
d926 2
a927 1
	DOUBLE PRECISION Q(KLM2D,N2D),X(N2D),RES(KLMD),CU(2,NKLMD),S(KLMD)
d998 2
a999 1
	DOUBLE PRECISION Q(KLM2D,N2D),X(N2D),RES(KLMD),CU(2,NKLMD),S(KLMD)
d1342 2
a1343 1
	DOUBLE PRECISION Q(KLM2D,N2D),X(N2D),RES(KLMD),CU(2,NKLMD),S(KLMD)
d1479 2
a1480 1
	DOUBLE PRECISION Q(KLM2D,N2D),X(N2D),RES(KLMD),CU(2,NKLMD),S(KLMD)
d1560 2
a1561 1
	DOUBLE PRECISION Q(KLM2D,N2D),X(N2D),RES(KLMD),CU(2,NKLMD),S(KLMD)
d1723 2
a1724 1
	DOUBLE PRECISION Q(KLM2D,N2D),X(N2D),RES(KLMD),CU(2,NKLMD),S(KLMD)
d1871 2
a1872 1
	DOUBLE PRECISION Q(KLM2D,N2D),X(N2D),RES(KLMD),CU(2,NKLMD),S(KLMD)
d1987 2
a1988 1
	DOUBLE PRECISION Q(KLM2D,N2D),X(N2D),RES(KLMD),CU(2,NKLMD),S(KLMD)
d2059 2
a2060 1
	DOUBLE PRECISION Q(KLM2D,N2D),X(N2D),RES(KLMD),CU(2,NKLMD),S(KLMD)
d2089 2
a2090 1
	DOUBLE PRECISION Q(KLM2D,N2D),X(N2D),RES(KLMD),CU(2,NKLMD),S(KLMD)
d2166 2
a2167 1
	DOUBLE PRECISION Q(KLM2D,N2D),X(N2D),RES(KLMD),CU(2,NKLMD),S(KLMD)
d2323 2
a2324 1
	DOUBLE PRECISION Q(KLM2D,N2D),X(N2D),RES(KLMD),CU(2,NKLMD),S(KLMD)
d2987 2
a2988 1
	DOUBLE PRECISION Q(KLM2D,N2D),X(N2D),RES(KLMD),CU(2,NKLMD),S(KLMD)
d3197 2
a3198 1
	DOUBLE PRECISION Q(KLM2D,N2D),X(N2D),RES(KLMD),CU(2,NKLMD),S(KLMD)
d3236 2
a3237 1
	DOUBLE PRECISION Q(KLM2D,N2D),X(N2D),RES(KLMD),CU(2,NKLMD),S(KLMD)
d3540 2
a3541 1
C THE PROGRAM MAY BE TESTED ON THE FOLLOWING DATA.                                                                                   
@


1.10
log
@deallocates added (leaky)
@
text
@d1 1
a1 2
C ****************************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.                               *
d3 25
a27 6
C *  COPYRIGHT (C)2002, Z.Huang & P.A.Penczek                                *
C *  University of Texas - Houston Medical School                            *
C *  pawel.a.penczek@@uth.tmc.edu                                             *
C *    THE CONTENTS OF THIS DOCUMENT CANNOT BE CHANGED WITHOUT WRITTEN       *
C *    PERMISSION OF THE AUTHOR                                              *
C ****************************************************************************
d32 1
a32 1
C ****************************************************************************
a3472 1
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.
d3474 25
a3498 6
C *  COPYRIGHT (C)2002, Z.Huang & P.A.Penczek
C *  University of Texas - Houston Medical School
C *  pawel.a.penczek@@uth.tmc.edu
C *    THE CONTENTS OF THIS DOCUMENT CANNOT BE CHANGED WITHOUT WRITTEN
C *    PERMISSION OF THE AUTHOR                          *
C **************************************************************************
d3582 1
a3582 2
C **************************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.
d3584 25
a3608 6
C *  COPYRIGHT (C)2002, Z.Huang & P.A.Penczek
C *  University of Texas - Houston Medical School
C *  pawel.a.penczek@@uth.tmc.edu
C *    THE CONTENTS OF THIS DOCUMENT CANNOT BE CHANGED WITHOUT WRITTEN
C *    PERMISSION OF THE AUTHOR                          *
C **************************************************************************
@


1.9
log
@had lines > 72 char.!!!
@
text
@d240 1
a240 1
     &           K,N2,PLOT1,N,ICUT1,ICUT2,KP)
d242 4
a245 6
CC==LOCAL
	REAL, DIMENSION(:,:), ALLOCATABLE :: T2_Q2,TT1_Q2,
     & 	TT2_Q2,PLOT2
	DOUBLE PRECISION, DIMENSION (:,:),ALLOCATABLE :: Q,CU
      	DOUBLE PRECISION,DIMENSION (:),ALLOCATABLE :: X,RES,S
      	INTEGER, DIMENSION(:,:), ALLOCATABLE :: IU
a247 3
	ALLOCATE(TT1_Q2(KLM2D,N2D),PLOT2(K,N2))
      	ALLOCATE(Q(KLM2D,N2D),X(N2D),RES(KLMD),CU(2,NKLMD),
     &  IU(2,NKLMD),S(KLMD))
a278 1
 	DEALLOCATE(TT1_Q2,PLOT2)
d286 2
a287 2
	INTEGER, DIMENSION (:), ALLOCATABLE :: IZERO
      	REAL, DIMENSION(:,:), ALLOCATABLE :: Q2,P,Q3,Q4
d291 1
d308 5
a312 3
      	ALLOCATE(Q2(KLM2D,N2D))
      	ALLOCATE(Q3(KLM2D,N2D))
	ALLOCATE(Q4(KLM2D,N2D))
d323 1
a323 1
     &           K,N2,PLOT,N,ICUT1,ICUT2,KP)
d325 1
d331 4
a334 6
CC==LOCAL
	REAL, DIMENSION(:,:), ALLOCATABLE :: T2_Q2,TT1_Q2,
     & 	TT2_Q2,PLOT2
	DOUBLE PRECISION, DIMENSION (:,:),ALLOCATABLE :: Q,CU
      	DOUBLE PRECISION,DIMENSION (:),ALLOCATABLE :: X,RES,S
      	INTEGER, DIMENSION(:,:), ALLOCATABLE :: IU
a336 3
	ALLOCATE(TT1_Q2(KLM2D,N2D),PLOT2(K,N2))
      	ALLOCATE(Q(KLM2D,N2D),X(N2D),RES(KLMD),CU(2,NKLMD),
     &  IU(2,NKLMD),S(KLMD))
a355 1

d361 1
a361 1
      	REAL, DIMENSION(:,:), ALLOCATABLE :: Q2,P,Q3,Q4
d364 1
d384 5
a388 3
      	ALLOCATE(Q2(KLM2D,N2D))
      	ALLOCATE(Q3(KLM2D,N2D))
	ALLOCATE(Q4(KLM2D,N2D))
d395 1
a395 1
     &           K,N2,N,PLOT,IFIT1,IFIT2,KP)
d405 1
a405 1
	CLOSE(91)
d412 1
a412 1
      	REAL, DIMENSION(:,:), ALLOCATABLE :: Q2,P,Q3,Q4
d415 1
a415 1
      	REAL PLOT(K,N2)
d435 11
a445 4
      	ALLOCATE(Q2(KLM2D,N2D))
      	ALLOCATE(Q3(KLM2D,N2D))
	ALLOCATE(Q4(KLM2D,N2D))
	ALLOCATE(PLOT1(K))
d452 1
a452 1
     &           K,N2,N,PLOT,IFIT1,IFIT2,KP)
d472 1
a472 1
     &           K,N2,PLOT1,N,ICUT1,ICUT2,ICNSTRNT,KP)
d475 4
a478 6
CC==LOCAL
	REAL, DIMENSION(:,:), ALLOCATABLE :: T2_Q2,TT1_Q2,
     & 	TT2_Q2,PLOT2
	DOUBLE PRECISION, DIMENSION (:,:),ALLOCATABLE :: Q,CU
      	DOUBLE PRECISION,DIMENSION (:),ALLOCATABLE :: X,RES,S
      	INTEGER, DIMENSION(:,:), ALLOCATABLE :: IU
a480 3
	ALLOCATE(TT1_Q2(KLM2D,N2D),PLOT2(K,N2))
      	ALLOCATE(Q(KLM2D,N2D),X(N2D),RES(KLMD),CU(2,NKLMD),
     &  IU(2,NKLMD),S(KLMD))
a500 1
 	DEALLOCATE(TT1_Q2,PLOT2)
d504 1
a504 1
     &           K,N2,PLOT1,N,ICUT1,ICUT2,KP)
d506 4
a509 6
CC==LOCAL
	REAL, DIMENSION(:,:), ALLOCATABLE :: T2_Q2,TT1_Q2,
     & 	TT2_Q2,PLOT2
	DOUBLE PRECISION, DIMENSION (:,:),ALLOCATABLE :: Q,CU
      	DOUBLE PRECISION,DIMENSION (:),ALLOCATABLE :: X,RES,S
      	INTEGER, DIMENSION(:,:), ALLOCATABLE :: IU
a511 3
	ALLOCATE(TT1_Q2(KLM2D,N2D),PLOT2(K,N2))
      	ALLOCATE(Q(KLM2D,N2D),X(N2D),RES(KLMD),CU(2,NKLMD),
     &  IU(2,NKLMD),S(KLMD))
d529 1
a529 2
 	DEALLOCATE(TT1_Q2,PLOT2)
      END
d540 1
a540 1
      	REAL, DIMENSION(:,:), ALLOCATABLE :: Q2,P,Q3,Q4
d543 2
a544 1
	REAL LAMBDA
d561 5
a565 3
      	ALLOCATE(Q2(KLM2D,N2D))
      	ALLOCATE(Q3(KLM2D,N2D))
	ALLOCATE(Q4(KLM2D,N2D))
d574 1
a574 1
     &           K,N2,PLOT,N,ICUT1,ICUT2,ICNSTRNT,KP)
d592 1
d606 5
a610 2
	ALLOCATE(TMP(NMB,2))

d619 1
a619 1
            CALL ERRT(36,'ECTF',NE)
d633 5
a637 1
	ALLOCATE(PLOT(NUMBER,N2))
d708 1
a708 1
      	REAL, DIMENSION(:,:), ALLOCATABLE :: Q2,P,Q3,Q4
d728 6
a733 3
      	ALLOCATE(Q2(KLM2D,N2D))
      	ALLOCATE(Q3(KLM2D,N2D))
	ALLOCATE(Q4(KLM2D,N2D))
d742 2
a743 2
	CALL PARTI10 (KLMD,NKLMD,KLM2D,N2D,Q2,
     &  	K,N2,PLOT,N,ICUT1,ICUT2,KP)
d770 1
a770 1
      	REAL, DIMENSION(:,:), ALLOCATABLE :: Q2,P,Q3,Q4
d791 7
a797 3
      	ALLOCATE(Q2(KLM2D,N2D))
      	ALLOCATE(Q3(KLM2D,N2D))
	ALLOCATE(Q4(KLM2D,N2D))
d809 1
a809 1
     &           K,N2,PLOT,N,ICUT1,ICUT2,ICUTD,KP)
d817 1
a817 1
     &           K,N2,PLOT1,N,ICUT1,ICUT2,ICUTD,KP)
d820 4
a823 6
CC==LOCAL
	REAL, DIMENSION(:,:), ALLOCATABLE :: T2_Q2,TT1_Q2,
     & 	TT2_Q2,PLOT2
	DOUBLE PRECISION, DIMENSION (:,:),ALLOCATABLE :: Q,CU
      	DOUBLE PRECISION,DIMENSION (:),ALLOCATABLE :: X,RES,S
      	INTEGER, DIMENSION(:,:), ALLOCATABLE :: IU
a825 4
	ALLOCATE(TT1_Q2(KLM2D,N2D),PLOT2(K,N2))
      	ALLOCATE(Q(KLM2D,N2D),X(N2D),RES(KLMD),CU(2,NKLMD),
     &  IU(2,NKLMD),S(KLMD))

a849 1
 	DEALLOCATE(TT1_Q2,PLOT2)
d855 1
a855 1
      	REAL, DIMENSION(:,:), ALLOCATABLE :: Q2,P,Q3,Q4
d859 1
d877 6
a882 3
      	ALLOCATE(Q2(KLM2D,N2D))
      	ALLOCATE(Q3(KLM2D,N2D))
	ALLOCATE(Q4(KLM2D,N2D))
d892 1
a892 1
     &           K,N2,PLOT,N,ICUT1,ICUT2,KP)
d899 1
a899 1
     &           K,N2,PLOT1,N,ICUT1,ICUT2,KP)
d902 4
a905 6
CC==LOCAL
	REAL, DIMENSION(:,:), ALLOCATABLE :: T2_Q2,TT1_Q2,
     & 	TT2_Q2,PLOT2
	DOUBLE PRECISION, DIMENSION (:,:),ALLOCATABLE :: Q,CU
      	DOUBLE PRECISION,DIMENSION (:),ALLOCATABLE :: X,RES,S
      	INTEGER, DIMENSION(:,:), ALLOCATABLE :: IU
a907 3
	ALLOCATE(TT1_Q2(KLM2D,N2D),PLOT2(K,N2))
      	ALLOCATE(Q(KLM2D,N2D),X(N2D),RES(KLMD),CU(2,NKLMD),
     &  IU(2,NKLMD),S(KLMD))
d924 1
a924 3
     &         Q,X,RES,CU,S,IU,KLMD,NKLMD,KP)
		
 	DEALLOCATE(TT1_Q2,PLOT2)
d930 1
a930 1
      	REAL, DIMENSION(:,:), ALLOCATABLE :: Q2,P,Q3,Q4
d952 5
a956 3
      	ALLOCATE(Q2(KLM2D,N2D))
      	ALLOCATE(Q3(KLM2D,N2D))
	ALLOCATE(Q4(KLM2D,N2D))
d966 1
a966 1
     &           K,N2,PLOT,ICUT1,ICUT2,KP)
d971 1
a971 1
     &           K,N2,PLOT1,ICUT1,ICUT2,KP)
d973 4
a976 6
CC==LOCAL
	REAL, DIMENSION(:,:), ALLOCATABLE :: T2_Q2,TT1_Q2,
     & 	TT2_Q2,PLOT2
	DOUBLE PRECISION, DIMENSION (:,:),ALLOCATABLE :: Q,CU
      	DOUBLE PRECISION,DIMENSION (:),ALLOCATABLE :: X,RES,S
      	INTEGER, DIMENSION(:,:), ALLOCATABLE :: IU
a978 3
	ALLOCATE(TT1_Q2(KLM2D,N2D),PLOT2(K,N2))
      	ALLOCATE(Q(KLM2D,N2D),X(N2D),RES(KLMD),CU(2,NKLMD),
     &  IU(2,NKLMD),S(KLMD))
a996 1
 	DEALLOCATE(TT1_Q2,PLOT2)
d1006 1
d1009 3
a1011 6
	REAL, DIMENSION(:,:), ALLOCATABLE :: PLOT,TMP,TMP_PLOT
	REAL, DIMENSION(:,:,:), ALLOCATABLE :: X_TMP
	INTEGER, DIMENSION(:,:), ALLOCATABLE :: RANK_NZEROS
	INTEGER,DIMENSION(:), ALLOCATABLE :: N_SELECT,
     &                                       TMP_FIRST,TMP_SECND
	REAL, DIMENSION(:), ALLOCATABLE :: X_DEFO
d1015 7
a1021 7

	NMRANK=6

	ALLOCATE(TMP(NMB,2),N_SELECT(NMRANK),TMP_FIRST(NMRANK),
     &		TMP_SECND(NMRANK),X_DEFO(NMRANK),
     &	X_TMP(NMB,NT,NMRANK))

d1031 1
a1031 1
            CALL ERRT(36,'ECTF',NE)
d1062 7
a1068 1
	ALLOCATE(PLOT(NUMBER,N2))
d1214 1
a1214 2
	DEALLOCATE(PLOT,TMP,N_SELECT,TMP_FIRST,
     &		TMP_SECND,X_DEFO)
d1224 1
a1224 1
      	REAL, DIMENSION(:,:), ALLOCATABLE :: Q2,P,Q3,Q4
d1227 1
d1244 5
a1248 4
      	ALLOCATE(Q2(KLM2D,N2D))
      	ALLOCATE(Q3(KLM2D,N2D))
	ALLOCATE(Q4(KLM2D,N2D))

d1257 2
a1258 2
     &           K,N2,PLOT,N,ICUT1,ICUT2,ICNSTRNT,KP)
	DEALLOCATE(Q2,Q3,Q4)
d1264 2
a1265 1
	REAL, DIMENSION(:), ALLOCATABLE :: TMP1,TMP2,TMP3
d1268 1
d1270 5
a1274 1
	ALLOCATE(TMP1(K),TMP2(K),TMP3(K))
d1307 1
a1307 1
     	DEALLOCATE(TMP1,TMP2,TMP3)
d1313 1
a1313 1
     &           K,N2,PLOT1,N,ICUT1,ICUT2,ICNSTRNT,KP)
d1316 4
a1319 6
CC==LOCAL
	REAL, DIMENSION(:,:), ALLOCATABLE :: T2_Q2,TT1_Q2,
     & 	TT2_Q2,PLOT2
	DOUBLE PRECISION, DIMENSION (:,:),ALLOCATABLE :: Q,CU
      	DOUBLE PRECISION,DIMENSION (:),ALLOCATABLE :: X,RES,S
      	INTEGER, DIMENSION(:,:), ALLOCATABLE :: IU
a1321 4
	ALLOCATE(TT1_Q2(KLM2D,N2D),PLOT2(K,N2))
      	ALLOCATE(Q(KLM2D,N2D),X(N2D),RES(KLMD),CU(2,NKLMD),
     &  IU(2,NKLMD),S(KLMD))

d1338 1
a1338 1
     &         Q,X,RES,CU,S,IU,KLMD,NKLMD,KP)
a1339 1
 	DEALLOCATE(TT1_Q2,PLOT2)
d1350 1
a1350 1
      	REAL, DIMENSION(:,:), ALLOCATABLE :: Q2,P,Q3,Q4
d1354 1
d1373 7
a1379 3
      	ALLOCATE(Q2(KLM2D,N2D))
      	ALLOCATE(Q3(KLM2D,N2D))
	ALLOCATE(Q4(KLM2D,N2D))
d1391 1
a1391 1
     &           K,N2,PLOT,N,ICUT1,ICUT2,KP)
d1402 2
a1403 2
	INTEGER, DIMENSION (:), ALLOCATABLE :: IZERO
      	REAL, DIMENSION(:,:), ALLOCATABLE :: Q2,P,Q3,Q4
d1407 1
d1425 5
a1429 3
      	ALLOCATE(Q2(KLM2D,N2D))
      	ALLOCATE(Q3(KLM2D,N2D))
	ALLOCATE(Q4(KLM2D,N2D))
d1441 1
a1441 1
     &           K,N2,PLOT,N,ICUT1,ICUT2,KP)
d1443 1
d1449 1
a1449 1
     &           K,N2,PLOT1,N,ICUT1,ICUT2,KP)
d1452 4
a1455 6
CC==LOCAL
	REAL, DIMENSION(:,:), ALLOCATABLE :: T2_Q2,TT1_Q2,
     & 	TT2_Q2,PLOT2
	DOUBLE PRECISION, DIMENSION (:,:),ALLOCATABLE :: Q,CU
      	DOUBLE PRECISION,DIMENSION (:),ALLOCATABLE :: X,RES,S
      	INTEGER, DIMENSION(:,:), ALLOCATABLE :: IU
a1457 3
	ALLOCATE(TT1_Q2(KLM2D,N2D),PLOT2(K,N2))
      	ALLOCATE(Q(KLM2D,N2D),X(N2D),RES(KLMD),CU(2,NKLMD),
     &  IU(2,NKLMD),S(KLMD))
d1476 1
a1476 3
     &         Q,X,RES,CU,S,IU,KLMD,NKLMD,KP)
		
 	DEALLOCATE(TT1_Q2,PLOT2)
d1484 1
a1484 1
      	REAL, DIMENSION(:,:), ALLOCATABLE :: Q2,P,Q3,Q4
d1488 1
d1506 5
a1510 3
      	ALLOCATE(Q2(KLM2D,N2D))
      	ALLOCATE(Q3(KLM2D,N2D))
	ALLOCATE(Q4(KLM2D,N2D))
d1515 1
d1522 1
a1522 1
     &           K,N2,PLOT,N,ICUT1,ICUT2,KP)
d1529 1
a1529 1
     &           K,N2,PLOT1,N,ICUT1,ICUT2,KP)
d1532 4
a1535 6
CC==LOCAL
	REAL, DIMENSION(:,:), ALLOCATABLE :: T2_Q2,TT1_Q2,
     & 	TT2_Q2,PLOT2
	DOUBLE PRECISION, DIMENSION (:,:),ALLOCATABLE :: Q,CU
      	DOUBLE PRECISION,DIMENSION (:),ALLOCATABLE :: X,RES,S
      	INTEGER, DIMENSION(:,:), ALLOCATABLE :: IU
a1537 4
	ALLOCATE(TT1_Q2(KLM2D,N2D),PLOT2(K,N2))
      	ALLOCATE(Q(KLM2D,N2D),X(N2D),RES(KLMD),CU(2,NKLMD),
     &  IU(2,NKLMD),S(KLMD))

a1553 1
 	DEALLOCATE(TT1_Q2,PLOT2)
d1566 5
a1570 1
	ALLOCATE(FOUR_ZERO(N4))
d1579 5
a1583 1
	ALLOCATE(NCON(N3))
d1691 1
a1691 1
     &           K,N2,PLOT1,N,ICUT1,ICUT2,ICUTD,ICUTC,KP)
d1694 4
a1697 6
CC==LOCAL
	REAL, DIMENSION(:,:), ALLOCATABLE :: T2_Q2,TT1_Q2,
     & 	TT2_Q2,PLOT2
	DOUBLE PRECISION, DIMENSION (:,:),ALLOCATABLE :: Q,CU
      	DOUBLE PRECISION,DIMENSION (:),ALLOCATABLE :: X,RES,S
      	INTEGER, DIMENSION(:,:), ALLOCATABLE :: IU
a1699 3
	ALLOCATE(TT1_Q2(KLM2D,N2D),PLOT2(K,N2))
      	ALLOCATE(Q(KLM2D,N2D),X(N2D),RES(KLMD),CU(2,NKLMD),
     &  IU(2,NKLMD),S(KLMD))
a1725 1
 	DEALLOCATE(TT1_Q2,PLOT2)
d1731 1
a1731 1
	REAL, DIMENSION(:,:), ALLOCATABLE :: Q2,P,Q3,Q4
d1734 1
d1750 6
a1755 3
      	ALLOCATE(Q2(KLM2D,N2D))
      	ALLOCATE(Q3(KLM2D,N2D))
	ALLOCATE(Q4(KLM2D,N2D))
d1760 1
d1772 1
a1772 1
     &          K,N2,PLOT,N,ICUT1,ICUT2,ICON3,ICON4,KP)
d1775 1
a1775 1
     &           K,N2,PLOT,N,ICUT1,ICON3,KP)
d1778 1
a1778 1
     &           K,N2,PLOT,N,ICUT1,ICUT2,KP)
d1786 1
a1786 1
	REAL, DIMENSION(:,:), ALLOCATABLE :: Q2,P,Q3,Q4
d1789 1
d1805 6
a1810 3
      	ALLOCATE(Q2(KLM2D,N2D))
      	ALLOCATE(Q3(KLM2D,N2D))
	ALLOCATE(Q4(KLM2D,N2D))
d1815 1
d1827 1
a1827 1
     &           K,N2,PLOT,N,ICUT1,ICUT2,ICON3,ICON4,KP)
d1830 1
a1830 1
     &           K,N2,PLOT,N,ICON3,ICUT2,KP)
d1833 1
a1833 1
     &           K,N2,PLOT,N,ICUT1,ICUT2,KP)
d1835 1
a1835 1
     	DEALLOCATE(Q2,Q3,Q4)
d1839 1
a1839 1
     &           K,N2,PLOT1,N,ICUT1,ICUT2,KP)
d1841 4
a1844 6
CC==LOCAL
	REAL, DIMENSION(:,:), ALLOCATABLE :: T2_Q2,TT1_Q2,
     & 	TT2_Q2,PLOT2
	DOUBLE PRECISION, DIMENSION (:,:),ALLOCATABLE :: Q,CU
      	DOUBLE PRECISION,DIMENSION (:),ALLOCATABLE :: X,RES,S
      	INTEGER, DIMENSION(:,:), ALLOCATABLE :: IU
a1846 3
	ALLOCATE(TT1_Q2(KLM2D,N2D),PLOT2(K,N2))
      	ALLOCATE(Q(KLM2D,N2D),X(N2D),RES(KLMD),CU(2,NKLMD),
     &  IU(2,NKLMD),S(KLMD))
a1858 1
 	DEALLOCATE(TT1_Q2,PLOT2)
d1873 1
a1873 1
	REAL, DIMENSION(:,:), ALLOCATABLE :: Q2,P,Q3,Q4
d1892 5
a1896 3
      	ALLOCATE(Q2(KLM2D,N2D))
      	ALLOCATE(Q3(KLM2D,N2D))
	ALLOCATE(Q4(KLM2D,N2D))
d1907 2
a1908 2
     &           K,N2,PLOT,N,IPT1,IPT2,KP)
      	DEALLOCATE(Q2,Q3,Q4)
d1914 2
a1915 2
	REAL, DIMENSION(:,:), ALLOCATABLE :: Q2,P,Q3,Q4
	REAL PLOT(K,N2)
d1932 5
a1936 3
      	ALLOCATE(Q2(KLM2D,N2D))
      	ALLOCATE(Q3(KLM2D,N2D))
	ALLOCATE(Q4(KLM2D,N2D))
d1947 1
a1947 1
     &           K,N2,PLOT,N,IPT1,IPT2,KP)
d1953 1
a1953 1
     &           K,N2,PLOT1,N,ICUT1,ICUT2,KP)
d1956 4
a1959 6
CC==LOCAL
	REAL, DIMENSION(:,:), ALLOCATABLE :: T2_Q2,TT1_Q2,
     & 	TT2_Q2,PLOT2
	DOUBLE PRECISION, DIMENSION (:,:),ALLOCATABLE :: Q,CU
      	DOUBLE PRECISION,DIMENSION (:),ALLOCATABLE :: X,RES,S
      	INTEGER, DIMENSION(:,:), ALLOCATABLE :: IU
a1961 4
	ALLOCATE(TT1_Q2(KLM2D,N2D),PLOT2(K,N2))
      	ALLOCATE(Q(KLM2D,N2D),X(N2D),RES(KLMD),CU(2,NKLMD),
     &  IU(2,NKLMD),S(KLMD))

a1977 1
 	DEALLOCATE(TT1_Q2,PLOT2)
d1981 1
a1981 1
	REAL, DIMENSION(:,:), ALLOCATABLE :: Q2,P,Q3,Q4
d2001 5
a2005 3
      	ALLOCATE(Q2(KLM2D,N2D))
      	ALLOCATE(Q3(KLM2D,N2D))
	ALLOCATE(Q4(KLM2D,N2D))
d2018 2
a2019 2
     &           K,N2,PLOT,N,IPT1,IPT2,KP)
     	DEALLOCATE(Q2,Q3,Q4)
d2024 1
a2024 1
     &           K,N2,PLOT1,N,IPT1,IPT2,KP)
d2027 4
a2030 6
CC==LOCAL
	REAL, DIMENSION(:,:), ALLOCATABLE :: T2_Q2,TT1_Q2,
     & 	TT2_Q2,PLOT2
	DOUBLE PRECISION, DIMENSION (:,:),ALLOCATABLE :: Q,CU
      	DOUBLE PRECISION,DIMENSION (:),ALLOCATABLE :: X,RES,S
      	INTEGER, DIMENSION(:,:), ALLOCATABLE :: IU
a2032 3
	ALLOCATE(TT1_Q2(KLM2D,N2D),PLOT2(K,N2))
      	ALLOCATE(Q(KLM2D,N2D),X(N2D),RES(KLMD),CU(2,NKLMD),
     &  IU(2,NKLMD),S(KLMD))
a2048 1
 	DEALLOCATE(TT1_Q2,PLOT2)
d2053 1
a2053 1
     &           K,N2,PLOT1,N,IPT1,IPT2,KP)
d2056 4
a2059 6
CC==LOCAL
	REAL, DIMENSION(:,:), ALLOCATABLE :: T2_Q2,TT1_Q2,
     & 	TT2_Q2,PLOT2
	DOUBLE PRECISION, DIMENSION (:,:),ALLOCATABLE :: Q,CU
      	DOUBLE PRECISION,DIMENSION (:),ALLOCATABLE :: X,RES,S
      	INTEGER, DIMENSION(:,:), ALLOCATABLE :: IU
a2061 3
	ALLOCATE(TT1_Q2(KLM2D,N2D),PLOT2(K,N2))
      	ALLOCATE(Q(KLM2D,N2D),X(N2D),RES(KLMD),CU(2,NKLMD),
     &  IU(2,NKLMD),S(KLMD))
a2076 1
 	DEALLOCATE(TT1_Q2,PLOT2)
d2084 1
a2084 1
      	REAL, DIMENSION(:,:), ALLOCATABLE :: Q2,P,Q3,Q4
d2088 1
d2109 5
a2113 3
      	ALLOCATE(Q2(KLM2D,N2D))
      	ALLOCATE(Q3(KLM2D,N2D))
	ALLOCATE(Q4(KLM2D,N2D))
d2118 1
d2125 1
a2125 1
     &           K,N2,PLOT,ICUT1,ICUT2,KP,N)
d2130 1
a2130 1
     &           K,N2,PLOT1,ICUT1,ICUT2,KP,N)
d2132 4
a2135 6
CC==LOCAL
	REAL, DIMENSION(:,:), ALLOCATABLE :: T2_Q2,TT1_Q2,
     & 	TT2_Q2,PLOT2
	DOUBLE PRECISION, DIMENSION (:,:),ALLOCATABLE :: Q,CU
      	DOUBLE PRECISION,DIMENSION (:),ALLOCATABLE :: X,RES,S
      	INTEGER, DIMENSION(:,:), ALLOCATABLE :: IU
a2137 3
	ALLOCATE(TT1_Q2(KLM2D,N2D),PLOT2(K,N2))
      	ALLOCATE(Q(KLM2D,N2D),X(N2D),RES(KLMD),CU(2,NKLMD),
     &  IU(2,NKLMD),S(KLMD))
a2150 1
 	DEALLOCATE(TT1_Q2,PLOT2)
d2156 1
a2156 1
      	REAL, DIMENSION(:,:), ALLOCATABLE :: Q2,P,Q3,Q4
d2160 1
d2181 5
a2185 3
      	ALLOCATE(Q2(KLM2D,N2D))
      	ALLOCATE(Q3(KLM2D,N2D))
	ALLOCATE(Q4(KLM2D,N2D))
d2195 1
a2195 1
     &           K,N2,PLOT,ICUT1,ICUT2,KP,N)
d2202 1
a2202 1
      	REAL, DIMENSION(:,:), ALLOCATABLE :: Q2,P
d2205 1
d2224 5
a2228 1
      	ALLOCATE(Q2(KLM2D,N2D))
d2235 1
a2235 1
     &           K,N2,N,PLOT,IFIT1,IFIT2,KP)
d2242 1
a2242 1
      	REAL, DIMENSION(:,:), ALLOCATABLE :: Q2,P
d2246 1
d2267 5
a2271 1
      	ALLOCATE(Q2(KLM2D,N2D))
d2276 1
d2281 1
a2281 1
     &           K,N2,PLOT,ICUT1,ICUT2,KP)
d2286 1
a2286 1
     &           K,N2,PLOT1,ICUT1,ICUT2,KP)
d2288 4
a2291 6
CC==LOCAL
	REAL, DIMENSION(:,:), ALLOCATABLE :: T2_Q2,TT1_Q2,
     & 	TT2_Q2,PLOT2
	DOUBLE PRECISION, DIMENSION (:,:),ALLOCATABLE :: Q,CU
      	DOUBLE PRECISION,DIMENSION (:),ALLOCATABLE :: X,RES,S
      	INTEGER, DIMENSION(:,:), ALLOCATABLE :: IU
a2293 3
	ALLOCATE(TT1_Q2(KLM2D,N2D),PLOT2(K,N2))
      	ALLOCATE(Q(KLM2D,N2D),X(N2D),RES(KLMD),CU(2,NKLMD),
     &  IU(2,NKLMD),S(KLMD))
a2307 1
 	DEALLOCATE(TT1_Q2,PLOT2)
d2345 20
a2364 1
	ALLOCATE(NZERO(N_X),TMP_NZERO_M(N_X),X_CC(N_X),X_PEAK(N_X))
d2381 20
a2400 3
	ALLOCATE(TMP_1(NUMBER,4),TMP_2(NUMBER),X_ITGL(N_X,3),
     &           TMP_3(NUMBER))

d2502 11
a2512 1
	ALLOCATE(PLOT(NUMBER,N2),TMP_PLOT(NUMBER,N2))
d2561 1
a2561 1
	REAL, DIMENSION(:,:), ALLOCATABLE :: Q2,P
d2581 5
a2585 1
      	ALLOCATE(Q2(KLM2D,N2D))
d2603 1
a2603 1
     &           K,N2,PLOT,N,ICUT1,ICUT2,KP)
d2612 1
a2612 1
      	REAL, DIMENSION(:,:), ALLOCATABLE :: Q2,P,Q3,Q4
d2616 1
d2637 5
a2641 3
      	ALLOCATE(Q2(KLM2D,N2D))
      	ALLOCATE(Q3(KLM2D,N2D))
	ALLOCATE(Q4(KLM2D,N2D))
d2651 1
a2651 1
     &           K,N2,PLOT,ICUT1,ICUT2,KP,N)
d2658 1
a2658 1
      	REAL, DIMENSION(:,:), ALLOCATABLE :: Q2,P
d2662 1
d2683 5
a2687 2
      	ALLOCATE(Q2(KLM2D,N2D))

d2691 1
d2696 1
a2696 1
     &           K,N2,PLOT,N,ICUT1,ICUT2,KP)
d2708 11
a2718 2
	ALLOCATE(PLOT(NUMBER,N2),TMP_PLOT(NUMBER,N2))

d2758 2
a2759 2
	INTEGER, DIMENSION (:), ALLOCATABLE :: IZERO
      	REAL, DIMENSION(:,:), ALLOCATABLE :: Q2,P
d2763 1
d2783 5
a2787 1
      	ALLOCATE(Q2(KLM2D,N2D))
d2798 1
a2798 1
     &           K,N2,N,PLOT,IFIT1,IFIT2,KP)
d2810 6
a2815 2
	ALLOCATE(TMP_PLOT(NUMBER,N2))

d2907 1
a2907 1
      	REAL, DIMENSION(:,:), ALLOCATABLE :: Q2,P,Q3,Q4
d2911 1
d2930 5
a2934 3
      	ALLOCATE(Q2(KLM2D,N2D))
      	ALLOCATE(Q3(KLM2D,N2D))
	ALLOCATE(Q4(KLM2D,N2D))
d2944 1
a2944 1
     &           K,N2,PLOT,ICUT1,ICUT2,KP,N)
d2949 1
a2949 1
     &           K,N2,PLOT1,ICUT1,ICUT2,KP,N)
d2951 5
a2955 6
CC==LOCAL
	REAL, DIMENSION(:,:), ALLOCATABLE :: T2_Q2,TT1_Q2,
     & 	TT2_Q2,PLOT2
	DOUBLE PRECISION, DIMENSION (:,:),ALLOCATABLE :: Q,CU
      	DOUBLE PRECISION,DIMENSION (:),ALLOCATABLE :: X,RES,S
      	INTEGER, DIMENSION(:,:), ALLOCATABLE :: IU
a2957 4
	ALLOCATE(TT1_Q2(KLM2D,N2D),PLOT2(K,N2))
      	ALLOCATE(Q(KLM2D,N2D),X(N2D),RES(KLMD),CU(2,NKLMD),
     &  IU(2,NKLMD),S(KLMD))

d2969 1
a2969 3
     &         Q,X,RES,CU,S,IU,KLMD,NKLMD,KP)
		
 	DEALLOCATE(TT1_Q2,PLOT2)
d2983 11
a2993 1
	ALLOCATE(TMP(NMB,2),X_DEFO(NMRANK))
d3008 1
a3008 1
            CALL ERRT(36,'ECTF',NE)
d3035 1
d3039 10
a3048 1
	ALLOCATE(PLOT(NUMBER,N2),TMP_X(NUMBER,N2))
d3105 2
a3106 2
	INTEGER, DIMENSION (:), ALLOCATABLE :: IZERO
      	REAL, DIMENSION(:,:), ALLOCATABLE :: Q2,P
d3110 1
d3127 5
a3131 1
      	ALLOCATE(Q2(KLM2D,N2D))
d3153 1
a3153 1
     &           K,N2,PLOT,N,ICUT1,ICUT2,KP)
d3160 4
a3163 6
CC==LOCAL
	REAL, DIMENSION(:,:), ALLOCATABLE :: T2_Q2,TT1_Q2,
     & 	TT2_Q2,PLOT2
	DOUBLE PRECISION, DIMENSION (:,:),ALLOCATABLE :: Q,CU
      	DOUBLE PRECISION,DIMENSION (:),ALLOCATABLE :: X,RES,S
      	INTEGER, DIMENSION(:,:), ALLOCATABLE :: IU
a3165 3
	ALLOCATE(TT1_Q2(KLM2D,N2D),PLOT2(K,N2))
      	ALLOCATE(Q(KLM2D,N2D),X(N2D),RES(KLMD),CU(2,NKLMD),
     &  IU(2,NKLMD),S(KLMD))
a3192 1
 	DEALLOCATE(TT1_Q2,PLOT2)
d3196 1
a3196 1
     &           K,N2,PLOT1,N,ICUT1,ICUT2,KP)
d3198 4
a3201 6
CC==LOCAL
	REAL, DIMENSION(:,:), ALLOCATABLE :: T2_Q2,TT1_Q2,
     & 	TT2_Q2,PLOT2
	DOUBLE PRECISION, DIMENSION (:,:),ALLOCATABLE :: Q,CU
      	DOUBLE PRECISION,DIMENSION (:),ALLOCATABLE :: X,RES,S
      	INTEGER, DIMENSION(:,:), ALLOCATABLE :: IU
a3203 4
	ALLOCATE(TT1_Q2(KLM2D,N2D),PLOT2(K,N2))
      	ALLOCATE(Q(KLM2D,N2D),X(N2D),RES(KLMD),CU(2,NKLMD),
     &  IU(2,NKLMD),S(KLMD))

a3227 1
 	DEALLOCATE(TT1_Q2,PLOT2)
a3231 1
	REAL, DIMENSION(:), ALLOCATABLE :: TMP1,TMP2,TMP3
a3234 2
	ALLOCATE(TMP1(K),TMP2(K),TMP3(K))

a3252 1
	TMP2(1:ICUT2)=PLOT(1:ICUT2,4)
d3259 1
a3259 1
     	DEALLOCATE(TMP1,TMP2,TMP3)
d3283 10
a3292 2
	ALLOCATE(PLOT(NUMBER,N2),TMP_PLOT(NUMBER,N2))

d3391 8
a3398 1
	ALLOCATE(XDEFO(NNLOOP),TMP_OUT(NMB,NT))
d3400 5
d3545 1
a3545 2
cc===============================================================================
CC======================================================================================================
@


1.8
log
@New version by Zhong Huang
@
text
@d29 1
a29 1
	PARAMETER (QUADPI = 3.141592653589793238462643383279502884197)
d102 1
a102 1
     &		LAMBDA,CONTRAST,X_AV_DEFO,IDGREE,AST_AGL,TMP_AMP,TMP_SUM)
d111 2
a112 1
	CALL REG_SET_NSEL(1,5,AST_AGL,TMP_AMP,TMP_SUM,AV_DEFO,XX_CC,IRTFLG)
d115 1
d117 1
d124 1
a124 1
      	PARAMETER (QUADPI = 3.141592653589793238462643383279502884197)
d142 1
d144 1
d147 1
d149 1
a149 1
      	PARAMETER (QUADPI = 3.141592653589793238462643383279502884197)
d198 1
d200 1
d202 1
d205 1
a205 1
	PARAMETER (QUADPI= 3.141592653589793238462643383279502884197)
d466 1
d468 1
d471 1
d542 3
a544 1
     	SUBROUTINE XFIT_BKGND1(K,N2,N,PLOT,ICUT1,ICUT2,ICNSTRNT,ICN_SND,
d546 1
d601 1
d603 1
d607 1
d700 1
d703 1
d759 1
d761 1
d763 1
d805 1
d807 1
d810 1
d890 1
d892 1
d895 1
d1004 1
d1006 1
d1017 2
a1018 1
	INTEGER,DIMENSION(:), ALLOCATABLE :: N_SELECT,TMP_FIRST,TMP_SECND
d1022 1
a1022 1
      	PARAMETER (QUADPI = 3.141592653589793238462643383279502884197)
d1219 1
d1221 1
d1223 1
d1304 1
d1306 1
d1309 1
d1343 1
d1345 1
d1347 1
d1391 1
d1393 1
d1395 1
d1438 1
d1440 1
d1443 1
d1521 1
d1523 1
d1526 1
d1601 1
d1603 1
d1606 1
d1608 1
a1608 1
      	PARAMETER (QUADPI = 3.141592653589793238462643383279502884197)
d1651 1
d1653 1
d1682 1
d1684 1
d1687 1
d1729 1
d1731 1
d1779 1
d1781 1
d1906 1
d1908 1
d1944 1
d1947 1
d2020 1
d2023 1
d2055 1
d2058 1
d2317 1
a2317 1
      	PARAMETER (QUADPI = 3.141592653589793238462643383279502884197)
d2322 2
a2323 1
	REAL,DIMENSION (:),ALLOCATABLE :: TMP_2,TMP_3,TMP_NZERO_M,X_CC,X_PEAK
d2366 2
a2367 1
	ALLOCATE(TMP_1(NUMBER,4),TMP_2(NUMBER),X_ITGL(N_X,3),TMP_3(NUMBER))
d2420 2
a2421 1
	DEALLOCATE(TMP_1,NZERO,TMP_2,TMP_3,X_ITGL,TMP_NZERO_M,X_CC,X_PEAK)
d2423 1
d2425 1
d2427 1
d2735 2
a2736 2
     &		N2,NT,NDGREE,ICUTA,ICUTB,PS,CS,LAMBDA,CONTRAST,IPW_ZERO,
     &		DEFO_MIN,DEFO_MAX,AV_DEFO,XX_CC)
d2811 1
a2811 1
		IF(DEFOCUS.GT.DEFO_MAX.OR.DEFOCUS.LT.AV_DEFO*2./3.) THEN
d2821 2
a2822 1
     &	IPW_ZERO,CS,LAMBDA,CONTRAST,PS,AV_DEFO,DEFO_MIN,DEFO_MAX ,XX_CC)
d2911 1
a2911 1
      	PARAMETER (QUADPI = 3.141592653589793238462643383279502884197)
d3185 1
d3187 1
d3189 1
d3194 1
d3196 3
a3198 1
     &	IPW_ZERO,CS,LAMBDA,CONTRAST,PS,AV_DEFO,DEFO_MIN,DEFO_MAX ,XX_CC)
d3262 1
a3262 1
	PARAMETER (QUADPI = 3.141592653589793238462643383279502884197)
@


1.7
log
@INtel compiler can not have splinen defined as before
@
text
@d1 51
d53 2
a54 8
C **************************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.
C *  TFED.F
C *  COPYRIGHT (C)2002, L.Joyeux&P.A.Penczek
C *  University of Texas - Houston Medical School
C *  pawel.a.penczek@@uth.tmc.edu
C 
C **************************************************************************
d56 469
a524 1
      SUBROUTINE  TFED
d526 2
a527 1
      IMPLICIT		NONE
d529 78
a606 35
      INCLUDE 'CMBLOCK.INC'
      INCLUDE 'F90ALLOC.INC'
  		INTEGER		NLIST
      PARAMETER  (NLIST=6)
      REAL			DLIST(NLIST)
      REAL, DIMENSION(:,:), POINTER ::   PANG


      INTEGER		degree
      INTEGER		x1, x2, x_1
      REAL			count, max
      INTEGER		number 
      REAL			cs, ps, lambda, DefocusAt
      
      CHARACTER*80	file, buffer
      REAL, DIMENSION(:), ALLOCATABLE :: 
     &		value,  env, bezdata, bezdata2, value2, back, value1,
     &		value4, value3
	
      INTEGER		maxxt, maxyt, degbez, irtflg, ne, ier
      REAL			contrast, a, b, c, err
      INTEGER		i,j,k,l,j1,j2, maxi, max1i, k1, degre, m
      REAL			affine, x, bezier, max1
      REAL			delta, quadratic, rect
      REAL          dz, dzmax, ctf_value, ctf, diff_ctf, defocus
      REAL      diff, diffmin, min, fi, spline, spline4, Comb
      REAL          der2x, maxder, der, pi, minder, derminmin, minder1
      INTEGER		dzlow, dzhigh, dzinc, number1
      REAL			suma, sumb, coef
      REAL			GetDefocus
      INTEGER 		limit ,NOT_USED
 		CHARACTER*1   ANS   
      INTEGER	NA, NULL
      
      INTEGER	NDOC
d608 9
a616 1
      DATA  NDOC/88/
d618 392
a1009 1
C     read document file in value()
d1011 35
a1045 2
      CALL RDPRM2(PS,CS,NOT_USED,
     &	          'PIXEL SIZE [A], SPHERICAL ABBERATION CS [MM]')
d1047 1227
a2273 13
C     CONVERT CS TO [A]
      CS = CS*1.0E07

      CALL RDPRM(LAMBDA,NOT_USED,
     &    'WAVELENGTH LAMBDA(ANGSTROEMS)[A]')

      CALL RDPRM(CONTRAST,NOT_USED,'AMPL. CONTRAST RATIO [0-1]')

C     RETRIEVE ARRAY WITH ANGLES DATA IN IT
      MAXXT = 0
      number = 0
      CALL GETDOCDAT('POWER SPECTRUM DOC',.TRUE.,FILE,
     &                77,.TRUE.,MAXXT,number,PANG,IRTFLG)
d2275 2
a2276 21
      IF (IRTFLG .NE. 0) THEN
      	CALL ERRT(4,'TF ED',NE)
      	RETURN
      ENDIF 		
      IF (IRTFLG.NE.0) THEN 
      	CALL ERRT(46,'TF ED',IER)
      	RETURN
      ENDIF

      ! number is even
      number = number /2
      number = number*2
      
C		degbez = number / 6
C		IF(degbez>9) degbez = 9
C		WRITE(NOUT,*) "number of spline points : ", degbez
      
C		WRITE(NOUT,*) __FILE__, " : ", __LINE__
      ALLOCATE(value(number), bezdata(0:20), bezdata2(0:20))

      value(1:NUMBER)=PANG(2,1:NUMBER)
d2278 1
a2278 12
      DEALLOCATE(PANG)
      
      
C
C
C		fit the curve e^(a*x+b) 
C
C

C		WRITE(NOUT,*) __FILE__, " : ", __LINE__
      k = 2			
      WRITE(NOUT,*) "low frequency cut-off ", k
d2280 66
a2345 50
      ALLOCATE(env(number), back(number), value2(number))
      
      
C		WRITE(NOUT,*) __FILE__, " : ", __LINE__
	  	
      limit = MAX0(number/20,3)
	  	DO i= 20, 6, -1
      	CALL FitSplineLogY(value, number, bezdata2, i, -1, 
     F 			6, 11, k, number, back)	!
	  	
      	back = EXP(back)
      	
      	CALL DerArrayN(back, number, value2, 2)
      	
#if 0
      	IF(i.eq.6) THEN
      		DO l=1,number
      			WRITE(NOUT,*) l, back(l), value2(l)
      		END DO
      	END IF
#endif			
      	minder = value2(k+limit)
      	DO l=k+limit, number-limit
      		IF(minder> value2(l))  minder = value2(l) 
      	END DO
      	
      	CALL DerArrayN(back, number, value2, 1)
      	minder1 = value2(k+limit)
      	DO l=k+limit, number-limit
      		IF(minder1> value2(l))  minder1 = value2(l) 
      	END DO
      	
C			WRITE(NOUT,*) i, minder, minder1
C			IF(minder>0) THEN
C				m = i
C				GOTO	101
C			END IF
      	
      	IF(i.eq.20 .or. minder1<maxder) THEN
      		maxder = minder1
      		m = i
      	END IF
      END DO
101	WRITE(NOUT,*) "New degree spline ", m

      CALL FitSplineLogY(value, number, bezdata, m, -1, 
     F			6, 11, 2, number, back)!
	  
	  	back = EXP(back)
      back(1) = back(2)
d2347 345
a2691 30
      
      value2 = value-back
      DO l=1, number
      	IF(value2(l)<0) value2(l) = 0
      	IF(l.eq.1 .or. a<value2(l)) THEN
      		j = l
      		a = value2(l)
      	END IF
      END DO
      
      k = 1
      IF(j<number/10) k = j*1.5
      
      l = MAX0(number/3,3)
      j = l/20+1
      DO i=k, l, j
      	CALL FitSpline(value2, number, bezdata2, m, 
     F				1, 6, 11, i, number, env)
	  		a = SQRT(sum(env(i:number)**2))/2 
      	b = SQRT(sum(value2(i:number)**2))*0.9
C			WRITE(NOUT,*) i, a, b
      	IF(a<b) GOTO 100
      END DO
100	k = i
      WRITE(NOUT,*) "Start ", k
      
      		
C		WRITE(NOUT,*) __FILE__, " : ", __LINE__


d2693 1
a2693 409
C
C
C		search defocus value
C
C

      
      k1 = number
      k = k*2
      ALLOCATE(value1(number))
C		dzmax = 15000
      env = ABS(env)
      WRITE(NOUT,*) number, ps, cs, 
     F 					lambda, dz, contrast
	  
	  	dzmax = GetDefocus(value2, number, ps, cs, lambda,
     F		contrast, env, 2000., 200000., k)
      PRINT *, "dz= ", dzmax
      CALL REG_SET_NSEL(1, 1, Real(dzmax), 0.0, 0.0, 0.0, 0.0, IRTFLG)

C
C
C		output ctf
C
C
      defocus = dzmax
      DO i=1,number
       	DLIST(1) = I
      	ctf_value = ctf(Real(i-1)/number/2, ps, cs, 
     &                 lambda, defocus, contrast)
       	DLIST(2) = value2(i)
      	DLIST(6) = ctf_value*sqrt(env(i))
      	DLIST(3) = DLIST(6)**2
      	DLIST(4) = back(i)
      	DLIST(5) = env(i)

      	CALL SAVD(NDOC,DLIST,NLIST,IRTFLG)
      END DO
      CALL SAVDC
      CLOSE(NDOC)
#if 0		
      CALL RDPRMC(ANS,NA,.TRUE.,
     &       'BUILD WIENER FILTER (Y/N)',NULL,IRTFLG)	 
      IF( (ANS.eq.'Y') .or. (ANS.eq.'y')) THEN
        CALL  RDPRMI(number, I, NLOOP, ILOOP, 'NUMBER OF FREQUENCIES')
      	DO i = 1, number
      		DLIST(1) = I
      		ctf_value = ctf(Real(i-1)/(number-1)/2, ps, cs, 
     &                     lambda, defocus, contrast)
	  			x = Real(i-2)*degbez/number
      		if(x<0) x = 0 
      		DLIST(3) = EXP(spline(x, bezdata, degbez, degree))
      		DLIST(4) = spline(x, bezdata2, degbez, degree)
      		DLIST(5) = ctf_value*sqrt(DLIST(4))
      		DLIST(2) = DLIST(5)**3/(DLIST(5)**4+DLIST(3))
      		CALL SAVD(NDOC,DLIST,NLIST,IRTFLG)
      	END DO
      	CALL SAVDC
      	CLOSE(NDOC)
      END IF
#endif 
      DEALLOCATE(env, back, value2, value1, bezdata, bezdata2)
C      DEALLOCATE(env, back, value2, value, bezdata, bezdata2, value1)
C       DEALLOCATE(value3, value4)
1000 	FORMAT(I5,I2,4F12.5)
1001 	FORMAT(I5)

      END



CCCCCCCCCCCCCCCCCCCCCC
      FUNCTION	affine(x, coef, length, istart, iend, a, b)
      REAL	x(length), coef(length)
      INTEGER	length, istart, iend
      REAL	a, b, fi
      
      REAL	sam, sum2, sumfx, sumf, div, sumc
      INTEGER	N
      
      sam	= 0
      sum2	= 0
      sumfx = 0
      sumf	= 0
      
      DO i=istart, iend
      	fi = i
      	sam   = sam   + fi*coef(i)
      	sum2  = sum2  + fi**2*coef(i)
      	sumfx = sumfx + x(i)*fi*coef(i)
      	sumf	= sumf  + x(i)*coef(i)
      	sumc  = sumc  + coef(i)
      END DO
      
      N=iend-istart+1
      div = 1/(sam**2-sumc*sum2)
      
      a = (sam*sumf-sumc*sumfx)*div
      b = (sam*sumfx-sum2*sumf)*div
      
      affine = 0
      div = 0
      DO i=istart, iend
      	affine = affine +coef(i)*(x(i)-(a*i+b))**2
      	div = div + coef(i)
      END DO
      
      affine = sqrt(affine / div)
      
      RETURN
      END
      		
CCCCCCCCCCCCCCCCCCCCCC
      SUBROUTINE InvMatr3x3(A, B)
      REAL	A(3,3)
      REAL  B(3,3)
      
      B(1,1) = A(2,2)*A(3,3)-A(2,3)*A(3,2)
      B(2,1) = A(3,1)*A(2,3)-A(2,1)*A(3,3)
      B(3,1) = A(2,1)*A(3,2)-A(2,2)*A(3,1)
      
      B(1,2) = A(1,3)*A(3,2)-A(1,2)*A(3,3)
      B(2,2) = A(1,1)*A(3,3)-A(3,1)*A(1,3)
      B(3,2) = A(1,2)*A(3,1)-A(3,2)*A(1,1)
      
      B(1,3) = A(1,2)*A(2,3)-A(1,3)*A(2,2)
      B(2,3) = A(1,3)*A(2,1)-A(1,1)*A(2,3)
      B(3,3) = A(1,1)*A(2,2)-A(1,2)*A(2,1)
      
      B = B / (A(1,1)*(A(2,2)*A(3,3)-A(2,3)*A(3,2))
     &		  +A(1,2)*(A(3,1)*A(2,3)-A(2,1)*A(3,3))
     &		  +A(1,3)*(A(2,1)*A(3,2)-A(2,2)*A(3,1)))
       
      RETURN
      END
      
CCCCCCCCCCCCCCCCCCCCCC
      FUNCTION quadratic(x, coef, length, istart, iend, a, b, c)
      REAL	x(length), coef(length)
      INTEGER	length, istart, iend
      REAL	a, b, c
      REAL	Xv(5),Fv(3)
      REAL	Xm(3,3), Xr(3,3)
      REAL	quadratic, fi

      Xv = 0
      Fv = 0
      DO i=istart, iend
      	fi = i
      	DO j=1,5
      		Xv(j) = Xv(j)+ fi**(j-1)*coef(i)
      	END DO
      	DO j=1,3
      		Fv(j) = Fv(j)+ x(i)*fi**(j-1)*coef(i)
      	END DO
      END DO
      
      DO j=1,3
      	DO i=1,3
      		Xm(i,j)=Xv((j-1)+i)
      	END DO
      END DO

      CALL InvMatr3x3(Xm, Xr)
      
      c = Xr(1,1)*Fv(1)+Xr(2,1)*Fv(2)+Xr(3,1)*Fv(3)
      b = Xr(1,2)*Fv(1)+Xr(2,2)*Fv(2)+Xr(3,2)*Fv(3)
      a = Xr(1,3)*Fv(1)+Xr(2,3)*Fv(2)+Xr(3,3)*Fv(3)
      
      quadratic = 0
      div = 0
      DO i=istart, iend
      	fi = i
      	quadratic = quadratic + 
     &		(x(i)-(a*fi**2+b*fi+c))**2*coef(i)
      	div = div + coef(i)
      END DO
      
      quadratic = sqrt(quadratic / div)
      
      RETURN
      END
      
CCCCCCCCCCCCCCCCCCCCCC
      FUNCTION ctf(f, ps, cs, lambda, defocus, contrast)
C		f between 0 et 0.5
C		ps in angstroem
C		cs in mm
C		defocus in angstroem
C		contrast between 0 and 1
C
      REAL	ctf, f, ps, cs, lambda, defocus, contrast
      PARAMETER(Pi=3.14159265358979)
      REAL	aa, bb, cc, ff
      
      aa = 0.5*Pi*cs*lambda**3
      bb = Pi*lambda
      cc = atan(contrast/(1.0-contrast))
      ff = f/ps
      
      ctf = sin((aa*ff**2-bb*defocus)*ff**2-cc)
      
      RETURN
      END
      
#if 0
CCCCCCCCCCCCCCCCCCCCCC
      FUNCTION diff_ctf(value, env, length, istart, iend, 
     F               ps, cs, lambda, defocus, contrast)
	   REAL value(length), env(length)
      INTEGER	length, istart, iend
      REAL	 	ps, cs, lambda, defocus, contrast
      REAL		sum1, sum2, sum3
      REAL		value_ctf
      
      diff_ctf = 0
      
      DO i=istart, iend
      	value_ctf = ctf(Real(i-1)/length/2, ps, cs,
     &					 lambda, defocus, contrast)
	  		value_ctf = value_ctf**2*env(i)
      	diff_ctf = diff_ctf + (value_ctf-value(i))**2
      END DO
      
      
      RETURN
      END	
#else
CCCCCCCCCCCCCCCCCCCCCC
      FUNCTION diff_ctf(value, env, length, istart, iend, 
     &			ps, cs, lambda, defocus, contrast)
	   REAL     value(length), env(length)
      INTEGER	length, istart, iend
      REAL	 	ps, cs, lambda, defocus, contrast
      REAL		sum1, sum2, sum3
      REAL		value_ctf
      PARAMETER (QUADPI = 3.141592653589793238462643383279502884197)
      REAL		ips
      
      diff_ctf = 0.0

      aa = 0.5*QUADPI*cs*lambda**3
      bb = QUADPI*lambda
      cc = atan(contrast/(1.0-contrast))
      ips = 1/(2.0*ps*(length-1))
      
C		PRINT *, defocus
      DO i=istart, iend
      	ff = REAL(i-1)*ips
      	value_ctf = sin((aa*ff**2-bb*defocus)*ff**2-cc)
      	
	  		value_ctf = value_ctf**2*env(i)
      	diff_ctf = diff_ctf + (value_ctf-value(i))**2
C			PRINT *, i, value_ctf, value(i)
      END DO
C		PRINT *, diff_ctf
      END
CCCCCCCCCCCCCCCCCCCCCC
      SUBROUTINE ctf_signal(value, length,
     &			ps, cs, lambda, defocus, contrast)
	  
      IMPLICIT NONE

      REAL 		QUADPI
      PARAMETER (QUADPI = 3.141592653589793238462643383279502884197)
      REAL		ips
      INTEGER  length, i
      REAL		value(length)
      REAL	 	ps, cs, lambda, defocus, contrast, ff
      REAL		aa, bb, cc
      
	  	aa = 0.5*QUADPI*cs*lambda**3
      bb = QUADPI*lambda
      cc = atan(contrast/(1.0-contrast))
      ips = 1/(2.0*ps*(length-1))
      DO i=1, length
      	ff = REAL(i-1)*ips
      	value(i) = sin((aa*ff**2-bb*defocus)*ff**2-cc)
      END DO
      
      RETURN
      END
#endif

CCCCCCCCCCCCCCCCCCCCCC
      FUNCTION Factorial(n)
      REAL Factorial
      INTEGER i,n
      
      Factorial = 1
      DO i=2,n
      	Factorial = Factorial*i
      END DO
      RETURN
      END
      
CCCCCCCCCCCCCCCCCCCCCC
      FUNCTION	Comb(n, p)
      REAL		Comb
      INTEGER 	n, p	! n \ge p
      REAL		a, b
      
!		Comb = Factorial(n)/Factorial(p)/Factorial(n-p)
      Comb = 1
      a = p+1
      b = 1
      DO i =1,n-p
      	Comb = Comb *  a / b
      	a = a + 1
      	b = b + 1
      END DO
      
      RETURN
      END
      
CCCCCCCCCCCCCCCCCCCCCC
      FUNCTION bezier(x, bezdata, degbez)
      INTEGER  degbez
      REAL		bezier, x, bezdata(0:degbez)
      REAL		Comb
      INTEGER	j

      bezier = 0
      DO j=0,degbez
      	bezier = bezier 
     F       + bezdata(j)*Comb(degbez,j)*x**j*(1-x)**(degbez-j)
      END DO
      
      RETURN
      END

#if 0		
CCCCCCCCCCCCCCCCCCCCCC
      FUNCTION floor(x)
      REAL floor, x
      
      floor = -ceil(-x)
      
      RETURN
      END
#endif
      
CCCCCCCCCCCCCCCCCCCCCC

      FUNCTION spline(x, splinedata, degspline, n)

      ! x \in [0,degbez-1]
      IMPLICIT NONE

      INTEGER	degspline
      REAL		splinedata(0:degspline)
      INTEGER 	i1, i2, i, n
      REAL 		spline4, spline, splinen
      REAL		x, delta
      
      spline = 0
C		i1=x-3
C		i2=-INT(-(x+3))	! floor
C		IF(i1<0) i1=0
C		IF(i2>degspline) i2=degspline
      i1=x-n/2.
      IF(i1<0) i1=0
      i2=-(x+n/2.)
      i2 = -i2
      IF(i2>degspline) i2=degspline
      DO i=0,degspline !i1,i2 !
      	spline = spline + splinen(x-i,n)*splinedata(i)
      END DO 

C		IF(x<n/2.) THEN
      	delta = splinedata(1)-splinedata(0)
      	DO i=-n/2,-1
      		spline = spline 
     F			+ splinen(x-i,n)*(splinedata(0)-delta*(-i))
      	END DO
C		END IF
      
C		IF(x>degspline-n/2.) THEN
      	delta = splinedata(degspline)-splinedata(degspline-1)
      	DO i=degspline+1, degspline+n/2
      		spline = spline 
     F   + splinen(x-i,n)*(splinedata(degspline)+delta*(i-degspline))
      	END DO
C		END IF
      
      RETURN
      END
      
      
CCCCCCCCCCCCCCCCCCCCCC

      FUNCTION spline4(x)

      IMPLICIT NONE
      REAL spline4
      REAL x, x1
      
      x1 = abs(x)

      IF(x1.ge.2) THEN
      	spline4=0
      ELSE IF(x1>1) THEN
      	spline4 = 4./3+x1*(-2+x1*(1-x1/6))
      ELSE
      	spline4 = 2./3+x1**2*(x1/2-1)		
      ENDIF
      
      RETURN
      END
d2695 160
a2854 12
CCCCCCCCCCCCCCCCCCCCCC

      RECURSIVE FUNCTION splinen(x,n) RESULT(ANSWER)

      REAL x,ANSWER
      INTEGER n
      
      IF (n.eq.1) THEN
      	IF (x.ge.-0.5 .and. x<0.5 ) THEN
           ANSWER = 1
      	ELSE
           ANSWER = 0
a2855 2
      	RETURN 
      ENDIF
d2857 59
a2915 6
      IF (abs(x)>n/2.) THEN
      	ANSWER = 0
      	RETURN
      ENDIF
      ANSWER = ( (x+n/2.)*splinen(x+0.5,n-1)
     &			  +(n/2.-x)*splinen(x-0.5,n-1))/(n-1)
d2917 183
a3099 12
      RETURN
      END FUNCTION splinen
      
CCCCCCCCCCCCCCCCCCCCCC

      SUBROUTINE FitSplineLogY(signal, number, coefs, degbez, 
     F		where, degree, nbIter, istart, iend, out)
      IMPLICIT NONE
      
      INTEGER  number, degbez, where, degree, nbIter
      REAL		signal(number), coefs(0:degbez), out(number)
      INTEGER	istart, iend
d3101 46
a3146 18
      REAL		signalLog(number)
      
      signalLog =  LOG(signal)
      CALL	FitSpline(signalLog, number, coefs, degbez, 
     F		where, degree, nbIter, istart, iend, out)
      
      RETURN
      END
      
CCCCCCCCCCCCCCCCCCCCCC
C Input : signal(number)
C Output : coefs(debgez) in log 
C where :  -1,1 for curve under or over the singal
C nbIter : self explain, should be between 10 and 100
C istart, iend : the fit is performed on signal(istart:iend)
C degree : degree of the spline
C
C Nb : the curve is force with positive second derivate 
d3148 639
a3786 189
      SUBROUTINE FitSpline(signal, number, coefs, degbez, 
     F		where, degree, nbIter, istart, iend, out)
      IMPLICIT NONE
      
      INCLUDE 'CMBLOCK.INC'
      INCLUDE 'F90ALLOC.INC'

      INTEGER  number, degbez, where, degree, nbIter
      REAL		signal(number), coefs(0:degbez), out(number)
      INTEGER	istart, iend

      INTEGER i, j, k, l, j1, j2
      REAL		coefsTmp(0:degbez), diff, der2
      REAL		a, scale, b
      REAL		spline, min, max, minder2, x, delta, value
      REAL		SplineN

      scale = Real(iend-istart)/degbez
      coefsTmp = 0
      coefs = 0
      b = 0.5
      DO l=1, nbIter
C			WRITE(NOUT,*) coefs
      	DO i=0, degbez
#if 1
C	lineaire extend
      		a = (1*i+0.5*(degbez-i)) / degbez
      		j1 = (istart*(degbez-(i-a))+iend*(i-a))/degbez
      		j2 = (istart*(degbez-(i+a))+iend*(i+a))/degbez
#endif
#if 0
C sqrt extend
      		a = i-0.5
      		if(a<0) a = 0
      		j1 = istart + (iend-istart)*SQRT(a/degbez)
      		j2 = istart + (iend-istart)*SQRT((i+0.5)/degbez)
#endif				
C                   IF(l.EQ.nbIter) PRINT *, "j1 = ", j1, "j2 =", j2
      		IF(j1<istart) j1 = istart
      		IF(j2>iend) j2 = iend
      		
      		min = 0
      		max = 0
      		minder2 = 0
      		DO j=j1,j2
      			x = degbez*Real(j-istart) / (iend-istart)
      			value =spline(x, coefs, degbez, degree)
      			diff = signal(j) - value
                        IF(j.EQ.j1 .OR. diff<min) min = diff
      			IF(j.EQ.j1 .OR. diff>max) max = diff
      			IF(j.EQ.j1 .OR. der2<minder2) minder2 = der2
C         IF(l.EQ.nbIter) PRINT *,"    ", j, diff, x,  signalLog(j), value
      		END DO
      		IF(where.EQ.-1) THEN
      			delta = min
      		ELSE IF(where.EQ.1) THEN
      			delta = max
      		END IF 
      		
      		IF(l.EQ.1) THEN
      			coefsTmp(i) =  delta
      		ELSE
C                      coefsTmp(i) =  coefsTmp(i) + delta
      			DO j=0, degbez
      				coefsTmp(j) =  coefsTmp(j) 
     F                          + delta*SplineN(Real(j-i),degree)
      			END DO
      		END IF
C                              PRINT *, l, where, i, delta, j1, j2
      	END DO
      	coefs = coefsTmp
      END DO
      
      DO i = istart, iend
      	x = (Real(i)-istart)/ (iend-istart) *degbez
      	out(i) = spline(x, coefs, degbez, degree)
      END DO
      
      DO i=1, istart
      	out(i) = out(istart)
      END DO
      
      DO i=iend, number
      	out(i) = out(iend)
      END DO

      RETURN
      END
      
CCCCCCCCCCCCCCCCCCCCCC
C Input : signal(number)
C Output : coefs(debgez) in log 
C where :  -1,1 for curve under or over the singal
C nbIter : self explain, should be between 10 and 100
C istart, iend : the fit is performed on signal(istart:iend)
C degree : degree of the spline
C
C Nb : the curve is force with positive second derivate 

      SUBROUTINE FitSplineLogYSqrtX(signal, number, coefs, degbez, 
     F		where, degree, nbIter, istart, iend, out)
      IMPLICIT NONE
      
      INCLUDE 'CMBLOCK.INC'
      INCLUDE 'F90ALLOC.INC'

      INTEGER  number, degbez, where, degree, nbIter
      REAL		signal(number), out(number), coefs(0:degbez)
      INTEGER	istart, iend

      INTEGER i, j, k, l, j1, j2, length
      REAL		coefsTmp(0:degbez), diff, der2
      REAL		a, scale, b
      PARAMETER(a=0.5)
      REAL		signalLog(number)
      REAL		spline, min, max, minder2, x, delta, value

      scale = Real(iend-istart)/degbez
      signalLog =  LOG(signal)
      coefsTmp = 0
      coefs = 0
      b = 0.5
      length = iend-istart
      DO l=1, nbIter
C			WRITE(NOUT,*) coefs
      	DO i=0, degbez
      		x = (i-a)/degbez
      		IF(x<0) THEN
      			j1 = istart
      		ELSE
      			j1 = SQRT(x)*length+istart
      		END IF
      		!(istart*(degbez-(i-a))+iend*(i-a))/degbez
      		j2 = length*SQRT((i+a)/degbez)+istart
C                  IF(l.EQ.nbIter) PRINT *, "j1 = ", j1, "j2 =", j2
      		IF(j2>iend) j2 = iend
      		
      		min = 0
      		max = 0
      		minder2 = 0
      		DO j=j1,j2
      			x = (Real(j-istart)/length)**2*degbez
      			!degbez*Real(j-istart) / (iend-istart)
      			value =spline(x, coefs, degbez, degree)
      			diff = signalLog(j) - value
                         IF(j.EQ.j1 .OR. diff<min) min = diff
      			IF(j.EQ.j1 .OR. diff>max) max = diff
C          IF(l.EQ.nbIter) PRINT *,"    ", j, diff, x,  signalLog(j), value
      		END DO
      		IF(where.EQ.-1) THEN
      			delta = min
      		ELSE IF(where.EQ.1) THEN
      			delta = max
      		END IF 
      		
      		IF(l.EQ.1) THEN
                   coefsTmp(i) =  delta
C                    WRITE(NOUT,*) i, j1, j2, length
      		ELSE
      			delta = delta / 2
      			 coefsTmp(i) =  coefsTmp(i) + delta
C                         DO j=0, degbez
C                         coefsTmp(i) =  coefsTmp(i) 
C     F                    + delta*SplineN(Real(j-i),degree)
C                         END DO
      		END IF
C				PRINT *, l, where, i, delta, j1, j2
      	END DO
      	coefs = coefsTmp
      END DO
      
      DO i = istart, iend
      	x = ((Real(i)-istart)/length)**2*degbez
      	out(i) = spline(x, coefs, degbez, degree)
      END DO
      DO i=1, istart
      	out(i) = out(istart)
      END DO

      RETURN
      END
      
CCCCCCCCCCCCCCCCCCCCCC
      FUNCTION Rect(x)
      REAL	Rect, x
      
      Rect = 0
      IF(x.ge.-0.5 .and. x<0.5) Rect = 1
      
a3788 32

CCCCCCCCCCCCCCCCCCCCCC
      SUBROUTINE DerArrayN(A, length, B, N)
      IMPLICIT NONE
      
      INTEGER length, N
      REAL A(length), B(length), C(length)
      
      INTEGER i, j
      
      C = A
      DO i=1, N
      	DO j=1, length-1
      		B(j)=C(j+1)-C(j)
      	END DO
      	B(length) = B(length-1)
      	C = B
      END DO
      
      RETURN
      END
      
CCCCCCCCCCCCCCCCCCCCCC
      FUNCTION DefocusAt(freq, cs, lambda, cphase, phase)
      REAL	PI, DefocusAt, freq, cs, lambda, cphase, phase
      PARAMETER (PI = 3.141592653589793238462643383279502884197)
      
      DefocusAt = cs*lambda**2*f**2/2-(phase+cphase)/(pi*f**2*lambda)
      
      RETURN 
      END
      
@


1.6
log
@NOT_USED was undefined
@
text
@d40 1
a40 1
      REAL      diff, diffmin, min, fi, spline, spline4, Comb, splinen
d532 1
d534 1
d579 1
d581 1
d600 4
a603 2
      RECURSIVE FUNCTION splinen(x,n)
      REAL x
d606 3
a608 3
      IF(n.eq.1) THEN
      	IF(x.ge.-0.5 .and. x<0.5 ) THEN
      		splinen = 1
d610 2
a611 2
      		splinen = 0
      	END IF
d614 3
a616 2
      IF(abs(x)>n/2.) THEN
      	splinen = 0
d619 2
a620 2
      splinen = ( (x+n/2.)*splinen(x+0.5,n-1)
     F			  +(n/2.-x)*splinen(x-0.5,n-1))/(n-1)
a621 1
      
d623 1
a623 1
      END
@


1.5
log
@RDPRM* call param. wrong
@
text
@d45 1
a45 1
      INTEGER 		limit 
@


1.4
log
@dec compiler does not like doubly defined variables
@
text
@d8 1
a8 2
C *    THE CONTENTS OF THIS DOCUMENT CANNOT BE CHANGED WITHOUT WRITTEN
C *    PERMISSION OF THE AUTHOR                          *
d11 1
a11 1

a12 1
      SUBROUTINE  TFED
d39 3
a41 3
      REAL			dz, dzmax, ctf_value, ctf, diff_ctf, defocus
      REAL			diff, diffmin, min, fi, spline, spline4, Comb, splinen
      REAL			der2x, maxder, der, pi, minder, derminmin, minder1
d50 1
d53 4
a56 7
C
C
C		read document file in value()
C
C		
      CALL RDPRM2(PS,CS,NLOOP,ILOOP,
     &	'PIXEL SIZE [A], SPHERICAL ABBERATION CS [MM]')
d61 1
a61 1
      CALL RDPRM(LAMBDA,NLOOP,ILOOP,
d64 1
a64 1
      CALL RDPRM(CONTRAST,NLOOP,ILOOP,'AMPL. CONTRAST RATIO [0-1]')
d70 1
a70 1
     &							77,.TRUE.,MAXXT,number,PANG,IRTFLG)
d218 1
a218 1
     &							 lambda, defocus, contrast)
d233 1
a233 1
        	CALL  RDPRMI(number, I, NLOOP, ILOOP, 'NUMBER OF FREQUENCIES')
d237 1
a237 1
     &							 lambda, defocus, contrast)
d251 2
a252 2
C		DEALLOCATE(env, back, value2, value, bezdata, bezdata2, value1)
C		DEALLOCATE(value3, value4)
d397 1
a397 1
     F						ps, cs, lambda, defocus, contrast)
d514 1
a514 1
     F			 + bezdata(j)*Comb(degbez,j)*x**j*(1-x)**(degbez-j)
d568 1
a568 1
     F		+ splinen(x-i,n)*(splinedata(degspline)+delta*(i-degspline))
d685 1
a685 1
C				IF(l.EQ.nbIter) PRINT *, "j1 = ", j1, "j2 =", j2
d696 1
a696 1
	  				IF(j.EQ.j1 .OR. diff<min) min = diff
d699 1
a699 1
C					IF(l.EQ.nbIter) PRINT *,"    ", j, diff, x,  signalLog(j), value
d710 1
a710 1
C					coefsTmp(i) =  coefsTmp(i) + delta
d713 1
a713 1
     F					+ delta*SplineN(Real(j-i),degree)
d716 1
a716 1
C				PRINT *, l, where, i, delta, j1, j2
d782 1
a782 1
C				IF(l.EQ.nbIter) PRINT *, "j1 = ", j1, "j2 =", j2
d793 1
a793 1
	  				IF(j.EQ.j1 .OR. diff<min) min = diff
d795 1
a795 1
C					IF(l.EQ.nbIter) PRINT *,"    ", j, diff, x,  signalLog(j), value
d804 2
a805 2
      			coefsTmp(i) =  delta
C					WRITE(NOUT,*) i, j1, j2, length
d809 4
a812 4
C					DO j=0, degbez
C						coefsTmp(i) =  coefsTmp(i) 
C     F					+ delta*SplineN(Real(j-i),degree)
C					END DO
@


1.3
log
@renamed ectf.f to tfed.f
@
text
@a31 1
      INTEGER			number
d37 1
a37 1
      REAL			contrast, a, b, c, err, av
d49 1
a49 1
      INTEGER	NA, NULL, nloop, iloop
a385 1
      REAL Pi
@


1.2
log
@*** empty log message ***
@
text
@d4 1
a4 1
C *  ECTF.F
d14 1
a14 1
      SUBROUTINE  ECTF
d78 1
a78 1
      	CALL ERRT(4,'TF ECTF',NE)
d82 1
a82 1
      	CALL ERRT(46,'TF ECTF',IER)
@


1.1
log
@Initial revision
@
text
@d40 1
a40 1
      REAL			affine, sum, x, bezier, max1
d271 1
a271 1
      REAL	sum, sum2, sumfx, sumf, div, sumc
d274 1
a274 1
      sum	= 0
d281 1
a281 1
      	sum   = sum   + fi*coef(i)
d289 1
a289 1
      div = 1/(sum**2-sumc*sum2)
d291 2
a292 2
      a = (sum*sumf-sumc*sumfx)*div
      b = (sum*sumfx-sum2*sumf)*div
@
