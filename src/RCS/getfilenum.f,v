head	1.6;
access;
symbols
	pre_mrcs:1.5
	healthdept_2018:1.5
	pre_getangas:1.4
	GPL2010:1.4
	pre_GPL2010:1.3
	pre_var_equation:1.3
	pre_fftwrings:1.3
	pre_opfiles:1.3
	src:1.3
	best-code:1.3
	x-named-regs:1.3
	x:1.3
	v13-00:1.3
	pre_GPL:1.1
	prec_CA:1.1
	noindx:1.1;
locks; strict;
comment	@c @;


1.6
date	2025.10.25.15.35.25;	author dean;	state Exp;
branches;
next	1.5;

1.5
date	2018.10.03.14.34.07;	author leith;	state Exp;
branches;
next	1.4;

1.4
date	2010.06.24.13.25.50;	author leith;	state Exp;
branches;
next	1.3;

1.3
date	2005.10.17.20.45.51;	author leith;	state Exp;
branches;
next	1.2;

1.2
date	2005.10.17.18.36.16;	author leith;	state Exp;
branches;
next	1.1;

1.1
date	2002.08.13.20.27.11;	author leith;	state Exp;
branches;
next	;


desc
@@


1.6
log
@defined (SP_DBUGIO)
added  GET_IMG_STK subroutine
@
text
@
C++*********************************************************************
C
C GETFILENUM.F  -- NEW JAN 1999                   AUTHOR: ARDEAN LEITH
C                  EXTRACTED FROM LUNSETHDR AUG 02 ARDEAN LEITH
C **********************************************************************
C=*                                                                    *
C=* This file is part of:   SPIDER - Modular Image Processing System.  *
C=* SPIDER System Authors:  Joachim Frank & ArDean Leith               *
C=* Copyright 1985-2010  Health Research Inc.,                         *
C=* Riverview Center, 150 Broadway, Suite 560, Menands, NY 12204.      *
C=* Email: spider@@health.ny.gov                                        *
C=*                                                                    *
C=* SPIDER is free software; you can redistribute it and/or            *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* SPIDER is distributed in the hope that it will be useful,          *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* merchantability or fitness for a particular purpose.  See the GNU  *
C=* General Public License for more details.                           *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program. If not, see <http://www.gnu.org/licenses> *
C=*                                                                    *
C **********************************************************************
C
C    GETFILENUM(FILNAM,IMGNUM,CALLERRT,IRTFLG)  
C
C    PURPOSE:    FINDS FILE NUMBER AT END OF FILENAME
C    
C    PARAMETERS:     FILNAM    CHAR. VARIABLE FILE NAME         (SENT)
C                    IMGNUM    NUMBER IN FILE NAME               (RET.)
C                    NDIGITS   NUMBER OF DIGITS                  (RET.)
C                    CALLERRT  CALL ERRT IF ERROR               (SENT)
C                    IRTFLG    ERROR FLAG                       (RET.)
C
C23456789 123456789 123456789 123456789 123456789 123456789 123456789 12
C--*********************************************************************
 
       SUBROUTINE GETFILENUM(FILNAM,IMGNUM,NDIGITS,CALLERRT,IRTFLG)

       INCLUDE 'CMBLOCK.INC'

       CHARACTER *(*) FILNAM
       CHARACTER *1   CHARI
       LOGICAL        CALLERRT
    
C      FIND NUMBER OF CHAR. IN FILNAM
       NLET   = LNBLNKN(FILNAM)
       IGO    = NLET - 1
       IMGNUM = 0

C      EXTRACT IMGNUM FROM FILENAME
       DO I = NLET,1,-1
          CHARI = FILNAM(I:I)
          IF (CHARI .LT. '0' .OR. CHARI .GT. '9') GOTO 10
          IGO = I 
       ENDDO

10     NDIGITS = NLET - IGO + 1
       IF (NDIGITS .LE. 0 .OR. NDIGITS .GT. 10) THEN
C         NO NUMBER AT END OF FILNAM OR > 10 DIGITS
          IRTFLG = -1
          RETURN
       ENDIF

       READ(FILNAM(IGO:NLET),'(I10)',ERR=999) IMGNUM
       IRTFLG = 0
       RETURN
     
999    WRITE(NOUT,*) '*** CAN NOT GET FILE NUMBER FROM: ',FILNAM(:NLET)
       IF (CALLERRT) THEN
          CALL ERRT(100,'GETFILENUM',NE)
       ENDIF
       IRTFLG = 1

       RETURN
       END


C ************************* GET_IMG_STK *******************************
C
C   GET_IMG_STK(FILNAM,FIL_DIRS,FIL_BASE,FIL_EXT,
C               ISMRC,LOCAST,NSTK,IRTFLG)
C
C   PURPOSE:    FINDS FILE NUMBER AT END OF FILENAME
C    
C   PARAMETERS: FILNAM     CHAR. VARIABLE FILE NAME         (SENT)
C               FIL_NOAT   CHAR. VARIABLE FILE NAME         (RET)
C               FIL_DIRS   CHAR. VARIABLE FILE NAME         (RET)
C               FIL_BASE   CHAR. VARIABLE FILE NAME         (RET)
C               FIL_EXT    CHAR. VARIABLE FILE NAME         (RET)
C               ISMRC      NUMBER IN FILE NAME              (RET.)
C               LOCAST     LOCATION OF * IN FILE NAME       (RET.)
C               NSTK       STACK IMG NUMBER FROM FILE NAME  (RET.)
C                          -2 :  AST IN STACK   
C                          -1 :  NOT A STACK   (NO @@)
C                           0 :  BARE STACK
C                          >1 :  STACKED IMAGE NUMBER
C               CALLERRT   CALL ERRT IF ERROR               (SENT)
C               IRTFLG     ERROR FLAG                       (RET.)
C  
C     IF PRESENT, EXTRACT STACK FILENAME AND NUMBER e.g. from
C     056@@file.mrcs       or file3321@@100.mrcs  or /dir/fileaa@@21 or
C     /dir/fileaa@@21.mrcs or /dir/056@@file         etc 
C
C23456789 123456789 123456789 123456789 123456789 123456789 123456789 12
C--*********************************************************************

      SUBROUTINE GET_IMG_STK(FILNAM,FIL_NOAT,FIL_DIRS,FIL_BASE,FIL_EXT,
     &                ISMRC,LOCAST,NSTK,IRTFLG)

      IMPLICIT NONE

      INCLUDE 'CMBLOCK.INC'
      INCLUDE 'CMLIMIT.INC'

      CHARACTER(LEN=*)      :: FILNAM,FIL_DIRS,FIL_BASE,FIL_EXT
      CHARACTER(LEN=MAXNAM) :: FIL_NOAT
      INTEGER               :: LOCAT,NSTK,IRTFLG

      INTEGER               :: LOCSLASH,NLEN,IGO,LOCDOT,IEND,IASTSB4
      INTEGER               :: IERR,NE,LOCAST,IDIGS,ilen,ILENT
      LOGICAL               :: ISMRC,GOT_EXT
      CHARACTER(LEN=1)      :: NULL = CHAR(0)
 
      INTEGER               :: lnblnkn

      NLEN     = lnblnkn(FILNAM)

C     FIND ENDING LOCATION OF  DIRECTORY(S) IN FILNAM_AT
      LOCSLASH = INDEX(FILNAM(1:NLEN),'/',BACK=.TRUE.)

C     STRIP OFF DIRECTORY(S)
      FIL_DIRS(1:) = NULL
      IF (LOCSLASH > 0) FIL_DIRS = FILNAM(1:LOCSLASH+1)

      !write(3,*)'0000000000000000000'
      !write(3,*)' In get_img_stk; locslash:',locslash
      !ilent = lnblnkn(fil_dirs)
      !write(3,*)' In get_img_stk; fil_dirs: ', fil_dirs(1:ilent)

C     FIND BEGINNING LOCATION OF EXTENSION IN FILNAM

      IEND     = NLEN
      LOCDOT   = INDEX(FILNAM(1:NLEN),'.',BACK=.TRUE.)
      GOT_EXT  = (LOCDOT > 0)

      !write(3,*)' In get_img_stk; nlen,locdot,ilent:',nlen,locdot,ilent

      IF (LOCDOT > 0) FIL_EXT = FILNAM(LOCDOT+1:NLEN)
      
      !write(3,*)' in get_img_stk; nlen,locdot,ilent:',nlen,locdot,ilent
         
      ISMRC = .FALSE.
      IF ((( (INDEX(FIL_EXT,'mrc') ) > 0) .OR. 
     &      ((INDEX(FIL_EXT,'MRC') ) > 0) ))
     &     ISMRC = .TRUE.

C     STRIP OFF DIRECTORY(S) and EXTENSION
      IF (LOCDOT .GT. 0 ) IEND = LOCDOT - 1 
      FIL_BASE  = FILNAM(1:IEND) // NULL

      IEND      = lnblnkn(FIL_BASE)
      LOCAT     = INDEX(FIL_BASE(1:IEND),'@@')
      LOCAST    = INDEX(FIL_BASE(1:IEND),'*')

#if defined (SP_DBUGIO)
      write(3,*)' In get_img_stk; locslash,locdot:',
     &                            locslash,locdot
      write(3,*)' In get_img_stk; locat,locast:',locat,locast

      ilent = lnblnkn(filnam)
      write(3,*)' In get_img_stk; filnam: ',   filnam(1:ilent)
      ilent = lnblnkn(fil_dirs)
      write(3,*)' In get_img_stk; fil_dirs: ', fil_dirs(1:ilent)
      ilent = lnblnkn(fil_base)
      write(3,*)' In get_img_stk; fil_base: ', fil_base(1:ilent) 
      ilent = lnblnkn(fil_ext)
      write(3,*)' In get_img_stk; fil_ext: ',  fil_ext(1:ilent) 
#endif

      IRTFLG   = 0

      IF (LOCAT <= 0) THEN
 
         !write(3,*) '  1111111111111111111111111 '

         FIL_NOAT  = FILNAM
         LOCAST    = INDEX(FIL_NOAT,'*')
         NSTK      = -1   ! NOT A STACK
         GOTO 999    !RETURN

      ELSEIF (LOCAT == 1 ) THEN
C        BARESTACK AT START OF FILE BASENAME

         !write(3,*) '  222222222222222222222 '
 
         NSTK      = -1      ! BARESTACK
         FIL_BASE  = FIL_BASE(2:IEND)
         ILENT     = lnblnkn(FIL_NOAT)
         IF (GOT_EXT) FIL_NOAT = FIL_NOAT(1:ILENT) // '.' // FIL_EXT
         LOCAST    = INDEX(FIL_NOAT,'*')
         !RETURN

      ELSEIF (LOCAT == IEND ) THEN
C        BARESTACK AT END OF FILE BASENAME

        !write(3,*) '  33333333333333333333333 '

         NSTK      = -1      ! BARESTACK
         FIL_BASE  = FIL_BASE(1:IEND-1) // NULL
         ILENT     = lnblnkn(FIL_DIRS)
         FIL_NOAT  = FIL_DIRS(1:ILENT) // FIL_BASE 
         ILENT     = lnblnkn(FIL_NOAT)
         IF (GOT_EXT) FIL_NOAT = FIL_NOAT(1:ILENT) // '.' // FIL_EXT
         LOCAST    = INDEX(FIL_NOAT,'*')
         GOTO 999    !RETURN

      ENDIF

      !write(3,*) '  33333  to  4444444 '

     
      IASTSB4 = VERIFY(FIL_BASE(1:LOCAT-1),'*',.TRUE.) 
      IF ((LOCAT > 1) .AND. (IASTSB4 == 0)) THEN
C        ONLY '*'s  AT START OF FILE BASENAME

         write(3,*) ' 44444444444444444 '

         NSTK      = -2      ! (*)@@
         FIL_BASE  = FIL_BASE(LOCAT+1:IEND) // NULL
         ILENT     = lnblnkn(FIL_DIRS)
         FIL_NOAT  = FIL_DIRS(1:ILENT) // FIL_BASE 
         ILENT     = lnblnkn(FIL_NOAT)
         IF (GOT_EXT) FIL_NOAT = FIL_NOAT(1:ILENT) // '.' // FIL_EXT
         LOCAST    = INDEX(FIL_NOAT,'*')
         GOTO 999    !RETURN
      ENDIF

      !write(3,*) '   4444444 to  55555555555 '


      IASTSB4 = VERIFY(FIL_BASE(LOCAT+1:IEND),'*') 
      IF ((LOCAT > 1) .AND. (IASTSB4 == 0)) THEN
C        ONLY '*'s  AT END OF FILE BASENAME

#if defined (SP_DBUGIO)
       write(3,*)' 55555555; ilen: ', ilen
       write(3,*)' 55555555; iastsb4,locat: ', iastsb4,locat
       write(3,*)' 55555555; iastsb4,fil_base: ', iastsb4,fil_base
       write(3,*)' 55555555; fil_base(1:locat) ', fil_base(1:locat)
#endif
         NSTK      = -2       ! @@(*)
         FIL_BASE  = FIL_BASE(1:LOCAT-1) // NULL
         ILENT     = lnblnkn(FIL_DIRS)
         FIL_NOAT  = FIL_DIRS(1:ILENT) // FIL_BASE 
         ILENT     = lnblnkn(FIL_NOAT)
         IF (GOT_EXT) FIL_NOAT = FIL_NOAT(1:ILENT) // '.' // FIL_EXT
         LOCAST    = INDEX(FIL_NOAT,'*')
         GOTO 999    !RETURN
      ENDIF

      !write(3,*) '   5555555555   TO  7777777777777 '


      IDIGS = VERIFY(FIL_BASE(1:LOCAT-1),'1234567890') 
      IF ((LOCAT > 1) .AND. (IDIGS == 0)) THEN
C        ONLY DIGITS  AT START OF FILE BASENAME BEFORE @@
 
         !write(3,*) '  777777777777777 '

          READ(FIL_BASE(1:LOCAT-1),'(I10)',IOSTAT=IERR) NSTK
         IF (IERR .NE. 0) THEN
             WRITE(NOUT,*)
     &          '*** CAN NOT GET STK NUMBER FROM: ',FIL_BASE(1:LOCAT)
             CALL ERRT(100,'GET_IMG_STK',NE)
             IRTFLG = 1
             RETURN
         ENDIF

         FIL_BASE  = FIL_BASE(LOCAT+1:) // NULL
         ILENT     = lnblnkn(FIL_DIRS)
         FIL_NOAT  = FIL_DIRS(1:ILENT) // FIL_BASE 
         ILENT     = lnblnkn(FIL_NOAT)
         IF (GOT_EXT) FIL_NOAT = FIL_NOAT(1:ILENT) // '.' // FIL_EXT
         LOCAST    = INDEX(FIL_NOAT,'*')
         GOTO 999    !RETURN
      ENDIF

 

      IDIGS = VERIFY(FIL_BASE(LOCAT+1:IEND),'1234567890') 
      IF ((LOCAT < IEND) .AND. (IDIGS == 0)) THEN
C        ONLY DIGITS  AT END OF FILE BASENAME AFTER @@
 
       !write(3,*)' 9999; locat,idigs,iend:', locat,idigs,iend
       !write(3,*)' 9999; fil_base ',  fil_base

       !write(3,*)' 9999; fil_base(1:locat-1): ', fil_base(1:locat-1)

       !write(3,*)' 9999; fil_base(locat+1:iend) ',
       !&                 fil_base(locat+1:iend)

        write(3,*) '  88888888888888888 '

         READ(FIL_BASE(LOCAT+1:IEND),'(I10)',IOSTAT=IERR) NSTK
         IF (IERR .NE. 0) THEN
             WRITE(NOUT,*)
     &         '*** CAN NOT GET STK NUMBER FROM: ',FIL_BASE(LOCAT:IEND)
             CALL ERRT(100,'GET_IMG_STK',NE)
             IRTFLG = 1
             RETURN
         ENDIF

         FIL_BASE  = FIL_BASE(1:LOCAT-1) // NULL
     
         ! ilent = lnblnkn(fil_base)
         !write(3,*)' 99997777; fil_base: ', fil_base

         ILENT     = lnblnkn(FIL_DIRS)
         FIL_NOAT  = FIL_DIRS(1:ILENT) // FIL_BASE 

         ILENT     = lnblnkn(FIL_NOAT)
         IF (GOT_EXT) FIL_NOAT = FIL_NOAT(1:ILENT) // '.' // FIL_EXT
 
        LOCAST    = INDEX(FIL_BASE,'*')

        !ilent = lnblnkn(fil_noat)
        !write(3,*)' 999999999999; fil_noat:', fil_noat(1:ilent)
        !ilent = lnblnkn(fil_base)
        !write(3,*)' 99999999 nstk,irtflg: ', nstk,irtflg,locast

        GOTO 999    
 
        !RETURN
      ENDIF

      write(3,*) '  Should not get to this line!!!!!! '


 999  CONTINUE

#if defined (SP_DBUGIO)
      ilen = lnblnkn(fil_noat)
      write(3,*)' End get_img_stk; fil_noat: ',    fil_noat(1:ilen)
      ilen = lnblnkn(fil_dirs)
      write(3,*)' End get_img_stk; fil_dirs: ',    fil_dirs(1:ilen)
      ilen = lnblnkn(fil_base)
      write(3,*)' End get_img_stk; fil_base: ',    fil_base(1:ilen)
      ilen = lnblnkn(fil_ext)
      write(3,*)' End get_img_stk; fil_ext: ',     fil_ext(1:ilen)

      write(3,*)' End get_img_stk; nstk,irtflg: ', nstk,irtflg

      LOCAST = INDEX(FIL_BASE,'*')
     
      write(3,*)' End get_img_stk; locast: ', locast

      write(3,*)' '
#endif

      END



@


1.5
log
@email_health_dept
@
text
@d26 1
a26 2
C *******************************************************************C **********************************************************************
C
d80 285
@


1.4
log
@GPL_2010
@
text
@d12 1
a12 1
C=* Email: spider@@wadsworth.org                                        *
@


1.3
log
@GPL License fixed
@
text
@a6 2
C=* FROM: SPIDER - MODULAR IMAGE PROCESSING SYSTEM.   AUTHOR: J.FRANK  *
C=* Copyright (C) 1985-2005  Health Research Inc.                      *
d8 5
a12 2
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *   
C=* ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
d14 1
a14 3
C=* Email:  spider@@wadsworth.org                                       *
C=*                                                                    *
C=* This program is free software; you can redistribute it and/or      *
d19 1
a19 1
C=* This program is distributed in the hope that it will be useful,    *
d21 1
a21 1
C=* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
a22 1
C=*                                                                    *
d24 1
a24 3
C=* along with this program; if not, write to the                      *
C=* Free Software Foundation, Inc.,                                    *
C=* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.      *
@


1.2
log
@HRI GPL License used
@
text
@a6 1
C * SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK       *
d10 1
a10 1
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *  
a29 6

C * COPYRIGHT (C)1985, 1999. HEALTH RESEARCH INCORPORATED (HRI),       *
C * ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C * THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HRI AND ARE NOT   *
C * TO BE DISCLOSED TO OTHERS OR USED FOR PURPOSES OTHER THAN INTENDED *
C * WITHOUT WRITTEN APPROVAL OF HRI.                                   *
@


1.1
log
@Initial revision
@
text
@d8 24
@

