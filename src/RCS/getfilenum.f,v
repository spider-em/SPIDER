head	1.7;
access;
symbols
	pre_mrcs:1.5
	healthdept_2018:1.5
	pre_getangas:1.4
	GPL2010:1.4
	pre_GPL2010:1.3
	pre_var_equation:1.3
	pre_fftwrings:1.3
	pre_opfiles:1.3
	src:1.3
	best-code:1.3
	x-named-regs:1.3
	x:1.3
	v13-00:1.3
	pre_GPL:1.1
	prec_CA:1.1
	noindx:1.1;
locks; strict;
comment	@c @;


1.7
date	2025.11.10.22.33.56;	author dean;	state Exp;
branches;
next	1.6;

1.6
date	2025.10.25.15.35.25;	author dean;	state Exp;
branches;
next	1.5;

1.5
date	2018.10.03.14.34.07;	author leith;	state Exp;
branches;
next	1.4;

1.4
date	2010.06.24.13.25.50;	author leith;	state Exp;
branches;
next	1.3;

1.3
date	2005.10.17.20.45.51;	author leith;	state Exp;
branches;
next	1.2;

1.2
date	2005.10.17.18.36.16;	author leith;	state Exp;
branches;
next	1.1;

1.1
date	2002.08.13.20.27.11;	author leith;	state Exp;
branches;
next	;


desc
@@


1.7
log
@*** empty log message ***
@
text
@
C++*********************************************************************
C
C GETFILENUM.F  -- NEW JAN 1999                   AUTHOR: ARDEAN LEITH
C                  EXTRACTED FROM LUNSETHDR AUG 02 ARDEAN LEITH
C
C **********************************************************************
C=*                                                                    *
C=* This file is part of:   SPIDER - Modular Image Processing System.  *
C=* SPIDER System Authors:  Joachim Frank & ArDean Leith               *
C=* Copyright 1985-2010  Health Research Inc.,                         *
C=* Riverview Center, 150 Broadway, Suite 560, Menands, NY 12204.      *
C=* Email:                                                             *
C=*                                                                    *
C=* SPIDER is free software; you can redistribute it and/or            *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* SPIDER is distributed in the hope that it will be useful,          *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* merchantability or fitness for a particular purpose.  See the GNU  *
C=* General Public License for more details.                           *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program. If not, see <http://www.gnu.org/licenses> *
C=*                                                                    *
C **********************************************************************
C
C    GETFILENUM(FILNAM,IMGNUM,NDIGITS,CALLERRT,IRTFLG)  
C
C    PURPOSE:    FINDS FILE NUMBER AT END OF FILENAME
C    
C    PARAMETERS: FILNAM    CHAR. VARIABLE FILE NAME             (SENT)
C                IMGNUM    NUMBER IN FILE NAME                   (RET)
C                NDIGITS   NUMBER OF DIGITS                      (RET)
C                CALLERRT  CALL ERRT IF ERROR                   (SENT)
C                IRTFLG    ERROR FLAG                            (RET)
C
C    CALLED BY:      deletf.f    filgen.f     openinstk.f 
C                    openstk.f   to_peaks.f 
C
C23456789 123456789 123456789 123456789 123456789 123456789 123456789 12
C--*********************************************************************
 
       SUBROUTINE GETFILENUM(FILNAM,IMGNUM,NDIGITS,CALLERRT,IRTFLG)

       IMPLICIT  NONE

       INCLUDE 'CMBLOCK.INC'

       CHARACTER *(*) :: FILNAM
       LOGICAL        :: CALLERRT
       INTEGER        :: IMGNUM,NDIGITS,IRTFLG

       CHARACTER *1   :: CHARI
       INTEGER        :: NLET,IGO,I,NE
       INTEGER        :: lnblnkn


C      FIND NUMBER OF CHAR. IN FILNAM
       NLET   = LNBLNKN(FILNAM)

       IGO    = NLET - 1
       IMGNUM = 0

C      EXTRACT IMGNUM FROM FILENAME
       DO I = NLET,1,-1
          CHARI = FILNAM(I:I)
          IF (CHARI .LT. '0' .OR. CHARI .GT. '9') EXIT
          IGO = I 
       ENDDO

       NDIGITS = NLET - IGO + 1
       IF (NDIGITS .LE. 0 .OR. NDIGITS .GT. 10) THEN
C         NO NUMBER AT END OF FILNAM OR > 10 DIGITS
          IRTFLG = -1
          RETURN
       ENDIF

       READ(FILNAM(IGO:NLET),'(I10)',ERR=999) IMGNUM
       IRTFLG = 0
       RETURN
 
    
999    WRITE(NOUT,*) '*** CAN NOT GET FILE NUMBER FROM: ',FILNAM(:NLET)
       IF (CALLERRT) THEN
          CALL ERRT(100,'GETFILENUM',NE)
       ENDIF
       IRTFLG = 1

       RETURN
       END


C++*********************************************************************
C
C GET_FILNAM_NSTK   NEW OCT 2005                 OCT 2025 ArDean Leith
C               
C **********************************************************************
C=*                                                                    *
C=* This file is part of:   SPIDER - Modular Image Processing System.  *
C=* SPIDER System Authors:  Joachim Frank & ArDean Leith               *
C=* Copyright 1985-2025  Health Research Inc.,                         *
C=* Riverview Center, 150 Broadway, Suite 560, Menands, NY 12204.      *
C=* Email:                                                             *
C=*                                                                    *
C=* SPIDER is free software; you can redistribute it and/or            *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* SPIDER is distributed in the hope that it will be useful,          *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* merchantability or fitness for a particular purpose.  See the GNU  *
C=* General Public License for more details.                           *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program. If not, see <http://www.gnu.org/licenses> *
C=*                                                                    *
C ************************* GET_FILNAM_NSTK ****************************
C
C   GET_FILNAM_NSTK(FILNAM,FIL_NOAT, FIL_DIRS,FIL_BASE,FIL_EXT,
C                   IS_MRC,LOCAST, IS_STK,NSTK_FLG, IRTFLG)
C
C   PURPOSE:    FINDS STACKED IMG  NUMBER IN FILENAME
C    
C   PARAMETERS: FILNAM     CHAR. VARIABLE FILE NAME            (SENT)
C               FIL_NOAT   CHAR. VARIABLE FILE NAME             (RET)
C               FIL_DIRS   CHAR. VARIABLE FILE NAME             (RET)
C               FIL_BASE   CHAR. VARIABLE FILE NAME             (RET)
C               FIL_EXT    CHAR. VARIABLE FILE NAME             (RET)
C               IS_MRC     NUMBER IN FILE NAME                  (RET)
C               LOCAST     LOCATION OF * IN FILE NAME           (RET)
C               IS_STK     IS A STACK                   (SENT or RET)
C               NSTK_FLG   STACK IMG NUMBER FROM FILE NAME      (RET)
C                            -2 :  NOT A STACK   (NO @@)
C                            -1 :  AST IN STACK   
C                             0 :  BARE STACK
C                            >1 :  STACKED IMAGE NUMBER
C
C               IRTFLG     ERROR FLAG                       (RET.)
C  
C     IF PRESENT, EXTRACT STACK FILENAME AND NUMBER e.g. from
C     056@@file.mrcs       or file3321@@100.mrcs  or /dir/fileaa@@21 or
C     /dir/fileaa@@21.mrcs or /dir/056@@file         etc 
C
C23456789 123456789 123456789 123456789 123456789 123456789 123456789 12
C--*********************************************************************

      SUBROUTINE GET_FILNAM_NSTK(FILNAM,
     &                      FIL_NOAT,FIL_DIRS,FIL_BASE,FIL_EXT,
     &                      IS_MRC, LOCAST, IS_STK, NSTK_FLG,IRTFLG)

      IMPLICIT NONE

      INCLUDE 'CMBLOCK.INC'
      INCLUDE 'CMLIMIT.INC'

      CHARACTER(LEN=*)              :: FILNAM,FIL_DIRS,FIL_BASE,FIL_EXT
      CHARACTER(LEN=*),INTENT(OUT)  :: FIL_NOAT
      LOGICAL                       :: IS_MRC,IS_STK
      INTEGER                       :: LOCAST,NSTK_FLG,IRTFLG

      LOGICAL               :: GOT_EXT, IS_MRCS
      INTEGER               :: LOCAT

      INTEGER               :: LOCSLASH,NLEN,IGO,LOCDOT,IENDB,IASTSB4
      INTEGER               :: LOCEXT,IERR,NE,IDIGS,ILENT
      CHARACTER(LEN=1)      :: NULL = CHAR(0)
 
      INTEGER               :: lnblnkn


      NLEN = lnblnkn(FILNAM)

C     FIND ENDING LOCATION OF  DIRECTORY(S) IN FILNAM_AT
      LOCSLASH = INDEX(FILNAM(1:NLEN),'/',BACK=.TRUE.)

C     STRIP OFF DIRECTORY(S)
      FIL_DIRS = NULL
      FIL_BASE = NULL

      IF (LOCSLASH > 0) THEN
          FIL_DIRS = FILNAM(1:LOCSLASH)
          FIL_BASE = FILNAM(LOCSLASH+1:NLEN) 
      ENDIF

#if defined (SP_DBUGIO)
      write(3,*)' In get_filnam_nstk  0000000'
      write(3,*)' In get_filnam_nstk; locslash:',locslash

      ilent = lnblnkn(filnam)
      write(3,*)' In get_filnam_nstk; filnam: ',   filnam(1:ilent)
      ilent = lnblnkn(fil_dirs)
      write(3,*)' In get_filnam_nstk; fil_dirs: ', fil_dirs(1:ilent)
#endif


C     FIND LOCATION OF EXTENSION IN FILNAM
      LOCDOT   = INDEX(FILNAM(1:NLEN),'.',BACK=.TRUE.)

C     EXTRACT  EXTENSION FROM FILNAM
      GOT_EXT  = (LOCDOT > 0)

      FIL_EXT  = NULL
 
      IF (GOT_EXT) THEN
C        GET FILE EXTENSION
         FIL_EXT  = FILNAM(LOCDOT+1:NLEN)

C        STRIP OFF EXTENSION FROM FIL_BASE
         LOCEXT   = INDEX(FIL_BASE,'.',BACK=.TRUE.)
         FIL_BASE = FIL_BASE(1:LOCEXT-1)
      ENDIF
               
      IS_MRC = .FALSE.
      IF  ( ( INDEX(FIL_EXT,'mrc') > 0) .OR. 
     &      ( INDEX(FIL_EXT,'MRC') > 0) ) THEN
        IS_MRC = .TRUE.
      ENDIF

      IS_MRCS = .FALSE.
      IF  ( ( INDEX(FIL_EXT,'mrcs') > 0) .OR. 
     &      ( INDEX(FIL_EXT,'MRCS') > 0) ) THEN
        IS_MRC = .TRUE.
      ENDIF


#if defined (SP_DBUGIO)
      write(3,*)' In get_filnam_nstk; ismrc,ismrcs:', is_mrc,is_mrcs
 
      ilent = lnblnkn(fil_ext)
      write(3,*)' In get_filnam_nstk; fil_ext: ',  fil_ext(1:ilent) 
      ilent = lnblnkn(fil_base)
      write(3,*)' In get_filnam_nstk; fil_base: ', fil_base(1:ilent) 
#endif

      IENDB   = lnblnkn(FIL_BASE)
      LOCAT   = INDEX(FIL_BASE(1:IENDB),'@@')

#if defined (SP_DBUGIO)
      write(3,*)' In get_filnam_nstk; iendb,nlen:',iendb,nlen
      write(3,*)' In get_filnam_nstk; locslash,locdot,locat:',
     &                                locslash,locdot,locat 
        
#endif
      

      IRTFLG   = 0

      IF (LOCAT <= 0 .AND. (.NOT. IS_MRCS)) THEN

#if defined (SP_DBUGIO)
         write(3,*)' In get_filnam_nstk  0000000 '      
#endif

         IS_STK    = .FALSE.
         FIL_NOAT  = FILNAM
         NSTK_FLG  = -2   ! NOT A STACK
         GOTO 999         !RETURN

      ELSEIF (LOCAT <= 0 .AND. IS_MRCS ) THEN

#if defined (SP_DBUGIO)
         write(3,*)' In get_filnam_nstk  1111111 ' 
#endif

         IS_STK    = .TRUE.
         FIL_NOAT  = FILNAM
         NSTK_FLG  = 1      ! MRCS STACK WITHOUT @@
         GOTO 999           ! RETURN

      ELSEIF (LOCAT == 1 ) THEN
C        BARESTACK AT START OF FILE BASENAME

#if defined (SP_DBUGIO)
         write(3,*)'  In GET_FILNAM_NSTK  2222222 '
#endif
 
         IS_STK    = .TRUE.
         NSTK_FLG  = 0      ! BARESTACK
         FIL_BASE  = FIL_BASE(2:IENDB)

         ILENT     = lnblnkn(FIL_NOAT)
         IF (GOT_EXT) FIL_NOAT = FIL_NOAT(1:ILENT) // '.' // FIL_EXT
         GOTO 999   

      ELSEIF (LOCAT == IENDB ) THEN
C        BARESTACK AT END OF FILE BASENAME

#if defined (SP_DBUGIO)
         write(3,*)' In get_filnam_nstk    3333333 '
#endif

         IS_STK    = .TRUE.
         NSTK_FLG  = 0      ! BARESTACK
         FIL_BASE  = FIL_BASE(1:IENDB-1) // NULL

         ILENT     = lnblnkn(FIL_DIRS)
         FIL_NOAT  = FIL_DIRS(1:ILENT) // FIL_BASE 
         ILENT     = lnblnkn(FIL_NOAT)
         IF (GOT_EXT) FIL_NOAT = FIL_NOAT(1:ILENT) // '.' // FIL_EXT
         GOTO 999    

      ENDIF

#if defined (SP_DBUGIO)
      !write(3,*)' In get_filnam_nstk  3333333  to   4444444 '
#endif
   
      IASTSB4 = VERIFY(FIL_BASE(1:LOCAT-1),'*',.TRUE.) 
      IF ((LOCAT > 1) .AND. (IASTSB4 == 0)) THEN
C        ONLY '*'s  AT START OF FILE BASENAME

#if defined (SP_DBUGIO)
         write(3,*)' In get_filnam_nstk 4444444 '
#endif

         IS_STK    = .TRUE.
         NSTK_FLG  = -1      ! (*)@@

         ILENT     = lnblnkn(FIL_DIRS)
         FIL_NOAT  = FIL_DIRS(1:ILENT) // FIL_BASE(LOCAT+1:IENDB) 

         ILENT     = lnblnkn(FIL_NOAT)
         IF (GOT_EXT) FIL_NOAT = FIL_NOAT(1:ILENT) // '.' // FIL_EXT
         GOTO 999    
      ENDIF

#if defined (SP_DBUGIO)
      !write(3,*)' In get_filnam_nstk    4444444 to  5555555 '
#endif

      IASTSB4 = VERIFY(FIL_BASE(LOCAT+1:IENDB),'*') 
      IF ((LOCAT > 1) .AND. (IASTSB4 == 0)) THEN
C        ONLY '*'s  AT END OF FILE BASENAME

#if defined (SP_DBUGIO)
         !write(3,*)' In get_filnam_nstk   5555555 '
         !write(3,*)' In get_filnam_nstk; ilent: ',  ilent
         !write(3,*)' In get_filnam_nstk; iastsb4,locat: ',    iastsb4,locat
         !write(3,*)' In get_filnam_nstk; fil_base ',fil_base(1:locat)
#endif

         IS_STK    = .TRUE.
         NSTK_FLG  = -1       ! @@(*)

         !!FIL_BASE  = FIL_BASE(1:LOCAT-1) // NULL

         ILENT     = lnblnkn(FIL_DIRS)
         FIL_NOAT  = FIL_DIRS(1:ILENT) // FIL_BASE 
         ILENT     = lnblnkn(FIL_NOAT)
         IF (GOT_EXT) FIL_NOAT = FIL_NOAT(1:ILENT) // '.' // FIL_EXT

         GOTO 999  
      ENDIF


#if defined (SP_DBUGIO)
      !write(3,*)' In get_filnam_nstk    5555555   TO  6666666 '
#endif

      IDIGS = VERIFY(FIL_BASE(1:LOCAT-1),'1234567890') 

      IF ((LOCAT > 1) .AND. (IDIGS == 0)) THEN
C        ONLY DIGITS  AT START OF FILE BASENAME BEFORE @@
 
#if defined (SP_DBUGIO)
        write(3,*)' In get_filnam_nstk   6666666 '
#endif

         READ(FIL_BASE(1:LOCAT-1),'(I10)',IOSTAT=IERR) NSTK_FLG
         IF (IERR .NE. 0) THEN
             WRITE(NOUT,*)
     &          '*** CAN NOT GET STK NUMBER FROM: ',FIL_BASE(1:LOCAT)
             CALL ERRT(100,'GET_FILNAM_NSTK',NE)
             IRTFLG = 1
             RETURN
         ENDIF

         IS_STK    = .TRUE.

         ILENT     = lnblnkn(FIL_DIRS)
         FIL_NOAT  = FIL_DIRS(1:ILENT) // FIL_BASE(LOCAT+1:)
 
         ILENT     = lnblnkn(FIL_NOAT)
         IF (GOT_EXT) FIL_NOAT = FIL_NOAT(1:ILENT) // '.' // FIL_EXT

         GOTO 999    !RETURN
      ENDIF

#if defined (SP_DBUGIO)
      !write(3,*)' In get_filnam_nstk    6666666 to  7777777  '
#endif


      IDIGS = VERIFY(FIL_BASE(LOCAT+1:IENDB),'1234567890') 
      IF ((LOCAT < IENDB) .AND. (IDIGS == 0)) THEN
C        ONLY DIGITS  AT END OF FILE BASENAME AFTER @@
 
#if defined (SP_DBUGIO)
        write(3,*)' In get_filnam_nstk    7777777 '
        write(3,*)' In get_filnam_nstk; locat,idigs,iendb:',
     &                                  locat,idigs,iendb
        ilent = lnblnkn(fil_base)
        write(3,*)' In get_filnam_nstk; fil_base ', 
     &                                  fil_base(locat+1:ilent)
c
c        write(3,*)' In get_filnam_nstk; fil_base(:locat-1):',
c     &                                  fil_base(:locat-1)
c
c        write(3,*)' In get_filnam_nstk; fil_base(locat+1:iendb) ',
c     &                                  fil_base(locat+1:iendb)
c
c        ilent = lnblnkn(fil_base)
c        write(3,*)' In get_filnam_nstk; fil_base ', 
c     &                                  fil_base(locat+1:ilent)

#endif

        READ(FIL_BASE(LOCAT+1:IENDB),'(I10)',IOSTAT=IERR) NSTK_FLG

        IF (IERR .NE. 0) THEN
            WRITE(NOUT,*)
     &        '*** CAN NOT GET STK NUMBER FROM: ',FIL_BASE(LOCAT:IENDB)
            CALL ERRT(100,'get_filnam_nstk',NE)
            IRTFLG = 1
            RETURN
        ENDIF

        IS_STK    = .TRUE.

        ILENT     = lnblnkn(FIL_DIRS)
        FIL_NOAT  = FIL_DIRS(1:ILENT) // FIL_BASE(1:LOCAT-1)
 
        ILENT     = lnblnkn(FIL_NOAT)
        IF (GOT_EXT) FIL_NOAT = FIL_NOAT(1:ILENT) // '.' // FIL_EXT
    
        GOTO 999    
 
      ENDIF

      write(3,*) '  Should not get to this line!!!!!! '

 999  CONTINUE

      LOCAST    = INDEX(FIL_NOAT,'*')

#if defined (SP_DBUGIO)

      write(3,*)'  '
      !ilent = lnblnkn(fil_noat)
      !write(3,*)' In get_filnam_nstk; lnblnkn fil_noat: ', ilent
      !ilent = len(fil_noat)
      !write(3,*)' In get_filnam_nstk; ilent fil_noat: ', ilent
      !write(3,*)' End get_filnam_nstk; fil_noat: ',    fil_noat(:ilent)

      ilent = lnblnkn(fil_noat)
      write(3,*)' End get_filnam_nstk; fil_noat: ', fil_noat(1:ilent)

      ilent = lnblnkn(fil_dirs)
      write(3,*)' End get_filnam_nstk; fil_dirs: ', fil_dirs(1:ilent)

      ilent = lnblnkn(fil_base)
      write(3,*)' End get_filnam_nstk; fil_base: ', fil_base(1:ilent)

      ilent = lnblnkn(fil_ext)
      write(3,*)' End get_filnam_nstk; fil_ext:  ', fil_ext(1:ilent)

      write(3,*)' End get_filnam_nstk; locast:   ', locast

      write(3,*)' End get_filnam_nstk; nstk_flg,irtflg: ',
     &                                 nstk_flg,irtflg
   
      write(3,*)' '



        
#endif

      END



@


1.6
log
@defined (SP_DBUGIO)
added  GET_IMG_STK subroutine
@
text
@d6 1
d13 1
a13 1
C=* Email: spider@@health.ny.gov                                        *
d29 1
a29 1
C    GETFILENUM(FILNAM,IMGNUM,CALLERRT,IRTFLG)  
d33 8
a40 5
C    PARAMETERS:     FILNAM    CHAR. VARIABLE FILE NAME         (SENT)
C                    IMGNUM    NUMBER IN FILE NAME               (RET.)
C                    NDIGITS   NUMBER OF DIGITS                  (RET.)
C                    CALLERRT  CALL ERRT IF ERROR               (SENT)
C                    IRTFLG    ERROR FLAG                       (RET.)
d47 2
d51 9
a59 4
       CHARACTER *(*) FILNAM
       CHARACTER *1   CHARI
       LOGICAL        CALLERRT
    
d62 1
d69 1
a69 1
          IF (CHARI .LT. '0' .OR. CHARI .GT. '9') GOTO 10
d73 1
a73 1
10     NDIGITS = NLET - IGO + 1
d83 2
a84 1
     
d95 25
a119 1
C ************************* GET_IMG_STK *******************************
d121 2
a122 2
C   GET_IMG_STK(FILNAM,FIL_DIRS,FIL_BASE,FIL_EXT,
C               ISMRC,LOCAST,NSTK,IRTFLG)
d124 1
a124 1
C   PURPOSE:    FINDS FILE NUMBER AT END OF FILENAME
d126 14
a139 13
C   PARAMETERS: FILNAM     CHAR. VARIABLE FILE NAME         (SENT)
C               FIL_NOAT   CHAR. VARIABLE FILE NAME         (RET)
C               FIL_DIRS   CHAR. VARIABLE FILE NAME         (RET)
C               FIL_BASE   CHAR. VARIABLE FILE NAME         (RET)
C               FIL_EXT    CHAR. VARIABLE FILE NAME         (RET)
C               ISMRC      NUMBER IN FILE NAME              (RET.)
C               LOCAST     LOCATION OF * IN FILE NAME       (RET.)
C               NSTK       STACK IMG NUMBER FROM FILE NAME  (RET.)
C                          -2 :  AST IN STACK   
C                          -1 :  NOT A STACK   (NO @@)
C                           0 :  BARE STACK
C                          >1 :  STACKED IMAGE NUMBER
C               CALLERRT   CALL ERRT IF ERROR               (SENT)
d149 3
a151 2
      SUBROUTINE GET_IMG_STK(FILNAM,FIL_NOAT,FIL_DIRS,FIL_BASE,FIL_EXT,
     &                ISMRC,LOCAST,NSTK,IRTFLG)
d158 10
a167 7
      CHARACTER(LEN=*)      :: FILNAM,FIL_DIRS,FIL_BASE,FIL_EXT
      CHARACTER(LEN=MAXNAM) :: FIL_NOAT
      INTEGER               :: LOCAT,NSTK,IRTFLG

      INTEGER               :: LOCSLASH,NLEN,IGO,LOCDOT,IEND,IASTSB4
      INTEGER               :: IERR,NE,LOCAST,IDIGS,ilen,ILENT
      LOGICAL               :: ISMRC,GOT_EXT
d172 2
a173 1
      NLEN     = lnblnkn(FILNAM)
d179 7
a185 2
      FIL_DIRS(1:) = NULL
      IF (LOCSLASH > 0) FIL_DIRS = FILNAM(1:LOCSLASH+1)
d187 9
a195 4
      !write(3,*)'0000000000000000000'
      !write(3,*)' In get_img_stk; locslash:',locslash
      !ilent = lnblnkn(fil_dirs)
      !write(3,*)' In get_img_stk; fil_dirs: ', fil_dirs(1:ilent)
a196 1
C     FIND BEGINNING LOCATION OF EXTENSION IN FILNAM
d198 1
a198 1
      IEND     = NLEN
d200 2
d204 22
a225 1
      !write(3,*)' In get_img_stk; nlen,locdot,ilent:',nlen,locdot,ilent
a226 21
      IF (LOCDOT > 0) FIL_EXT = FILNAM(LOCDOT+1:NLEN)
      
      !write(3,*)' in get_img_stk; nlen,locdot,ilent:',nlen,locdot,ilent
         
      ISMRC = .FALSE.
      IF ((( (INDEX(FIL_EXT,'mrc') ) > 0) .OR. 
     &      ((INDEX(FIL_EXT,'MRC') ) > 0) ))
     &     ISMRC = .TRUE.

C     STRIP OFF DIRECTORY(S) and EXTENSION
      IF (LOCDOT .GT. 0 ) IEND = LOCDOT - 1 
      FIL_BASE  = FILNAM(1:IEND) // NULL

      IEND      = lnblnkn(FIL_BASE)
      LOCAT     = INDEX(FIL_BASE(1:IEND),'@@')
      LOCAST    = INDEX(FIL_BASE(1:IEND),'*')

#if defined (SP_DBUGIO)
      write(3,*)' In get_img_stk; locslash,locdot:',
     &                            locslash,locdot
      write(3,*)' In get_img_stk; locat,locast:',locat,locast
d228 5
a232 4
      ilent = lnblnkn(filnam)
      write(3,*)' In get_img_stk; filnam: ',   filnam(1:ilent)
      ilent = lnblnkn(fil_dirs)
      write(3,*)' In get_img_stk; fil_dirs: ', fil_dirs(1:ilent)
d234 1
a234 3
      write(3,*)' In get_img_stk; fil_base: ', fil_base(1:ilent) 
      ilent = lnblnkn(fil_ext)
      write(3,*)' In get_img_stk; fil_ext: ',  fil_ext(1:ilent) 
d237 11
d250 16
a265 3
      IF (LOCAT <= 0) THEN
 
         !write(3,*) '  1111111111111111111111111 '
d267 1
d269 2
a270 3
         LOCAST    = INDEX(FIL_NOAT,'*')
         NSTK      = -1   ! NOT A STACK
         GOTO 999    !RETURN
d275 3
a277 1
         !write(3,*) '  222222222222222222222 '
d279 4
a282 2
         NSTK      = -1      ! BARESTACK
         FIL_BASE  = FIL_BASE(2:IEND)
d285 1
a285 2
         LOCAST    = INDEX(FIL_NOAT,'*')
         !RETURN
d287 1
a287 1
      ELSEIF (LOCAT == IEND ) THEN
d290 7
a296 1
        !write(3,*) '  33333333333333333333333 '
a297 2
         NSTK      = -1      ! BARESTACK
         FIL_BASE  = FIL_BASE(1:IEND-1) // NULL
d302 1
a302 2
         LOCAST    = INDEX(FIL_NOAT,'*')
         GOTO 999    !RETURN
d306 4
a309 3
      !write(3,*) '  33333  to  4444444 '

     
d314 6
a319 1
         write(3,*) ' 44444444444444444 '
a320 2
         NSTK      = -2      ! (*)@@
         FIL_BASE  = FIL_BASE(LOCAT+1:IEND) // NULL
d322 2
a323 1
         FIL_NOAT  = FIL_DIRS(1:ILENT) // FIL_BASE 
d326 1
a326 2
         LOCAST    = INDEX(FIL_NOAT,'*')
         GOTO 999    !RETURN
d329 3
a331 2
      !write(3,*) '   4444444 to  55555555555 '

d333 1
a333 1
      IASTSB4 = VERIFY(FIL_BASE(LOCAT+1:IEND),'*') 
d338 4
a341 4
       write(3,*)' 55555555; ilen: ', ilen
       write(3,*)' 55555555; iastsb4,locat: ', iastsb4,locat
       write(3,*)' 55555555; iastsb4,fil_base: ', iastsb4,fil_base
       write(3,*)' 55555555; fil_base(1:locat) ', fil_base(1:locat)
d343 6
a348 2
         NSTK      = -2       ! @@(*)
         FIL_BASE  = FIL_BASE(1:LOCAT-1) // NULL
d353 2
a354 2
         LOCAST    = INDEX(FIL_NOAT,'*')
         GOTO 999    !RETURN
a356 1
      !write(3,*) '   5555555555   TO  7777777777777 '
d358 3
d363 1
d367 3
a369 1
         !write(3,*) '  777777777777777 '
d371 1
a371 1
          READ(FIL_BASE(1:LOCAT-1),'(I10)',IOSTAT=IERR) NSTK
d375 1
a375 1
             CALL ERRT(100,'GET_IMG_STK',NE)
d380 2
a381 1
         FIL_BASE  = FIL_BASE(LOCAT+1:) // NULL
d383 2
a384 1
         FIL_NOAT  = FIL_DIRS(1:ILENT) // FIL_BASE 
d387 1
a387 1
         LOCAST    = INDEX(FIL_NOAT,'*')
d391 4
a394 1
 
d396 2
a397 2
      IDIGS = VERIFY(FIL_BASE(LOCAT+1:IEND),'1234567890') 
      IF ((LOCAT < IEND) .AND. (IDIGS == 0)) THEN
d400 17
a416 2
       !write(3,*)' 9999; locat,idigs,iend:', locat,idigs,iend
       !write(3,*)' 9999; fil_base ',  fil_base
d418 1
a418 1
       !write(3,*)' 9999; fil_base(1:locat-1): ', fil_base(1:locat-1)
d420 1
a420 2
       !write(3,*)' 9999; fil_base(locat+1:iend) ',
       !&                 fil_base(locat+1:iend)
d422 7
a428 1
        write(3,*) '  88888888888888888 '
d430 1
a430 16
         READ(FIL_BASE(LOCAT+1:IEND),'(I10)',IOSTAT=IERR) NSTK
         IF (IERR .NE. 0) THEN
             WRITE(NOUT,*)
     &         '*** CAN NOT GET STK NUMBER FROM: ',FIL_BASE(LOCAT:IEND)
             CALL ERRT(100,'GET_IMG_STK',NE)
             IRTFLG = 1
             RETURN
         ENDIF

         FIL_BASE  = FIL_BASE(1:LOCAT-1) // NULL
     
         ! ilent = lnblnkn(fil_base)
         !write(3,*)' 99997777; fil_base: ', fil_base

         ILENT     = lnblnkn(FIL_DIRS)
         FIL_NOAT  = FIL_DIRS(1:ILENT) // FIL_BASE 
d432 2
a433 2
         ILENT     = lnblnkn(FIL_NOAT)
         IF (GOT_EXT) FIL_NOAT = FIL_NOAT(1:ILENT) // '.' // FIL_EXT
d435 3
a437 7
        LOCAST    = INDEX(FIL_BASE,'*')

        !ilent = lnblnkn(fil_noat)
        !write(3,*)' 999999999999; fil_noat:', fil_noat(1:ilent)
        !ilent = lnblnkn(fil_base)
        !write(3,*)' 99999999 nstk,irtflg: ', nstk,irtflg,locast

a439 1
        !RETURN
d444 1
d446 1
a446 1
 999  CONTINUE
a448 14
      ilen = lnblnkn(fil_noat)
      write(3,*)' End get_img_stk; fil_noat: ',    fil_noat(1:ilen)
      ilen = lnblnkn(fil_dirs)
      write(3,*)' End get_img_stk; fil_dirs: ',    fil_dirs(1:ilen)
      ilen = lnblnkn(fil_base)
      write(3,*)' End get_img_stk; fil_base: ',    fil_base(1:ilen)
      ilen = lnblnkn(fil_ext)
      write(3,*)' End get_img_stk; fil_ext: ',     fil_ext(1:ilen)

      write(3,*)' End get_img_stk; nstk,irtflg: ', nstk,irtflg

      LOCAST = INDEX(FIL_BASE,'*')
     
      write(3,*)' End get_img_stk; locast: ', locast
d450 24
d475 4
@


1.5
log
@email_health_dept
@
text
@d26 1
a26 2
C *******************************************************************C **********************************************************************
C
d80 285
@


1.4
log
@GPL_2010
@
text
@d12 1
a12 1
C=* Email: spider@@wadsworth.org                                        *
@


1.3
log
@GPL License fixed
@
text
@a6 2
C=* FROM: SPIDER - MODULAR IMAGE PROCESSING SYSTEM.   AUTHOR: J.FRANK  *
C=* Copyright (C) 1985-2005  Health Research Inc.                      *
d8 5
a12 2
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *   
C=* ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
d14 1
a14 3
C=* Email:  spider@@wadsworth.org                                       *
C=*                                                                    *
C=* This program is free software; you can redistribute it and/or      *
d19 1
a19 1
C=* This program is distributed in the hope that it will be useful,    *
d21 1
a21 1
C=* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
a22 1
C=*                                                                    *
d24 1
a24 3
C=* along with this program; if not, write to the                      *
C=* Free Software Foundation, Inc.,                                    *
C=* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.      *
@


1.2
log
@HRI GPL License used
@
text
@a6 1
C * SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK       *
d10 1
a10 1
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *  
a29 6

C * COPYRIGHT (C)1985, 1999. HEALTH RESEARCH INCORPORATED (HRI),       *
C * ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C * THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HRI AND ARE NOT   *
C * TO BE DISCLOSED TO OTHERS OR USED FOR PURPOSES OTHER THAN INTENDED *
C * WITHOUT WRITTEN APPROVAL OF HRI.                                   *
@


1.1
log
@Initial revision
@
text
@d8 24
@

