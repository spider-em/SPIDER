head	1.29;
access;
symbols
	pre_mrcs:1.28
	healthdept_2018:1.28
	pre_getangas:1.22
	GPL2010:1.16
	pre_GPL2010:1.15
	pre_var_equation:1.15
	pre_fftwrings:1.13
	pre_opfiles:1.9
	src:1.9
	best-code:1.9
	x-named-regs:1.9
	x:1.9
	v13-00:1.9
	pre_GPL:1.7
	prec_CA:1.4
	noindx:1.4
	Bproc:1.2
	oct21:1.1;
locks; strict;
comment	@c @;


1.29
date	2025.11.10.22.32.19;	author dean;	state Exp;
branches;
next	1.28;

1.28
date	2018.10.03.14.34.03;	author leith;	state Exp;
branches;
next	1.27;

1.27
date	2013.01.09.17.13.52;	author leith;	state Exp;
branches;
next	1.26;

1.26
date	2012.12.14.15.40.55;	author leith;	state Exp;
branches;
next	1.25;

1.25
date	2012.08.23.14.23.43;	author leith;	state Exp;
branches;
next	1.24;

1.24
date	2011.11.04.17.39.27;	author leith;	state Exp;
branches;
next	1.23;

1.23
date	2011.07.28.16.31.19;	author leith;	state Exp;
branches;
next	1.22;

1.22
date	2011.02.09.17.41.48;	author leith;	state Exp;
branches;
next	1.21;

1.21
date	2010.10.22.17.43.08;	author leith;	state Exp;
branches;
next	1.20;

1.20
date	2010.10.21.17.32.52;	author leith;	state Exp;
branches;
next	1.19;

1.19
date	2010.07.13.18.46.14;	author leith;	state Exp;
branches;
next	1.18;

1.18
date	2010.06.29.18.41.34;	author leith;	state Exp;
branches;
next	1.17;

1.17
date	2010.06.24.14.52.16;	author leith;	state Exp;
branches;
next	1.16;

1.16
date	2010.06.24.13.25.22;	author leith;	state Exp;
branches;
next	1.15;

1.15
date	2008.11.07.17.39.36;	author leith;	state Exp;
branches;
next	1.14;

1.14
date	2008.05.19.12.02.42;	author leith;	state Exp;
branches;
next	1.13;

1.13
date	2008.04.09.14.54.59;	author leith;	state Exp;
branches;
next	1.12;

1.12
date	2008.04.09.13.23.52;	author leith;	state Exp;
branches;
next	1.11;

1.11
date	2008.03.31.11.51.11;	author leith;	state Exp;
branches;
next	1.10;

1.10
date	2008.03.19.12.10.05;	author leith;	state Exp;
branches;
next	1.9;

1.9
date	2005.10.17.19.58.13;	author leith;	state Exp;
branches;
next	1.8;

1.8
date	2005.10.17.17.54.32;	author leith;	state Exp;
branches;
next	1.7;

1.7
date	2004.11.04.15.46.07;	author leith;	state Exp;
branches;
next	1.6;

1.6
date	2004.08.17.16.08.40;	author leith;	state Exp;
branches;
next	1.5;

1.5
date	2003.10.30.19.04.02;	author leith;	state Exp;
branches;
next	1.4;

1.4
date	2001.01.30.17.05.32;	author pawel;	state Exp;
branches;
next	1.3;

1.3
date	2000.10.03.20.31.49;	author bimal;	state Exp;
branches;
next	1.2;

1.2
date	2000.08.04.20.44.42;	author bimal;	state Exp;
branches;
next	1.1;

1.1
date	99.08.05.13.20.24;	author pawel;	state Exp;
branches;
next	;


desc
@@


1.29
log
@*** empty log message ***
@
text
@
C++*********************************************************************
C
C CROSRNG_COM.F  MERGED CROSRMG_DS.F & CROSRNG_DS    AUG 04 ARDEAN LEITH
C                REWRITE FOR FFTW3                   MAR 08 ARDEAN LEITH
C                REMOVED TT FOR CROSRNG_EP           JUN 10 ARDEAN LEITH
C                REMOVED CROSRNG_E*                  JUN 10 ARDEAN LEITH
C                CROSRNG_COM_N PARAMETERS            JUL 10 ARDEAN LEITH
C                CROSRNG_COM_R ADDED                 OCT 10 ARDEAN LEITH
C                CROSRNG_COM_RR   IRAY1,IRA          NOV 11 ARDEAN LEITH
C                CROSRNG_COM_NEW  BAD MAXLTEST       AUG 12 ARDEAN LEITH
C **********************************************************************
C=*                                                                    *
C=* This file is part of:   SPIDER - Modular Image Processing System.  *
C=* SPIDER System Authors:  Joachim Frank & ArDean Leith               *
C=* Copyright 1985-2012 Health Research Inc.,                         *
C=* Riverview Center, 150 Broadway, Suite 560, Menands, NY 12204.      *
C=* Email: spider@@wadsworth.org                                        *
C=*                                                                    *
C=* SPIDER is free software; you can redistribute it and/or            *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* SPIDER is distributed in the hope that it will be useful,          *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* merchantability or fitness for a particular purpose.  See the GNU  *
C=* General Public License for more details.                           *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program. If not, see <http://www.gnu.org/licenses> *
C=*                                                                    *
C **********************************************************************
C
C CROSRNG_COM_N(QS,LCIRC,MAXRIN,QMAX,POS_MAX,FFTW3PLAN)
C
C PURPOSE: CROSS CORRELATION OF RADIAL RINGS FOR USE IN ROTATIONAL
C          ALIGNMENT. COMMON CODE FOR CROSRNG_2 CROSRNG_M*
C
C PARAMETERS:
C    QS      - RING FOR FFT                                (SENT)
C    LCIRC   - SIZE OF CIRCS RING ARRAYS                   (SENT)
C    MAXRIN  - LONGEST RING                                (SENT)
C    QMAX    - CC MAX                                      (RETURNED)
C    POS_MAX - POSITION OF CC MAX                          (RETURNED)
C    FFTW3PLAN PLAN FOR FFTW3 REVERSE FOURIER OF MAXRIN    (SENT)
C
C
C    Typical radii:  32, 64, 128, 256, 512  (only)
c               ip: -9    lcirc: 23168
C
C23456789012345678901234567890123456789012345678901234567890123456789012
C--*********************************************************************

cpgi$g opt=3

        SUBROUTINE CROSRNG_COM_N(QS,NRAYS,FFTW3PLAN, QMAX,POS_MAX)

C       COMMON CODE FOR REVERSE FFT AND MAX LOCATION DETERMINATION
C       USES FFT3 OR NATIVE SPIDER FFT
C       NO SGI FFT TT REMAINS 
C       RETURNS: QMAX,POS_MAX
C       CALLERS: crosrng_2.f, crosrng_trans.f


        IMPLICIT NONE

        REAL,             INTENT(INOUT) :: QS(NRAYS+2) ! 2=FFT CMPLX PAD
        INTEGER,          INTENT(IN)    :: NRAYS
        INTEGER*8,        INTENT(IN)    :: FFTW3PLAN  ! STRUCTURE POINTER
        DOUBLE PRECISION, INTENT(OUT)   :: QMAX
        REAL,             INTENT(OUT)   :: POS_MAX

C       AUTOMATIC ARRAYS
        DOUBLE PRECISION                :: T7(-3:3)
        INTEGER                         :: MAXL_ARRAY(1)

        INTEGER                         :: IRTFLG,MAXL,K,J
        REAL                            :: POS

        LOGICAL, PARAMETER              :: SPIDER_SIGN  = .FALSE.
        LOGICAL, PARAMETER              :: SPIDER_SCALE = .FALSE.
        INTEGER, PARAMETER              :: INV = -1   ! REVERSE TRANSFORM

        INTEGER, SAVE :: IDONE = 1

C       REVERSE FOURIER TRANSFORM ON QS

        CALL FMRS(QS,NRAYS,1,1,FFTW3PLAN,
     &            SPIDER_SIGN,SPIDER_SCALE,INV,IRTFLG)
        !call chkreal('real qs',qs,1026, 20,1, 1025)

C       FIND MAXIMUM AND ITS LOCATION INSIDE QS
        MAXL_ARRAY = MAXLOC(QS(1:NRAYS)) ! RETURNS ARRAY OF LENGTH: 1
        MAXL       = MAXL_ARRAY(1)       ! LOCATION OF MAXIMUM
        QMAX       = QS(MAXL)            ! MAXIMUM VALUE

        QMAX       = 1.00048 * QMAX / (NRAYS) ! HACK TO = PRE FFTW3

       
C       INTERPOLATION OVER 3+3 NEIGHBORHOOD AROUND MAXL
        DO K=-3,3
           J     = MOD(MAXL+K+NRAYS-1,NRAYS) + 1
           T7(K) = QS(J)
        ENDDO

        CALL PRB1D(T7,7,POS)
        POS_MAX = FLOAT(MAXL) + POS    ! SUB-PIXEL LOCATION
 
#ifdef DEBUG
        !write(6,*)'nrays:',nrays
        if (idone .le. 2) write(6,901)maxl,qmax
 901    format(' crosrng_com_n; maxl: ',i6,' qmax: ',f16.3)
        idone=idone+1
#endif

        END





C--************************  CROSRNG_COM ******************************

        SUBROUTINE CROSRNG_COM(QS,LCIRC,MAXRIN,QMAX,POS_MAX,TT)

C       COMMON CODE FOR REVERSE TRANSFORM AND MAX LOCATION DETERMINATION
C       FOR USE WITH SPIDER FFT ONLY  CALLED FROM: oracfmskm.f
C       RETURNS: QMAX,POS_MAX,MAXL

        DOUBLE PRECISION              :: QS(MAXRIN + 2)
        INTEGER, INTENT(IN)           :: LCIRC,MAXRIN
        DOUBLE PRECISION, INTENT(OUT) :: QMAX
        REAL, INTENT(OUT)             :: POS_MAX
        DOUBLE PRECISION, INTENT(IN)  :: TT(*)     ! UNUSED

        DOUBLE PRECISION              :: T7(-3:3)
        INTEGER                       :: MAXL_ARRRAY(1)
        
C       REVERSE FOURIER TRANSFORM ON QS   
        IP = -LOG2(MAXRIN)
        CALL FFTR_D(QS,IP)            ! SPIDER FFT

C       FIND MAXIMUM AND ITS LOCATION INSIDE QS
        MAXL_ARRRAY = MAXLOC(QS(1:MAXRIN)) ! RETURNS ARRAY OF LENGTH: 1
        MAXL        = MAXL_ARRRAY(1)       ! LOCATION OF MAXIMUM
        QMAX        = QS(MAXL)             ! MAXIMUM VALUE

        QMAX = QMAX/MAXRIN

C       INTERPOLATION OVER 3+3 NEIGHBORHOOD AROUND MAXL
        DO K=-3,3
           J     = MOD(MAXL+K+MAXRIN-1,MAXRIN) + 1
           T7(K) = QS(J)
        ENDDO

        CALL PRB1D(T7,7,POS)
        POS_MAX = FLOAT(MAXL) + POS    ! SUB-PIXEL LOCATION

        END

C--************************  CROSRNG_COM_RR ******************************

        SUBROUTINE CROSRNG_COM_RR(QS,NRAYS,IRAY1,IRAY2,
     &                           FFTW3PLAN,QMAX,POS_MAX,MAXL)

C       COMMON CODE FOR REVERSE FFT AND MAX LOCATION DETERMINATION
C       USES FFT3 
C       CAN RESTRICT RAY SEARCH RANGE 
C       RETURNS: QMAX,POS_MAX,MAXL

        IMPLICIT NONE

        REAL,        INTENT(INOUT) :: QS(NRAYS+2) ! 2=FFT CMPLX PAD
        INTEGER,     INTENT(IN)    :: NRAYS,IRAY1,IRAY2
        INTEGER*8,   INTENT(IN)    :: FFTW3PLAN  ! STRUCTURE POINTER
        REAL,        INTENT(OUT)   :: QMAX
        REAL,        INTENT(OUT)   :: POS_MAX
        INTEGER,     INTENT(OUT)   :: MAXL

C       AUTOMATIC ARRAYS
        REAL                       :: T7(-3:3)
        INTEGER                    :: MAXL_ARRAY(1)

        INTEGER                    :: IRTFLG,MAXL2,K,J
        REAL                       :: POS

        LOGICAL, PARAMETER         :: SPIDER_SIGN  = .FALSE.
        LOGICAL, PARAMETER         :: SPIDER_SCALE = .FALSE.
        INTEGER, PARAMETER         :: INV = -1   ! REVERSE TRANSFORM

C       REVERSE FOURIER TRANSFORM ON QS
        CALL FMRS(QS,NRAYS,1,1,FFTW3PLAN,
     &            SPIDER_SIGN,SPIDER_SCALE,INV,IRTFLG)
        !call chkreal('real qs',qs,1026, 20,1, 1025)

C       FIND MAXIMUM AND ITS LOCATION INSIDE QS
        IF (IRAY1 > IRAY2) THEN
C          RANGE GOES ACROSS ZERO, BREAK IT IN TWO PARTS
           MAXL_ARRAY = MAXLOC(QS(IRAY1:NRAYS))  ! RETURNS ARRAY OF LENGTH: 1
           MAXL       = IRAY1 + MAXL_ARRAY(1) -1 ! LOCATION OF MAXIMUM

           MAXL_ARRAY = MAXLOC(QS(1:IRAY2))      ! RETURNS ARRAY OF LENGTH: 1
           MAXL2      = MAXL_ARRAY(1)            ! LOCATION OF MAXIMUM

           IF (QS(MAXL2) > QS(MAXL)) MAXL = MAXL2
        ELSE   
           MAXL_ARRAY = MAXLOC(QS(IRAY1:IRAY2)) ! RETURNS ARRAY OF LENGTH: 1
           MAXL       = MAXL_ARRAY(1)           ! LOCATION OF MAXIMUM
        ENDIF

        QMAX       = QS(MAXL)                 ! MAXIMUM VALUE
        QMAX       = 1.00048 * QMAX / (NRAYS) ! HACK TO = PRE FFTW3

C       CAN NOT! USE PRB1 FOR INTERPOLATION OVER 3+3 
C       NEIGHBORHOOD AROUND MAXL SINCE IT IS NOT HIGHEST POINT!!!
        POS_MAX = FLOAT(MAXL)  
 
#ifdef DEBUGNEVER
        !if (maxl .eq. 1) write(6,*) 'bad j:',it
        write(6,*)maxl,pos
 901    format(' crosrng_com_rr; maxl,pos: ',i6,f8.2)
#endif
        END



C--************************  CROSRNG_COM_R ******************************

        SUBROUTINE CROSRNG_COM_R(QS,NRAYS,FFTW3PLAN,QMAX,POS_MAX,MAXL)

C       COMMON CODE FOR REVERSE FFT AND MAX LOCATION DETERMINATION
C       RETURNS: QMAX, POS_MAX, MAXL


        IMPLICIT NONE

        REAL,        INTENT(INOUT) :: QS(NRAYS+2) ! 2=FFT CMPLX PAD
        INTEGER,     INTENT(IN)    :: NRAYS
        INTEGER*8,   INTENT(IN)    :: FFTW3PLAN  ! STRUCTURE POINTER
        REAL,        INTENT(OUT)   :: QMAX
        REAL,        INTENT(OUT)   :: POS_MAX
        INTEGER                    :: MAXL

C       AUTOMATIC ARRAYS
        REAL                       :: T7(-3:3)
        INTEGER                    :: MAXL_ARRAY(1)

        INTEGER                    :: IRTFLG,K,J
        REAL                       :: POS

        LOGICAL, PARAMETER         :: SPIDER_SIGN  = .FALSE.
        LOGICAL, PARAMETER         :: SPIDER_SCALE = .FALSE.
        INTEGER, PARAMETER         :: INV = -1   ! REVERSE TRANSFORM

C       REVERSE FOURIER TRANSFORM ON QS
        CALL FMRS(QS,NRAYS,1,1,FFTW3PLAN,
     &            SPIDER_SIGN,SPIDER_SCALE,INV,IRTFLG)
        !call chkreal('real qs',qs,1026, 20,1, 1025)

C       FIND MAXIMUM AND ITS LOCATION INSIDE QS
        MAXL_ARRAY = MAXLOC(QS(1:NRAYS)) ! RETURNS ARRAY OF LENGTH: 1
        MAXL       = MAXL_ARRAY(1)       ! LOCATION OF MAXIMUM
        QMAX       = QS(MAXL)            ! MAXIMUM VALUE

        QMAX       = 1.00048 * QMAX / (NRAYS) ! HACK TO = PRE FFTW3

C       INTERPOLATION OVER 3+3 NEIGHBORHOOD AROUND MAXL
         DO K=-3,3
           J     = MOD(MAXL+K+NRAYS-1,NRAYS) + 1
           T7(K) = QS(J)
        ENDDO

        CALL PRB1(T7,7,POS)
        POS_MAX = FLOAT(MAXL) + POS    ! SUB-PIXEL LOCATION

        END

























@


1.28
log
@email_health_dept
@
text
@d18 1
a18 1
C=* Email: spider@@health.ny.gov                                        *
@


1.27
log
@removed crosrng_com_new
@
text
@d18 1
a18 1
C=* Email: spider@@wadsworth.org                                        *
@


1.26
log
@comments
@
text
@d60 1
a60 1
C       LIKE: CROSRNG_COM_NEW BUT NO SGI FFT TT REMAINS 
a120 57
C--************************  CROSRNG_COM_NEW ******************************

        SUBROUTINE CROSRNG_COM_NEW(QS,LCIRC,MAXRIN,QMAX,POS_MAX,
     &                             TT,FFTW3PLAN)

C       COMMON CODE FOR REVERSE TRANSFORM AND MAX LOCATION DETERMINATION
C       REMAINS OF SGI FFT SUPPORT: TT
C       RETURNS: QMAX,POS_MAX
C       ONLY CALLER: crosrng.f

        REAL                          :: QS(MAXRIN + 2)
        INTEGER, INTENT(IN)           :: LCIRC,MAXRIN
        DOUBLE PRECISION, INTENT(OUT) :: QMAX
        REAL, INTENT(OUT)             :: POS_MAX
        INTEGER*8, INTENT(IN)         :: FFTW3PLAN  ! STRUCTURE POINTER 
        DOUBLE PRECISION              :: TT(*)      ! UNUSED FROM SGI

C       AUTOMATIC ARRAYS
        DOUBLE PRECISION              :: T7(-3:3)
        INTEGER                       :: MAXL_ARRRAY(1)

        LOGICAL, PARAMETER            :: SPIDER_SIGN  = .FALSE.
        LOGICAL, PARAMETER            :: SPIDER_SCALE = .FALSE.
        INTEGER, PARAMETER            :: INV = -1

C       REVERSE FOURIER TRANSFORM ON QS   
        CALL FMRS(QS,MAXRIN, 1,1,FFTW3PLAN, 
     &            SPIDER_SIGN,SPIDER_SCALE, INV,IRTFLG)
 
C       FIND MAXIMUM AND ITS LOCATION INSIDE QS
        MAXL_ARRRAY = MAXLOC(QS(1:MAXRIN)) ! RETURNS ARRAY OF LENGTH: 1
        MAXL        = MAXL_ARRRAY(1)       ! LOCATION OF MAXIMUM
        QMAX        = QS(MAXL)             ! MAXIMUM VALUE

        IF (MAXL <= 0 .OR. MAXL > MAXRIN) THEN
           CALL ERRT(102,'CROSRNG_COM_NEW; BAD MAXL',MAXL)
           STOP
        ENDIF

C       INTERPOLATION OVER 3+3 NEIGHBORHOOD AROUND MAXL
        DO K=-3,3
           J     = MOD(MAXL+K+MAXRIN-1,MAXRIN) + 1
           T7(K) = QS(J)
        ENDDO

        CALL PRB1D(T7,7,POS)
        POS_MAX = FLOAT(MAXL) + POS    ! SUB-PIXEL LOCATION

        QMAX = 1.00048 * QMAX / (MAXRIN)

#ifdef DEBUGNEVER
        write(6,901)maxl,qmax,f_maxl,qs(15)
 901    format(' crosrng_com_new; maxl: ',i6,' qmax: ',f16.3,
     &         ' f_maxl: ',f10.3,' qs(15):  ',f16.3)
#endif

        END
d232 1
a232 1
C       RETURNS: QMAX,POS_MAX,MAXL
d242 1
d248 1
a248 1
        INTEGER                    :: IRTFLG,MAXL,K,J
@


1.25
log
@CROSRNG_COM_NEW  BAD MAXLTEST
@
text
@d61 3
d127 3
a129 1
C       REMAINS OF SGI FFT SUPPORT
d136 1
a136 1
        DOUBLE PRECISION              :: TT(*)      ! FOR SGI LIBFFT
d185 1
d191 1
a191 1
        DOUBLE PRECISION, INTENT(IN)  :: TT(*)
d224 3
a226 1
C       USES FFT3 OR NATIVE SPIDER FFT
d289 2
@


1.24
log
@MAXLOC(QS(1:MAXRIN), CROSRNG_C
@
text
@d11 1
d16 1
a16 1
C=* Copyright 1985-2011  Health Research Inc.,                         *
d149 5
@


1.23
log
@removed: ifdef SP_LIBFFTW3,
@
text
@d10 1
d15 1
a15 1
C=* Copyright 1985-2010  Health Research Inc.,                         *
d95 1
d145 3
a147 3
        MAXL_ARRRAY = MAXLOC(QS)      ! RETURNS ARRAY OF LENGTH: 1
        MAXL        = MAXL_ARRRAY(1)  ! LOCATION OF MAXIMUM
        QMAX        = QS(MAXL)        ! MAXIMUM VALUE
d149 1
a149 1
C       INTERPOLATION OVER 3x3 NEIGHBORHOOD
d173 1
a173 1
C       FOR USE WITH SPIDER FFT ONLY
d189 3
a191 3
        MAXL_ARRRAY = MAXLOC(QS)      ! RETURNS ARRAY OF LENGTH: 1
        MAXL        = MAXL_ARRRAY(1)  ! LOCATION OF MAXIMUM
        QMAX        = QS(MAXL)        ! MAXIMUM VALUE
d195 1
a195 1
C       INTERPOLATION OVER 3x3 NEIGHBORHOOD
d206 64
a274 1
C       USES FFT3 OR NATIVE SPIDER FFT
a295 2

C       FFTW3 USED
d315 1
a315 1
 
a316 1

@


1.22
log
@ cpgi$g opt=3
@
text
@d54 1
a54 1
         SUBROUTINE CROSRNG_COM_N(QS,NRAYS,FFTW3PLAN, QMAX,POS_MAX)
d79 2
a82 2
#ifdef SP_LIBFFTW3
C       FFTW3 USED
a84 5
#else
C       NATIVE SPIDER FFT USED
        IP = -LOG2(NRAYS)
        CALL FFTR_D(QS,IP)
#endif
a91 1
#ifdef SP_LIBFFTW3
a92 1
#endif
d95 1
a95 1
         DO K=-3,3
d103 7
a112 7
#ifdef DEBUGNEVER
        write(6,901)maxl,qmax,f_maxl,qs(15)
 901    format(' crosrng_com_n; maxl: ',i6,' qmax: ',f16.3,
     &         ' f_maxl: ',f10.3,' qs(15):  ',f16.3)
#endif


d134 1
a134 1
        LOGICAL, PARAMETER            :: SPIDER_SIGN = .FALSE.
a137 1
#ifdef SP_LIBFFTW3        
a140 7
#else
#C      NATIVE SPIDER FFT USED
        IP = -LOG2(MAXRIN)

C       REVERSE FOURIER TRANSFORM ON QS   
        CALL FFTR_D(QS,IP)
#endif
a155 1
#ifdef SP_LIBFFTW3        
a156 1
#endif
a231 1
#ifdef SP_LIBFFTW3
a234 5
#else
C       NATIVE SPIDER FFT USED
        IP = -LOG2(NRAYS)
        CALL FFTR_D(QS,IP)
#endif
a241 1
#ifdef SP_LIBFFTW3
a242 1
#endif
a253 9


#ifdef DEBUGNEVER
        write(6,901)maxl,qmax,f_maxl,qs(15)
 901    format(' crosrng_com_r; maxl: ',i6,
     &         ' qmax: ',  f10.3,
     &         ' f_maxl: ',f10.3 )
#endif

@


1.21
log
@CROSRN_COM_N* PARAM. WRONG
@
text
@d52 2
@


1.20
log
@CROSRNG_COM_R ADDED
@
text
@d52 1
a52 2
         SUBROUTINE CROSRNG_COM_N(QS,NRAYS,USE_OMP,FFTW3PLAN,
     &                            QMAX,POS_MAX)
a61 1
        LOGICAL,          INTENT(IN)    :: USE_OMP
d73 2
a74 1
        LOGICAL, PARAMETER              :: SPIDER_SIGN = .FALSE.
d81 2
a82 1
        CALL FMRS(QS,NRAYS,1,1,FFTW3PLAN,SPIDER_SIGN,USE_OMP,INV,IRTFLG)
d140 1
d145 2
a146 2
        CALL FMRS(QS,MAXRIN, 1,1,FFTW3PLAN, SPIDER_SIGN,.FALSE., 
     &            INV,IRTFLG)
d221 1
a221 2
        SUBROUTINE CROSRNG_COM_R(QS,NRAYS,USE_OMP,FFTW3PLAN,
     &                            QMAX,POS_MAX,MAXL)
d228 5
a232 6
        REAL,             INTENT(INOUT) :: QS(NRAYS+2) ! 2=FFT CMPLX PAD
        INTEGER,          INTENT(IN)    :: NRAYS
        LOGICAL,          INTENT(IN)    :: USE_OMP
        INTEGER*8,        INTENT(IN)    :: FFTW3PLAN  ! STRUCTURE POINTER
        REAL,             INTENT(OUT)   :: QMAX
        REAL,             INTENT(OUT)   :: POS_MAX
d235 2
a236 2
        REAL                            :: T7(-3:3)
        INTEGER                         :: MAXL_ARRAY(1)
d238 2
a239 2
        INTEGER                         :: IRTFLG,MAXL,K,J
        REAL                            :: POS
d241 3
a243 2
        LOGICAL, PARAMETER              :: SPIDER_SIGN = .FALSE.
        INTEGER, PARAMETER              :: INV = -1   ! REVERSE TRANSFORM
d249 2
a250 1
        CALL FMRS(QS,NRAYS,1,1,FFTW3PLAN,SPIDER_SIGN,USE_OMP,INV,IRTFLG)
@


1.19
log
@CROSRNG_COM_N parameter order changed.
@
text
@d9 1
d217 67
@


1.18
log
@moved from crosrng_e.f
@
text
@d8 1
d51 2
a52 1
        SUBROUTINE CROSRNG_COM_N(QS,LCIRC,MAXRIN,QMAX,POS_MAX,FFTW3PLAN)
d54 1
a54 1
C       COMMON CODE FOR REVERSE TRANSFORM AND MAX LOCATION DETERMINATION
d58 8
a65 5
        REAL                          :: QS(MAXRIN + 2)
        INTEGER, INTENT(IN)           :: LCIRC,MAXRIN
        DOUBLE PRECISION, INTENT(OUT) :: QMAX
        REAL, INTENT(OUT)             :: POS_MAX
        INTEGER*8, INTENT(IN)         :: FFTW3PLAN  ! STRUCTURE POINTER 
d68 8
a75 2
        DOUBLE PRECISION              :: T7(-3:3)
        INTEGER                       :: MAXL_ARRRAY(1)
d77 1
a77 2
        LOGICAL, PARAMETER            :: SPIDER_SIGN = .FALSE.
        INTEGER, PARAMETER            :: INV = -1
d79 3
a81 4
#ifdef SP_LIBFFTW3        
C       REVERSE FOURIER TRANSFORM ON QS   
        CALL FMRS(QS,MAXRIN, 1,1,FFTW3PLAN, SPIDER_SIGN,.FALSE., 
     &            INV,IRTFLG)
d84 1
a84 3
        IP = -LOG2(MAXRIN)

C       REVERSE FOURIER TRANSFORM ON QS   
d87 2
a88 1
 
d90 11
a100 7
        MAXL_ARRRAY = MAXLOC(QS)      ! RETURNS ARRAY OF LENGTH: 1
        MAXL        = MAXL_ARRRAY(1)  ! LOCATION OF MAXIMUM
        QMAX        = QS(MAXL)        ! MAXIMUM VALUE

C       INTERPOLATION OVER 3x3 NEIGHBORHOOD
        DO K=-3,3
           J     = MOD(MAXL+K+MAXRIN-1,MAXRIN) + 1
d106 2
a107 4

#ifdef SP_LIBFFTW3        
        QMAX = 1.00048 * QMAX / (MAXRIN)  ! HACK TO GIVE EXACT SAME
#endif
d112 1
a112 1
 901    format(' crosrng_com_new; maxl: ',i6,' qmax: ',f16.3,
a115 1
        END
a116 18



#ifdef NEVER
           J  = NVAL  + 1
           JC = IGOM1 + NVAL 
           IF (NVAL .NE. MAXRIN) THEN
              Q(J)   = Q(J)   + ((CIRC1(JC))   * CIRC2(JC)   + IPOS *
     &                           (CIRC1(JC+1)) * CIRC2(JC+1) / 2.0)
              Q(J+1) = Q(J+1) - ((CIRC1(JC))   * CIRC2(JC+1) + IPOS *
     &                           (CIRC1(JC+1)) * CIRC2(JC) / 2.0)
           ELSE
              Q(J)   = Q(J)   + (CIRC1(JC))   * CIRC2(JC)   + IPOS *
     &                          (CIRC1(JC+1)) * CIRC2(JC+1)
              Q(J+1) = Q(J+1) - (CIRC1(JC))   * CIRC2(JC+1) + IPOS *
     &                          (CIRC1(JC+1)) * CIRC2(JC)
           ENDIF
#endif
@


1.17
log
@REMOVED TT FOR CROSRNG_EP , removed some sgi remanins
@
text
@d4 4
a7 3
C CROSRNG_E.F  MERGED CROSRMG_DS.F & CROSRNG_DS    AUG 04 ARDEAN LEITH
C              REWRITE FOR FFTW3                   MAR 08 ARDEAN LEITH
C              REMOVED TT FOR CROSRNG_EP           JUN 10 ARDEAN LEITH
d30 1
a30 1
C CROSRNG_E(CIRC1,CIRC2,LCIRC,NRING,MAXRIN,NUMR,QMAX,POS_MAX,TT,NEG)
d33 1
a33 1
C          ALIGNMENT. CHECKS ONLY UN-MIRRORED POSITION
d36 2
a37 4
C    CIRC1   - FT OF RINGS MULTIPLIED BY WEIGHTS           (SENT)
C    CIRC2   - FT OF RINGS MULTIPLIED BY WEIGHTS           (SENT)
C    LCIRC   - SIZE OF CIRCS ARRAYS                        (SENT)
C    NRING   - NUMBER OF RINGS                             (SENT)
a38 1
C    NUMR    - RING LOCATION POINTERS                      (SENT)
d41 1
a41 2
C    TT      - USED FOR SGI FFT (UNUSED NOW)               (SENT)
C    NEG     - FLAG FOR CONJUGATE (MIRROR) OF 1'ST RING    (SENT)
a42 19
C    U = 11*21+ 12*22  (e.g.)
C
C    ABNORMAL LOCATION   <MAXRIN       NVAL=MAXRIN    (U = USUAL)
C     E.g. NVAL:            256             512
C        1:                 11x21          11x21         (same)
C        2:                   0            12x22 
C        NVAL-1               U              U           (same)
C        NVAL                 U              U (maxrin)  (same)
C        NVAL+1             12x22            0 (unused)
C        MAXRIN               0 (unused)     U               
C        MAXRIN + 1:          0              0           (same) (unused) 
C        MAXRIN + 2:          0              0           (same) (unused)    
C        summation          0..257         0..514
C
C  NOTES:     COMPLEX CONJUGATE OF COMPLEX NUMBER = a - bi
C             USUAL COMPLEX MULTIPLICATION: (ac-bd),(ad+bc)
C             OUR   COMPLEX MULTIPLICATION: (ac+bd),(-ad+bc) 
C             (If loaded by fmrs can use usual method)
C             SPIDER_SIGN flag when data originally transformed))
a49 89

C--************************  CROSRNG_EP ******************************

        SUBROUTINE CROSRNG_EP(CIRCR,CIRCE,LCIRC, NRING,MAXRIN,NUMR,
     &                        QMAX,POS_MAX, NEG, FFTW3PLAN)

C       USES NUMR TABLE FOR MAPPING INTO Q ARRAY 
C       USES SIMPLIFIED LOGIC FOR BOUNDARY VALUES, FLOATING PT. ARITH.
C       USES FFT3, LIKE CROSRNG_EP_NEW BUT NO SGI FFT TT REMAINS 

        INTEGER, INTENT(IN)           :: NUMR(3,NRING)
        REAL, INTENT(IN)              :: CIRCR(LCIRC), CIRCE(LCIRC)
        DOUBLE PRECISION, INTENT(OUT) :: QMAX
        REAL, INTENT(OUT)             :: POS_MAX
        LOGICAL, INTENT(IN)           :: NEG 

        LOGICAL                       :: NEG_USED

C       AUTOMATIC ARRAY
        REAL                          :: Q(MAXRIN+2)

        NEG_USED = NEG

C       ZERO WHOLE Q ARRAY,  STRAIGHT  = CIRCR * CONJG(CIRCE)
        Q = 0.0
     
        DO I=1,NRING
           IGO   = NUMR(2,I)
           IGOM1 = IGO - 1
           NVAL  = NUMR(3,I)       
           J1    = 1
           
#ifndef SP_LIBFFTW3
C          NATIVE SPIDER FFT
           Q(1) = Q(1) + (CIRCR(IGO)) * CIRCE(IGO)
           IF (NVAL .NE. MAXRIN) THEN
              Q(NVAL+1) = Q(NVAL+1) + (CIRCR(IGO+1)) * CIRCE(IGO+1)
           ELSE
              Q(2)      = Q(2)      + (CIRCR(IGO+1)) * CIRCE(IGO+1)            
           ENDIF
           J1 = 3
#endif

           IF (NEG_USED) THEN
C             FIRST RING SET IS CONJUGATED (MIRRORED)
              DO J=J1,NVAL,2
                 JC     = J + IGOM1

                 Q(J)   = Q(J)   + (CIRCR(JC))   * CIRCE(JC)   -
     &                             (CIRCR(JC+1)) * CIRCE(JC+1)
                 Q(J+1) = Q(J+1) - (CIRCR(JC))   * CIRCE(JC+1) -
     &                             (CIRCR(JC+1)) * CIRCE(JC)
              ENDDO
           ELSE
C             FIRST RING SET IS NON-CONJUGATED (NOT MIRRORED)
              DO J=J1,NVAL,2
                 JC     = J + IGOM1

                 Q(J)   = Q(J)   + (CIRCR(JC))   * CIRCE(JC)   +
     &                             (CIRCR(JC+1)) * CIRCE(JC+1)
                 Q(J+1) = Q(J+1) - (CIRCR(JC))   * CIRCE(JC+1) +
     &                             (CIRCR(JC+1)) * CIRCE(JC)
              ENDDO
           ENDIF
        ENDDO

        CALL CROSRNG_COM_N(Q,LCIRC,MAXRIN,QMAX,POS_MAX,FFTW3PLAN)
 
        END

#ifdef NEVER
           J  = NVAL  + 1
           JC = IGOM1 + NVAL 
           IF (NVAL .NE. MAXRIN) THEN
              Q(J)   = Q(J)   + ((CIRC1(JC))   * CIRC2(JC)   + IPOS *
     &                           (CIRC1(JC+1)) * CIRC2(JC+1) / 2.0)
              Q(J+1) = Q(J+1) - ((CIRC1(JC))   * CIRC2(JC+1) + IPOS *
     &                           (CIRC1(JC+1)) * CIRC2(JC) / 2.0)
           ELSE
              Q(J)   = Q(J)   + (CIRC1(JC))   * CIRC2(JC)   + IPOS *
     &                          (CIRC1(JC+1)) * CIRC2(JC+1)
              Q(J+1) = Q(J+1) - (CIRC1(JC))   * CIRC2(JC+1) + IPOS *
     &                          (CIRC1(JC+1)) * CIRC2(JC)
           ENDIF
#endif


C--************************  CROSRNG_COM_N ******************************

d54 1
a54 1
C       LIKE: CROSRNG_COM_NEQ BUT NO SGI FFT TT REMAINS 
a108 69
C--************************  CROSRNG_EP_NEW ******************************

        SUBROUTINE CROSRNG_EP_NEW(CIRC1,CIRC2,LCIRC, NRING,MAXRIN,NUMR,
     &                           QMAX,POS_MAX, TT,NEG, FFTW3PLAN)

C       USES NUMR TABLE FOR MAPPING INTO Q ARRAY 
C       USES SIMPLIFIED LOGIC FOR BOUNDARY VALUES, FLOATING PT. ARITH.
C       REMAINS OF SGI FFT SUPPORT

        INTEGER, INTENT(IN)           :: NUMR(3,NRING)
        REAL, INTENT(IN)              :: CIRC1(LCIRC), CIRC2(LCIRC)
        DOUBLE PRECISION, INTENT(OUT) :: QMAX
        REAL, INTENT(OUT)             :: POS_MAX
	DOUBLE PRECISION, INTENT(IN)  :: TT(*)
        LOGICAL, INTENT(IN)           :: NEG

        LOGICAL                       :: NEG_USED

C       AUTOMATIC ARRAYS
        REAL                          :: Q(MAXRIN+2)

        NEG_USED = NEG

C       ZERO WHOLE Q ARRAY,  STRAIGHT  = CIRC1 * CONJG(CIRC2)
        Q = 0.0
     
        DO I=1,NRING
           IGO   = NUMR(2,I)
           IGOM1 = IGO - 1
           NVAL  = NUMR(3,I)       
           J1    = 1
           
#ifndef SP_LIBFFTW3
C          NATIVE OR SGI FFT
           Q(1) = Q(1) + (CIRC1(IGO)) * CIRC2(IGO)
           IF (NVAL .NE. MAXRIN) THEN
              Q(NVAL+1) = Q(NVAL+1) + (CIRC1(IGO+1)) * CIRC2(IGO+1)
           ELSE
              Q(2)      = Q(2)      + (CIRC1(IGO+1)) * CIRC2(IGO+1)            
           ENDIF
           J1 = 3
#endif

           IF (NEG_USED) THEN
C             FIRST RING SET IS CONJUGATED (MIRRORED)
              DO J=J1,NVAL,2
                 JC     = J + IGOM1

                 Q(J)   = Q(J)   + (CIRC1(JC))   * CIRC2(JC)   -
     &                             (CIRC1(JC+1)) * CIRC2(JC+1)
                 Q(J+1) = Q(J+1) - (CIRC1(JC))   * CIRC2(JC+1) -
     &                             (CIRC1(JC+1)) * CIRC2(JC)
              ENDDO
           ELSE
C             FIRST RING SET IS NON-CONJUGATED (NOT MIRRORED)
              DO J=J1,NVAL,2
                 JC     = J + IGOM1

                 Q(J)   = Q(J)   + (CIRC1(JC))   * CIRC2(JC)   +
     &                             (CIRC1(JC+1)) * CIRC2(JC+1)
                 Q(J+1) = Q(J+1) - (CIRC1(JC))   * CIRC2(JC+1) +
     &                             (CIRC1(JC+1)) * CIRC2(JC)
              ENDDO
           ENDIF
        ENDDO

        CALL CROSRNG_COM_NEW(Q,LCIRC,MAXRIN,QMAX,POS_MAX,TT,FFTW3PLAN)
 
        END
d148 1
a148 2

        INV = -1
a187 65
C       --------------- CROSRNG_E ------------------------------------

        SUBROUTINE CROSRNG_E(CIRC1,CIRC2,LCIRC, NRING,MAXRIN,NUMR,
     &                           QMAX,POS_MAX,TT,NEG)

C       USES NUMR TABLE FOR MAPPING INTO Q ARRAY 
C       USES SIMPLIFIED LOGIC FOR BOUNDARY VALUES, FLOATING PT. ARITH.
C       FOR USE WITH SPIDER FFT ONLY

        INTEGER, INTENT(IN) :: NUMR(3,NRING)
        REAL, INTENT(IN)    :: CIRC1(LCIRC), CIRC2(LCIRC)
        DOUBLE PRECISION    :: QMAX
        REAL, INTENT(OUT)   :: POS_MAX
	DOUBLE PRECISION    :: TT(*)
        LOGICAL, INTENT(IN) :: NEG

C       AUTOMATIC ARRAYS
        DOUBLE PRECISION    :: Q(MAXRIN+2)

C       ZERO WHOLE Q ARRAY
        Q = 0.0
     
        DO I=1,NRING
           IGO  = NUMR(2,I)
           NVAL = NUMR(3,I)

           Q(1) = Q(1) + (CIRC1(IGO)) * CIRC2(IGO)

           IF (NVAL .NE. MAXRIN) THEN
              Q(NVAL+1) = Q(NVAL+1) + (CIRC1(IGO+1)) * CIRC2(IGO+1)
           ELSE
              Q(2)      = Q(2)      + (CIRC1(IGO+1)) * CIRC2(IGO+1)            
           ENDIF

           IGOM1 = IGO - 1

           IF (NEG) THEN
C             FIRST RING SET IS CONJUGATED (MIRRORED)
              DO J=3,NVAL,2
                 JC     = J + IGOM1

                 Q(J)   = Q(J)   + (CIRC1(JC))   * CIRC2(JC)   -
     &                             (CIRC1(JC+1)) * CIRC2(JC+1)

                 Q(J+1) = Q(J+1) - (CIRC1(JC))   * CIRC2(JC+1) -
     &                             (CIRC1(JC+1)) * CIRC2(JC)
              ENDDO
           ELSE
C             FIRST RING SET IS NON-CONJUGATED (NOT MIRRORED)
              DO J=3,NVAL,2
                 JC     = J + IGOM1

                 Q(J)   = Q(J)   + (CIRC1(JC))   * CIRC2(JC)   +
     &                             (CIRC1(JC+1)) * CIRC2(JC+1)

                 Q(J+1) = Q(J+1) - (CIRC1(JC))   * CIRC2(JC+1) +
     &                             (CIRC1(JC+1)) * CIRC2(JC)
              ENDDO
           ENDIF
        ENDDO

        CALL CROSRNG_COM(Q,LCIRC,MAXRIN,QMAX,POS_MAX,TT)
 
        END

d205 2
a206 5

        IP = MAXRIN

        IP = -LOG2(IP)
        CALL FFTR_D(QS,IP)
@


1.16
log
@GPL_2010
@
text
@d6 1
d35 7
a41 7
C    CIRC1  - FT OF RINGS MULTIPLIED BY WEIGHTS           (SENT)
C    CIRC2  - FT OF RINGS MULTIPLIED BY WEIGHTS           (SENT)
C    LCIRC  - SIZE OF CIRCS ARRAYS                        (SENT)
C    NRING  - NUMBER OF RINGS                             (SENT)
C    MAXRIN - LONGEST RING                                (SENT)
C    NUMR   - RING LOCATION POINTERS                      (SENT)
C    QMAX   - CC MAX                                      (RETURNED)
d43 2
a44 2
C    TT     - USED FOR SGI FFT (UNUSED NOW)               (SENT)
C    NEG    - FLAG FOR CONJUGATE (MIRROR) OF 1'ST RING    (SENT)
d46 1
a46 1
C     U = 11*21+ 12*22  (e.g.)
d48 1
a48 1
C     ABNORMAL LOCATION   <MAXRIN       NVAL=MAXRIN   (U = USUAL)
d64 1
a64 1
C              SPIDER_SIGN flag when data originally transformed))
d67 2
a68 1
c  ip:            -9    lcirc:          23168
d73 146
d227 1
d314 1
d336 1
a336 11
#if defined (SP_LIBFFT)
C       SGI FFT USED
        LDA         = 1
        QS(MAXRIN+1) = QS(2)
        QS(2)        = 0.0
        QS(MAXRIN+2) = 0.0

C       REVERSE FOURIER TRANSFORM ON QS   
        CALL ZDFFT1DU(INV,MAXRIN,QS,LDA,TT)
#else
C       NATIVE SPIDER FFT USED
a341 1
#endif
d363 1
a363 1
 901    format(' crosrng_com_s; maxl: ',i6,' qmax: ',f16.3,
d376 1
d439 1
a453 8
#ifdef SP_LIBFFT
        INV         = -1
        LDA         = 1
        QS(MAXRIN+1) = QS(2)
        QS(2)        = 0.0
        QS(MAXRIN+2) = 0.0
        CALL ZDFFT1DU(INV,IP,QS,LDA,TT)
#else
a455 1
#endif
a461 1
#ifdef SP_LIBFFT
a462 1
#endif
d473 15
a487 5
#ifdef DEBUGNEVER
        write(6,901)maxl,qmax,f_maxl,qs(15)
 901    format(' crosrng_com_s; maxl: ',i6,' qmax: ',f16.3,
     &         ' f_maxl: ',f10.3,' qs(15):  ',f16.3)
#endif
a488 1
        END
@


1.15
log
@*** empty log message ***
@
text
@a6 2
C=* FROM: SPIDER - MODULAR IMAGE PROCESSING SYSTEM.   AUTHOR: J.FRANK  *
C=* Copyright (C) 1985-2008  Health Research Inc.                      *
d8 5
a12 2
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *
C=* ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
d14 1
a14 3
C=* Email:  spider@@wadsworth.org                                       *
C=*                                                                    *
C=* This program is free software; you can redistribute it and/or      *
d19 1
a19 1
C=* This program is distributed in the hope that it will be useful,    *
d21 1
a21 1
C=* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
a22 1
C=*                                                                    *
d24 1
a24 3
C=* along with this program; if not, write to the                      *
C=* Free Software Foundation, Inc.,                                    *
C=* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.      *
@


1.14
log
@FFTW3 plan changes, FFTW aprings, speed
@
text
@d10 2
a11 1
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *   C=* ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
@


1.13
log
@reverted to pre aprings change
@
text
@d1 1
d4 2
a5 2
C CROSRNG_E.F 
C                  MERGED CROSRMG_DS.F & CROSRNG_DS  AUG 04 ARDEAN LEITH
d8 1
a8 1
C=* Copyright (C) 1985-2005  Health Research Inc.                      *
d10 1
a10 2
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *   
C=* ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
d31 18
a48 1
C CROSRNG_E(CIRC1,CIRC2,LCIRC,NRING,MAXRIN,NUMR,QN,TOT,TT,NEG)
d50 11
a60 1
C CHECKS SINGLE POSITION, NEG IS FLAG FOR CHECKING MIRRORED POSITION
d62 5
a66 3
C  INPUT - FOURIER TRANSFORMS OF RINGS!
C  FIRST SET IS CONJUGATED (MIRRORED) IF NEG
C  CIRC1 ALREADY MULTIPLIED BY WEIGHTS!
d68 2
a72 2
	SUBROUTINE CROSRNG_E(CIRC1,CIRC2,LCIRC,NRING,MAXRIN,NUMR,
     &                        QN,TOT,TT,NEG)
d74 17
a90 4
	INTEGER           NUMR(3,NRING)
	DIMENSION         CIRC1(LCIRC),CIRC2(LCIRC)
	DOUBLE PRECISION  TT(*),QN
	LOGICAL           NEG
d93 50
a142 3
	DIMENSION         T(MAXRIN+2)
	DOUBLE PRECISION  Q(MAXRIN+2)
	DOUBLE PRECISION  T7(-3:3)
a143 1
	IP = MAXRIN
d145 14
a158 2
#ifndef SP_LIBFFT
	IP = -LOG2(IP)
a160 5
C       ZERO Q ARRAY
	Q = 0.0D0
     
	T(MAXRIN+1) = 0.0
	T(MAXRIN+2) = 0.0
d162 1
a162 3
	DO I=1,NRING
	   NUMR3I = NUMR(3,I)
	   NUMR2I = NUMR(2,I)
d164 2
a165 1
	   T(1)   = (CIRC1(NUMR2I)) * CIRC2(NUMR2I)
d167 1
a167 4
	   IF (NUMR3I .NE. MAXRIN) THEN
C             TEST .NE. FIRST FOR SPEED ON SOME COMPILERS
	      T(NUMR3I+1) = CIRC1(NUMR2I+1) * CIRC2(NUMR2I+1)
	      T(2)        = 0.0
d169 6
a174 2
              IF (NEG) THEN
C                FIRST SET IS CONJUGATED (MIRRORED)
d176 3
a178 2
	         DO J=3,NUMR3I,2
	            JC     = J+NUMR2I-1
d180 1
a180 2
	            T(J)   =  (CIRC1(JC))*CIRC2(JC)   -
     &                        (CIRC1(JC+1))*CIRC2(JC+1)
d182 1
a182 6
	            T(J+1) = -(CIRC1(JC))*CIRC2(JC+1) -
     &                        (CIRC1(JC+1))*CIRC2(JC)
	         ENDDO
              ELSE
	         DO J=3,NUMR3I,2
	            JC     = J+NUMR2I-1
d184 11
a194 2
	            T(J)   =  (CIRC1(JC))*CIRC2(JC)   +
     &                        (CIRC1(JC+1))*CIRC2(JC+1)
d196 5
a200 4
	            T(J+1) = -(CIRC1(JC))*CIRC2(JC+1) +
     &                     (CIRC1(JC+1))*CIRC2(JC)
	         ENDDO
              ENDIF
d202 4
a205 1
	      Q(1:NUMR3I+1) = Q(1:NUMR3I+1) + T(1:NUMR3I+1)
d207 23
a229 2
	   ELSE
	      T(2) = CIRC1(NUMR2I+1) * CIRC2(NUMR2I+1)
d231 1
a231 2
              IF (NEG) THEN
C                FIRST SET IS CONJUGATED (MIRRORED)
d233 1
a233 2
	         DO J=3,MAXRIN,2
	            JC      =  J+NUMR2I-1
d235 2
a236 17
	            T(J)    =  (CIRC1(JC))*CIRC2(JC) -
     &                         (CIRC1(JC+1))*CIRC2(JC+1)

	             T(J+1) = -(CIRC1(JC))*CIRC2(JC+1) -
     &                         (CIRC1(JC+1))*CIRC2(JC)
	         ENDDO
              ELSE
	         DO J=3,MAXRIN,2
	            JC      =  J+NUMR2I-1

	            T(J)    =  (CIRC1(JC))*CIRC2(JC) +
     &                         (CIRC1(JC+1))*CIRC2(JC+1)

	             T(J+1) = -(CIRC1(JC))*CIRC2(JC+1) +
     &                         (CIRC1(JC+1))*CIRC2(JC)
	         ENDDO
              ENDIF
d238 26
a263 1
	      Q = Q + T
d265 50
a314 1
	ENDDO
d317 6
a322 6
	INV         = -1
	LDA         = 1
	Q(MAXRIN+1) = Q(2)
	Q(2)        = 0.0
	Q(MAXRIN+2) = 0.0
	CALL ZDFFT1DU(INV,IP,Q,LDA,TT)
d324 2
a325 1
	CALL FFTR_D(Q,IP)
d327 5
a331 8
C
	QN = -1.0D20
	DO J=1,MAXRIN
	   IF (Q(J) .GE. QN) THEN
	      QN   = Q(J)
	      JTOT = J
	   ENDIF
	ENDDO 
d334 16
a349 1
	QN = QN/MAXRIN
a350 4
	DO K=-3,3
           J     = MOD(JTOT+K+MAXRIN-1,MAXRIN) + 1
	   T7(K) = Q(J)
	ENDDO
d352 11
a362 1
	CALL PRB1D(T7,7,POS)
a363 1
	TOT = FLOAT(JTOT) + POS
a364 1
	END
@


1.12
log
@reverted to pre aprings change
@
text
@a0 1

d3 2
a4 2
C CROSRNG_E.F  MERGED CROSRMG_DS.F & CROSRNG_DS    AUG 04 ARDEAN LEITH
C              REWRITE FOR FFTW3                   MAR 08 ARDEAN LEITH
d7 1
a7 1
C=* Copyright (C) 1985-2008  Health Research Inc.                      *
d9 2
a10 1
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *   C=* ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
d31 1
a31 16
C CROSRNG_E(CIRC1,CIRC2,LCIRC,NRING,MAXRIN,NUMR,QMAX,F_MAXL,TT,NEG)
C
C PURPOSE: CROSS CORRELATION OF RADIAL RINGS FOR USE IN ROTATIONAL
C          ALIGNMENT. CHECKS ONLY UN-MIRRORED POSITION
C
C PARAMETERS:
C    CIRC1  - FT OF RINGS MULTIPLIED BY WEIGHTS           (SENT)
C    CIRC2  - FT OF RINGS MULTIPLIED BY WEIGHTS           (SENT)
C    LCIRC  - SIZE OF CIRCS ARRAYS                        (SENT)
C    NRING  - NUMBER OF RINGS                             (SENT)
C    MAXRIN - LONGEST RING                                (SENT)
C    NUMR   - RING LOCATION POINTERS                      (SENT)
C    QMAX   - CC MAX                                      (RETURNED)
C    F_MAXL - POSITION OF CC MAX                          (RETURNED)
C    TT     - USED FOR SGI FFT (UNUSED NOW)               (SENT)
C    NEG    - FLAG FOR CONJUGATE (MIRROR) OF 1'ST RING    (SENT)
d33 1
a33 1
C     U = 11*21+ 12*22  (e.g.)
d35 3
a37 11
C     ABNORMAL LOCATION   <MAXRIN       NVAL=MAXRIN   (U = USUAL)
C     E.g. NVAL:            256             512
C        1:                 11x21          11x21         (same)
C        2:                   0            12x22 
C        NVAL-1               U              U           (same)
C        NVAL                 U              U (maxrin)  (same)
C        NVAL+1             12x22            0 (unused)
C        MAXRIN               0 (unused)     U               
C        MAXRIN + 1:          0              0           (same) (unused) 
C        MAXRIN + 2:          0              0           (same) (unused)    
C        summation          0..257         0..514
a38 8
C  NOTES:     COMPLEX CONJUGATE OF COMPLEX NUMBER = a - bi
C             USUAL COMPLEX MULTIPLICATION: (ac-bd),(ad+bc)
C             OUR   COMPLEX MULTIPLICATION: (ac+bd),(-ad+bc) 
C             (If loaded by fmrs can use usual method)
C              SPIDER_SIGN flag when data originally transformed))
C
C    Typical radii:  32, 64, 128, 256, 512  (only)
c  ip:            -9    lcirc:          23168
d42 2
a43 141
        SUBROUTINE CROSRNG_E(CIRC1,CIRC2,LCIRC, NRING,MAXRIN,NUMR,
     &                           QMAX,F_MAXL,TT,NEG)

C       USES NUMR TABLE FOR MAPPING INTO Q ARRAY 
C       USES SIMPLIFIED LOGIC FOR BOUNDARY VALUES, FLOATING PT. ARITH.

#ifdef SP_LIBFFTW3
        USE TYPE_KINDS      
        INTEGER(KIND=I_8)   :: IPLAN = 0     !STRUCTURE POINTER 
#endif

        INTEGER, INTENT(IN) :: NUMR(3,NRING)
        REAL, INTENT(IN)    :: CIRC1(LCIRC), CIRC2(LCIRC)
        DOUBLE PRECISION    :: QMAX
        REAL, INTENT(OUT)   :: F_MAXL
	DOUBLE PRECISION    :: TT(*)
        LOGICAL, INTENT(IN) :: NEG

C       AUTOMATIC ARRAYS
        REAL                :: Q(MAXRIN+2)

C       ZERO WHOLE Q ARRAY
        Q = 0.0
     
        DO I=1,NRING
           IGO  = NUMR(2,I)
           NVAL = NUMR(3,I)

           Q(1) = Q(1) + (CIRC1(IGO)) * CIRC2(IGO)

           IF (NVAL .NE. MAXRIN) THEN
              Q(NVAL+1) = Q(NVAL+1) + (CIRC1(IGO+1)) * CIRC2(IGO+1)
           ELSE
              Q(2)      = Q(2)      + (CIRC1(IGO+1)) * CIRC2(IGO+1)            
           ENDIF

           IGOM1 = IGO - 1

           IF (NEG) THEN
C             FIRST RING SET IS CONJUGATED (MIRRORED)
              DO J=3,NVAL,2
                 JC     = J + IGOM1

                 Q(J)   = Q(J)   + (CIRC1(JC))   * CIRC2(JC)   -
     &                             (CIRC1(JC+1)) * CIRC2(JC+1)

                 Q(J+1) = Q(J+1) - (CIRC1(JC))   * CIRC2(JC+1) -
     &                             (CIRC1(JC+1)) * CIRC2(JC)
              ENDDO
           ELSE
C             FIRST RING SET IS NON-CONJUGATED (NOT MIRRORED)
              DO J=3,NVAL,2
                 JC     = J + IGOM1

                 Q(J)   = Q(J)   + (CIRC1(JC))   * CIRC2(JC)   +
     &                             (CIRC1(JC+1)) * CIRC2(JC+1)

                 Q(J+1) = Q(J+1) - (CIRC1(JC))   * CIRC2(JC+1) +
     &                             (CIRC1(JC+1)) * CIRC2(JC)
              ENDDO
           ENDIF
        ENDDO

        CALL CROSRNG_COM(Q,LCIRC,MAXRIN,QMAX,F_MAXL,NRING,IPLAN)
 
        END


C--************************  CROSRNG_EP ******************************


        SUBROUTINE CROSRNG_EP(CIRC1,CIRC2,LCIRC, NRING,MAXRIN,NUMR,
     &                           QMAX,F_MAXL,TT,NEG,FFTW3PLAN)

#ifdef SP_LIBFFTW3
        USE TYPE_KINDS      
        INTEGER(KIND=I_8)   :: FFTW3PLAN !STRUCTURE POINTER 
#endif

C       USES NUMR TABLE FOR MAPPING INTO Q ARRAY 
C       USES SIMPLIFIED LOGIC FOR BOUNDARY VALUES, FLOATING PT. ARITH.

        INTEGER, INTENT(IN) :: NUMR(3,NRING)
        REAL, INTENT(IN)    :: CIRC1(LCIRC), CIRC2(LCIRC)
        DOUBLE PRECISION    :: QMAX
        REAL, INTENT(OUT)   :: F_MAXL
	DOUBLE PRECISION    :: TT(*)
        LOGICAL, INTENT(IN) :: NEG

C       AUTOMATIC ARRAYS
        REAL                :: Q(MAXRIN+2)

C       ZERO WHOLE Q ARRAY
        Q = 0.0
     
        DO I=1,NRING
           IGO  = NUMR(2,I)
           NVAL = NUMR(3,I)

           Q(1) = Q(1) + (CIRC1(IGO)) * CIRC2(IGO)

           IF (NVAL .NE. MAXRIN) THEN
              Q(NVAL+1) = Q(NVAL+1) + (CIRC1(IGO+1)) * CIRC2(IGO+1)
           ELSE
              Q(2)      = Q(2)      + (CIRC1(IGO+1)) * CIRC2(IGO+1)            
           ENDIF

           IGOM1 = IGO - 1

           IF (NEG) THEN
C             FIRST RING SET IS CONJUGATED (MIRRORED)
              DO J=3,NVAL,2
                 JC     = J + IGOM1

                 Q(J)   = Q(J)   + (CIRC1(JC))   * CIRC2(JC)   -
     &                             (CIRC1(JC+1)) * CIRC2(JC+1)

                 Q(J+1) = Q(J+1) - (CIRC1(JC))   * CIRC2(JC+1) -
     &                             (CIRC1(JC+1)) * CIRC2(JC)
              ENDDO
           ELSE
C             FIRST RING SET IS NON-CONJUGATED (NOT MIRRORED)
              DO J=3,NVAL,2
                 JC     = J + IGOM1

                 Q(J)   = Q(J)   + (CIRC1(JC))   * CIRC2(JC)   +
     &                             (CIRC1(JC+1)) * CIRC2(JC+1)

                 Q(J+1) = Q(J+1) - (CIRC1(JC))   * CIRC2(JC+1) +
     &                             (CIRC1(JC+1)) * CIRC2(JC)
              ENDDO
           ENDIF
        ENDDO

        CALL CROSRNG_COM(Q,LCIRC,MAXRIN,QMAX,F_MAXL,NRING,FFTW3PLAN)
 
        END



C--************************  CROSRNG_COM ******************************
d45 4
a48 62
        SUBROUTINE CROSRNG_COM(QS,LCIRC,MAXRIN,QMAX,F_MAXL,NRING,
     &                          FFTW3PLAN)

C       COMMON CODE FOR REVERSE TRANSFORM AND MAX LOCATION DETERMINATION

#ifdef SP_LIBFFTW3
        USE TYPE_KINDS      
        INTEGER(KIND=I_8)   :: FFTW3PLAN !STRUCTURE POINTER 
#endif

        REAL                          :: QS(MAXRIN + 2)
        INTEGER, INTENT(IN)           :: LCIRC,MAXRIN,NRING
        DOUBLE PRECISION, INTENT(OUT) :: QMAX
        REAL, INTENT(OUT)             :: F_MAXL

        DOUBLE PRECISION              :: T7(-3:3)
        INTEGER                       :: MAXL_ARRRAY(1)
        
C       REVERSE FOURIER TRANSFORM ON Q   
        QS(MAXRIN+1) = QS(2)
        QS(2)        = 0.0
        QS(MAXRIN+2) = 0.0
        
        INV = -1
        CALL FMRS(QS,MAXRIN, 1,1,FFTW3PLAN, .TRUE.,.FALSE., INV,IRTFLG)

C       FIND MAXIMUM AND ITS LOCATION INSIDE QS
        MAXL_ARRRAY = MAXLOC(QS)      ! RETURNS ARRAY OF LENGTH: 1
        MAXL        = MAXL_ARRRAY(1)  ! LOCATION OF MAXIMUM
        QMAX        = QS(MAXL)        ! MAXIMUM VALUE

C       INTERPOLATION OVER 3x3 NEIGHBORHOOD
        DO K=-3,3
           J     = MOD(MAXL+K+MAXRIN-1,MAXRIN) + 1
           T7(K) = QS(J)
        ENDDO

        CALL PRB1D(T7,7,POS)
        F_MAXL = FLOAT(MAXL) + POS    ! SUB-PIXEL LOCATION

#ifdef DEBUGNEVER
        write(6,901)maxl,qmax,f_maxl,qs(15)
 901    format(' crosrng_com_s; maxl: ',i6,' qmax: ',f16.3,
     &         ' f_maxl: ',f10.3,' qs(15):  ',f16.3)
#endif

        END



C--************************  CROSRNG_E_OLD ****************************

        SUBROUTINE CROSRNG_E_OLD(CIRC1,CIRC2,LCIRC,NRING,MAXRIN,NUMR,
     &                        QMAX,F_MAXL,TT,NEG)

C       USES NUMR TABLE FOR MAPPING INTO Q ARRAY 
C       SAME AS PRODUCTION CODE USED CURRENTLY IN SPIDER AS OF OCT 2005

        INTEGER          ::  NUMR(3,NRING)
        DIMENSION        ::  CIRC1(LCIRC),CIRC2(LCIRC)
        DOUBLE PRECISION ::  TT(*),QMAX
        LOGICAL          ::  NEG
d51 3
a53 3
        DIMENSION        ::  T(MAXRIN+2)
        DOUBLE PRECISION ::  Q(MAXRIN+2)
        DOUBLE PRECISION ::  T7(-3:3)
d55 1
a55 1
        IP = MAXRIN
d58 1
a58 1
        IP = -LOG2(IP)
d62 1
a62 1
        Q = 0.0D0
d64 2
a65 2
        T(MAXRIN+1) = 0.0
        T(MAXRIN+2) = 0.0
d67 3
a69 3
        DO I=1,NRING
           NUMR3I = NUMR(3,I)
           NUMR2I = NUMR(2,I)
d71 1
a71 1
           T(1)   = (CIRC1(NUMR2I)) * CIRC2(NUMR2I)
d73 1
a73 1
           IF (NUMR3I .NE. MAXRIN) THEN
d75 2
a76 2
              T(NUMR3I+1) = CIRC1(NUMR2I+1) * CIRC2(NUMR2I+1)
              T(2)        = 0.0
d81 2
a82 2
                 DO J=3,NUMR3I,2
                    JC     = J+NUMR2I-1
d84 1
a84 1
                    T(J)   =  (CIRC1(JC))*CIRC2(JC)   -
d87 1
a87 1
                    T(J+1) = -(CIRC1(JC))*CIRC2(JC+1) -
d89 1
a89 1
                 ENDDO
d91 2
a92 2
                 DO J=3,NUMR3I,2
                    JC     = J+NUMR2I-1
d94 1
a94 1
                    T(J)   =  (CIRC1(JC))*CIRC2(JC)   +
d97 1
a97 1
                    T(J+1) = -(CIRC1(JC))*CIRC2(JC+1) +
d99 1
a99 1
                 ENDDO
d102 1
a102 1
              Q(1:NUMR3I+1) = Q(1:NUMR3I+1) + T(1:NUMR3I+1)
d104 2
a105 2
           ELSE
              T(2) = CIRC1(NUMR2I+1) * CIRC2(NUMR2I+1)
d110 2
a111 2
                 DO J=3,MAXRIN,2
                    JC      =  J+NUMR2I-1
d113 1
a113 1
                    T(J)    =  (CIRC1(JC))*CIRC2(JC) -
d116 1
a116 1
                     T(J+1) = -(CIRC1(JC))*CIRC2(JC+1) -
d118 1
a118 1
                 ENDDO
d120 2
a121 2
                 DO J=3,MAXRIN,2
                    JC      =  J+NUMR2I-1
d123 1
a123 1
                    T(J)    =  (CIRC1(JC))*CIRC2(JC) +
d126 1
a126 1
                     T(J+1) = -(CIRC1(JC))*CIRC2(JC+1) +
d128 1
a128 1
                 ENDDO
d131 1
a131 1
              Q = Q + T
d133 1
a133 1
        ENDDO
d136 6
a141 6
        INV         = -1
        LDA         = 1
        Q(MAXRIN+1) = Q(2)
        Q(2)        = 0.0
        Q(MAXRIN+2) = 0.0
        CALL ZDFFT1DU(INV,IP,Q,LDA,TT)
d143 1
a143 1
        CALL FFTR_D(Q,IP)
d146 7
a152 104
        QMAX = -1.0D20
        DO J=1,MAXRIN
           IF (Q(J) .GE. QMAX) THEN
              QMAX   = Q(J)
              MAXL = J
           ENDIF
        ENDDO 

#ifdef SP_LIBFFT
        QMAX = QMAX/MAXRIN
#endif
        DO K=-3,3
           J     = MOD(MAXL+K+MAXRIN-1,MAXRIN) + 1
           T7(K) = Q(J)
        ENDDO

        CALL PRB1D(T7,7,POS)

        F_MAXL = FLOAT(MAXL) + POS

        END












C ---------------- UNUSED BELOW HERE --------------------------------

#ifdef NEVER

C--************************  CROSRNG_NEW_E  ***************************

        SUBROUTINE CROSRNG_NEW_E(CIRC1,CIRC2,LCIRC, NRING,MAXRIN,NUMR,
     &                           QMAX,F_MAXL,TT,NEG)

C       USES NUMR TABLE FOR MAPPING INTO Q ARRAY 
C       USES SIMPLIFIED LOGIC FOR BOUNDARY VALUES, FLOATING PT. ARITH.

        INTEGER          ::  NUMR(3,NRING)
        DIMENSION        ::  CIRC1(LCIRC), CIRC2(LCIRC)
        DOUBLE PRECISION ::  TT(*), QMAX
        LOGICAL          ::  NEG

C       AUTOMATIC ARRAYS
        DOUBLE PRECISION ::  Q(MAXRIN+2)

C       ZERO WHOLE Q ARRAY
        Q = 0.0D0
     
        DO I=1,NRING
           IGO  = NUMR(2,I)
           NVAL = NUMR(3,I)

           Q(1) = Q(1) + (CIRC1(IGO)) * CIRC2(IGO)

           IF (NVAL .NE. MAXRIN) THEN
              Q(NVAL+1) = Q(NVAL+1) + (CIRC1(IGO+1)) * CIRC2(IGO+1)
           ELSE
              Q(2)      = Q(2)      + (CIRC1(IGO+1)) * CIRC2(IGO+1)            
           ENDIF

           IGOM1 = IGO - 1

           IF (NEG) THEN
C             FIRST RING SET IS CONJUGATED (MIRRORED)
              DO J=3,NVAL,2
                 JC     = J + IGOM1

                 Q(J)   = Q(J)   + (CIRC1(JC))   * CIRC2(JC)   -
     &                             (CIRC1(JC+1)) * CIRC2(JC+1)

                 Q(J+1) = Q(J+1) - (CIRC1(JC))   * CIRC2(JC+1) -
     &                             (CIRC1(JC+1)) * CIRC2(JC)
              ENDDO
           ELSE
C             FIRST RING SET IS NON-CONJUGATED (NOT MIRRORED)
              DO J=3,NVAL,2
                 JC     = J + IGOM1

                 Q(J)   = Q(J)   + (CIRC1(JC))   * CIRC2(JC)   +
     &                             (CIRC1(JC+1)) * CIRC2(JC+1)

                 Q(J+1) = Q(J+1) - (CIRC1(JC))   * CIRC2(JC+1) +
     &                             (CIRC1(JC+1)) * CIRC2(JC)
              ENDDO
           ENDIF
        ENDDO

        CALL CROSRNG_COM(Q,LCIRC,MAXRIN,QMAX,F_MAXL,TT,NRING)
 
        END

C--************************  CROSRNG_COM ******************************

        SUBROUTINE CROSRNG_COM(Q,LCIRC,MAXRIN,QMAX,F_MAXL,TT,NRING)

C       COMMON CODE FOR REVERSE TRANSFORM AND MAX LOCATION DETERMINATION
a153 19
        DOUBLE PRECISION              :: Q(MAXRIN + 2)
        INTEGER, INTENT(IN)           :: LCIRC,MAXRIN,NRING
        DOUBLE PRECISION, INTENT(OUT) :: QMAX
        REAL, INTENT(OUT)             :: F_MAXL
        DOUBLE PRECISION, INTENT(IN)  :: TT(*)

        DOUBLE PRECISION              :: T7(-3:3)
        INTEGER                       :: MAXL_ARRRAY(1)
 
C       REVERSE FOURIER TRANSFORM ON Q

#ifdef SP_LIBFFTW3DEEEEE
C       FFTW3  NOT IMPLIMENTED YET NEEDS DOUBLE
        INV         = -1
        Q(MAXRIN+1) = Q(2)
        Q(MAXRIN+2) = 0.0
        Q(2)        = 0.0
        CALL FMRS(Q,MAXRIN,1,1,0, .FALSE.,.FALSE, INV,IRTFLG)
#else
d155 1
a155 192
C       SGI FFT LIB
        write(6,*) ' using SGI FFT LIB'
        INV         = -1
        LDA         = 1
        Q(MAXRIN+1) = Q(2)
        Q(MAXRIN+2) = 0.0
        Q(2)        = 0.0
        CALL ZDFFT1DU(INV,MAXRIN,Q,LDA,TT)
#else
C       NATIVE OLD SPIDER FFT
        IP = MAXRIN
        IP = -LOG2(IP)
        CALL FFTR_D(Q,IP)
#endif
#endif

C       FIND MAX AND ITS LOCATION INSIDE Q
        MAXL_ARRRAY = MAXLOC(Q)      ! RETURNS AN ARRAY OF LENGTH: 1
        MAXL        = MAXL_ARRRAY(1) ! LOCATION OF MAXIMUM
        QMAX        = Q(MAXL)        ! MAXIMUM VALUE

C       INTERPOLATION OVER 3x3 NEIGHBORHOOD
        DO K=-3,3
           J     = MOD(MAXL+K+MAXRIN-1,MAXRIN) + 1
           T7(K) = Q(J)
        ENDDO

        CALL PRB1D(T7,7,POS)
        F_MAXL = FLOAT(MAXL) + POS    ! SUB-PIXEL LOCATION

#ifdef DEBUGNEVER
        write(6,901) maxl,qmax,f_maxl,q(15)
 901    format(' crosrng_com; maxl: ',i6,' qmax: ',f16.3,
     &            ' f_maxl: ',f10.3,' q(15):  ',f16.3)
#endif

        END



C--************************  CROSRNG_NEW_C ****************************

        SUBROUTINE CROSRNG_NEW_C(CIRC1,CIRC2,LCIRCD2, NRING,MAXRIN,NUMR,
     &                           QMAX,F_MAXL,TT,NEG,IPTR)

C       USES LOOK-UP TABLE FOR MAPPING INTO Q ARRAY 
C       USES SIMPLIFIED LOGIC FOR BOUNDARY VALUES, COMPLEX ARITH.
C       IPTR FILLED IN CALLING ROUTINE FROM NUMR ARRAY
c	 allocate(iptr(lcirc/2),stat=irtflg)
c	 if (irtflg .ne. 0) then
c           call errt(46,'iptr...',lcirc/2)
c           goto 9999
c        endif
c        load iptr with location in q
c        do i=1,nring
c           igo  = (numr(2,i)/2) + 1
c           nval = numr(3,i)
c           j    = 1
c           do iloc=igo,igo+(nval/2)-1
c              iptr(iloc) = j
c              j          = j + 1
c           enddo
c           write(6,*) ' iptr(',igo,'): ',iptr(igo),igo,nval
c        enddo


        INTEGER          :: NUMR(3,NRING)
        COMPLEX          :: CIRC1(LCIRCD2), CIRC2(LCIRCD2)

        DOUBLE PRECISION :: TT(*), QT1,QT2,QTN
        LOGICAL          :: NEG
        INTEGER          :: IPTR(LCIRCD2)

C       AUTOMATIC ARRAYS
        COMPLEX(KIND=8)  :: Q(MAXRIN/2 + 1)

C       ZERO WHOLE Q ARRAY
        Q = CMPLX(0.0,0.0)

        DO I=1,LCIRCD2
           J = IPTR(I)

           IF (NEG) THEN
C             FIRST RING SET IS UN-CONJUGATED (MIRRORED)
              Q(J) = Q(J) + (CIRC1(I) * CIRC2(I)) 
           ELSE
C             FIRST RING SET IS CONJUGATED (NOT MIRRORED)
              Q(J) = Q(J) + (CIRC1(I) * CONJG(CIRC2(I)) ) 
           ENDIF
        ENDDO

C       RESET NON-STANDARD BOUNDARY Q LOCATIONS 1 AND NVAL
        QT1 = 0.0
        QT2 = 0.0

        DO I=1,NRING
           IGO  = NUMR(2,I) / 2 + 1
           NVAL = NUMR(3,I) / 2 
           QT1  = QT1 + DBLE(CIRC1(IGO)) * DBLE(CIRC2(IGO))

           IF (NVAL .NE. (MAXRIN/2)) THEN
              QTN   = DBLE(AIMAG(CIRC1(IGO))) * DBLE(AIMAG(CIRC2(IGO)))
              Q(NVAL) = Q(NVAL) + CMPLX(0.0, QTN) 

           ELSE
              QT2 = QT2 + DBLE(AIMAG(CIRC1(IGO))) * 
     &                    DBLE(AIMAG(CIRC2(IGO)))
            
           ENDIF
        ENDDO

        Q(1) = CMPLX(QT1,QT2) 

        CALL CROSRNG_COM(Q,2*LCIRCD2,MAXRIN,QMAX,F_MAXL,TT,NRING)
 
        END

#endif


#ifdef NEVER

C--************************  CROSRNG_NEW_EG ***************************

        SUBROUTINE CROSRNG_NEW_EG(CIRC1,CIRC2,LCIRC, NRING,MAXRIN,NUMR,
     &                           QMAX,F_MAXL,TT,NEG,IPTR)

C       USES LOOK-UP TABLE FOR MAPPING INTO Q ARRAY 
C       USES SIMPLIFIED LOGIC FOR BOUNDARY VALUES, FLOATING PT. ARITH.

        INTEGER           NUMR(3,NRING)
        DIMENSION         CIRC1(LCIRC), CIRC2(LCIRC)
        DOUBLE PRECISION  TT(*), QMAX, qsum
        LOGICAL           NEG
        INTEGER           IPTR(LCIRC/2)

C       AUTOMATIC ARRAYS
        DOUBLE PRECISION  Q(MAXRIN+2)
        DOUBLE PRECISION  T7(-3:3)
        DIMENSION         MAXL_ARRRAY(1)
        
C       ZERO WHOLE Q ARRAY
        Q = 0.0D0

        I = 1
        DO JC=1,LCIRC,2
           J = IPTR(I)
           I = I + 1

           IF (NEG) THEN
C             FIRST RING SET IS CONJUGATED (MIRRORED)
              Q(J)   = Q(J)   + (CIRC1(JC))   * CIRC2(JC)   -
     &                          (CIRC1(JC+1)) * CIRC2(JC+1)
              Q(J+1) = Q(J+1) - (CIRC1(JC))   * CIRC2(JC+1) -
     &                          (CIRC1(JC+1)) * CIRC2(JC)
           ELSE

C             FIRST RING SET IS NON-CONJUGATED (NOT MIRRORED)
C             COMPLEX CONJUGATE OF COMPLEX NUMBER = a - bi

C             USUAL COMPLEX MULTIPLICATION: (ac-bd),(ad+bc)
C             OUR   COMPLEX MULTIPLICATION: (ac+bd),(-ad+bc) 
C             EFFECTIVELY: conjugate(A)*conjugate(B)

              Q(J)   = Q(J)   + (CIRC1(JC))   * CIRC2(JC)   +
     &                          (CIRC1(JC+1)) * CIRC2(JC+1)

              Q(J+1) = Q(J+1) - (CIRC1(JC))   * CIRC2(JC+1) +
     &                          (CIRC1(JC+1)) * CIRC2(JC)
           ENDIF
        ENDDO

C       RESET NON-STANDARD Q LOCATIONS
        Q(1) = 0.0
        Q(2) = 0.0
        DO I=1,NRING
           IGO  = NUMR(2,I)
           NVAL = NUMR(3,I)

           Q(1) = Q(1) + (CIRC1(IGO)) * CIRC2(IGO)
           IF (NVAL .NE. MAXRIN) THEN
              Q(NVAL+1) = Q(NVAL+1) + (CIRC1(IGO+1)) * CIRC2(IGO+1)
c             write(6,*) 'q(',NVAL+1,'): ',Q(NVAL+1)
           ELSE
              Q(2)      = Q(2) + (CIRC1(IGO+1)) * CIRC2(IGO+1)            
           ENDIF
        ENDDO

        CALL CROSRNG_COM(Q,2LCIRC,MAXRIN,QMAX,F_MAXL,TT,NRING)

        END

d157 4
d162 1
d164 1
d166 1
a166 183


#ifdef NEVER
C--****************************  CROSRNG_NEW_E2  ***********************

        SUBROUTINE CROSRNG_NEW_E2(CIRCS,LCIRC, NRING,MAXRIN,NUMR,
     &                           QMAX,F_MAXL,TT, NEG)

C       USES NUMR TABLE FOR MAPPING INTO Q ARRAY 
C       USES SIMPLIFIED LOGIC FOR BOUNDARY VALUES, FLOATING PT. ARITH.

        INTEGER           NUMR(3,NRING)
        DIMENSION         CIRCS(2*LCIRC)
        DOUBLE PRECISION  TT(*), QMAX
        LOGICAL           NEG
        DIMENSION         MAXL_ARRRAY(1)

C       AUTOMATIC ARRAYS
        DOUBLE PRECISION  Q(MAXRIN+2)
        DOUBLE PRECISION  T7(-3:3)

C       ZERO WHOLE Q ARRAY
        Q = 0.0D0
     
        DO I=1,NRING
           IGO  = 2 * NUMR(2,I) - 1
           NVAL = NUMR(3,I)

C          CIRCS: 11,12,21,22,13,14,23,24,........
           Q(1) = Q(1) + (CIRCS(IGO)) * CIRCS(IGO+2)

           IF (NVAL .NE. MAXRIN) THEN
              Q(NVAL+1) = Q(NVAL+1) + (CIRCS(IGO+1)) * CIRCS(IGO+3)
           ELSE
              Q(2)      = Q(2)      + (CIRCS(IGO+1)) * CIRCS(IGO+3)    
           ENDIF

           JCON = IGO - 2
           IF (NEG) THEN
C             FIRST SET IS CONJUGATED (MIRRORED)

              DO J=3,NVAL,2
c                JC     = (J * 2 - 1) + IGO - 1
                 JC     = J * 2 + JCON
                 JCP1   = JC + 1
                 JCP2   = JC + 2
                 JCP3   = JC + 3

                 Q(J)   = Q(J)   + (CIRCS(JC))   * CIRCS(JCP2) -
     &                             (CIRCS(JCP1)) * CIRCS(JCP3)
                 Q(J+1) = Q(J+1) - (CIRCS(JC))   * CIRCS(JCP3) -
     &                             (CIRCS(JCP1)) * CIRCS(JCP2)
              ENDDO
           ELSE
              DO J=3,NVAL,2
C                FIRST SET IS NOT-CONJUGATED (NOT-MIRRORED)
c                JC     = (J * 2 - 1) + IGO - 1
                 JC     = J * 2 + JCON
                 JCP1   = JC + 1
                 JCP2   = JC + 2
                 JCP3   = JC + 3

                 Q(J)   = Q(J)   + (CIRCS(JC))   * CIRCS(JCP2) +
     &                             (CIRCS(JCP1)) * CIRCS(JCP3) 
                 Q(J+1) = Q(J+1) - (CIRCS(JC))   * CIRCS(JCP3) +
     &                             (CIRCS(JCP1)) * CIRCS(JCP2) 
              ENDDO
           ENDIF

        ENDDO

        CALL CROSRNG_COM(Q,LCIRC,MAXRIN,QMAX,F_MAXL,TT,NRING)

        END

#endif





#ifdef NEVER
C       LOAD IPTR WITH LOCATION IN Q----------------- DEBUG -----------
        DO I=1,NRING
           IGO  = NUMR(2,I)
           NVAL = NUMR(3,I)
           J    = 1
           DO ILOC=IGO,IGO+NVAL-1
              IPTR(ILOC) = J
              J          = J + 1
           ENDDO
c          IPTR(IGO)     = MAXRIN + 1   ! ABNORMAL 1'ST LOC
c          IPTR(IGO+1)   = MAXRIN + 1   ! ABNORMAL 2'ND LOC
ccc        write(6,*) ' iptr(',igo,'): ',iptr(igo),igo,nval
        ENDDO

c       write(6,90) (Q(k),k=1,maxrin+2)
90      format(8(F10.3,' '))

        write(6,*) ' q(1): ',Q(1)
        write(6,*) ' q(2): ',Q(2)
        write(6,*) ' q(3): ',Q(3)
        write(6,*) ' q(4): ',Q(4)
        write(6,*) ' q(5): ',Q(5)
        write(6,*) ' q(6): ',Q(6)
        write(6,*) ' q(31): ',Q(31)
        write(6,*) ' q(32): ',Q(32)

c        write(6,*) ' q(',NVAL  ,'): ',Q(NVAL+0)
c        write(6,*) ' q(',NVAL+1,'): ',Q(NVAL+1)
c        write(6,*) ' q(',NVAL+2,'): ',Q(NVAL+2)

        write(6,*) ' q(',MAXRIN-1,'): ',Q(MAXRIN-1)
        write(6,*) ' q(',MAXRIN+0,'): ',Q(MAXRIN+0)
        write(6,*) ' q(',MAXRIN+1,'): ',Q(MAXRIN+1)
        write(6,*) ' q(',MAXRIN+2,'): ',Q(MAXRIN+2)
          
        qsum = sum(q)
        write(6,*)' nring: ',nring,'   maxrin: ',maxrin,'  qsum: ',qsum
        write(6,*)' ip: ',ip,      '   lcirc:  ',lcirc,2**9

        write(6,90) (Q(k),k=1,maxrin+2)
90      format(8(F10.3,' '))

        write(6,*) ' iptr(1): ',iptr(1)
        write(6,*) ' iptr(2): ',iptr(2)
        write(6,*) ' iptr(3): ',iptr(3)
        write(6,*) ' iptr(4): ',iptr(4)
        write(6,*) ' iptr(lcirc-1): ',iptr(lcirc-1)
        write(6,*) ' iptr(lcirc+0): ',iptr(lcirc+0)
        write(6,*) ' iptr(lcirc+1): ',iptr(lcirc+1)
        write(6,*) ' iptr(lcirc+2): ',iptr(lcirc+2)

        write(6,*) ' q(1): ',Q(1)
        write(6,*) ' q(2): ',Q(2)
        write(6,*) ' q(3): ',Q(3)
        write(6,*) ' q(4): ',Q(4)

c       write(6,*) ' q(',NVAL  ,'): ',Q(NVAL+0)
c       write(6,*) ' q(',NVAL+1,'): ',Q(NVAL+1)
c       write(6,*) ' q(',NVAL+2,'): ',Q(NVAL+2)

        write(6,*) ' q(',MAXRIN+0,'): ',Q(MAXRIN+0)
        write(6,*) ' q(',MAXRIN+1,'): ',Q(MAXRIN+1)
        write(6,*) ' q(',MAXRIN+2,'): ',Q(MAXRIN+2)
          
        qsum = sum(q)
        write(6,*)' nring: ',nring,'   maxrin: ',maxrin,'  qsum: ',qsum
        write(6,*)' ip: ',ip,      '   lcirc:  ',lcirc,2**9
#endif
#ifdef NEVER
        write(6,*)' jtot: ',jtot,'  q(jtot): ',qn,'  tot: ',tot
        ikind = KIND(qn)
        write(6,*)'  KIND(qn): ',ikind

c       write(6,90) (Q(k),k=1,maxrin+2)
90      format(8(F10.3,' '))

c        write(6,*) ' iptr(1): ',iptr(1)
c        write(6,*) ' iptr(2): ',iptr(2)
c        write(6,*) ' iptr(3): ',iptr(3)
c        write(6,*) ' iptr(4): ',iptr(4)
c        write(6,*) ' iptr(lcircd2-1): ',iptr(lcircd2-1)
c        write(6,*) ' iptr(lcircd2+0): ',iptr(lcircd2+0)

        write(6,*) ' q(1): ',Q(1)
        write(6,*) ' q(2): ',Q(2)
        write(6,*) ' q(3): ',Q(3)
        write(6,*) ' q(4): ',Q(4)
        write(6,*) ' q(5): ',Q(5)
        write(6,*) ' q(6): ',Q(6)
        write(6,*) ' q(31): ',Q(31)
        write(6,*) ' q(32): ',Q(32)

        write(6,*) ' q(',MAXRIN-1,'): ',Q(MAXRIN-1)
        write(6,*) ' q(',MAXRIN+0,'): ',Q(MAXRIN+0)
        write(6,*) ' q(',MAXRIN+1,'): ',Q(MAXRIN+1)
        write(6,*) ' q(',MAXRIN+2,'): ',Q(MAXRIN+2)
          
        qsum = sum(q)
        write(6,*)' nring: ',nring,'   maxrin: ',maxrin,'  qsum: ',qsum
        write(6,*)' ip: ',ip,      '   lcirc:  ',lcirc,2**9
#endif
@


1.11
log
@ fftw3 and speedups
@
text
@d211 2
a254 229

#ifdef DEBUGNEVER
        write(6,901)maxl,qmax,f_maxl,qs(15)
 901    format(' crosrng_com_s; maxl: ',i6,' qmax: ',f16.3,
     &         ' f_maxl: ',f10.3,' qs(15):  ',f16.3)
#endif

        END


C--************************  CROSRNG_E_NEW ******************************


        SUBROUTINE CROSRNG_E_NEW(CIRC1,CIRC2,LCIRC, NRING,MAXRIN,NUMR,
     &                           QMAX,F_MAXL,TT,NEG)

C       USES NUMR TABLE FOR MAPPING INTO Q ARRAY 
C       USES SIMPLIFIED LOGIC FOR BOUNDARY VALUES, FLOATING PT. ARITH.

#ifdef SP_LIBFFTW3
        USE TYPE_KINDS      
        INTEGER(KIND=I_8)   :: IPLAN = 0     !STRUCTURE POINTER 
#endif

        INTEGER, INTENT(IN) :: NUMR(3,NRING)
        REAL, INTENT(IN)    :: CIRC1(LCIRC), CIRC2(LCIRC)
        DOUBLE PRECISION    :: QMAX
        REAL, INTENT(OUT)   :: F_MAXL
	DOUBLE PRECISION    :: TT(*)
        LOGICAL, INTENT(IN) :: NEG

C       AUTOMATIC ARRAYS
        REAL                :: Q(MAXRIN+2)

C       ZERO WHOLE Q ARRAY
        Q = 0.0
     
        DO I=1,NRING
           IGO   = NUMR(2,I)
           NVAL  = NUMR(3,I)
           IGOM1 = IGO - 1

           IF (NEG) THEN
C             FIRST RING SET IS CONJUGATED (MIRRORED)
              DO J=1,NVAL,2
                 JC     = J + IGOM1

                 Q(J)   = Q(J)   + (CIRC1(JC))   * CIRC2(JC)   -
     &                             (CIRC1(JC+1)) * CIRC2(JC+1)
                 Q(J+1) = Q(J+1) - (CIRC1(JC))   * CIRC2(JC+1) -
     &                             (CIRC1(JC+1)) * CIRC2(JC)
                 IPOS = -1
              ENDDO
           ELSE
C             FIRST RING SET IS NON-CONJUGATED (NOT MIRRORED)
              DO J=1,NVAL,2
                 JC     = J + IGOM1

                 Q(J)   = Q(J)   + (CIRC1(JC))   * CIRC2(JC)   +
     &                             (CIRC1(JC+1)) * CIRC2(JC+1)
                 Q(J+1) = Q(J+1) - (CIRC1(JC))   * CIRC2(JC+1) +
     &                             (CIRC1(JC+1)) * CIRC2(JC)
              ENDDO
              IPOS = 1
           ENDIF

           IF (NVAL .NE. MAXRIN) THEN
              JC     = IGOM1 + NVAL 
              J      = NVAL + 1
              Q(J)   = Q(J)   + ((CIRC1(JC))   * CIRC2(JC)   + IPOS *
     &                           (CIRC1(JC+1)) * CIRC2(JC+1) / 2.0)
              Q(J+1) = Q(J+1) - ((CIRC1(JC))   * CIRC2(JC+1) + IPOS *
     &                           (CIRC1(JC+1)) * CIRC2(JC) / 2.0)
           ELSE
              Q(J)   = Q(J)   + (CIRC1(JC))   * CIRC2(JC)   + IPOS *
     &                          (CIRC1(JC+1)) * CIRC2(JC+1)
              Q(J+1) = Q(J+1) - (CIRC1(JC))   * CIRC2(JC+1) + IPOS *
     &                          (CIRC1(JC+1)) * CIRC2(JC)
           ENDIF
        ENDDO

        CALL CROSRNG_COM_NEW(Q,LCIRC,MAXRIN,QMAX,F_MAXL,NRING,TT,IPLAN)
 
        END


C--************************  CROSRNG_EP_NEW ******************************

        SUBROUTINE CROSRNG_EP_NEW(CIRC1,CIRC2,LCIRC, NRING,MAXRIN,NUMR,
     &                           QMAX,F_MAXL, TT,NEG,FFTW3PLAN)

C       USES NUMR TABLE FOR MAPPING INTO Q ARRAY 
C       USES SIMPLIFIED LOGIC FOR BOUNDARY VALUES, FLOATING PT. ARITH.

        INTEGER, INTENT(IN) :: NUMR(3,NRING)
        REAL, INTENT(IN)    :: CIRC1(LCIRC), CIRC2(LCIRC)
        DOUBLE PRECISION    :: QMAX
        REAL, INTENT(OUT)   :: F_MAXL
	DOUBLE PRECISION    :: TT(*)
        LOGICAL, INTENT(IN) :: NEG

C       AUTOMATIC ARRAYS
        REAL                :: Q(MAXRIN+2)

C       ZERO WHOLE Q ARRAY
        Q = 0.0
     
        DO I=1,NRING
           IGO   = NUMR(2,I)
           NVAL  = NUMR(3,I)       
           IGOM1 = IGO - 1
           J1    = 1
           
#ifndef SP_LIBFFTW3
           Q(1) = Q(1) + (CIRC1(IGO)) * CIRC2(IGO)
           IF (NVAL .NE. MAXRIN) THEN
              Q(NVAL+1) = Q(NVAL+1) + (CIRC1(IGO+1)) * CIRC2(IGO+1)
           ELSE
              Q(2)      = Q(2)      + (CIRC1(IGO+1)) * CIRC2(IGO+1)            
           ENDIF
           J1 = 3
#endif

           IF (NEG) THEN
C             FIRST RING SET IS CONJUGATED (MIRRORED)
              DO J=J1,NVAL,2
                 JC     = J + IGOM1

                 Q(J)   = Q(J)   + (CIRC1(JC))   * CIRC2(JC)   -
     &                             (CIRC1(JC+1)) * CIRC2(JC+1)
                 Q(J+1) = Q(J+1) - (CIRC1(JC))   * CIRC2(JC+1) -
     &                             (CIRC1(JC+1)) * CIRC2(JC)
              ENDDO
           ELSE
C             FIRST RING SET IS NON-CONJUGATED (NOT MIRRORED)
              DO J=J1,NVAL,2
                 JC     = J + IGOM1

                 Q(J)   = Q(J)   + (CIRC1(JC))   * CIRC2(JC)   +
     &                             (CIRC1(JC+1)) * CIRC2(JC+1)
                 Q(J+1) = Q(J+1) - (CIRC1(JC))   * CIRC2(JC+1) +
     &                             (CIRC1(JC+1)) * CIRC2(JC)
              ENDDO
           ENDIF
        ENDDO

        CALL CROSRNG_COM_NEW(Q,LCIRC,MAXRIN,QMAX,F_MAXL,
     &                       NRING,TT,FFTW3PLAN)
 
        END


#ifdef NEVER
           J  = NVAL  + 1
           JC = IGOM1 + NVAL 
           IF (NVAL .NE. MAXRIN) THEN
              Q(J)   = Q(J)   + ((CIRC1(JC))   * CIRC2(JC)   + IPOS *
     &                           (CIRC1(JC+1)) * CIRC2(JC+1) / 2.0)
              Q(J+1) = Q(J+1) - ((CIRC1(JC))   * CIRC2(JC+1) + IPOS *
     &                           (CIRC1(JC+1)) * CIRC2(JC) / 2.0)
           ELSE
              Q(J)   = Q(J)   + (CIRC1(JC))   * CIRC2(JC)   + IPOS *
     &                          (CIRC1(JC+1)) * CIRC2(JC+1)
              Q(J+1) = Q(J+1) - (CIRC1(JC))   * CIRC2(JC+1) + IPOS *
     &                          (CIRC1(JC+1)) * CIRC2(JC)
           ENDIF
#endif


C--************************  CROSRNG_COM_NEW ******************************

        SUBROUTINE CROSRNG_COM_NEW(QS,LCIRC,MAXRIN,QMAX,F_MAXL,NRING,
     &                             TT,FFTW3PLAN)

C       COMMON CODE FOR REVERSE TRANSFORM AND MAX LOCATION DETERMINATION

        REAL                          :: QS(MAXRIN + 2)
        INTEGER, INTENT(IN)           :: LCIRC,MAXRIN,NRING
        DOUBLE PRECISION, INTENT(OUT) :: QMAX
        REAL, INTENT(OUT)             :: F_MAXL
        INTEGER*8, INTENT(IN)         :: FFTW3PLAN  ! STRUCTURE POINTER 
        DOUBLE PRECISION              :: TT(*)      ! FOR SGI LIBFFT

C       AUTOMATIC ARRAYS
        DOUBLE PRECISION              :: T7(-3:3)
        INTEGER                       :: MAXL_ARRRAY(1)

        INV = -1

#ifdef SP_LIBFFTW3        
C       REVERSE FOURIER TRANSFORM ON Q   
        CALL FMRS(QS,MAXRIN, 1,1,FFTW3PLAN, .TRUE.,.FALSE., INV,IRTFLG)
#else
#if defined (SP_LIBFFT)
C       SGI FFT USED
        LDA         = 1
        Q(MAXRIN+1) = Q(2)
        Q(2)        = 0.0
        Q(MAXRIN+2) = 0.0

C       REVERSE FOURIER TRANSFORM ON Q   
        CALL ZDFFT1DU(INV,MAXRIN,Q,LDA,TT)
#else
C       NATIVE SPIDER FFT USED
        IP = -LOG2(MAXRIN)

C       REVERSE FOURIER TRANSFORM ON Q   
        CALL FFTR_D(Q,IP)
#endif
#endif
 
C       FIND MAXIMUM AND ITS LOCATION INSIDE QS
        MAXL_ARRRAY = MAXLOC(QS)      ! RETURNS ARRAY OF LENGTH: 1
        MAXL        = MAXL_ARRRAY(1)  ! LOCATION OF MAXIMUM
        QMAX        = QS(MAXL)        ! MAXIMUM VALUE

C       INTERPOLATION OVER 3x3 NEIGHBORHOOD
        DO K=-3,3
           J     = MOD(MAXL+K+MAXRIN-1,MAXRIN) + 1
           T7(K) = QS(J)
        ENDDO

        CALL PRB1D(T7,7,POS)
        F_MAXL = FLOAT(MAXL) + POS    ! SUB-PIXEL LOCATION

#ifdef SP_LIBFFTW3        
        F_MAXL = F_MAXL / (MAXRIN * MAXRIN)
#endif

@


1.10
log
@ plan
@
text
@a210 2


d253 229
@


1.9
log
@GPL License fixed
@
text
@d1 1
d4 2
a5 2
C CROSRNG_E.F 
C                  MERGED CROSRMG_DS.F & CROSRNG_DS  AUG 04 ARDEAN LEITH
d8 1
a8 1
C=* Copyright (C) 1985-2005  Health Research Inc.                      *
d10 1
a10 2
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *   
C=* ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
d31 16
a46 1
C CROSRNG_E(CIRC1,CIRC2,LCIRC,NRING,MAXRIN,NUMR,QN,TOT,TT,NEG)
d48 1
a48 1
C CHECKS SINGLE POSITION, NEG IS FLAG FOR CHECKING MIRRORED POSITION
d50 11
a60 3
C  INPUT - FOURIER TRANSFORMS OF RINGS!
C  FIRST SET IS CONJUGATED (MIRRORED) IF NEG
C  CIRC1 ALREADY MULTIPLIED BY WEIGHTS!
d62 8
d73 141
a213 2
	SUBROUTINE CROSRNG_E(CIRC1,CIRC2,LCIRC,NRING,MAXRIN,NUMR,
     &                        QN,TOT,TT,NEG)
d215 62
a276 4
	INTEGER           NUMR(3,NRING)
	DIMENSION         CIRC1(LCIRC),CIRC2(LCIRC)
	DOUBLE PRECISION  TT(*),QN
	LOGICAL           NEG
d279 3
a281 3
	DIMENSION         T(MAXRIN+2)
	DOUBLE PRECISION  Q(MAXRIN+2)
	DOUBLE PRECISION  T7(-3:3)
d283 1
a283 1
	IP = MAXRIN
d286 1
a286 1
	IP = -LOG2(IP)
d290 1
a290 1
	Q = 0.0D0
d292 2
a293 2
	T(MAXRIN+1) = 0.0
	T(MAXRIN+2) = 0.0
d295 3
a297 3
	DO I=1,NRING
	   NUMR3I = NUMR(3,I)
	   NUMR2I = NUMR(2,I)
d299 1
a299 1
	   T(1)   = (CIRC1(NUMR2I)) * CIRC2(NUMR2I)
d301 1
a301 1
	   IF (NUMR3I .NE. MAXRIN) THEN
d303 2
a304 2
	      T(NUMR3I+1) = CIRC1(NUMR2I+1) * CIRC2(NUMR2I+1)
	      T(2)        = 0.0
d309 2
a310 2
	         DO J=3,NUMR3I,2
	            JC     = J+NUMR2I-1
d312 1
a312 1
	            T(J)   =  (CIRC1(JC))*CIRC2(JC)   -
d315 1
a315 1
	            T(J+1) = -(CIRC1(JC))*CIRC2(JC+1) -
d317 1
a317 1
	         ENDDO
d319 2
a320 2
	         DO J=3,NUMR3I,2
	            JC     = J+NUMR2I-1
d322 1
a322 1
	            T(J)   =  (CIRC1(JC))*CIRC2(JC)   +
d325 1
a325 1
	            T(J+1) = -(CIRC1(JC))*CIRC2(JC+1) +
d327 1
a327 1
	         ENDDO
d330 1
a330 1
	      Q(1:NUMR3I+1) = Q(1:NUMR3I+1) + T(1:NUMR3I+1)
d332 2
a333 2
	   ELSE
	      T(2) = CIRC1(NUMR2I+1) * CIRC2(NUMR2I+1)
d338 2
a339 2
	         DO J=3,MAXRIN,2
	            JC      =  J+NUMR2I-1
d341 1
a341 1
	            T(J)    =  (CIRC1(JC))*CIRC2(JC) -
d344 1
a344 1
	             T(J+1) = -(CIRC1(JC))*CIRC2(JC+1) -
d346 1
a346 1
	         ENDDO
d348 2
a349 2
	         DO J=3,MAXRIN,2
	            JC      =  J+NUMR2I-1
d351 1
a351 1
	            T(J)    =  (CIRC1(JC))*CIRC2(JC) +
d354 1
a354 1
	             T(J+1) = -(CIRC1(JC))*CIRC2(JC+1) +
d356 1
a356 1
	         ENDDO
d359 1
a359 1
	      Q = Q + T
d361 1
a361 1
	ENDDO
d364 6
a369 6
	INV         = -1
	LDA         = 1
	Q(MAXRIN+1) = Q(2)
	Q(2)        = 0.0
	Q(MAXRIN+2) = 0.0
	CALL ZDFFT1DU(INV,IP,Q,LDA,TT)
d371 1
a371 1
	CALL FFTR_D(Q,IP)
d374 104
a477 7
	QN = -1.0D20
	DO J=1,MAXRIN
	   IF (Q(J) .GE. QN) THEN
	      QN   = Q(J)
	      JTOT = J
	   ENDIF
	ENDDO 
d479 19
d499 192
a690 1
	QN = QN/MAXRIN
a691 4
	DO K=-3,3
           J     = MOD(JTOT+K+MAXRIN-1,MAXRIN) + 1
	   T7(K) = Q(J)
	ENDDO
a692 1
	CALL PRB1D(T7,7,POS)
a693 1
	TOT = FLOAT(JTOT) + POS
d695 183
a877 1
	END
@


1.8
log
@HRI GPL License used
@
text
@a5 1
C * SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK       *
d9 1
a9 1
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *  
a28 6

C * COPYRIGHT (C)1985, 2003. HEALTH RESEARCH INCORPORATED (HRI),       *
C * ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C * THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HRI AND ARE NOT   *
C * TO BE DISCLOSED TO OTHERS OR USED FOR PURPOSES OTHER THAN INTENDED *
C * WITHOUT WRITTEN APPROVAL OF HRI.                                   *
@


1.7
log
@was missing else... endif
@
text
@d7 24
@


1.6
log
@MERGED CROSRMG_DS.F & CROSRNG_DS
@
text
@d56 1
a56 1
	   IF (NUMR3I .NE. MAXRIN)  THEN
d73 1
a73 1

d86 1
a86 1

d115 1
@


1.5
log
@cosmetic
@
text
@d1 1
a1 1
C++************************************************************************
d3 2
a4 2
C CROSRNG_DS.F 
C
d14 3
a16 1
C CROSRNG_DS(CIRC1,CIRC2,LCIRC,NRING,MAXRIN,NUMR,QN,TOT,TT)
d18 3
a20 2
C  INPUT - FOURIER TRANSFORMS OF RINGS!!!
C  CIRC1 ALREADY MULTIPLIED BY WEIGHTS!!
d23 1
a23 1
C--************************************************************************
d25 2
a26 2
	SUBROUTINE CROSRNG_DS(CIRC1,CIRC2,LCIRC,NRING,MAXRIN,NUMR,
     &                        QN,TOT,TT)
d31 1
d38 1
a38 1
        DATA  ICALL/0/
a39 1
	IP = MAXRIN
d41 1
a41 1
	IP=-LOG2(IP)
a43 1

d50 1
a50 1
 	DO I=1,NRING
d54 1
a54 1
	   T(1) = (CIRC1(NUMR2I)) * CIRC2(NUMR2I)
d57 2
a58 1
	      T(NUMR3I+1) = (CIRC1(NUMR2I+1))*CIRC2(NUMR2I+1)
d61 2
a62 2
	      DO J=3,NUMR3I,2
	         JC     = J+NUMR2I-1
d64 2
a65 2
	         T(J)   =  (CIRC1(JC))*CIRC2(JC) +
     &                     (CIRC1(JC+1))*CIRC2(JC+1)
d67 14
a80 1
	         T(J+1) = -(CIRC1(JC))*CIRC2(JC+1) +
d82 2
a83 1
	      ENDDO
d90 5
a94 2
	      DO J=3,MAXRIN,2
	         JC     =  J+NUMR2I-1
d96 2
a97 2
	         T(J)   =  (CIRC1(JC))*CIRC2(JC) +
     &                     (CIRC1(JC+1))*CIRC2(JC+1)
d99 15
a113 3
	         T(J+1) = -(CIRC1(JC))*CIRC2(JC+1) +
     &                     (CIRC1(JC+1))*CIRC2(JC)
	      ENDDO
a114 1
           ENDIF
d116 1
a116 1
 
d123 1
a123 4
	CALL  ZDFFT1DU(INV,IP,Q,LDA,TT)

C       SKIP THE NORMALIZATION, DIVIDE THE MAXIMUM INSTEAD.
C	CALL DSCAL1D(IP,1.0D0/DBLE(FLOAT(IP)),Q,LDA)
d127 1
a127 1

d130 1
a130 1
	   IF (Q(J) .GE. QN)  THEN
d134 2
a135 1
	ENDDO
d137 1
a137 1
	QN=QN/MAXRIN
a138 1

d144 1
a144 1
	CALL  PRB1D(T7,7,POS)
@


1.4
log
@*** empty log message ***
@
text
@d3 1
a3 1
C $$ CROSRNG_DS.FOR
d5 8
a12 9
C **************************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
C *  COPYRIGHT (C)1981,1987, WADSWORTH CENTER FOR LABORATORIES AND         *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *  THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR       *
C *  LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR    *
C *  USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF     *
C *  THE CENTER FOR LABORATORIES AND RESEARCH                              *
C **************************************************************************
d14 1
a14 1
C IMAGE_PROCESSING_ROUTINE
d16 2
a17 1
C        1         2         3         4         5         6         7
d21 10
a30 15
C
C $$ CROSRNG_DS.FOR
C
	SUBROUTINE  CROSRNG_DS
     &   (CIRC1,CIRC2,LCIRC,NRING,MAXRIN,NUMR,QN,TOT,TT)
C
C  INPUT - Fourier transforms of rings!!!
C  CIRC1 already multiplied by weights!!
C
	INTEGER  NUMR(3,NRING),MAXRIN,NUMR3I,NUMR2I
	DIMENSION  CIRC1(LCIRC),CIRC2(LCIRC)
	DOUBLE PRECISION  TT(*)
	DOUBLE PRECISION  QN,T7(-3:3)
C Automatic arrays
	DIMENSION  T(MAXRIN+2)
d32 3
d36 2
a37 3
	IP=MAXRIN
#ifdef SP_LIBFFT
#else
d41 25
a65 15
	Q=0.0D0
	T(MAXRIN+1)=0.0
	T(MAXRIN+2)=0.0

	DO    I=1,NRING
	   NUMR3I=NUMR(3,I)
	   NUMR2I=NUMR(2,I)

	   T(1)=(CIRC1(NUMR2I))*CIRC2(NUMR2I)
	   IF(NUMR3I.EQ.MAXRIN)  THEN
	      T(2)=(CIRC1(NUMR2I+1))*CIRC2(NUMR2I+1)
	      DO    J=3,MAXRIN,2
	         JC=J+NUMR2I-1
	T(J)=(CIRC1(JC))*CIRC2(JC)+(CIRC1(JC+1))*CIRC2(JC+1)
	T(J+1)=-(CIRC1(JC))*CIRC2(JC+1)+(CIRC1(JC+1))*CIRC2(JC)
d67 3
a69 1
	      Q=Q+T
d71 10
a80 6
	      T(NUMR3I+1)=(CIRC1(NUMR2I+1))*CIRC2(NUMR2I+1)
	      T(2)=0.0
	      DO    J=3,NUMR3I,2
	         JC=J+NUMR2I-1
	T(J)=(CIRC1(JC))*CIRC2(JC)+(CIRC1(JC+1))*CIRC2(JC+1)
	T(J+1)=-(CIRC1(JC))*CIRC2(JC+1)+(CIRC1(JC+1))*CIRC2(JC)
d82 2
a83 3
C###
	      Q(1:NUMR3I+1)=Q(1:NUMR3I+1)+T(1:NUMR3I+1)
	   ENDIF
d85 1
a85 1
C
d87 5
a91 5
	INV=-1
	LDA=1
	Q(MAXRIN+1)=Q(2)
	Q(2)=0.0
	Q(MAXRIN+2)=0.0
d93 3
a95 2
C skip the normalization, divide the maximum instead.
C	CALL  DSCAL1D(IP,1.0D0/DBLE(FLOAT(IP)),Q,LDA)
d97 1
a97 1
	CALL  FFTR_D(Q,IP)
d99 6
a104 6
C
	QN=-1.0D20
	DO    J=1,MAXRIN
	   IF(Q(J).GE.QN)  THEN
	      QN=Q(J)
	      JTOT=J
d110 4
a113 4
C
	DO    K=-3,3
           J=MOD(JTOT+K+MAXRIN-1,MAXRIN)+1
	   T7(K)=Q(J)
d115 1
d117 3
a119 1
	TOT=FLOAT(JTOT)+POS
@


1.3
log
@header & cosmetic
@
text
@d70 1
a70 3
	      DO    J=1,NUMR3I+1
	         Q(J)=Q(J)+T(J)
	      ENDDO
@


1.2
log
@replaced log2_p log2
@
text
@d15 1
d17 1
d37 1
a37 1
C
d43 1
a43 1
C
d47 1
a47 1
C
d49 8
a56 8
	NUMR3I=NUMR(3,I)
	NUMR2I=NUMR(2,I)
C
	T(1)=(CIRC1(NUMR2I))*CIRC2(NUMR2I)
	IF(NUMR3I.EQ.MAXRIN)  THEN
	T(2)=(CIRC1(NUMR2I+1))*CIRC2(NUMR2I+1)
	DO    J=3,MAXRIN,2
	JC=J+NUMR2I-1
d59 7
a65 7
	ENDDO
	Q=Q+T
	ELSE
	T(NUMR3I+1)=(CIRC1(NUMR2I+1))*CIRC2(NUMR2I+1)
	T(2)=0.0
	DO    J=3,NUMR3I,2
	JC=J+NUMR2I-1
d68 1
a68 1
	ENDDO
d70 4
a73 4
	DO    J=1,NUMR3I+1
	Q(J)=Q(J)+T(J)
	ENDDO
	ENDIF
d91 4
a94 4
	IF(Q(J).GE.QN)  THEN
	QN=Q(J)
	JTOT=J
	ENDIF
d101 2
a102 2
        J=MOD(JTOT+K+MAXRIN-1,MAXRIN)+1
	T7(K)=Q(J)
@


1.1
log
@Initial revision
@
text
@d39 1
a39 1
	IP=-LOG2_P(IP)
@
