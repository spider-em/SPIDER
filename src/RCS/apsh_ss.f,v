head	1.110;
access;
symbols
	pre_mrcs:1.109
	healthdept_2018:1.109
	pre_getangas:1.99
	GPL2010:1.95
	pre_GPL2010:1.94
	pre_var_equation:1.90
	pre_fftwrings:1.87
	pre_opfiles:1.84
	src:1.84
	best-code:1.82
	x-named-regs:1.82
	x:1.82
	v13-00:1.82
	pre_GPL:1.80
	prec_CA:1.66
	noindx:1.58
	Bproc:1.43
	oct21:1.33
	last77:1.20;
locks; strict;
comment	@c @;


1.110
date	2025.11.10.22.32.00;	author dean;	state Exp;
branches;
next	1.109;

1.109
date	2018.10.03.14.33.55;	author leith;	state Exp;
branches;
next	1.108;

1.108
date	2015.04.24.14.03.31;	author leith;	state Exp;
branches;
next	1.107;

1.107
date	2012.05.09.15.01.33;	author leith;	state Exp;
branches;
next	1.106;

1.106
date	2012.04.16.17.16.42;	author leith;	state Exp;
branches;
next	1.105;

1.105
date	2012.01.18.13.38.15;	author leith;	state Exp;
branches;
next	1.104;

1.104
date	2012.01.11.15.10.49;	author leith;	state Exp;
branches;
next	1.103;

1.103
date	2011.12.23.16.14.29;	author leith;	state Exp;
branches;
next	1.102;

1.102
date	2011.12.02.14.39.02;	author leith;	state Exp;
branches;
next	1.101;

1.101
date	2011.04.12.15.19.16;	author leith;	state Exp;
branches;
next	1.100;

1.100
date	2011.02.16.18.50.00;	author leith;	state Exp;
branches;
next	1.99;

1.99
date	2011.01.21.16.22.16;	author leith;	state Exp;
branches;
next	1.98;

1.98
date	2010.10.12.18.32.31;	author leith;	state Exp;
branches;
next	1.97;

1.97
date	2010.06.25.17.44.51;	author leith;	state Exp;
branches;
next	1.96;

1.96
date	2010.06.24.19.11.10;	author leith;	state Exp;
branches;
next	1.95;

1.95
date	2010.06.24.13.26.16;	author leith;	state Exp;
branches;
next	1.94;

1.94
date	2010.05.26.15.49.47;	author leith;	state Exp;
branches;
next	1.93;

1.93
date	2010.03.02.13.04.44;	author leith;	state Exp;
branches;
next	1.92;

1.92
date	2009.08.28.15.36.25;	author leith;	state Exp;
branches;
next	1.91;

1.91
date	2009.08.11.13.36.59;	author leith;	state Exp;
branches;
next	1.90;

1.90
date	2008.11.25.17.40.43;	author leith;	state Exp;
branches;
next	1.89;

1.89
date	2008.11.25.15.47.32;	author leith;	state Exp;
branches;
next	1.88;

1.88
date	2008.05.19.12.02.36;	author leith;	state Exp;
branches;
next	1.87;

1.87
date	2008.04.08.13.48.16;	author leith;	state Exp;
branches;
next	1.86;

1.86
date	2008.03.19.12.12.20;	author leith;	state Exp;
branches;
next	1.85;

1.85
date	2007.03.19.14.06.30;	author leith;	state Exp;
branches;
next	1.84;

1.84
date	2006.09.05.15.52.47;	author leith;	state Exp;
branches;
next	1.83;

1.83
date	2006.06.23.13.41.53;	author leith;	state Exp;
branches;
next	1.82;

1.82
date	2005.10.17.19.53.21;	author leith;	state Exp;
branches;
next	1.81;

1.81
date	2005.10.17.17.50.28;	author leith;	state Exp;
branches;
next	1.80;

1.80
date	2005.08.01.15.13.31;	author leith;	state Exp;
branches;
next	1.79;

1.79
date	2005.03.23.15.35.14;	author leith;	state Exp;
branches;
next	1.78;

1.78
date	2005.01.27.16.00.58;	author leith;	state Exp;
branches;
next	1.77;

1.77
date	2004.11.15.20.41.52;	author leith;	state Exp;
branches;
next	1.76;

1.76
date	2004.11.02.15.20.29;	author leith;	state Exp;
branches;
next	1.75;

1.75
date	2004.10.07.14.33.29;	author leith;	state Exp;
branches;
next	1.74;

1.74
date	2004.08.17.19.29.07;	author leith;	state Exp;
branches;
next	1.73;

1.73
date	2004.08.05.13.44.03;	author leith;	state Exp;
branches;
next	1.72;

1.72
date	2004.04.23.16.36.17;	author leith;	state Exp;
branches;
next	1.71;

1.71
date	2004.04.23.15.58.23;	author leith;	state Exp;
branches;
next	1.70;

1.70
date	2004.04.23.15.32.02;	author leith;	state Exp;
branches;
next	1.69;

1.69
date	2004.03.22.13.55.55;	author leith;	state Exp;
branches;
next	1.68;

1.68
date	2004.03.18.14.48.20;	author leith;	state Exp;
branches;
next	1.67;

1.67
date	2003.12.10.19.59.21;	author leith;	state Exp;
branches;
next	1.66;

1.66
date	2003.09.05.18.14.42;	author leith;	state Exp;
branches;
next	1.65;

1.65
date	2003.09.05.14.22.38;	author leith;	state Exp;
branches;
next	1.64;

1.64
date	2003.09.02.14.55.09;	author leith;	state Exp;
branches;
next	1.63;

1.63
date	2003.08.27.15.01.31;	author leith;	state Exp;
branches;
next	1.62;

1.62
date	2003.08.27.14.51.14;	author leith;	state Exp;
branches;
next	1.61;

1.61
date	2003.07.24.14.36.14;	author leith;	state Exp;
branches;
next	1.60;

1.60
date	2003.07.14.13.03.44;	author leith;	state Exp;
branches;
next	1.59;

1.59
date	2003.02.19.21.41.02;	author leith;	state Exp;
branches;
next	1.58;

1.58
date	2002.12.30.14.50.49;	author leith;	state Exp;
branches;
next	1.57;

1.57
date	2002.05.01.14.04.09;	author leith;	state Exp;
branches;
next	1.56;

1.56
date	2002.04.30.19.06.06;	author leith;	state Exp;
branches;
next	1.55;

1.55
date	2002.03.11.14.07.52;	author leith;	state Exp;
branches;
next	1.54;

1.54
date	2002.01.22.20.57.27;	author leith;	state Exp;
branches;
next	1.53;

1.53
date	2002.01.22.18.36.01;	author leith;	state Exp;
branches;
next	1.52;

1.52
date	2001.11.05.19.08.18;	author hxgao;	state Exp;
branches;
next	1.51;

1.51
date	2001.10.09.16.58.30;	author leith;	state Exp;
branches;
next	1.50;

1.50
date	2001.08.27.14.25.18;	author leith;	state Exp;
branches;
next	1.49;

1.49
date	2001.04.13.16.04.35;	author leith;	state Exp;
branches;
next	1.48;

1.48
date	2001.04.09.14.05.04;	author leith;	state Exp;
branches;
next	1.47;

1.47
date	2001.03.28.15.21.44;	author leith;	state Exp;
branches;
next	1.46;

1.46
date	2001.02.02.20.33.04;	author pawel;	state Exp;
branches;
next	1.45;

1.45
date	2000.12.15.18.29.33;	author leith;	state Exp;
branches;
next	1.44;

1.44
date	2000.10.03.19.57.10;	author bimal;	state Exp;
branches;
next	1.43;

1.43
date	2000.08.22.18.47.47;	author leith;	state Exp;
branches;
next	1.42;

1.42
date	2000.03.21.21.02.28;	author leith;	state Exp;
branches;
next	1.41;

1.41
date	2000.03.20.20.31.53;	author leith;	state Exp;
branches;
next	1.40;

1.40
date	2000.01.27.15.56.54;	author leith;	state Exp;
branches;
next	1.39;

1.39
date	2000.01.06.18.31.29;	author leith;	state Exp;
branches;
next	1.38;

1.38
date	2000.01.06.18.18.47;	author leith;	state Exp;
branches;
next	1.37;

1.37
date	2000.01.06.17.54.24;	author leith;	state Exp;
branches;
next	1.36;

1.36
date	99.12.03.20.33.51;	author leith;	state Exp;
branches;
next	1.35;

1.35
date	99.12.03.20.21.56;	author leith;	state Exp;
branches;
next	1.34;

1.34
date	99.10.25.18.22.43;	author pawel;	state Exp;
branches;
next	1.33;

1.33
date	99.10.20.21.39.19;	author pawel;	state Exp;
branches;
next	1.32;

1.32
date	99.08.05.13.27.37;	author pawel;	state Exp;
branches;
next	1.31;

1.31
date	99.08.04.21.12.19;	author pawel;	state Exp;
branches;
next	1.30;

1.30
date	99.08.04.13.04.42;	author pawel;	state Exp;
branches;
next	1.29;

1.29
date	99.08.03.20.51.39;	author pawel;	state Exp;
branches;
next	1.28;

1.28
date	99.08.03.19.36.59;	author pawel;	state Exp;
branches;
next	1.27;

1.27
date	99.08.03.19.23.15;	author pawel;	state Exp;
branches;
next	1.26;

1.26
date	99.08.03.18.58.21;	author pawel;	state Exp;
branches;
next	1.25;

1.25
date	99.07.30.14.36.34;	author pawel;	state Exp;
branches;
next	1.24;

1.24
date	99.07.26.21.25.04;	author pawel;	state Exp;
branches;
next	1.23;

1.23
date	99.06.03.20.50.54;	author pawel;	state Exp;
branches;
next	1.22;

1.22
date	99.05.03.19.53.19;	author pawel;	state Exp;
branches;
next	1.21;

1.21
date	99.04.16.14.12.11;	author pawel;	state Exp;
branches;
next	1.20;

1.20
date	99.03.19.15.01.06;	author pawel;	state Exp;
branches;
next	1.19;

1.19
date	99.03.01.18.34.14;	author pawel;	state Exp;
branches;
next	1.18;

1.18
date	99.03.01.14.55.11;	author pawel;	state Exp;
branches;
next	1.17;

1.17
date	99.02.13.18.55.34;	author pawel;	state Exp;
branches;
next	1.16;

1.16
date	99.02.11.15.31.05;	author pawel;	state Exp;
branches;
next	1.15;

1.15
date	99.02.10.16.08.42;	author pawel;	state Exp;
branches;
next	1.14;

1.14
date	98.11.30.19.20.33;	author pawel;	state Exp;
branches;
next	1.13;

1.13
date	98.11.06.20.53.04;	author pawel;	state Exp;
branches;
next	1.12;

1.12
date	98.11.05.21.16.55;	author pawel;	state Exp;
branches;
next	1.11;

1.11
date	98.11.03.23.32.35;	author pawel;	state Exp;
branches;
next	1.10;

1.10
date	98.11.02.20.31.40;	author pawel;	state Exp;
branches;
next	1.9;

1.9
date	98.10.30.16.23.50;	author pawel;	state Exp;
branches;
next	1.8;

1.8
date	98.04.06.19.25.35;	author pawel;	state Exp;
branches;
next	1.7;

1.7
date	97.10.17.15.19.05;	author pawel;	state Exp;
branches;
next	1.6;

1.6
date	97.10.10.17.48.04;	author pawel;	state Exp;
branches;
next	1.5;

1.5
date	97.08.15.16.15.54;	author pawel;	state Exp;
branches;
next	1.4;

1.4
date	97.08.15.16.05.56;	author pawel;	state Exp;
branches;
next	1.3;

1.3
date	97.08.15.13.27.04;	author pawel;	state Exp;
branches;
next	1.2;

1.2
date	97.07.24.15.08.46;	author pawel;	state Exp;
branches;
next	1.1;

1.1
date	97.01.21.15.29.57;	author pawel;	state Exp;
branches;
next	;


desc
@AP MQ
@


1.110
log
@*** empty log message ***
@
text
@C++*********************************************************************
C
C    APSH_SS.F      USED CMLIMIT                  AUG 00 ARDEAN LEITH
C                   ADDED REF_CIRC FILE           APR 01 ARDEAN LEITH
C                   NORMASS -> NORMAS             OCT 01 ARDEAN LEITH
C                   PROMPTS                       JAN 02 ARDEAN LEITH
C                   OPFILEC                       FEB 03 ARDEAN LEITH
C                   APMASTER REWRITE              AUG 03 ARDEAN LEITH
C                   'OR MQ' SUPPORT               SEP 03 ARDEAN LEITH
C                   AP_OUT USAGE                  FEB 04 ARDEAN LEITH
C                   'MQ' NOT READ EXP. ANGLES     APR 04 ARDEAN LEITH
C                   BAD PEAK IF INTERP ON EDGE    AUG 04 ARDEAN LEITH
C                   CROSRNG_E SPEEDS UP           AUG 04 ARDEAN LEITH
C                   AP_END CALL HAS PARLIST       OCT 04 ARDEAN LEITH
C                   LIMITRANGE BUG                OCT 04 ARDEAN LEITH
C                   PEAKV = 1                     JAN 05 ARDEAN LEITH
C                   DISCARD MIRROR ...            JUN 06 ARDEAN LEITH
C                   AP_STAT CALL                  JAN 07 ARDEAN LEITH
C                   USE FFTW3 IN APRINGS          MAR 08 ARDEAN LEITH
C                   APRINGS_ONE_NEW               APR 08 ARDEAN LEITH
C                   AP_END CALL ALTERED           NOV 08 ARDEAN LEITH
C                   AP_STAT_ADD                   NOV 08 ARDEAN LEITH
C                   CIRCREF NOT INCORE            AUG 09 ARDEAN LEITH
C                   ISHRANGEX                     FEB 10 ARDEAN LEITH
C                   ANGREF NOT IN OUTPUT          MAY 10 ARDEAN LEITH
C                   CROSRNG NO TT                 JUN 10 ARDEAN LEITH
C                   CROSRNG_2, REMOVED IA_64      JUN 10 ARDEAN LEITH
C                   AP_STAT NBORDER               OCT 10 ARDEAN LEITH
C                   MAKE_CLOSE_LIST, GETANGAS     FEB 11 ARDEAN LEITH
C                   AP_GETDATA USED               NOV 11 ARDEAN LEITH  
C                   ROTFIRST                      DEC 11 ARDEAN LEITH
C
C **********************************************************************
C=*                                                                    *
C=* This file is part of:   SPIDER - Modular Image Processing System.  *
C=* SPIDER System Authors:  Joachim Frank & ArDean Leith               *
C=* Copyright 1985-2011  Health Research Inc.,                         *
C=* Riverview Center, 150 Broadway, Suite 560, Menands, NY 12204.      *
C=* Email: spider@@wadsworth.org                                        *
C=*                                                                    *
C=* SPIDER is free software; you can redistribute it and/or            *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* SPIDER is distributed in the hope that it will be useful,          *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* merchantability or fitness for a particular purpose.  See the GNU  *
C=* General Public License for more details.                           *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program. If not, see <http://www.gnu.org/licenses> *
C=*                                                                    *
C **********************************************************************
C
C  APSH_SS(IREFLIST,NUMREF,IEXPLIST,NUMEXP, 
C           NX,NY,NR,ISHRANGEX,ISHRANGEY,ISTEP,
C           NRING,LCIRC,NUMR,CIRCREF,CIRCREF_IN_CORE,
C           MODE,REFANGDOC,EXPANGDOC,SCRFILE,FFTW_PLANS,
C           REFPAT,EXPPAT,RANGE,ROTFIRST,CKMIRROR,
C           CTYPE,LUNDOC,FBS_WANTED)
C
C  PURPOSE: FIND ROTATIONAL AND SHIFT PARAMETERS TO ALIGN A SERIES OF
C           REFERENCE IMAGES WITH SERIES OF SAMPLE IMAGES
C
C           VERSION FOR MP AND A SMALL NUMBER OF IMAGES TO BE ALIGNED. 
C           NOT FOR MPI USE.
C
C  OPERATIONS:  'AP SH', 'AP OR'
C
C PARAMETERS:
C       IREFLIST            LIST OF REF. IMAGE FILE NUMBERS   (INPUT)
C       NUMREF              NO. OF REF. IMAGES                (INPUT)
C       IEXPLIST            LIST OF EXP. IMAGE FILE NUMBERS   (INPUT)
C       NUMEXP              NO. OF EXP IMAGES                 (INPUT)
C       REFANGDOC           REF. ANGLES FILE NAME             (INPUT)
C       EXPANGDOC           EXP. ANGLES FILE NAME             (INPUT)
C       REFPAT              REF. IMAGE SERIES FILE TEMPLATE   (INPUT)
C       EXPPAT              EXP. IMAGE SERIES FILE TEMPLATE   (INPUT)
C       ROTFIRST            USE RTSQ ON EXP INPUT IMAGES      (INPUT)
C
C23456789012345678901234567890123456789012345678901234567890123456789012
C--*********************************************************************

       SUBROUTINE APSH_SS(IREFLIST,NUMREF,IEXPLIST,NUMEXP, 
     &               NX,NY,ISHRANGEX,ISHRANGEY,ISTEP,
     &               NRING,LCIRC,NUMR,CIRCREF,CIRCREF_IN_CORE,
     &               MODE,REFANGDOC,EXPANGDOC,SCRFILE,FFTW_PLANS,
     &               REFPAT,EXPPAT,RANGE,ROTFIRST,
     &               CKMIRROR,CTYPE,LUNDOC,FBS_WANTED)

        INCLUDE 'MAKE_CLOSE_LIST.INC'  
	INCLUDE 'CMBLOCK.INC'
        INCLUDE 'CMLIMIT.INC'

	INTEGER               :: IREFLIST(NUMREF)
	INTEGER               :: IEXPLIST(NUMEXP)
	INTEGER               :: NUMREF,NUMEXP,NX,NY,ISHRANGEX,ISHRANGEY
	INTEGER               :: ISTEP,NRING,LCIRC
	INTEGER               :: NUMR(3,NRING)
	REAL                  :: CIRCREF(LCIRC,NUMREF)
	LOGICAL               :: CIRCREF_IN_CORE
	LOGICAL               :: MIRRORNEW
	LOGICAL               :: GOTREFANG
	LOGICAL               :: LIMITRANGE
	CHARACTER (LEN=1)     :: MODE,NULL
        CHARACTER (LEN=*)     :: REFANGDOC,EXPANGDOC
        CHARACTER (LEN=*)     :: SCRFILE
        CHARACTER (LEN=*)     :: REFPAT,EXPPAT
        CHARACTER (LEN=*)     :: CTYPE
	LOGICAL               :: ROTFIRST,CKMIRROR
        INTEGER               :: LUNDOC
        LOGICAL               :: FBS_WANTED

	DOUBLE PRECISION      :: FITP(-1:1,-1:1)

	DOUBLE PRECISION      :: CCROTD,PEAK,CCROTD_INTERP
        INTEGER *8            :: FFTW_PLANS(*)

C       AUTOMATIC ARRAYS
	DOUBLE PRECISION      :: CCOA(NUMREF,   -ISHRANGEX:ISHRANGEX,
     &                                          -ISHRANGEY:ISHRANGEY)
	REAL                  :: RANGOA(NUMREF, -ISHRANGEX:ISHRANGEX,
     &                                          -ISHRANGEY:ISHRANGEY)
	LOGICAL               :: ISMIRRORED(NUMREF, 
     &                                          -ISHRANGEX:ISHRANGEX,
     &                                          -ISHRANGEY:ISHRANGEY)

	DOUBLE PRECISION      :: FIT(     -ISTEP:ISTEP,-ISTEP:ISTEP)
	DIMENSION             :: ROTMP(   -ISTEP:ISTEP,-ISTEP:ISTEP)
        LOGICAL               :: ISMIRDUM(-ISTEP:ISTEP,-ISTEP:ISTEP)

        INTEGER, POINTER      :: LCG(:)
	REAL                  :: ANGOUT(3)
	REAL                  :: EXPDIR(3)
        LOGICAL               :: USE_UN,USE_MIR
        LOGICAL               :: ANGINHEADER  

C       ALLOCATED ARRAYS
	REAL, ALLOCATABLE     :: CIRCEXP(:,:,:)
	REAL, ALLOCATABLE     :: A(:,:)
	REAL, ALLOCATABLE     :: REFDIR(:,:) 
	REAL, ALLOCATABLE     :: ANGREF(:,:),ANGEXP(:,:)
	REAL, ALLOCATABLE     :: TMPBUF(:,:)
 
        LOGICAL, PARAMETER    :: MPIBCAST = .TRUE.
        LOGICAL, PARAMETER    :: USE_OMP  = .FALSE.
        INTEGER, PARAMETER    :: NLISTMAX = 15
        REAL                  :: PARLIST(NLISTMAX)

        REAL, PARAMETER       :: QUADPI = 3.1415926535
        REAL, PARAMETER       :: DGR_TO_RAD = (QUADPI/180)

        INTEGER               :: NBORDER = 0       ! # BORDER PIXELS
        INTEGER               :: NSUBPIX = 0       ! # SUBPIX PIXELS

        INTEGER, PARAMETER    :: INPIC   = 77
        INTEGER, PARAMETER    :: INANG   = 78
        INTEGER, PARAMETER    :: LUNRING = 50

        NULL = CHAR(0)

C       INITIALIZE CCROT STATISTICS COUNTERS
        ANGDIFTHR   = 0.0
        CALL  AP_STAT_ADD(-1,CCROT,ANGDIF,ANGDIFTHR,CCROTLAS,
     &                  CCROTAVG,IBIGANGDIF,ANGDIFAVG,IMPROVCCROT,
     &                  CCROTIMPROV,IWORSECCROT,CCROTWORSE)

C       FLAG FOR RESTRICTED PROJECTION RANGE
        LIMITRANGE = RANGE .GT. 0 .AND. RANGE .LT. 360

        MAXRIN = NUMR(3,NRING)
#ifdef SP_LIBFFTW3
        MAXRIN = NUMR(3,NRING) -2  ! ACTUAL LENGTH OF LONGEST RING
#endif

	RANGECOS = COS(RANGE*DGR_TO_RAD)
        WR       = 0.0    ! DUMMY VALUE FLAG FOR APRINGS CALL

C       FIND NUMBER OF OMP THREADS
        CALL GETTHREADS(NUMTH)
        CALL FLUSHRESULTS()

C       READ REFERENCE IMAGES INTO REFERENCE RINGS (CIRCREF) ARRAY OR
C       CREATE REFERENCE RINGS FILE FOR LATER READING 

        CALL APRINGS_NEW(IREFLIST,NUMREF, NX,NY,
     &               NRING,LCIRC,NUMR,MODE,FFTW_PLANS,
     &               REFPAT,INPIC,CIRCREF,CIRCREF_IN_CORE,
     &               LUNRING,SCRFILE,IRTFLG)

        IF (CIRCREF_IN_CORE) THEN
           WRITE(NOUT,91)NUMTH
91         FORMAT('  Ref. rings in core,  Threads: ',I4)
        ELSE
           WRITE(NOUT,92)NUMTH
92         FORMAT('  Ref. rings not in core,  Threads: ',I4)
        ENDIF

	NSISX = MAX(ISHRANGEX/ISTEP, ISTEP)
	NSISY = MAX(ISHRANGEY/ISTEP, ISTEP)
	ALLOCATE(CIRCEXP(LCIRC,-NSISX:NSISX, -NSISY:NSISY),
     &           A(NX,NY), 
     &           STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
           NSISTX = 2 * NSISX + 1
           NSISTY = 2 * NSISY + 1
           MWANT = LCIRC*NSISTX*NSISTY + NX*NY 
           CALL  ERRT(46,'APSH_SS; CIRCEXP,....',MWANT)
           GOTO 9999
        ENDIF 

        NULLIFY(LCG)             ! INTEL COMPILER REQUIRES THIS
        NUMREFLCG = NUMREF
        IEND      = NUMREF
        NGOTPAR   = 0
        GOTREFANG = .FALSE.

        IF (LIMITRANGE .OR. CTYPE(1:2) .EQ. 'SH') THEN
C          REFANGLES FILE FOR RESTRICTED ANGULAR SEARCH  OR 'SH'
	   ALLOCATE(ANGREF(3,NUMREF), 
     &              REFDIR(3,NUMREF),STAT=IRTFLG)
	   IF (IRTFLG .NE. 0) THEN
               MWANT = 6*NUMREF  
               CALL ERRT(46,'APSH_SS; ANGREF..',MWANT)
               RETURN
           ENDIF 

C          READ REF. ANGLES INTO ANGREF FROM REFANGDOC OR HEADER
C          CONVERT REF. ANGLES TO UNITARY DIRECTIONAL VECTORS (REFDIR).
	   CALL AP_GETANGAS(IREFLIST,NUMREF,0,REFANGDOC,REFPAT,
     &                     INPIC,INANG,3,ANGREF,GOTREFANG,NGOTREF,
     &                     .TRUE.,REFDIR,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9999
        ENDIF
   
        IF (EXPANGDOC .NE. NULL) THEN
	   ALLOCATE(ANGEXP(8,NUMEXP), STAT=IRTFLG)
	   IF (IRTFLG .NE. 0) THEN
              CALL ERRT(46,'APSH_SS; ANGEXP',8*NUMEXP)
              RETURN
           ENDIF 

C          LOAD EXP. ANGLES & ALIGNMENT PARAMETERS (ANGEXP) 
C          FROM DOC. FILE (EXPANGDOC) OR IMAGE FILE (REFPAT) HEAD
C          THIS RETURNS NGOTPAR
	   CALL AP_GETANGAS(IEXPLIST,NUMEXP,0,EXPANGDOC,EXPPAT,
     &                     INPIC,INANG,8,ANGEXP,GOTEXPANG,NGOTPAR,
     &                     .FALSE.,EXPDIR,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9999
        ENDIF

        ANGINHEADER = .FALSE. ! unfinished !!!!!!!!!!!
        IF (ROTFIRST) THEN
	   ALLOCATE(TMPBUF(NX,NY), STAT=IRTFLG)
	   IF (IRTFLG .NE. 0) THEN
              CALL ERRT(46,'APSH_SS; TMPBUF',NX*NY)
              GOTO 9999
           ENDIF
           anginheader = (expangdoc == '*') ! unfinished !!!!!!!!!!!
           IF (FBS_WANTED) THEN
            WRITE(NOUT,*)' ALIGNING INPUT IMAGES WITH FBS INTERPOLATION'
           ELSE
           WRITE(NOUT,*)' ALIGNING INPUT IMAGES WITH QUAD INTERPOLATION'
           ENDIF
        ENDIF 

C       LOOP OVER EXP. IMAGES TO BE ALIGNED
	DO IEXP=1,NUMEXP
           IMGEXP = IEXPLIST(IEXP)

           IF (LIMITRANGE .AND. EXPANGDOC .NE. NULL) THEN
C             CONVERT EXP. ANGLE TO UNITARY DIRECTIONAL VECTORS (EXPDIR).
	      CALL AP_GETSATA(ANGEXP(1,IEXP),EXPDIR,8,1,IRTFLG)

C             MAKE LIST OF NEARBY REFERENCE IMAGES, RETURNS: NUMREFLCG
              CALL MAKE_CLOSE_LIST(NUMREF,LIMITRANGE,
     &                             REFDIR,EXPDIR,
     &                             RANGECOS, CKMIRROR, 
     &                             LCG, NUMREFLCG, IRTFLG)
              !print *,'numreflcg:',numreflcg
              !print *,'list:',lcg(1:numreflcg)
              IEND = NUMREFLCG

              IF (NUMREFLCG .LE. 0) THEN
C                REPORT THAT THERE ARE NO NEARBY REFERENCE IMAGES
                 IMGREF    = 0
                 PEAKV     = 0.0
                 CCROT     = 0.0
                 XSHNEW    = 0.0
                 YSHNEW    = 0.0
                 MIRRORNEW = .FALSE.

                 CALL AP_END(IEXP,IMGEXP,IMGREF,
     &                ANGREF,REFDIR,
     &                ANGEXP(1,IEXP),EXPDIR,ISHRANGEX,
     &                GOTREFANG, NGOTPAR, CCROT,PEAKV,
     &                RANGNEW,XSHNEW,YSHNEW,MIRRORNEW,REFPAT,
     &                NUMREFLCG, CTYPE, LUNDOC,PARLIST)

                 CYCLE
              ENDIF
           ENDIF

C          LOAD EXP. IMAGE DATA FOR THIS IMAGE
           IMITT = IEXP
           IF (CTYPE(1:2) == 'OR') IMITT = 0

           IF (ROTFIRST) THEN
C             WANT TO ROTATE/SHIFT EXP IMAGE WHEN READING THEM
	      CALL AP_GETDATA_RTSQ(IEXPLIST,NUMEXP, 
     &                    NX,NY, NX,NY,0.0,
     &                    NUMTH,EXPPAT,INPIC, IMITT,IMITT,
     &                    ANGINHEADER, ANGEXP(1,IEXP), 
     &                    MPIBCAST, TMPBUF, A,
     &                    .TRUE., AVI,SIGI, FBS_WANTED,IRTFLG)
           ELSE
	      CALL AP_GETDATA(IEXPLIST,NUMEXP,
     &                     NX,NY, NX,NY, 0.0,
     &                     NUMTH,EXPPAT,INPIC,IMITT,IMITT,
     &                     MPIBCAST,A, 
     &                     .TRUE.,AVI,SIGI, IRTFLG)
           ENDIF

           IF (IRTFLG .NE. 0) GOTO 9999

           IF ( CIRCREF_IN_CORE) THEN
C             USE CIRCREF ARRAY FOR REFERENCE RINGS
              !write(6,*) ' incore, old parallel '

C             LOOP OVER ALL SHIFTS IN ||
c$omp         parallel do private(jt,cnr2,it,cns2,imil,imi,use_un,
c$omp&              use_mir)
             
              DO JT=-ISHRANGEY,ISHRANGEY,ISTEP
C                LOOP OVER SHIFTED CENTERS IN Y
                 CNR2 = NY/2+1+JT

                 DO IT=-ISHRANGEX,ISHRANGEX,ISTEP
C                   LOOP OVER SHIFTED CENTERS IN X
                    CNS2 = NX/2+1+IT

C                   NORMALIZE IMAGE VALUES UNDER THE MASK OVER VARIANCE 
C                   RANGE INTERPOLATE TO POLAR COORDINATES, CREATE 
C                   FOURIER OF: CIRCEXP.  NO WEIGHTING OF RINGS
	            CALL APRINGS_ONE_NEW(NX,NY, CNS2,CNR2, 
     &                           A,.FALSE.,
     &                           MODE,NUMR,NRING,LCIRC,WR,FFTW_PLANS,
     &                           CIRCEXP(1,IT/ISTEP,JT/ISTEP),IRTFLG)

                    DO IMIL=1,IEND
C                      LOOP OVER REFERENCE IMAGES
                       IMI = IMIL
                       IF (LIMITRANGE) IMI = ABS(LCG(IMIL))

                       IF (CKMIRROR .AND. LIMITRANGE) THEN
C                         ONLY SEARCH EITHER MIRRORED OR NON-MIRRORED
                          USE_UN  = (LCG(IMIL) .GE. 0)
                          USE_MIR = (LCG(IMIL) .LT. 0)
                       ELSE
C                         SEARCH BOTH MIRRORED & NON-MIRRORED IF CHKMIR
                          USE_UN  = .TRUE.
                          USE_MIR = CKMIRROR
                       ENDIF

C                      CHECK EITHER MIRRORED/NON-MIRRORED POSITIONS 
                       CALL CROSRNG_2(CIRCREF(1,IMI),
     &                            CIRCEXP(1,IT/ISTEP,JT/ISTEP),
     &                            LCIRC,NRING, MAXRIN,NUMR,
     &                            USE_OMP,FFTW_PLANS(1),
     &                            USE_UN,USE_MIR,   
     &                            ISMIRRORED(IMI,IT,JT),
     &                            CCOA(IMI,IT,JT),RANGOA(IMI,IT,JT))
	            ENDDO  ! END OF: DO IMIL=1,IEND
                 ENDDO     ! END OF: DO IT=-ISHRANGEX,ISHRANGEX,ISTEP
              ENDDO        ! END OF: DO JT=-ISHRANGEY,ISHRANGEY,ISTEP

C$OMP         END PARALLEL DO
C             END OF THE OMP PARALLEL SECTION
           ELSE
              !write(6,*) ' not incore,  new parallel  '
C             USE REFERENCE RINGS FILE (MIGHT BE AN INCORE FILE?) -----

              DO JT=-ISHRANGEY,ISHRANGEY,ISTEP ! LOOP OVER ALL SHIFTS IN ||
C                LOOP OVER SHIFTED CENTERS IN Y
                 CNR2 = NY/2+1+JT

                 DO IT=-ISHRANGEX,ISHRANGEX,ISTEP
C                   LOOP OVER SHIFTED CENTERS IN X
                    CNS2 = NX/2+1+IT

C                   NORMALIZE IMAGE VALUES UNDER THE MASK OVER VARIANCE 
C                   RANGE INTERPOLATE TO POLAR COORDINATES, CREATE 
C                   FOURIER OF: CIRCEXP.  NO WEIGHTING OF RINGS
	            CALL APRINGS_ONE_NEW(NX,NY,  CNS2,CNR2, 
     &                           A,.FALSE.,
     &                           MODE,NUMR,NRING,LCIRC,WR,FFTW_PLANS,
     &                           CIRCEXP(1,IT/ISTEP,JT/ISTEP),IRTFLG)

c$omp               parallel do private(imil,imi,ithread,use_un,use_mir)
c$omp&              schedule(static,1)
                    DO IMIL=1,IEND
C                      LOOP OVER ALL REFERENCE IMAGES IN ||

                       IMI = IMIL
                       IF (LIMITRANGE) IMI = ABS(LCG(IMIL))
C                      FIND THREAD NUMBER 
                       ITHREAD = MOD((IMIL-1),NUMTH) + 1

C                      FILL CIRCREF FROM REFERENCE RINGS FILE
c$omp                  critical
                       CALL REDLIN(LUNRING,CIRCREF(1,ITHREAD),LCIRC,IMI)
c$omp                  end critical

                       IF (CKMIRROR .AND. LIMITRANGE) THEN
C                         ONLY SEARCH EITHER MIRRORED OR NON-MIRRORED
                          USE_UN  = (LCG(IMIL) .GE. 0)
                          USE_MIR = (LCG(IMIL) .LT. 0)
                       ELSE
C                         SEARCH BOTH MIRRORED & NON-MIRRORED IF CHKMIR
                          USE_UN  = .TRUE.
                          USE_MIR = CKMIRROR
                       ENDIF

C                      CHECK EITHER MIRRORED/NON-MIRRORED POSITIONS 
                       CALL CROSRNG_2(CIRCREF(1,ITHREAD),
     &                          CIRCEXP(1,IT/ISTEP,JT/ISTEP),
     &                          LCIRC,NRING, MAXRIN,NUMR,
     &                          USE_OMP,FFTW_PLANS(1),
     &                          USE_UN,USE_MIR,  ISMIRRORED(IMI,IT,JT),
     &                          CCOA(IMI,IT,JT), RANGOA(IMI,IT,JT))
	            ENDDO  ! END OF: DO IMIL=1,IEND
                 ENDDO     ! END OF: DO IT=-ISHRANGEX,ISHRANGEY,ISTEP
              ENDDO        ! END OF: DO JT=-ISHRANGEX,ISHRANGEY,ISTEP
           ENDIF           ! END OF: ELSE/IF ( CIRCREF_IN_CORE) THEN


C          LOCATE BEST CCROT MATCH FROM ALL THE VALUES ACCUMULATED ABOVE
           CCROTD  = -1.0D23

           DO JT=-ISHRANGEY,ISHRANGEY,ISTEP
              DO IT=-ISHRANGEX,ISHRANGEX,ISTEP

                 DO IRR=1,IEND
C                   LOOP OVER REFERENCE IMAGES
                    IR = IRR
                    IF (LIMITRANGE) IR = ABS(LCG(IRR))

                    IF (CCOA(IR,IT,JT) .GE. CCROTD)  THEN
C                      BETTER POSITION    
	               CCROTD    = CCOA(IR,IT,JT)
                       IREF      = IR
                       ISX       = IT
                       ISY       = JT
                       RANGNEW   = ANG_N(RANGOA(IR,IT,JT),MODE,MAXRIN)
                       MIRRORNEW = ISMIRRORED(IR,IT,JT)
                    ENDIF
                 ENDDO     ! END OF: DO IRR=1,IEND
               ENDDO        ! END OF: DO IT=-ISHRANGEX,ISHRANGEX,ISTEP
            ENDDO           ! END OF: DO JT=-ISHRANGEY,ISHRANGEY,ISTEP
C          write(6,*) 'iref: ',iref,  '   ccrotd: ',ccrotd

	   SX      = ISX
           SY      = ISY
	   CCROT   = CCROTD
           IMGREF  = IREFLIST(IREF)

           IF (CIRCREF_IN_CORE) THEN
              IREFT = IREF
           ELSE
C             FILL CIRCREF (1,1) FROM REFERENCE RINGS FILE
              IREFT = 1
              CALL REDLIN(LUNRING,CIRCREF(1,IREFT),LCIRC,IREF)
           ENDIF

#ifdef DEBUG
           write(6,921) imgref,isx,isy,ccrotd,rangnew
921        format(' 1 ',i5,' (',i3,',',i3,'): ',f14.4,' ',2f8.2,f6.1)
#endif

C          CHECK LOCATIONS WITHIN ISHRANGE AROUND MAX  ------------------
   
	   IF (ABS(ISX) .NE. ISHRANGEX .AND. 
     &         ABS(ISY) .NE. ISHRANGEY)  THEN
C             NOT ON BOUNDARY, HAVE TO FIND NEIGHBOURING VALUES

	      FIT(0,0)   = CCROTD
	      ROTMP(0,0) = RANGNEW

c$omp         parallel do private(jt,it,cnr2,cns2)
	      DO JT=-ISTEP,ISTEP
	         DO IT=-ISTEP,ISTEP
	            CNR2 = NY / 2 + 1 + JT + ISY
	            IF (IT.NE.0 .OR. JT.NE.0) THEN
	               CNS2 = NX / 2 + 1 + IT + ISX

C                      NORMALIZE IMAGE VALUES UNDER THE MASK OVER VARIANCE RANGE
C                      INTERPOLATE INTO POLAR COORDINATES
C                      CREATES FOURIER OF: CIRCEXP

	               CALL APRINGS_ONE_NEW(NX,NY, CNS2,CNR2, 
     &                           A,.FALSE.,
     &                           MODE,NUMR,NRING,LCIRC,WR,FFTW_PLANS,
     &                           CIRCEXP(1,IT,JT),IRTFLG)

C                      ONLY CHECK THE MIR/UN-MIR RETURNED ABOVE
                       CALL CROSRNG_2(CIRCREF(1,IREFT),
     &                          CIRCEXP(1,IT,JT),
     &                          LCIRC,NRING, MAXRIN,NUMR,
     &                          USE_OMP,FFTW_PLANS(1),
     &                          .NOT. MIRRORNEW,MIRRORNEW,  
     &                          ISMIRDUM(IT,JT),
     &                          FIT(IT,JT),ROTMP(IT,JT))

C                      RECORD BEST ANGLE IN ROTMP
	               ROTMP(IT,JT) = ANG_N(ROTMP(IT,JT),MODE,MAXRIN)
	            ENDIF
	         ENDDO      ! END OF: DO IT=-ISTEP,ISTEP
	      ENDDO         ! END OF: DO JT=-ISTEP,ISTEP
c$omp         end parallel do 
	         
C             FIND THE MAXIMUM CC ANGLE WITHIN +/-ISTEP
C             MAXIMUM CANNOT BE ON THE EDGE, I.E., IT,JT/=ISTEP

	      AFIT     = FIT(0,0)
	      JTMA     = 0
	      ITMA     = 0
              RANGNEWT = ROTMP(0,0)

	      IF (ISTEP .GT. 1) THEN
	         DO JT=-ISTEP+1,ISTEP-1
	            DO IT=-ISTEP+1,ISTEP-1
	               IF (FIT(IT,JT) .GT. AFIT)  THEN
	                  AFIT     = FIT(IT,JT)
	                  RANGNEWT = ROTMP(IT,JT) !compiler bug on OPT64
	                  ITMA     = IT
	                  JTMA     = JT
	               ENDIF
	            ENDDO
	         ENDDO
	      ENDIF    ! END OF: IF (ISTEP .GT. 1)
C             write(6,*) ((fit(i,j),i=-1,1),j=-1,1)

C             TEMP VARIABLE OVERCOMES COMPILER BUG ON OPT 64 PGI 6.0
              RANGNEW = RANGNEWT

C             COPY VALUES AROUND THE PEAK.
	      DO JT=-1,1
	         DO IT=-1,1
	            FITP(IT,JT) = FIT(ITMA+IT,JTMA+JT)
c                   write(6,910) it,jt,fitp(it,jt)
910                 format(' fitp(',i5,',',i5,') : ',f14.4)
	         ENDDO
	      ENDDO

C             UPDATE INTEGRAL LOCATION OF THE PEAK
              IF (AFIT > CCROTD) NBORDER = NBORDER + 1
	      CCROTD  = AFIT
	      ISX     = ISX + ITMA
	      ISY     = ISY + JTMA
              SX      = ISX
              SY      = ISY

#ifdef DEBUG
	      cnr2 = NY / 2 + 1 + isy
              cns2 = NX / 2 + 1 + isx
              write(6,905)imgref,isx,isy,ccrotd,rangnew,cns2,cnr2,sx,sy
905           format(' 2 ',i5,' (',i3,',',i3,'): ',f12.4,' ',5f8.2)
#endif

C             SUB-PIXEL INTERPOLATION ------------------------------

C             FIND PEAK BY FITTING PARABOLA TO 3x3 NEIGHBORHOOD
	      CALL PARABLD(FITP,SSX,SSY,PEAK)

	      IF (ABS(SSX) .LT. 1.0 .AND. ABS(SSY) .LT. 1.0)  THEN
C                INTERPOLATED LOCATION IS NOT ON BOUNDARY

	         CNS2 = NX/2+1 + SX + SSX
	         CNR2 = NY/2+1 + SY + SSY

C                NORMALIZE IMAGE VALUES UNDER MASK OVER VARIANCE RANGE
C                INTERPOLATE INTO POLAR COORD., CREATE FFT OF: CIRCEXP
C                CAN NOT USE: APRINGS_ONE_COEF AS NOT INTEGRAL SHIFT

	         CALL APRINGS_ONE_NEW(NX,NY, CNS2,CNR2, A,.FALSE.,
     &                           MODE,NUMR,NRING,LCIRC,WR,FFTW_PLANS,
     &                           CIRCEXP,IRTFLG)
 
C                ONLY CHECK THE MIR/UN-MIR RETURNED ABOVE
                 CALL CROSRNG_2(CIRCREF(1,IREFT), CIRCEXP,
     &                          LCIRC,NRING, MAXRIN,NUMR,
     &                          USE_OMP,FFTW_PLANS(1),
     &                          .NOT. MIRRORNEW,MIRRORNEW,  
     &                          ISMIRDUM(0,0),
     &                          CCROTD_INTERP,RANGNEW_INTERP)

#ifdef DEBUG
	         rt1 = ang_n(rangnew_interp,mode,maxrin)
                 write(6,904) imgref,isx,isy, ccrotd_interp,rt1,
     &                     cns2,cnr2, sx+ssx,sy+ssy
904              format(' 3 ',i5,' (',i3,',',i3,'): ',f12.4,' ',5f8.2)
#endif

                 IF (CCROTD_INTERP .GT. CCROTD) THEN
C                   USE SUB-PIXEL LOCATION
                    NSUBPIX = NSUBPIX + 1
                    CCROTD  = CCROTD_INTERP
	            RANGNEW = ANG_N(RANGNEW_INTERP,MODE,MAXRIN)
	            SX      = SX + SSX 
	            SY      = SY + SSY 
                 ENDIF
	      ENDIF  ! END OF: IF (ABS(SX) .LT. 1.0 .....
           ENDIF     ! END OF: IF ( ABS(ISX) .NE. ISHRANGE ......
	
           CCROT = CCROTD
	   SX    = -SX
	   SY    = -SY

C          HAVE TO CHANGE ORDER OF SHIFT & ROTATION.
C          IN THIS PROGRAM IMAGE IS SHIFTED FIRST, ROTATED SECOND.
C          IN 'RT SQ' IT IS ROTATION FIRST, SHIFT SECOND.
C          THIS CODE CORRESPONDS TO 'SA P'.
	   CO        =  COS(RANGNEW * DGR_TO_RAD)
	   SO        = -SIN(RANGNEW * DGR_TO_RAD)
	   XSHNEW    = SX*CO - SY*SO
	   YSHNEW    = SX*SO + SY*CO
           PEAKV     = 1.0

           !write(6,*) 'iref, angref:', iref,angref(1:3,iref)

           CALL AP_END(IEXP,IMGEXP,IMGREF,
     &                ANGREF(1,IREF),REFDIR(1,IREF),
     &                ANGEXP(1,IEXP),EXPDIR,ISHRANGEX,
     &                GOTREFANG, NGOTPAR, CCROT,PEAKV,
     &                RANGNEW,XSHNEW,YSHNEW,MIRRORNEW,REFPAT,
     &                NUMREFLCG, CTYPE, LUNDOC,PARLIST)

           CALL AP_STAT_ADD(NGOTPAR,CCROT,PARLIST(10),
     &                     ANGDIFTHR,ANGEXP(8,IEXP),
     &                     CCROTAVG,IBIGANGDIF,ANGDIFAVG,IMPROVCCROT,
     &                     CCROTIMPROV,IWORSECCROT,CCROTWORSE)

#ifdef DEBUG
           WRITE(6,96) 'HOST EXP:', IMGEXP,
     &                 '   REF:',   IMGREF,
     &                 '   XSH:',   ISX,
     &                 '   YSH:',   ISY,
     &                 '   RAY:',   IRAY,
     &                 '   CC:',    CCROTD
 96        FORMAT ('  ',A,I6, A,I5,  A,I3, A,I3, A,I5, A,F11.2)
           cns2 = NX / 2 + 1 - sx
           cnr2 = NY / 2 + 1 - sy
           write(6,906) imgref,isx,isy, ccrotd,rangnew,
     &                  cns2,cnr2, xshsum,yshsum
906        format(' 4 ',i5,' (',i3,',',i3,'): ',f12.4,' ',5f8.2)

           write(6,*) ' ------------------------------------- '
           write(6,*) '  '
#endif
	ENDDO
	
        CALL REG_GET_USED(NSEL_USED)
        IF (NSEL_USED .GT. 0 .AND. CTYPE(1:2) .EQ. 'OR') THEN
C           OUTPUT TO REGISTER NOT TO DOC FILE (FOR 'OR')
            DMR = 0
            IF (MIRRORNEW) DMR = 1
            CALL REG_SET_NSEL(1,5,RANGNEW,XSHNEW,YSHNEW,
     &                        DMR,CCROT,IRTFLG)
        ENDIF

        IF (LUNDOC .GT. 0 .AND. NUMEXP .GT. 1) THEN
C          SAVE CCROT & ANGULAR DISPLACEMENT STATISTICS
           CALL AP_STAT(NUMEXP,ANGDIFTHR,IBIGANGDIF,
     &                  ANGDIFAVG, CCROTAVG,
     &                  IMPROVCCROT,CCROTIMPROV,
     &                  IWORSECCROT,CCROTWORSE,
     &                  NBORDER,NSUBPIX,LUNDOC)
        ENDIF



9999    IF (ALLOCATED(CIRCEXP))  DEALLOCATE(CIRCEXP)
	IF (ALLOCATED(A))        DEALLOCATE(A)
	IF (ALLOCATED(ANGREF))   DEALLOCATE(ANGREF)
	IF (ALLOCATED(ANGEXP))   DEALLOCATE(ANGEXP)
	IF (ALLOCATED(REFDIR))   DEALLOCATE(REFDIR)
        IF (ASSOCIATED(LCG))     DEALLOCATE(LCG)
        NULLIFY(LCG)

	END

@


1.109
log
@email_health_dept
@
text
@d39 1
a39 1
C=* Email: spider@@health.ny.gov                                        *
@


1.108
log
@undefined anginheader
@
text
@d39 1
a39 1
C=* Email: spider@@wadsworth.org                                        *
@


1.107
log
@NULLIFY(LCG)             ! INTEL COMPILER REQUIRES THIS
@
text
@d252 1
@


1.106
log
@logical FBS_WANTED
@
text
@d212 1
@


1.105
log
@added rtsq call msg.
@
text
@d59 2
a60 1
C           REFPAT,EXPPAT,RANGE,ROTFIRST,CKMIRROR,CTYPE,LUNDOC)
d97 2
d111 3
a113 1
        INTEGER               :: LUNDOC,FBS_WANTED
@


1.104
log
@FBS_WANTED, added AP_GETDATA_RTSQ if rotfirst
@
text
@d253 5
@


1.103
log
@renamed nsam,nrow, added rotfirst support
@
text
@d88 1
a88 1
     &               CKMIRROR,CTYPE,LUNDOC)
d108 2
a110 1
	DOUBLE PRECISION      :: FITP(-1:1,-1:1)
d131 1
d140 2
a141 1
        LOGICAL, PARAMETER    :: USE_OMP = .FALSE.
d245 1
d252 1
d294 1
a294 1
           IF (CTYPE(1:2) .EQ. 'OR') IMITT = 0
d296 10
a305 1
	   CALL AP_GETDATA(IEXPLIST,NUMEXP,
d308 1
a308 1
     &                     .TRUE.,A, 
d310 2
@


1.102
log
@ap_getdats --> ap_getdata
@
text
@d31 1
d56 1
a56 1
C           NSAM,NROW,NR,ISHRANGEX,ISHRANGEY,ISTEP,
d59 1
a59 1
C           REFPAT,EXPPAT,RANGE,CKMIRROR,CTYPE,LUNDOC)
d78 1
d84 1
a84 1
     &               NSAM,NROW,ISHRANGEX,ISHRANGEY,ISTEP,
d87 2
a88 1
     &               REFPAT,EXPPAT,RANGE,CKMIRROR,CTYPE,LUNDOC)
d98 1
a98 1
	LOGICAL               :: CIRCREF_IN_CORE,CKMIRROR
d107 1
d136 1
d178 1
a178 1
        CALL APRINGS_NEW(IREFLIST,NUMREF, NSAM,NROW,
d194 1
a194 1
     &           A(NSAM,NROW), 
d199 1
a199 1
           MWANT = LCIRC*NSISTX*NSISTY + NSAM*NROW 
d242 7
d292 1
a292 1
     &                     NSAM,NROW, NSAM,NROW, 0.0,
d308 1
a308 1
                 CNR2 = NROW/2+1+JT
d312 1
a312 1
                    CNS2 = NSAM/2+1+IT
d317 1
a317 1
	            CALL APRINGS_ONE_NEW(NSAM,NROW, CNS2,CNR2, 
d357 1
a357 1
                 CNR2 = NROW/2+1+JT
d361 1
a361 1
                    CNS2 = NSAM/2+1+IT
d366 1
a366 1
	            CALL APRINGS_ONE_NEW(NSAM,NROW,  CNS2,CNR2, 
d464 1
a464 1
	            CNR2 = NROW / 2 + 1 + JT + ISY
d466 1
a466 1
	               CNS2 = NSAM / 2 + 1 + IT + ISX
d472 1
a472 1
	               CALL APRINGS_ONE_NEW(NSAM,NROW, CNS2,CNR2, 
d536 2
a537 2
	      cnr2 = nrow / 2 + 1 + isy
              cns2 = nsam / 2 + 1 + isx
d550 2
a551 2
	         CNS2 = NSAM/2+1 + SX + SSX
	         CNR2 = NROW/2+1 + SY + SSY
d557 1
a557 1
	         CALL APRINGS_ONE_NEW(NSAM,NROW, CNS2,CNR2, A,.FALSE.,
d623 2
a624 2
           cns2 = nsam / 2 + 1 - sx
           cnr2 = nrow / 2 + 1 - sy
@


1.101
log
@CCROTD_INTERP,RANGNEW_INTER)
CCROTD_INTERP,RANGNEW_INTER)
@
text
@d30 1
d279 2
a280 1
	   CALL AP_GETDATS(IEXPLIST,NUMEXP,NSAM,NROW,
d282 2
a283 1
     &                     A, AVI,SIGI, IRTFLG)
@


1.100
log
@ap_sh --> apsh in names, MAKE_CLOSE_LIST, '*' in refangdoc
@
text
@d552 1
a552 1
     &                          CCROTD_INTERP,RANGNEW_INTER)
@


1.99
log
@renamed, allocated circexp
@
text
@d3 1
a3 1
C    AP_SH_SS.F     USED CMLIMIT                  AUG 00 ARDEAN LEITH
d29 1
d35 1
a35 1
C=* Copyright 1985-2010  Health Research Inc.,                         *
d53 1
a53 1
C  AP_SH_SS(IREFLIST,NUMREF,IEXPLIST,NUMEXP, 
d80 1
a80 1
       SUBROUTINE AP_SH_SS(IREFLIST,NUMREF,IEXPLIST,NUMEXP, 
d86 1
d90 17
a106 17
	INTEGER                           :: IREFLIST(NUMREF)
	INTEGER                           :: IEXPLIST(NUMEXP)
	INTEGER                           :: NUMR(3,NRING)
	REAL                              :: CIRCREF(LCIRC,NUMREF)
	LOGICAL                           :: CIRCREF_IN_CORE,CKMIRROR
	LOGICAL                           :: MIRRORNEW
	LOGICAL                           :: GOTREFANG
	LOGICAL                           :: LIMITRANGE
	CHARACTER (LEN=1)                 :: MODE,NULL
        CHARACTER (LEN=*)                 :: REFANGDOC,EXPANGDOC
        CHARACTER (LEN=*)                 :: SCRFILE
        CHARACTER (LEN=*)                 :: REFPAT,EXPPAT
        CHARACTER (LEN=*)                 :: CTYPE

	DOUBLE PRECISION                  :: FITP(-1:1,-1:1)
	DOUBLE PRECISION                  :: CCROTD,PEAK,CCROTD_INTERP
        INTEGER *8                        :: FFTW_PLANS(*)
d109 16
a124 16
	DOUBLE PRECISION  :: CCOA(NUMREF,   -ISHRANGEX:ISHRANGEX,
     &                                      -ISHRANGEY:ISHRANGEY)
	REAL              :: RANGOA(NUMREF, -ISHRANGEX:ISHRANGEX,
     &                                      -ISHRANGEY:ISHRANGEY)
	LOGICAL           :: ISMIRRORED(NUMREF, 
     &                                      -ISHRANGEX:ISHRANGEX,
     &                                      -ISHRANGEY:ISHRANGEY)

	DOUBLE PRECISION  :: FIT(     -ISTEP:ISTEP,-ISTEP:ISTEP)
	DIMENSION         :: ROTMP(   -ISTEP:ISTEP,-ISTEP:ISTEP)
        LOGICAL           :: ISMIRDUM(-ISTEP:ISTEP,-ISTEP:ISTEP)

	INTEGER                               :: LCG(NUMREF)
	REAL                                  :: ANGOUT(3)
	REAL                                  :: EXPDIR(3)
        LOGICAL                               :: USE_UN,USE_MIR
d127 4
a130 4
	REAL, ALLOCATABLE                     :: CIRCEXP(:,:,:)
	REAL, ALLOCATABLE                     :: A(:,:)
	REAL, ALLOCATABLE                     :: REFDIR(:,:) 
	REAL, ALLOCATABLE                     :: ANGREF(:,:),ANGEXP(:,:)
d132 13
a144 11
        LOGICAL, PARAMETER                    :: USE_OMP = .FALSE.
        INTEGER, PARAMETER                    :: NLISTMAX = 15
        REAL                                  :: PARLIST(NLISTMAX)

        REAL, PARAMETER           :: QUADPI = 3.1415926535
        REAL, PARAMETER           :: DGR_TO_RAD = (QUADPI/180)

        INTEGER                   :: NBORDER = 0       ! # BORDER PIXELS
        INTEGER                   :: NSUBPIX = 0       ! # SUBPIX PIXELS

	DATA  INPIC/77/,INANG/78/,LUNRING/50/
d162 2
a163 3
C       THIS ALTERS RANGE!
	RANGE  = COS(RANGE*DGR_TO_RAD)
        WR     = 0.0    ! DUMMY VALUE FLAG FOR APRINGS CALL
d194 1
a194 1
           CALL  ERRT(46,'AP_SH_SS; CIRCEXP,....',MWANT)
d204 3
a206 2
C          RESTRICTED ANGULAR SEARCH FOR 'SH' 
	   ALLOCATE(ANGREF(3,NUMREF), STAT=IRTFLG)
d208 2
a209 2
               MWANT = 3*NUMREF  
               CALL ERRT(46,'AP_SH_SS; ANGREF',MWANT)
d213 5
a217 4
C          LOAD REF. PROJ. ANGLES () FROM DOC. FILE (REFANGDOC) OR
C          IMAGE FILE (REFPAT) HEAD INTO ANGREF
	   CALL AP_GETANGA(IREFLIST,NUMREF,0,REFANGDOC,REFPAT,
     &                    INPIC,INANG,3,ANGREF,NGOTREF,IRTFLG)
a218 2

           GOTREFANG = .TRUE.
d220 1
a220 1
      
a221 17
C         READ EXP. ANGLES INTO ANGEXP

          IF (REFANGDOC .NE. NULL) THEN
	      ALLOCATE(REFDIR(3,NUMREF),STAT=IRTFLG)
	      IF (IRTFLG .NE. 0) THEN
                 MWANT = 3*NUMREF  
                 CALL ERRT(46,'AP_SH_SS; REFDIR',MWANT)
                 RETURN
              ENDIF 

C             CONVERT REF. ANGLES TO UNITARY DIRECTIONAL VECTORS (REFDIR).
	      CALL AP_GETSATA(ANGREF,REFDIR,3,NUMREF,IRTFLG)
           ENDIF

C          LOAD EXP. PROJ. ANGLES & ALIGNMENT PARAMETERS (ANGEXP) 
C          FROM DOC. FILE (EXPANGDOC) OR IMAGE FILE (REFPAT) HEAD

d224 1
a224 1
              CALL ERRT(46,'AP_SH_SS; ANGEXP',8*NUMEXP)
d227 3
d231 3
a233 2
	   CALL AP_GETANGA(IEXPLIST,NUMEXP,0,EXPANGDOC,EXPPAT,
     &                       INPIC,INANG,8,ANGEXP,NGOTPAR,IRTFLG)
d245 8
a252 23
C             MAKE LIST OF NEARBY REFERENCE IMAGES
	      NUMREFLCG = 0
	      DO IMIR=1,NUMREF
C                LOOP OVER REFERENCE IMAGES 

C                DT NEAR 1.0 = NOT-MIRRORED, DT NEAR -1.0 = MIRRORED
	         DT =    (EXPDIR(1) * REFDIR(1,IMIR) +
     &                    EXPDIR(2) * REFDIR(2,IMIR) +
     &                    EXPDIR(3) * REFDIR(3,IMIR))
	         DTABS = ABS(DT)

	         IF (DTABS .GE. RANGE) THEN
C                    MIRRORED OR NON-MIRRORED IS WITHIN RANGE

                    IF (CKMIRROR .OR. DT .GT. 0) THEN
C                      DO NOT DISCARD IF NOT MIRRORED OR WANT MIRRORED
	               NUMREFLCG      = NUMREFLCG + 1
	               LCG(NUMREFLCG) = IMIR
                       IF (DT .LT. 0) LCG(NUMREFLCG) = -IMIR
	            ENDIF
                    IEND = NUMREFLCG
                 ENDIF
	      ENDDO
d644 2
@


1.98
log
@AP_STAT NBORDER
@
text
@d3 1
a3 1
C    MRQLI_SS.F     USED CMLIMIT                  AUG 00 ARDEAN LEITH
d52 1
a52 1
C  MRQLI_SS(IREFLIST,NUMREF,IEXPLIST,NUMEXP, 
d79 1
a79 1
       SUBROUTINE MRQLI_SS(IREFLIST,NUMREF,IEXPLIST,NUMEXP, 
d88 4
a91 4
	INTEGER, DIMENSION(NUMREF)        :: IREFLIST
	INTEGER, DIMENSION(NUMEXP)        :: IEXPLIST
	INTEGER, DIMENSION(3,NRING)       :: NUMR
	REAL, DIMENSION(LCIRC,NUMREF)     :: CIRCREF
d96 1
a96 1
	CHARACTER(LEN=1)                  :: MODE,NULL
d119 3
a121 3
	INTEGER, DIMENSION(NUMREF)            :: LCG
	REAL, DIMENSION(3)                    :: ANGOUT
	REAL, DIMENSION(3)                    :: EXPDIR
d125 4
a128 4
	REAL, ALLOCATABLE, DIMENSION(:,:,:)   :: CIRCEXP
	REAL, ALLOCATABLE, DIMENSION(:,:)     :: A
	REAL, ALLOCATABLE,DIMENSION(:,:)      :: REFDIR 
	REAL, ALLOCATABLE,DIMENSION(:,:)      :: ANGREF,ANGEXP
d132 1
a132 1
        REAL, DIMENSION(NLISTMAX)             :: PARLIST
d191 1
a191 1
           CALL  ERRT(46,' CIRCEXP,....',MWANT)
d205 1
a205 1
               CALL ERRT(46,'ANGREF',MWANT)
d225 1
a225 1
                 CALL ERRT(46,'REFDIR',MWANT)
d238 1
a238 1
              CALL ERRT(46,'ANGEXP',8*NUMEXP)
@


1.97
log
@getrefang not set right
@
text
@d28 1
d137 3
d538 1
d588 1
d658 2
a659 1
     &                  IWORSECCROT,CCROTWORSE,LUNDOC)
@


1.96
log
@CROSRNG_2
@
text
@d63 1
a63 1
C  OPERATIONS:  'AP SH'
d194 2
d197 1
a197 1
C          RESTRICTED ANGULAR SEARCH FOR 'RQ' OR 'SH' 
d210 2
d214 3
a216 3
        IF (CTYPE(1:2) .NE. 'MQ' .AND. 
     &     EXPANGDOC .NE. CHAR(0)) THEN
C          READ EXP. ANGLES INTO ANGEXP
a240 2

           GOTREFANG = .TRUE.
d247 1
a247 2
           IF (CTYPE(1:2) .EQ. 'RQ' .OR. 
     &         (LIMITRANGE .AND. EXPANGDOC .NE. NULL)) THEN
d335 2
a336 2
                          USE_UN  = (LCG(IRR) .GE. 0)
                          USE_MIR = (LCG(IRR) .LT. 0)
d394 2
a395 2
                          USE_UN  = (LCG(IRR) .GE. 0)
                          USE_MIR = (LCG(IRR) .LT. 0)
d604 2
@


1.95
log
@GPL_2010
@
text
@d26 3
d52 1
a52 1
C           LSAM,LROW,NR,LENTT,ISHRANGEX,ISHRANGEY,ISTEP,
d79 1
a79 1
     &               LSAM,LROW,NR,LENTT,ISHRANGEX,ISHRANGEY,ISTEP,
a104 8
#ifdef __ia64
C       INTEL PARALLEL COMPILER BUGGY MUST ALLOCATE THESE ARRAYS IF ||
C       DOES NOT HANDLE NEGATIVE SUBSCRIPTS CORRECTLY
	DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:,:,:) :: CCOA,CCMA
	REAL,             ALLOCATABLE, DIMENSION(:,:,:) :: RANGOA,RANGMA
	DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:,:)   :: FIT
	REAL,             ALLOCATABLE, DIMENSION(:,:)   :: ROTMP
#else
d106 11
a116 11
	DOUBLE PRECISION  CCOA(NUMREF,   -ISHRANGEX:ISHRANGEX,
     &                                   -ISHRANGEY:ISHRANGEY)
	DOUBLE PRECISION  CCMA(NUMREF,   -ISHRANGEX:ISHRANGEX,
     &                                   -ISHRANGEY:ISHRANGEY)
	DIMENSION         RANGOA(NUMREF, -ISHRANGEX:ISHRANGEX,
     &                                   -ISHRANGEY:ISHRANGEY),
     &                    RANGMA(NUMREF, -ISHRANGEX:ISHRANGEX,
     &                                   -ISHRANGEY:ISHRANGEY)
	DOUBLE PRECISION  FIT(  -ISTEP:ISTEP,-ISTEP:ISTEP)
	DIMENSION         ROTMP(-ISTEP:ISTEP,-ISTEP:ISTEP)
#endif
a117 1
	DOUBLE PRECISION, DIMENSION(LENTT)    :: TT
d121 1
a121 1
        LOGICAL                               :: MIRRORED
d129 1
d133 2
a134 2
	PARAMETER (QUADPI = 3.1415926535897932384626)
	PARAMETER (DGR_TO_RAD = (QUADPI/180))
d158 3
a160 3
C       FIND DIVAS, NUMTH, NSAM, & NROW
	CALL APMASTER_1(MODE,DIVAS,NR,NUMTH,LSAM,LROW,NSAM,NROW,
     &                  TT,LENTT)
d165 1
a165 1
        CALL APRINGS_NEW(IREFLIST,NUMREF, LSAM,LROW,
a169 3
        NSAM = LSAM
        NROW = LROW

d230 1
a230 2
              MWANT = 8*NUMEXP 
              CALL ERRT(46,'ANGEXP',MWANT)
d298 1
a298 1
	   CALL AP_GETDATS(IEXPLIST,NUMEXP,LSAM,LROW,
a302 16
#ifdef __ia64
	   ALLOCATE(
     &      CCOA(NUMREF,   -ISHRANGEX:ISHRANGEX, -ISHRANGEY:ISHRANGEY),
     &      CCMA(NUMREF,   -ISHRANGEX:ISHRANGEX, -ISHRANGEY:ISHRANGEY),
     &      RANGOA(NUMREF, -ISHRANGEX:ISHRANGEX, -ISHRANGEY:ISHRANGEY),
     &      RANGMA(NUMREF, -ISHRANGEX:ISHRANGEX, -ISHRANGEY:ISHRANGEY),
     &      FIT(  -ISTEP:ISTEP, -ISTEP:ISTEP),
     &      ROTMP(-ISTEP:ISTEP, -ISTEP:ISTEP),
     &      STAT=IRTFLG)
	   IF (IRTFLG .NE. 0) THEN
              MWANT1 = 4 * (NUMREF * (ISHRANGEX*2+1)*(ISHRANGEY*2+1)) + 
     &                 2 * (ISTEP*2+1) 
              CALL  ERRT(46,' CCOA,....',MWANT1)
              GOTO 9999
           ENDIF 
#endif
d308 2
a309 1
c$omp         parallel do private(jt,it,imil,imi,cnr2,cns2,mirrored)
d332 8
a339 19
                       IF ((CKMIRROR .AND. LIMITRANGE)  .OR.
     &                     (.NOT. CKMIRROR)) THEN
                          IF (.NOT. CKMIRROR) MIRRORED = .FALSE. 
                          IF (LIMITRANGE)  MIRRORED = (LCG(IMIL) .LT. 0) 

C                         CHECK EITHER MIRRORED OR NON-MIRRORED POSITION 
	                  CALL CROSRNG_EP_NEW(CIRCREF(1,IMI),
     &                       CIRCEXP(1,IT/ISTEP,JT/ISTEP),
     &                       LCIRC,NRING,MAXRIN,NUMR,
     &                       CCOA(IMI,IT,JT),RANGOA(IMI,IT,JT),
     &                       TT,MIRRORED, FFTW_PLANS(1))
                        ELSE
C                          CHECK BOTH NON-MIRRORED & MIRRORED POSITIONS 
	                   CALL CROSRNG_MSP_NEW(CIRCREF(1,IMI),
     &                         CIRCEXP(1,IT/ISTEP,JT/ISTEP),
     &                         LCIRC,NRING,MAXRIN,NUMR,
     &                         CCOA(IMI,IT,JT),RANGOA(IMI,IT,JT),
     &                         CCMA(IMI,IT,JT),RANGMA(IMI,IT,JT), 
     &                         TT,FFTW_PLANS(1))
d341 9
d360 1
a360 1
              DO JT=-ISHRANGEY,ISHRANGEY,ISTEP
d376 1
a376 1
c$omp               parallel do private(imil,imi,ithread,mirrored)
d391 8
a398 19
                       IF ((CKMIRROR .AND. LIMITRANGE)  .OR.
     &                     (.NOT. CKMIRROR)) THEN
                          IF (.NOT. CKMIRROR) MIRRORED = .FALSE. 
                          IF (LIMITRANGE)  MIRRORED = (LCG(IMIL) .LT. 0) 

C                         CHECK EITHER MIRRORED OR NON-MIRRORED POSITION 
	                  CALL CROSRNG_EP_NEW(CIRCREF(1,ITHREAD),
     &                       CIRCEXP(1,IT/ISTEP,JT/ISTEP),
     &                       LCIRC,NRING,MAXRIN,NUMR,
     &                       CCOA(IMI,IT,JT),RANGOA(IMI,IT,JT),
     &                       TT,MIRRORED, FFTW_PLANS(1))
                        ELSE
C                          CHECK BOTH NON-MIRRORED & MIRRORED POSITIONS 
	                   CALL CROSRNG_MSP_NEW(CIRCREF(1,ITHREAD),
     &                         CIRCEXP(1,IT/ISTEP,JT/ISTEP),
     &                         LCIRC,NRING,MAXRIN,NUMR,
     &                         CCOA(IMI,IT,JT),RANGOA(IMI,IT,JT),
     &                         CCMA(IMI,IT,JT),RANGMA(IMI,IT,JT), 
     &                         TT,FFTW_PLANS(1))
d400 8
d411 2
a412 1
           ENDIF
d426 1
a426 1
C                      BETTER POSITION (MAY BE MIRRORED IF LIMITRANGE)   
d432 1
a432 1
                       MIRRORNEW = (LIMITRANGE .AND. (LCG(IRR) .LT. 0)) 
d434 3
a436 16

                    IF (CKMIRROR .AND. .NOT. LIMITRANGE) THEN 
C                      HAVE TO COMPARE WITH MIRRORED POSITION 
                       IF (CCMA(IR,IT,JT) .GE. CCROTD) THEN
C                        BETTER MIRRORED POSITION 
                         IREF      = IR
                         CCROTD    = CCMA(IR,IT,JT)
                         ISX       = IT
                         ISY       = JT
                         RANGNEW   = ANG_N(RANGMA(IR,IT,JT),MODE,MAXRIN)
                         MIRRORNEW = .TRUE.
                       ENDIF
                    ENDIF
                 ENDDO
              ENDDO
           ENDDO
d482 8
a489 5
	               CALL CROSRNG_EP_NEW(CIRCREF(1,IREFT),
     &                              CIRCEXP(1,IT,JT),
     &                              LCIRC,NRING,MAXRIN,NUMR,
     &                              FIT(IT,JT),ROTMP(IT,JT),
     &                              TT, MIRRORNEW,FFTW_PLANS(1))
d557 4
a560 3
C                NORMALIZE IMAGE VALUES UNDER THE MASK OVER VARIANCE RANGE
C                INTERPOLATE INTO POLAR COORDINATES
C                CREATE FOURIER OF: CIRCEXP
d564 8
a572 4
 	         CALL CROSRNG_EP_NEW(CIRCREF(1,IREFT),CIRCEXP,LCIRC,
     &                    NRING,MAXRIN,NUMR,CCROTD_INTERP,
     &                    RANGNEW_INTERP,TT,MIRRORNEW,FFTW_PLANS(1))
 
a603 5
C          ALMOST ZERO IS LIKELY TO BE ZERO
           IF (ABS(XSHNEW)  .LT. 0.04) XSHNEW  = 0.0
           IF (ABS(YSHNEW)  .LT. 0.04) YSHNEW  = 0.0
           IF (ABS(RANGNEW) .LT. 0.04) RANGNEW = 0.0

d611 1
a611 1
           CALL  AP_STAT_ADD(NGOTPAR,CCROT,PARLIST(10),
d617 7
a632 1

@


1.94
log
@ANGREF NOT IN OUTPUT so no psi,thea,phi
@
text
@d27 4
a30 4
C=* This file is part of:                                              * 
C=* SPIDER - Modular Image Processing System.                          *
C=* Authors: J. FRANK & A. LEITH                                       *
C=* Copyright 1985-2010  Health Research Inc.                          *
d41 1
a41 1
C=* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
a42 1
C=*                                                                    *
@


1.93
log
@x & y shift now can be different
@
text
@d25 1
a25 1
C
d28 2
a29 1
C=* SPIDER - Modular Image Processing System.   Author: J. FRANK       *
d644 1
a644 1
     &                ANGREF,REFDIR(1,IREF),
@


1.92
log
@imi parallel bug
@
text
@d24 1
d29 1
a29 1
C=* Copyright 1985-2009  Health Research Inc.                          *
d49 1
a49 1
C           LSAM,LROW,NR,LENTT,ISHRANGE,ISTEP,
d76 1
a76 1
     &               LSAM,LROW,NR,LENTT,ISHRANGE,ISTEP,
d111 8
a118 8
	DOUBLE PRECISION  CCOA(NUMREF,-ISHRANGE:ISHRANGE,
     &                                -ISHRANGE:ISHRANGE)
	DOUBLE PRECISION  CCMA(NUMREF,-ISHRANGE:ISHRANGE,
     &                                -ISHRANGE:ISHRANGE)
	DIMENSION         RANGOA(NUMREF, -ISHRANGE:ISHRANGE,
     &                                -ISHRANGE:ISHRANGE),
     &                    RANGMA(NUMREF, -ISHRANGE:ISHRANGE,
     &                                -ISHRANGE:ISHRANGE)
d186 3
a188 2
	NSIS = MAX(ISHRANGE/ISTEP, ISTEP)
	ALLOCATE(CIRCEXP(LCIRC,-NSIS:NSIS,-NSIS:NSIS),
d192 3
a194 2
           NSIST = 2 * NSIS + 1
           MWANT = LCIRC*NSIST*NSIST + NSAM*NROW 
d294 1
a294 1
     &                ANGEXP(1,IEXP),EXPDIR,ISHRANGE,
d313 8
a320 7
	   ALLOCATE(CCOA(NUMREF,-ISHRANGE:ISHRANGE, -ISHRANGE:ISHRANGE),
     &           CCMA(NUMREF,-ISHRANGE:ISHRANGE, -ISHRANGE:ISHRANGE),
     &           RANGOA(NUMREF, -ISHRANGE:ISHRANGE, -ISHRANGE:ISHRANGE),
     &           RANGMA(NUMREF, -ISHRANGE:ISHRANGE, -ISHRANGE:ISHRANGE),
     &           FIT(  -ISTEP:ISTEP, -ISTEP:ISTEP),
     &           ROTMP(-ISTEP:ISTEP, -ISTEP:ISTEP),
     &           STAT=IRTFLG)
d322 1
a322 1
              MWANT1 = 4 * (NUMREF * (ISHRANGE*2+1) * (ISHRANGE*2+1)) + 
d335 1
a335 1
              DO JT=-ISHRANGE,ISHRANGE,ISTEP
d339 1
a339 1
                 DO IT=-ISHRANGE,ISHRANGE,ISTEP
d377 2
a378 2
                 ENDDO     ! END OF: DO IT=-ISHRANGE,ISHRANGE,ISTEP
              ENDDO        ! END OF: DO JT=-ISHRANGE,ISHRANGE,ISTEP
d380 1
a380 1
c$omp         end parallel do
d386 1
a386 1
              DO JT=-ISHRANGE,ISHRANGE,ISTEP
d390 1
a390 1
                 DO IT=-ISHRANGE,ISHRANGE,ISTEP
d438 2
a439 2
                 ENDDO     ! END OF: DO IT=-ISHRANGE,ISHRANGE,ISTEP
              ENDDO        ! END OF: DO JT=-ISHRANGE,ISHRANGE,ISTEP
d445 2
a446 2
           DO JT=-ISHRANGE,ISHRANGE,ISTEP
              DO IT=-ISHRANGE,ISHRANGE,ISTEP
d500 2
a501 2
	   IF (ABS(ISX) .NE. ISHRANGE .AND. 
     &         ABS(ISY) .NE. ISHRANGE)  THEN
d644 1
a644 1
     &                ANGEXP(1,IEXP),EXPDIR,ISHRANGE,
@


1.91
log
@can do incore AP SH now
@
text
@d43 1
a43 1
C=* along with this program. If not, see <http://www.gnu.org/licenses> *                      *
d104 2
a105 2
	DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:,:,:) :: TOTA,TMTA
	REAL,             ALLOCATABLE, DIMENSION(:,:,:) :: TOT,TMT
d110 1
a110 1
	DOUBLE PRECISION  TOTA(NUMREF,-ISHRANGE:ISHRANGE,
d112 1
a112 1
	DOUBLE PRECISION  TMTA(NUMREF,-ISHRANGE:ISHRANGE,
d114 1
a114 1
	DIMENSION         TOT(NUMREF, -ISHRANGE:ISHRANGE,
d116 1
a116 1
     &                    TMT(NUMREF, -ISHRANGE:ISHRANGE,
d254 1
a254 1
	      CALL AP_GETSATA(ANGEXP(1,IEXP),EXPDIR,7,1,IRTFLG)
d310 7
a316 7
	   ALLOCATE(TOTA(NUMREF,-ISHRANGE:ISHRANGE, -ISHRANGE:ISHRANGE),
     &              TMTA(NUMREF,-ISHRANGE:ISHRANGE, -ISHRANGE:ISHRANGE),
     &              TOT(NUMREF, -ISHRANGE:ISHRANGE, -ISHRANGE:ISHRANGE),
     &              TMT(NUMREF, -ISHRANGE:ISHRANGE, -ISHRANGE:ISHRANGE),
     &              FIT(  -ISTEP:ISTEP, -ISTEP:ISTEP),
     &              ROTMP(-ISTEP:ISTEP, -ISTEP:ISTEP),
     &              STAT=IRTFLG)
d320 1
a320 1
              CALL  ERRT(46,' TOTA,....',MWANT1)
d329 2
a330 1
c$omp         parallel do private(jt,it,irr,ir,cnr2,cns2,mirrored)
d342 1
a342 1
	            CALL APRINGS_ONE_NEW(NSAM,NROW,  CNS2,CNR2, 
d361 1
a361 1
     &                       TOTA(IMI,IT,JT),TOT(IMI,IT,JT),
d368 2
a369 2
     &                         TOTA(IMI,IT,JT),TOT(IMI,IT,JT),
     &                         TMTA(IMI,IT,JT),TMT(IMI,IT,JT), 
d422 1
a422 1
     &                       TOTA(IMI,IT,JT),TOT(IMI,IT,JT),
d429 2
a430 2
     &                         TOTA(IMI,IT,JT),TOT(IMI,IT,JT),
     &                         TMTA(IMI,IT,JT),TMT(IMI,IT,JT), 
d449 1
a449 1
                    IF (TOTA(IR,IT,JT) .GE. CCROTD)  THEN
d451 1
a451 1
	               CCROTD    = TOTA(IR,IT,JT)
d455 1
a455 1
                       RANGNEW   = ANG_N(TOT(IR,IT,JT),MODE,MAXRIN)
d461 8
a468 8
                       IF (TMTA(IR,IT,JT) .GE. CCROTD) THEN
C                         BETTER MIRRORED POSITION 
                          IREF      = IR
                          CCROTD    = TMTA(IR,IT,JT)
                          ISX       = IT
                          ISY       = JT
                          RANGNEW   = ANG_N(TMT(IR,IT,JT),MODE,MAXRIN)
                          MIRRORNEW = .TRUE.
@


1.90
log
@ngotpar for 8
@
text
@d22 2
a23 1
C                    AP_STAT_ADD                  NOV 08 ARDEAN LEITH
d26 5
a30 2
C=* FROM: SPIDER - MODULAR IMAGE PROCESSING SYSTEM.   AUTHOR: J.FRANK  *
C=* Copyright (C) 1985-2008  Health Research Inc.                      *
d32 1
a32 6
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *   
C=* ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C=*                                                                    *
C=* Email:  spider@@wadsworth.org                                       *
C=*                                                                    *
C=* This program is free software; you can redistribute it and/or      *
d37 1
a37 1
C=* This program is distributed in the hope that it will be useful,    *
d43 1
a43 3
C=* along with this program; if not, write to the                      *
C=* Free Software Foundation, Inc.,                                    *
C=* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.      *
d158 1
d166 3
a168 1
C       READ REFERENCE IMAGES INTO REFERENCE RINGS (CIRCREF) ARRAY 
d177 8
d324 21
d346 9
a354 4
C          GO THROUGH REFERENCE IMAGES AND CENTERS
c$omp      parallel do private(jt,it,irr,ir,cnr2,cns2,mirrored)
           DO JT=-ISHRANGE,ISHRANGE,ISTEP
              CNR2 = NROW/2+1+JT
d356 38
a393 7
              DO IT=-ISHRANGE,ISHRANGE,ISTEP
                 CNS2 = NSAM/2+1+IT

C                NORMALIZE IMAGE VALUES UNDER THE MASK OVER VARIANCE 
C                RANGE INTERPOLATE TO POLAR COORDINATES, CREATE 
C                FOURIER OF: CIRCEXP.  NO WEIGHTING OF RINGS
	         CALL APRINGS_ONE_NEW(NSAM,NROW,  CNS2,CNR2, A,.FALSE.,
d397 19
a415 9
                 DO IRR=1,IEND
C                   LOOP OVER REFERENCE IMAGES
                    IR = IRR
                    IF (LIMITRANGE) IR = ABS(LCG(IRR))

                    IF ((CKMIRROR .AND. LIMITRANGE)  .OR.
     &                  (.NOT. CKMIRROR)) THEN
                       IF (.NOT. CKMIRROR) MIRRORED = .FALSE. 
                       IF (LIMITRANGE)    MIRRORED = (LCG(IRR) .LT. 0) 
d417 2
a418 2
C                      CHECK EITHER MIRRORED OR NON-MIRRORED POSITION 
	               CALL CROSRNG_EP_NEW(CIRCREF(1,IR),
d421 1
a421 1
     &                       TOTA(IR,IT,JT),TOT(IR,IT,JT),
d423 13
a435 15
                     ELSE
C                       CHECK BOTH NON-MIRRORED & MIRRORED POSITIONS 
	                CALL CROSRNG_MSP_NEW(CIRCREF(1,IR),
     &                       CIRCEXP(1,IT/ISTEP,JT/ISTEP),
     &                       LCIRC,NRING,MAXRIN,NUMR,
     &                       TOTA(IR,IT,JT),TOT(IR,IT,JT),
     &                       TMTA(IR,IT,JT),TMT(IR,IT,JT), 
     &                       TT,FFTW_PLANS(1))
                    ENDIF
	         ENDDO  ! END OF: DO IRR=1,IEND
              ENDDO     ! END OF: DO IT=-ISHRANGE,ISHRANGE,ISTEP
           ENDDO        ! END OF: DO JT=-ISHRANGE,ISHRANGE,ISTEP

C          END OF THE OMP PARALLEL SECTION

d480 8
d489 1
a489 1
           write(6,921) IMGREF,isx,isy,ccrotd,rangnew
d518 1
a518 1
	               CALL CROSRNG_EP_NEW(CIRCREF(1,IREF),
d529 1
d597 1
a597 1
 	         CALL CROSRNG_EP_NEW(CIRCREF(1,IREF),CIRCEXP,LCIRC,
@


1.89
log
@ apstat,mpi
@
text
@d225 1
a225 1
	   ALLOCATE(ANGEXP(7,NUMEXP), STAT=IRTFLG)
d227 1
a227 1
              MWANT = 7*NUMEXP 
d233 1
a233 1
     &                       INPIC,INANG,7,ANGEXP,NGOTPAR,IRTFLG)
@


1.88
log
@FFTW3 plan changes, FFTW aprings
@
text
@d21 2
d50 5
a54 1
C  MRQLI_SS.F
d57 1
a57 1
C           REFERENCE IMAGES WITH SAMPLE IMAGES
d59 14
a72 1
C  VERSION FOR MP AND A SMALL NUMBER OF IMAGES TO BE ALIGNED
d149 3
a151 7
        IBIGANGDIF  = -1
        ANGDIFAVG   = 0.0
        CCROTAVG    = 0.0
        IMPROVCCROT = 0
        CCROTIMPROV = 0.0
        IWORSECCROT = 0
        CCROTWORSE  = 0.0
d284 3
a286 3
     &                GOTREFANG, NGOTPAR,LSAM,LROW,CCROT,PEAKV,
     &                RANGNEW,XSHNEW,YSHNEW,MIRRORNEW,EXPPAT,REFPAT,
     &                NUMREFLCG, CTYPE, XBUF,LUNDOC,PARLIST)
d298 1
a298 1
     &                     A, IRTFLG)
d325 3
a327 3
C                NORMALIZE IMAGE VALUES UNDER THE MASK OVER VARIANCE RANGE
C                INTERPOLATE TO POLAR COORDINATES, CREATE FOURIER OF: CIRCEXP
C                NO WEIGHTING OF RINGS
d558 8
a565 22
     &                GOTREFANG, NGOTPAR,LSAM,LROW,CCROT,PEAKV,
     &                RANGNEW,XSHNEW,YSHNEW,MIRRORNEW,EXPPAT,REFPAT,
     &                NUMREFLCG, CTYPE, XDUM,LUNDOC,PARLIST)

           CCROTAVG = CCROTAVG + CCROT
           IF (NGOTPAR .GE. 8) THEN
C             COMPILE CCROT CHANGE STATISTICS

              ANGDIF = PARLIST(10)
              IF (ANGDIF .GT. ANGDIFTHR)IBIGANGDIF = IBIGANGDIF + 1
  
              CCROTLAS  = ANGEXP(8,IEXP)
              ANGDIFAVG = ANGDIFAVG + PARLIST(10)

              IF (CCROT .GE. CCROTLAS) THEN
                 IMPROVCCROT = IMPROVCCROT + 1
                 CCROTIMPROV = CCROTIMPROV + CCROT
              ELSE
                 IWORSECCROT = IWORSECCROT + 1
                 CCROTWORSE  = CCROTWORSE + CCROT
              ENDIF
            ENDIF   ! END OF: IF (NGOTPAR .GE. 8)
@


1.87
log
@reverted to pre aprings change
@
text
@d17 4
a20 2
C                   DISCARD MIRROR ...            Jun 06 ARDEAN LEITH
C                   AP_STAT CALL                  Jan 07 ARDEAN LEITH
d24 1
a24 1
C=* Copyright (C) 1985-2007  Health Research Inc.                      *
d50 3
d58 1
a58 1
       SUBROUTINE MRQLI_SS(ILIST,NIMA,ILIP,NIDI, 
d60 2
a61 2
     &               NRING,LCIRC,NUMR,BFC,BFC_IN_CORE,
     &               MODE,REFANGDOC,EXPANGDOC,SCRFILE,
d67 17
a83 16
	INTEGER, DIMENSION(NIMA)            :: ILIST
	INTEGER, DIMENSION(NIDI)            :: ILIP
	INTEGER, DIMENSION(3,NRING)         :: NUMR
	REAL, DIMENSION(LCIRC,NIMA)         :: BFC
	LOGICAL                             :: BFC_IN_CORE,CKMIRROR
	LOGICAL                             :: MIRRORNEW
	LOGICAL                             :: GOTREFANG
	LOGICAL                             :: LIMITRANGE
	CHARACTER(LEN=1)                    :: MODE,NULL
        CHARACTER (LEN=*)                   :: REFANGDOC,EXPANGDOC
        CHARACTER (LEN=*)                   :: SCRFILE
        CHARACTER (LEN=*)                   :: REFPAT,EXPPAT
        CHARACTER (LEN=*)                   :: CTYPE

	DOUBLE PRECISION  FITP(-1:1,-1:1)
	DOUBLE PRECISION                    :: CCROTD,PEAK
d94 8
a101 8
	DOUBLE PRECISION  TOTA(NIMA,-ISHRANGE:ISHRANGE,
     &                              -ISHRANGE:ISHRANGE)
	DOUBLE PRECISION  TMTA(NIMA,-ISHRANGE:ISHRANGE,
     &                              -ISHRANGE:ISHRANGE)
	DIMENSION         TOT(NIMA, -ISHRANGE:ISHRANGE,
     &                              -ISHRANGE:ISHRANGE),
     &                    TMT(NIMA, -ISHRANGE:ISHRANGE,
     &                              -ISHRANGE:ISHRANGE)
d107 1
a107 1
	INTEGER, DIMENSION(NIMA)              :: LCG
d113 1
a113 2
	REAL, ALLOCATABLE, DIMENSION(:,:,:)   :: A_CIRC
	REAL, ALLOCATABLE, DIMENSION(:,:,:,:) :: AA
d118 2
a119 2
        INTEGER, PARAMETER                          :: NLISTMAX = 15
        REAL, DIMENSION(NLISTMAX)                   :: PARLIST
d124 1
a124 1
	DATA  INPIC/77/,INANG/78/,NSCF/50/
d131 1
a131 1
        ANGDIFAVG   = HUGE(ANGDIFAVG)
d142 4
d147 1
d153 5
a157 6
C       READ REFERENCE IMAGES INTO REFERENCE RINGS (BFC) ARRAY 
        CALL APRINGS(ILIST,NIMA, 
     &               LSAM,LROW,LSAM,LROW,
     &               NRING,LCIRC,NUMR,MODE,
     &               REFPAT,INPIC,BFC,BFC_IN_CORE,
     &               NSCF,SCRFILE,IRTFLG)
a161 6
C       CALCULATE DIMENSIONS FOR NORMAS
	NSB = -NSAM/2
	NSE = -NSB-1+MOD(NSAM,2)
	NRB = -NROW/2
	NRE = -NRB-1+MOD(NROW,2)

d163 1
a163 1
	ALLOCATE(A_CIRC(LCIRC,-NSIS:NSIS,-NSIS:NSIS),
a164 1
     &           AA(NSAM,NROW,-NSIS:NSIS,-NSIS:NSIS),
d168 2
a169 2
           MWANT = LCIRC*NSIST*NSIST + NSAM*NROW + NSAM*NROW*NSIST
           CALL  ERRT(46,' A_CIRC,....',MWANT)
d173 3
a175 3
        NIMALCG = 1
        IEND    = NIMA
        NGOTPAR = 0
d178 1
a178 1
	   ALLOCATE(ANGREF(3,NIMA), STAT=IRTFLG)
d180 1
a180 1
               MWANT = 3*NIMA  
a183 7
           IF (CTYPE(1:2) .EQ. 'SH') THEN
C              AA IS USED FOR IMAGE ALSO IN APSHIFT
               IF ((LSAM * LROW) .GT. (NSAM*NROW*(2*NSIS+1))) THEN
                  CALL ERRT(46,'MRQLI_SS, PGM ERROR AA TOO SMALL',MWANT)
                  RETURN
               ENDIF
           ENDIF
d187 1
a187 1
	   CALL AP_GETANGA(ILIST,NIMA,0,REFANGDOC,REFPAT,
d196 1
a196 1
	      ALLOCATE(REFDIR(3,NIMA),STAT=IRTFLG)
d198 1
a198 1
                 MWANT = 3*NIMA  
d204 1
a204 1
	      CALL AP_GETSATA(ANGREF,REFDIR,3,NIMA,IRTFLG)
d210 1
a210 1
	   ALLOCATE(ANGEXP(7,NIDI), STAT=IRTFLG)
d212 1
a212 1
              MWANT = 7*NIDI 
d217 1
a217 1
	   CALL AP_GETANGA(ILIP,NIDI,0,EXPANGDOC,EXPPAT,
d225 2
a226 2
	DO IEXP=1,NIDI
           IMGEXP = ILIP(IEXP)
d234 2
a235 2
	      NIMALCG = 0
	      DO IMIR=1,NIMA
d249 3
a251 3
	               NIMALCG      = NIMALCG + 1
	               LCG(NIMALCG) = IMIR
                       IF (DT .LT. 0) LCG(NIMALCG) = -IMIR
d253 1
a253 1
                    IEND = NIMALCG
d257 1
a257 1
              IF (NIMALCG .LE. 0) THEN
d271 1
a271 1
     &                NIMALCG, CTYPE, XBUF,LUNDOC,PARLIST)
d281 1
a281 1
	   CALL AP_GETDATS(ILIP,NIDI,LSAM,LROW,
d287 4
a290 4
	   ALLOCATE(TOTA(NIMA,-ISHRANGE:ISHRANGE, -ISHRANGE:ISHRANGE),
     &              TMTA(NIMA,-ISHRANGE:ISHRANGE, -ISHRANGE:ISHRANGE),
     &              TOT(NIMA, -ISHRANGE:ISHRANGE, -ISHRANGE:ISHRANGE),
     &              TMT(NIMA, -ISHRANGE:ISHRANGE, -ISHRANGE:ISHRANGE),
d295 1
a295 1
              MWANT1 = 4 * (NIMA * (ISHRANGE*2+1) * (ISHRANGE*2+1)) + 
d303 1
a303 1
c$omp      parallel do private(jt,it,irr,ir,cnr2,cns2)
d310 6
a315 12
C                NORMALIZE UNDER THE MASK
	         CALL NORMASC(A,AA(1,1,IT/ISTEP,JT/ISTEP),
     &                NSB-IT,NSE-IT,NRB-JT,NRE-JT,NUMR,NUMR(1,NRING))

C                INTERPOLATION INTO POLAR COORDINATES
                 CALL ALRQ_MS(AA(1,1,IT/ISTEP,JT/ISTEP),NSAM,NROW,
     &                CNS2,CNR2,NUMR,A_CIRC(1,IT/ISTEP,JT/ISTEP),
     &                LCIRC,NRING,MODE)

C                FOURIER TRANSFORM OF REF. IMAGE RINGS
	         CALL FRNGS(A_CIRC(1,IT/ISTEP,JT/ISTEP),LCIRC,
     &                NUMR,NRING)
d322 9
a330 7
                    IF (CKMIRROR) THEN
                       IF (LIMITRANGE) THEN
                          MIRRORED = (LCG(IRR) .LT. 0) 
C                         CHECK EITHER MIRRORED OR NON-MIRRORED POSITION 
	                  CALL CROSRNG_E(BFC(1,IR),
     &                       A_CIRC(1,IT/ISTEP,JT/ISTEP),LCIRC,
     &                       NRING,MAXRIN,NUMR,
d332 6
a337 6
     &                       TT,MIRRORED)
                       ELSE
C                         CHECK BOTH NON-MIRRORED & MIRRORED POSITIONS 
	                  CALL CROSRNG_MS(BFC(1,IR),
     &                       A_CIRC(1,IT/ISTEP,JT/ISTEP),LCIRC,
     &                       NRING,MAXRIN,NUMR,
d339 2
a340 9
     &                       TMTA(IR,IT,JT),TMT(IR,IT,JT), TT)
                       ENDIF
                    ELSE 
C                      DO NOT CHECK MIRRORED POSITION
	               CALL CROSRNG_E(BFC(1,IR),
     &                      A_CIRC(1,IT/ISTEP,JT/ISTEP),LCIRC,
     &                      NRING, MAXRIN,NUMR,
     &	                    TOTA(IR,IT,JT),TOT(IR,IT,JT), 
     &                      TT, .FALSE.)
d348 1
a385 1
C          write(6,*) 'x,y:',isx, isy
d390 1
a390 1
           IMGREF  = ILIST(IREF)
d392 4
a395 24
C          INTERPOLATE IF PEAK IS NOT ON THE EDGE

	      IF ( ABS(ISX) .NE. ISHRANGE .AND. 
     &             ABS(ISY) .NE. ISHRANGE)  THEN
C                NOT ON BOUNDARY, HAVE TO FIND NEIGHBOURING VALUES

	         FIT(0,0)   = CCROTD
	         ROTMP(0,0) = RANGNEW
c$omp            parallel do private(jt,it,cnr2,cns2)
	         DO JT=-ISTEP,ISTEP
	            DO IT=-ISTEP,ISTEP
	               IF (IT.NE.0 .OR. JT.NE.0) THEN
	                  CNR2 = NROW/2+1+JT+ISY
	                  CNS2 = NSAM/2+1+IT+ISX

C                         'NORMALIZE' IMAGE VALUES OVER VARIANCE RANGE
	                  CALL NORMASC(A,AA(1,1,IT,JT),
     &	                      NSB-(IT+ISX),NSE-(IT+ISX),NRB-(JT+ISY),
     &                        NRE-(JT+ISY),NUMR,NUMR(1,NRING))

C                         INTERPOLATION INTO POLAR COORDINATES
	                  CALL ALRQ_MS(AA(1,1,IT,JT),NSAM,NROW,
     &                             CNS2,CNR2,NUMR,
     &                             A_CIRC(1,IT,JT),LCIRC,NRING,MODE)
d397 24
a420 2
C                         FOURIER TRANSFORM OF EXP. IMAGE RINGS
	                  CALL FRNGS(A_CIRC(1,IT,JT),LCIRC,NUMR,NRING)
d422 2
a423 2
	                  CALL CROSRNG_E(BFC(1,IREF),
     &                              A_CIRC(1,IT,JT),
d426 1
a426 1
     &                              TT, MIRRORNEW)
d428 22
a449 1
	                  ROTMP(IT,JT) = ANG_N(ROTMP(IT,JT),MODE,MAXRIN)
a450 18
	            ENDDO      ! END OF: DO IT=-ISTEP,ISTEP
	         ENDDO         ! END OF: DO JT=-ISTEP,ISTEP
	         
C                FIND THE MAXIMUM WITHIN +/-ISTEP
C                MAXIMUM CANNOT BE ON THE EDGE, I.E., IT,JT/=ISTEP
	         AFIT = FIT(0,0)
	         JTMA = 0
	         ITMA = 0
	         IF (ISTEP .GT. 1) THEN
	            DO JT=-ISTEP+1,ISTEP-1
	               DO IT=-ISTEP+1,ISTEP-1
	                  IF (FIT(IT,JT) .GT. AFIT)  THEN
	                     AFIT    = FIT(IT,JT)
	                     RANGNEW = ROTMP(IT,JT)
	                     ITMA    = IT
	                     JTMA    = JT
	                  ENDIF
	               ENDDO
d452 3
a454 2
	         ENDIF    ! END OF: IF (ISTEP .GT. 1)
C                write(6,*) ((fit(i,j),i=-1,1),j=-1,1)
d456 9
a464 5
C                COPY VALUES AROUND THE PEAK.
	         DO JT=-1,1
	            DO IT=-1,1
	               FITP(IT,JT) = FIT(ITMA+IT,JTMA+JT)
	            ENDDO
d466 17
a482 1
c                write(6,*) ((FITP(i,j),i=-1,1),j=-1,1)
d484 2
a485 23
C                UPDATE LOCATION OF THE PEAK
	         CCROTD  = AFIT
	         ISX     = ISX + ITMA
	         ISY     = ISY + JTMA

C                FIND PEAK BY FITTING PARABOLA TO 3x3 NEIGHBORHOOD
	         CALL PARABLD(FITP,SX,SY,PEAK)

C                CHECK WHETHER PARABOLIC INTERPOLATION IS OK.
	         IF (ABS(SX) .LT. 1.0 .AND. ABS(SY) .LT. 1.0)  THEN
C                   INTERPOLATED LOCATION IS NOT ON BOUNDARY
	            SX   = SX + ISX
	            SY   = SY + ISY
	            CNR2 = NROW/2+1+SY
	            CNS2 = NSAM/2+1+SX

C                   'NORMALIZE' IMAGE VALUES OVER VARIANCE RANGE
	            CALL NORMAS(A,NSB-ISX,NSE-ISX,NRB-ISY,NRE-ISY,
     &                   NUMR,NUMR(1,NRING))

C                   INTERPOLATION INTO POLAR COORDINATES
	            CALL ALRQ_M(A,NSAM,NROW,CNS2,CNR2,NUMR,A_CIRC,
     &                   LCIRC,NRING,MODE)
d487 2
a488 2
C                   FOURIER TRANSFORM OF EXP. IMAGE RINGS
	            CALL FRNG(A_CIRC,LCIRC,NUMR,NRING)
d490 13
a502 2
 	            CALL CROSRNG_E(BFC(1,IREF),A_CIRC,LCIRC,
     &                    NRING,MAXRIN,NUMR,CCROTD,RANGNEW,TT,MIRRORNEW)
d504 6
a509 7
	            CCROT   = CCROTD
	            RANGNEW = ANG_N(RANGNEW,MODE,MAXRIN)
                 ELSE
C                   INTERPOLATED LOCATION IS ON BOUNDARY
	            SX    = ISX
	            SY    = ISY
	            CCROT = CCROTD
d511 9
a519 2
	         ENDIF  ! END OF: IF (ABS(SX) .LT. 1.0 .....
              ENDIF     ! END OF: IF ( ABS(ISX) .NE. ISHRANGE ......
d521 3
a523 2
	   SX = -SX
	   SY = -SY
d525 1
a525 1
C          NOW HAVE TO CHANGE ORDER OF SHIFT & ROTATION.
d528 1
a528 1
C          THIS PART CORRESPONDS TO 'SA P'.
d535 5
d545 1
a545 1
     &                NIMALCG, CTYPE, AA,LUNDOC,PARLIST)
d547 1
a556 1
              CCROTAVG = CCROTAVG + CCROT
d565 12
d588 1
a588 1
        IF (NGOTPAR .GE. 8 .AND. NIDI .GT. 1) THEN
d590 1
a590 1
           CALL AP_STAT(NIDI,ANGDIFTHR,IBIGANGDIF,
d596 7
a602 6
9999    IF (ALLOCATED(AA))      DEALLOCATE(AA)
	IF (ALLOCATED(A_CIRC))  DEALLOCATE(A_CIRC)
	IF (ALLOCATED(A))       DEALLOCATE(A)
	IF (ALLOCATED(ANGREF))  DEALLOCATE(ANGREF)
	IF (ALLOCATED(ANGEXP))  DEALLOCATE(ANGEXP)
	IF (ALLOCATED(REFDIR))  DEALLOCATE(REFDIR)
@


1.86
log
@ crosrng calls, variable names, split out mpi
@
text
@a18 1
C                   FFTW3 PLAN                    Mar 08 ARDEAN LEITH
d22 1
a22 1
C=* Copyright (C) 1985-2008  Health Research Inc.                      *
a47 3
C  PURPOSE: FIND ROTATIONAL AND SHIFT PARAMETERS TO ALIGN A SERIES OF
C           REFERENCE IMAGES WITH SAMPLE IMAGES
C
d56 1
a56 1
     &               MODE,REFANGDOC,EXPANGDOC,SCRFILE,FFTW3PLAN,
d337 1
a337 1
	                  CALL CROSRNG_EP(BFC(1,IR),
d341 1
a341 1
     &                       TT,MIRRORED,FFTW3PLAN)
d344 1
a344 1
	                  CALL CROSRNG_MSP(BFC(1,IR),
d348 1
a348 1
     &                       TMTA(IR,IT,JT),TMT(IR,IT,JT), TT,FFTW3PLAN)
d352 1
a352 1
	               CALL CROSRNG_EP(BFC(1,IR),
d356 1
a356 1
     &                      TT, .FALSE.,FFTW3PLAN)
d436 1
a436 1
	                  CALL CROSRNG_EP(BFC(1,IREF),
d440 1
a440 1
     &                              TT, MIRRORNEW,FFTW3PLAN)
d501 2
a502 3
 	            CALL CROSRNG_EP(BFC(1,IREF),A_CIRC,LCIRC,
     &                    NRING,MAXRIN,NUMR,CCROTD,
     &                    RANGNEW,TT,MIRRORNEW,FFTW3PLAN)
@


1.85
log
@statfile output
@
text
@d19 1
d23 1
a23 1
C=* Copyright (C) 1985-2007  Health Research Inc.                      *
d49 3
d60 1
a60 1
     &               MODE,REFANGDOC,EXPANGDOC,SCRFILE,
d341 1
a341 1
	                  CALL CROSRNG_E(BFC(1,IR),
d345 1
a345 1
     &                       TT,MIRRORED)
d348 1
a348 1
	                  CALL CROSRNG_MS(BFC(1,IR),
d352 1
a352 1
     &                       TMTA(IR,IT,JT),TMT(IR,IT,JT), TT)
d356 1
a356 1
	               CALL CROSRNG_E(BFC(1,IR),
d360 1
a360 1
     &                      TT, .FALSE.)
d440 1
a440 1
	                  CALL CROSRNG_E(BFC(1,IREF),
d444 1
a444 1
     &                              TT, MIRRORNEW)
d505 3
a507 2
 	            CALL CROSRNG_E(BFC(1,IREF),A_CIRC,LCIRC,
     &                    NRING,MAXRIN,NUMR,CCROTD,RANGNEW,TT,MIRRORNEW)
@


1.84
log
@ALLOCATABLE FIT,ROTMP on ia64
@
text
@d14 1
a14 1
C                   AP_END CALL HAS DUMLIST       OCT 04 ARDEAN LEITH
d18 1
d22 1
a22 1
C=* Copyright (C) 1985-2005  Health Research Inc.                      *
d114 1
a114 1
        REAL, DIMENSION(NLISTMAX)                   :: DUMLIST
d123 10
d276 1
a276 1
     &                NIMALCG, CTYPE, XBUF,LUNDOC,DUMLIST)
d533 4
a536 1
     &                NIMALCG, CTYPE, AA,LUNDOC,DUMLIST)
d538 15
d564 8
@


1.83
log
@DO NOT DISCARD IF NOT MIRRORED
@
text
@d80 1
d83 2
d95 2
a98 2
	DOUBLE PRECISION  FIT(  -ISTEP:ISTEP,-ISTEP:ISTEP)
	DIMENSION         ROTMP(-ISTEP:ISTEP,-ISTEP:ISTEP)
d148 1
a148 1
	NSIS = MAX(ISHRANGE/ISTEP,ISTEP)
d154 2
a155 1
           MWANT = LCIRC*2*NSIS * 2*NSIS + NSAM*NROW + NSAM*NROW*2*NSIS
d285 2
d289 2
a290 1
              MWANT1 = 4 * (NIMA * (ISHRANGE*2+1) * (ISHRANGE*2+1)) 
d452 2
a453 1
	         ENDIF    ! END OF: IF (ISTEP .GT. 1) 
d461 1
@


1.82
log
@GPL License fixed
@
text
@d17 1
d236 9
a244 5
	             NIMALCG      = NIMALCG + 1
	             LCG(NIMALCG) = IMIR
                     IF (DT .LT. 0) LCG(NIMALCG) = -IMIR
	         ENDIF
                 IEND = NIMALCG
@


1.81
log
@HRI GPL License used
@
text
@a18 1
C * SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK       *
d22 1
a22 1
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *  
a41 6

C * COPYRIGHT (C)1985, 2001. HEALTH RESEARCH INCORPORATED (HRI),       *
C * ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C * THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HRI AND ARE NOT   *
C * TO BE DISCLOSED TO OTHERS OR USED FOR PURPOSES OTHER THAN INTENDED *
C * WITHOUT WRITTEN APPROVAL OF HRI.                                   *
@


1.80
log
@OR had register output NAN bug
@
text
@d20 24
@


1.79
log
@removed windowing in getdats call
@
text
@d500 1
a500 1
            CALL REG_SET_NSEL(1,5,RANGOUT,XSHNEW,YSHNEW,
@


1.78
log
@PEAKV = 1
@
text
@d249 1
a249 1
	   CALL AP_GETDATS(ILIP,NIDI,LSAM,LROW,LSAM,LROW,
@


1.77
log
@overcome ia64 || compilation bug
@
text
@d16 1
d484 1
a484 1
           PEAKV     = 0.0
@


1.76
log
@doc file nproj
@
text
@d59 5
d73 1
d253 13
d307 1
a307 1
     &                       TMTA(IR,IT,JT),TMT(IR,IT,JT), TT,MIRRORED)
@


1.75
log
@AP_END CALL HAS DLIST
@
text
@d15 1
d135 1
a135 1
C          RESTRICTED ANGULAR SEARCH FOR 'RQ' OR 'SH' OR 'SH' MQ like 
d193 2
a194 1
           IF (CTYPE(1:2) .EQ. 'RQ' .OR. EXPANGDOC .NE. NULL) THEN
d204 1
a204 1
	         DT = ABS(EXPDIR(1) * REFDIR(1,IMIR) +
@


1.74
log
@if limitrange no longer finds cc for both mirror & non-mirror (if chkmirror)
@
text
@d14 1
d83 3
d230 1
a230 1
     &                NIMALCG, CTYPE, XBUF,LUNDOC)
d469 1
a469 1
     &                NIMALCG, CTYPE, AA,LUNDOC)
@


1.73
log
@parabolic interp on edge bug
sx & xy
@
text
@d13 1
d73 1
d201 1
d203 1
a203 1
	         IF (DT .GE. RANGE) THEN
d207 1
d265 1
a265 1
                    IF (LIMITRANGE) IR = LCG(IRR)
d268 16
a283 6
	               CALL CROSRNG_MS(BFC(1,IR),
     &                      A_CIRC(1,IT/ISTEP,JT/ISTEP),LCIRC,
     &                      NRING,MAXRIN,NUMR,
     &                      TOTA(IR,IT,JT),TOT(IR,IT,JT),
     &                      TMTA(IR,IT,JT),TMT(IR,IT,JT), TT)

d285 2
a286 1
	               CALL CROSRNG_DS(BFC(1,IR),
d289 2
a290 1
     &	                    TOTA(IR,IT,JT),TOT(IR,IT,JT), TT)
d307 1
a307 1
                    IF (LIMITRANGE) IR = LCG(IRR)
d310 1
a310 1
C                      BETTER NON-MIRRORED POSITION   
d316 1
a316 1
                       MIRRORNEW = .FALSE.
d319 2
a320 2
                    IF (CKMIRROR) THEN 
C                      CHECK MIRRORED POSITION 
d363 1
a363 1
	                  CALL  ALRQ_MS(AA(1,1,IT,JT),NSAM,NROW,
d370 1
a370 2
                          IF (MIRRORNEW) THEN
	                     CALL CROSRMG_DS(BFC(1,IREF),
d373 2
a374 7
     &                              FIT(IT,JT),ROTMP(IT,JT),TT)

                          ELSE
	                     CALL CROSRNG_DS(BFC(1,IREF),
     &                           A_CIRC(1,IT,JT),LCIRC,NRING,
     &		                 MAXRIN,NUMR,FIT(IT,JT),ROTMP(IT,JT),TT)
                          ENDIF
d433 3
a435 8
                    IF (MIRRORNEW) THEN
	               CALL CROSRMG_DS(BFC(1,IREF),A_CIRC,LCIRC,
     &                            NRING,MAXRIN,NUMR,CCROTD,RANGNEW,TT)
                    ELSE
	               CALL CROSRNG_DS(BFC(1,IREF),A_CIRC,LCIRC,
     &                      NRING,MAXRIN,NUMR,CCROTD,RANGNEW,TT)
                    ENDIF

@


1.72
log
@limitrange for mq getanga call
@
text
@d1 1
a1 1
C++************************************************************************
d12 1
d28 1
a28 1
C--************************************************************************
d276 3
a278 3
	         ENDDO
              ENDDO
           ENDDO
d280 1
a280 1
C          END OF THE PARALLEL SECTION
d282 1
a282 1
C          LOCATE BEST MATCH
d318 2
d326 1
a326 1
C          TRY TO INTERPOLATE, DO NOT INTERPOLATE FOR POINT ON THE EDGE
d330 1
a330 1
C                HAVE TO FIND NEIGHBOURING VALUES
d368 2
a369 2
	            ENDDO
	         ENDDO
d387 1
a387 1
	         ENDIF
d401 1
d404 1
a404 1
C                CHECK WHETHER INTERPOLATION IS OK.
d406 1
d433 8
a440 2
	         ENDIF
              ENDIF
@


1.71
log
@)) typo
@
text
@d11 1
a11 1
C                   'Mq' NOT READ EXP. ANGLES     APR 04 ARDEAN LEITH
d126 1
a126 1
        IF (RANGE .GT. 0 .OR. CTYPE(1:2) .EQ. 'SH') THEN
@


1.70
log
@'ap mq' should not read ref angles from header
@
text
@d150 1
a150 1
     &     EXPANGDOC .NE. CHAR(0))) THEN
@


1.69
log
@*** empty log message ***
@
text
@d11 1
d149 4
a152 2
        IF (EXPANGDOC .NE. NULL) THEN
           IF (REFANGDOC .NE. NULL) THEN
@


1.68
log
@AP SH, AP REF major changes
@
text
@d42 1
a42 1
	LOGICAL                             :: MIRROROLD,MIRRORNEW
@


1.67
log
@oneimage error
@
text
@d10 1
d29 1
a29 1
     &               LSAM,LROW,NR,LENTT,NSI,ISTEP,
d31 2
a32 2
     &               MODE,REFANG,EXPANG,SCRFILE,
     &               REFPAT,EXPPAT,RANGE,CTYPE)
d41 7
a47 3
	LOGICAL                             :: BFC_IN_CORE
	CHARACTER(LEN=1)                    :: MODE 
        CHARACTER (LEN=*)                   :: REFANG,EXPANG,SCRFILE
a50 2
        PARAMETER (NLIST=7)
        REAL, DIMENSION(NLIST)              :: DLIST
d52 1
a52 1
	DOUBLE PRECISION                    :: QT,QM,PEAK
d55 9
a63 4
	DOUBLE PRECISION  TOTA(NIMA,-NSI:NSI,-NSI:NSI)
	DOUBLE PRECISION  TMTA(NIMA,-NSI:NSI,-NSI:NSI)
	DIMENSION         TOT(NIMA, -NSI:NSI,-NSI:NSI),
     &                    TMT(NIMA, -NSI:NSI,-NSI:NSI)
d68 2
d75 2
a76 2
	REAL, ALLOCATABLE,DIMENSION(:,:)      :: SA 
	REAL, ALLOCATABLE,DIMENSION(:,:)      :: TA
d78 1
a78 1
	PARAMETER (QUADPI = 3.141592653589793238462643383279502884197)
d81 3
a83 1
	DATA  INPIC/77/,INANG/78/,NDOC/55/,NSCF/50/
d85 3
d106 4
a109 4
	NSB=-NSAM/2
	NSE=-NSB-1+MOD(NSAM,2)
	NRB=-NROW/2
	NRE=-NRB-1+MOD(NROW,2)
d111 1
a111 1
	NSIS = MAX(NSI/ISTEP,ISTEP)
d113 2
a114 1
     &           A(NSAM,NROW), AA(NSAM,NROW,-NSIS:NSIS,-NSIS:NSIS),
a120 1
CCH
d122 6
a127 3
        IEND = NIMA
        IF (CTYPE(1:2) .EQ. 'RQ') THEN
	   ALLOCATE(SA(3,NIMA), TA(3,NIDI),STAT=IRTFLG)
d129 2
a130 2
               MWANT = 3*NIMA + 3*NIDI 
               CALL  ERRT(46,'SA, TA',MWANT)
d133 7
d141 4
a144 3
C          READ REF. ANGLES & CONVERT TO SA (UNITARY DIRECTIONAL VECTORS.
	   CALL AP_GETANG(ILIST,NIMA,0,REFANG,REFPAT,
     &                    INPIC,INANG,SA,IRTFLG)
d146 17
d164 9
a172 3
C          READ EXP. ANGLES & CONVERT TO TA (UNITARY DIRECTIONAL VECTOR
	   CALL AP_GETANG(ILIP,NIDI,0,EXPANG,EXPPAT,
     &                    INPIC,INANG,TA,IRTFLG)
d174 2
d179 8
a186 2
	DO IMI=1,NIDI
           IF (CTYPE(1:2) .EQ. 'RQ') THEN
d190 5
a194 3
	         DT = ABS(TA(1,IMI)*SA(1,IMIR) +
     &                    TA(2,IMI)*SA(2,IMIR) +
     &                    TA(3,IMI)*SA(3,IMIR))
d197 1
d205 14
a218 7
C                NO NEARBY REFERENCE IMAGES
                 DLIST(2) =  0.0
                 DLIST(3) = -1.0
                 DLIST(4) =  0.0
                 DLIST(5) =  0.0
                 DLIST(6) =  0.0
                 DLIST(7) = ILIP(IMI)
a219 1
                 CALL LUNDOCWRTDAT(NDOC,IMI,DLIST(2),NLIST-1,IRTFLG)
d225 1
a225 1
           IMITT = IMI
d235 2
a236 2
           DO JT=-NSI,NSI,ISTEP
              CNR2=NROW/2+1+JT
d238 2
a239 2
              DO IT=-NSI,NSI,ISTEP
                 CNS2=NSAM/2+1+IT
a241 1

d245 1
d250 1
d253 1
a253 1
CCH
d257 3
a259 5
                    IF (CTYPE(1:2) .EQ. 'RQ') IR = LCG(IRR)
CCH*
                    IF (CTYPE(1:2) .EQ. 'MQ' .OR. 
     &                  CTYPE(1:3) .EQ. 'ORM' .OR.
     &                  CTYPE(1:2) .EQ. 'RQ')THEN
d264 1
a264 1
     &                      TMTA(IR,IT,JT),TMT(IR,IT,JT),TT)
d266 1
a266 2
                    ELSE IF (CTYPE(1:2) .EQ. 'NQ' .OR.
     &                  CTYPE(1:3) .EQ. 'ORN') THEN
d270 1
a270 2
     &	                    TOTA(IR,IT,JT),TOT(IR,IT,JT),TT)

d277 1
d279 1
d281 2
a282 2
           QT = -1.0D23
           QM = -1.0D23
a283 3
           DO JT=-NSI,NSI,ISTEP
              DO IT=-NSI,NSI,ISTEP
CCH
d287 10
a296 9
                    IF (CTYPE(1:2) .EQ. 'RQ') IR = LCG(IRR)
CCH*
                    IF (TOTA(IR,IT,JT) .GE. QT)  THEN
	               QT   = TOTA(IR,IT,JT)
	               IBE  = IR
                       ISX  = IT
                       ISY  = JT
                       D4   = ANG_N(TOT(IR,IT,JT),MODE,MAXRIN)
                       D6   = ILIST(IR)
d299 10
a308 8
                    IF (CTYPE(1:2) .NE. 'NQ') THEN 
                       IF (TMTA(IR,IT,JT) .GE. QM) THEN
                         QM   = TMTA(IR,IT,JT)
                         IME  = IR
                         IMX  = IT
                         IMY  = JT
                         E4   = ANG_N(TMT(IR,IT,JT),MODE,MAXRIN)
                         E6   = -ILIST(IR)
d315 4
a318 5
C          TRY TO INTERPOLATE
	   IF (QT .GT. QM .OR. 
     &         CTYPE(3:3) .EQ. 'N' .OR.
     &         CTYPE(1:2) .EQ. 'NQ')  THEN
C             FOR NOT-MIRRORED
d320 1
a320 1
              DLIST(2) = D6
d322 3
a324 1
C             DO NOT INTERPOLATE FOR POINT ON THE EDGE
d326 2
a327 4
	      IF (IABS(ISX).NE.NSI .AND. IABS(ISY).NE.NSI)  THEN
C                HAVE TO FIND NEIGHBOURING VALUES
	         FIT(0,0)=QT
	         ROTMP(0,0)=D4
d332 2
a333 2
	                  CNR2=NROW/2+1+JT+ISY
	                  CNS2=NSAM/2+1+IT+ISX
d335 1
d340 4
a343 3
	                  CALL  ALRQ_MS
     &                       (AA(1,1,IT,JT),NSAM,NROW,CNS2,CNR2,NUMR,
     &                        A_CIRC(1,IT,JT),LCIRC,NRING,MODE)
d345 1
d348 11
a358 3
	                  CALL CROSRNG_DS(BFC(1,IBE),
     &                        A_CIRC(1,IT,JT),LCIRC,NRING,
     &		              MAXRIN,NUMR,FIT(IT,JT),ROTMP(IT,JT),TT)
d367 3
a369 3
	         AFIT=FIT(0,0)
	         JTMA=0
	         ITMA=0
d374 4
a377 4
	                     AFIT = FIT(IT,JT)
	                     D4   = ROTMP(IT,JT)
	                     ITMA = IT
	                     JTMA = JT
d391 3
a393 3
	         QT  = AFIT
	         ISX = ISX+ITMA
	         ISY = ISY+JTMA
d399 2
a400 2
	            SX   = SX+ISX
	            SY   = SY+ISY
d404 1
d408 1
d412 1
d415 7
a421 2
	            CALL CROSRNG_DS(BFC(1,IBE),A_CIRC,LCIRC,
     &                   NRING,MAXRIN,NUMR,QT,D4,TT)
d423 2
a424 7
	            D5 = QT
	            D4 = ANG_N(D4,MODE,MAXRIN)
	         ELSE
C                   INTERPOLATION FAILED
	            D5 = QT
	            SX = ISX
	            SY = ISY
a425 4
	      ELSE
	         D5 = QT
	         SX = ISX
	         SY = ISY
a426 100

	   ELSE
              DLIST(2)=E6

C             INTERPOLATE FOR MIRRORED
	      IF (IABS(IMX).NE.NSI .AND. IABS(IMY).NE.NSI)  THEN
C                HAVE TO FIND NEIGHBOURING VALUES
	         FIT(0,0)   = QM
	         ROTMP(0,0) = E4
c$omp            parallel do private(jt,it,cnr2,cns2)
	         DO JT=-ISTEP,ISTEP
	            DO IT=-ISTEP,ISTEP
	               IF (IT.NE.0 .OR. JT.NE.0) THEN
	                 CNR2 = NROW/2+1+JT+IMY
	                 CNS2 = NSAM/2+1+IT+IMX

	                 CALL NORMASC(A,AA(1,1,IT,JT),
     &	                     NSB-(IT+IMX),NSE-(IT+IMX),NRB-(JT+IMY),
     &                       NRE-(JT+IMY), NUMR,NUMR(1,NRING))

	                 CALL ALRQ_MS
     &                      (AA(1,1,IT,JT),NSAM,NROW,CNS2,CNR2,NUMR,
     &                      A_CIRC(1,IT,JT),LCIRC,NRING,MODE)

	                 CALL FRNGS(A_CIRC(1,IT,JT),LCIRC,NUMR,NRING)

	                 CALL CROSRMG_DS
     &		         (BFC(1,IME),A_CIRC(1,IT,JT),LCIRC,NRING,
     &		            MAXRIN,NUMR,FIT(IT,JT),ROTMP(IT,JT),TT)

	                 ROTMP(IT,JT)=ANG_N(ROTMP(IT,JT),MODE,MAXRIN)
	              ENDIF
	           ENDDO
	        ENDDO

C               FIND THE MAXIMUM WITHIN +/-ISTEP
C               MAXIMUM CANNOT BE ON THE EDGE, I.E., IT,JT/=ISTEP
	        AFIT = FIT(0,0)
	        JTMA = 0
	        ITMA = 0
	        IF (ISTEP .GT. 1)  THEN
	           DO JT=-ISTEP+1,ISTEP-1
	              DO IT=-ISTEP+1,ISTEP-1
	                  IF (FIT(IT,JT) .GT. AFIT)  THEN
	                     AFIT   = FIT(IT,JT)
	                     E4     = ROTMP(IT,JT)
	                     ITMA   = IT
	                     JTMA   = JT
	                  ENDIF
	               ENDDO
	            ENDDO
	         ENDIF

C                COPY VALUES AROUND THE PEAK.
	         DO JT=-1,1
	            DO IT=-1,1
	               FITP(IT,JT) = FIT(ITMA+IT,JTMA+JT)
	            ENDDO
	         ENDDO

C                UPDATE LOCATION OF THE PEAK
	         QM  = AFIT
	         IMX = IMX+ITMA
	         IMY = IMY+JTMA

	         CALL PARABLD(FITP,SX,SY,PEAK)

C                CHECK WHETHER INTERPOLATION IS OK.
	         IF (ABS(SX).LT.1.0 .AND. ABS(SY).LT.1.0)  THEN
	            SX=SX+IMX
	            SY=SY+IMY
	            CNR2 = NROW/2+1+SY
	            CNS2 = NSAM/2+1+SX
	            CALL NORMAS(A,NSB-IMX,NSE-IMX,NRB-IMY,NRE-IMY,
     &                          NUMR,NUMR(1,NRING))

	            CALL ALRQ_M(A,NSAM,NROW,CNS2,CNR2,NUMR,A_CIRC,LCIRC,
     &                  NRING,MODE)

	            CALL FRNG(A_CIRC,LCIRC,NUMR,NRING)

	            CALL CROSRMG_DS (BFC(1,IME),A_CIRC,LCIRC,
     &                  NRING,MAXRIN,NUMR,QM,D4,TT)

	            D5 = QM
	            D4 = ANG_N(D4,MODE,MAXRIN)
	         ELSE
C                   INTERPOLATION FAILED
	            SX = IMX
	            SY = IMY
	            D4 = E4
	            D5 = QM
	         ENDIF
	      ELSE
	         SX = IMX
	         SY = IMY
	         D4=E4
	         D5=QM
	      ENDIF
           ENDIF
d431 1
a431 1
C          NOW HAVE TO CHANGE ORDER OF SHIFT&ROTATION.
d433 14
a446 20
C          IN RT SQ IT IS ROTATION FIRST, SHIFT SECOND.
C          THIS PART CORRESPONDS TO SA P.
	   CO     = COS(D4*DGR_TO_RAD)
	   SO     = -SIN(D4*DGR_TO_RAD)
	   XSHSUM = SX*CO-SY*SO
	   YSHSUM = SX*SO+SY*CO

C          1 - NUMBER OF THE MOST SIMILAR REFERENCE PROJECTION.
C          2 - NOT-NORMALIZED CORRELATION COEFFICIENT.
C          3 - PSI ANGLE. (IN=PLANE ROTATION)
C          4 - SX
C          5 - SY
C          6 - INPUT IMAGE NUMBER.

           DLIST(3) = D5
           DLIST(4) = D4
           DLIST(5) = XSHSUM
           DLIST(6) = YSHSUM
           DLIST(7) = ILIP(IMI)
           DLIST(1) = IMI
a447 1
           CALL LUNDOCWRTDAT(NDOC,IMI,DLIST(2),NLIST-1,IRTFLG)
d451 1
a451 1
        IF (NSEL_USED .GT. 0) THEN
d454 3
a456 3
            IF (DLIST(2) .LT. 0) DMR = 1
            CALL REG_SET_NSEL(1,5,DLIST(4),DLIST(5),
     &             DLIST(6),DMR,DLIST(3),IRTFLG)
d459 6
a464 7
9999    CLOSE(NDOC)

	IF (ALLOCATED(AA))         DEALLOCATE(AA)
	IF (ALLOCATED(A_CIRC))     DEALLOCATE(A_CIRC)
	IF (ALLOCATED(A))          DEALLOCATE(A)
	IF (ALLOCATED(SA))         DEALLOCATE(SA)
	IF (ALLOCATED(TA))         DEALLOCATE(TA)
@


1.66
log
@'OR' bug
@
text
@d162 3
a164 4
	   CALL AP_GETDAT(ILIP,NIMA,lSAM,lROW,lSAM,lROW,
     &                       NUMTH,EXPPAT,INPIC,IMITT,IMITT,
     &                       1,LROW,1,LSAM, A,
     &                       IRTFLG)
@


1.65
log
@'OR MQ' support
@
text
@a22 1
C  NEEDS ERROR RECOVERY
d194 1
d202 2
a203 1
                    ELSE IF (CTYPE(1:2) .EQ. 'NQ') THEN
@


1.64
log
@AP rewrite
@
text
@d9 1
d20 1
a20 3
C  MRQLI 
C  
C MRQLI_SS.F
d160 3
d164 1
a164 1
     &                       NUMTH,EXPPAT,INPIC,IMI,IMI,
d295 1
a295 1
	         IF (ISTEP .GT. 1)  THEN
d483 9
@


1.63
log
@rewrite
@
text
@d214 3
a216 2
           QT=-1.0D23
           QM=-1.0D23
d234 9
a242 7
                    IF (CTYPE .NE. 'NQ'.AND. TMTA(IR,IT,JT) .GE. QM)THEN
                       QM   = TMTA(IR,IT,JT)
                       IME  = IR
                       IMX  = IT
                       IMY  = JT
                       E4   = ANG_N(TMT(IR,IT,JT),MODE,MAXRIN)
                       E6   = -ILIST(IR)
d436 1
a436 1
	            D4 = ANG_N(D4,MODEi,MAXRIN)
@


1.62
log
@*** empty log message ***
@
text
@d3 1
a3 1
C    MRQLI.F        USED CMLIMIT                  AUG 00 ARDEAN LEITH
d8 1
a8 1
C                   APMASTER                      AUG 03 ARDEAN LEITH
a20 174
C  PARAMETERS:  MAKEREFFILE   CREATE BFC FILE              (INPUT)
C
C NOTE:  IF USING MRQLI_PS, MOST MEMORY DEMAND APPEARS TO BE DEPENDENT 
C        ON LCIRC & NIMA.  LCIRC IS THE TOTAL LENGTH OF THE ARRAY
C        THAT HOLDS THE CIRCULAR RINGS, SO IT IS DEPENDENT ON
C        NUMBER OF RINGS AND THEIR RADIUS.  NIMA IS NUMBER OF REFERENCE
C        IMAGES. BIGGEST ARRAY ALLOCATED IS: BFC(LCIRC,NIMA)
C        ANOTHER SMALL ALLOCATED ARRAY IS: A(NSAM,NROW,NUMTH)
C        FOR 83 IMAGES of 125x125 WITH RINGS AT 5...47 SIZE=45MB
C        ARRAYS ONLY APPEAR TO TAKE: 3.6MB?
C
C23456789012345678901234567890123456789012345678901234567890123456789012
C--************************************************************************

C **************************************************************************
C
C  MRQLI_PS
C
C--************************************************************************

       SUBROUTINE MRQLI_PS(ILIST,NIMA,ILIP,NIDI, 
     &               LSAM,LROW,NR,LENTT,NSI,ISTEP,
     &               NRING,LCIRC,NUMR,BFC,BFC_IN_CORE,
     &               MODE, REFANG,EXPANG,SCRFILE,
     &               REFPAT,EXPPAT,RANGE,CTYPE)

        INCLUDE 'CMLIMIT.INC'
        INCLUDE 'CMBLOCK.INC'

	INTEGER, DIMENSION(NIMA)               :: ILIST 
	INTEGER, DIMENSION(NIDI)               :: ILIP 
        INTEGER, DIMENSION(3,NRING)            :: NUMR
	REAL, DIMENSION(LCIRC,NIMA)            :: BFC
	LOGICAL                                :: BFC_IN_CORE
        CHARACTER(LEN=1)                       :: MODE
        CHARACTER (LEN=*)                      :: REFANG,EXPANG
        CHARACTER (LEN=*)                      :: SCRFILE
        CHARACTER (LEN=*)                      :: REFPAT,EXPPAT 
        CHARACTER (LEN=*)                      :: CTYPE

C       AUTOMATIC ARRAYS
	DOUBLE PRECISION, DIMENSION(LENTT)     :: TT

C       ALLOCATED ARRAYS
	REAL, ALLOCATABLE, DIMENSION(:,:,:)    :: A
	REAL, ALLOCATABLE, DIMENSION(:,:)      :: DLIST 
	REAL, ALLOCATABLE,DIMENSION(:,:)       :: SA 
	REAL, ALLOCATABLE,DIMENSION(:,:)       :: TA

        PARAMETER (NLIST=7)
	PARAMETER (QUADPI = 3.141592653589793238462643383279502884197)
	PARAMETER (DGR_TO_RAD =   (QUADPI/180))

	DATA  INPIC/77/,INANG/78/,NDOC/55/,NSCF/50/

        MAXRIN = NUMR(3,NRING)
        IF (CTYPE(1:2) .EQ. 'RQ') RANGE  = COS(RANGE*DGR_TO_RAD)

C       FIND DIVAS, NUMTH, NSAM, & NROW
	CALL APMASTER_1(MODE,DIVAS,NR,NUMTH,LSAM,LROW,NSAM,NROW,
     &                   TT,LENTT)

C       READ REFERENCE IMAGES INTO REFERENCE RINGS (BFC) ARRAY 
        CALL APRINGS(ILIST,NIMA, 
     &               LSAM,LROW,LSAM,LROW,
     &               NRING,LCIRC,NUMR,MODE,
     &               REFPAT,INPIC,BFC,BFC_IN_CORE,
     &               NSCF,SCRFILE,IRTFLG)
        NSAM = LSAM
        NROW = LROW

C       CALCULATE DIMENSIONS FOR NORMAS
	NSB  = -NSAM/2
	NSE  = -NSB-1+MOD(NSAM,2)
	NRB  = -NROW/2
	NRE  = -NRB-1+MOD(NROW,2)


	ALLOCATE(A(LSAM,LROW,NUMTH), DLIST(NLIST,NUMTH),  STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
           MWANT = LSAM*LROW*NUMTH + NLIST*NUMTH  
           CALL  ERRT(46,'A...',MWANT)
           RETURN
        ENDIF 
        DLIST = 0.0

        IF (CTYPE(1:2) .EQ. 'RQ') THEN
	   ALLOCATE(SA(3,NIMA), TA(3,NIDI),STAT=IRTFLG)
	   IF (IRTFLG .NE. 0) THEN
               MWANT = 3*NIMA + 3*NIDI 
               CALL  ERRT(46,'SA, TA',MWANT)
               RETURN
           ENDIF 

C          READ REF. ANGLES & CONVERT TO SA (UNITARY DIRECTIONAL VECTORS.
	   CALL AP_GETANG(ILIST,NIMA,0,REFANG,REFPAT,
     &                    INPIC,INANG,SA,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9999

C          READ EXP. ANGLES & CONVERT TO TA (UNITARY DIRECTIONAL VECTOR
	   CALL AP_GETANG(ILIP,NIDI,0,EXPANG,EXPPAT,
     &                    INPIC,INANG,TA,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9999
        ENDIF

C       LOOP OVER ALL SETS OF EXPERIMENTAL (SAMPLE) IMAGES
 	DO IMIT=1,NIDI,NUMTH

C          LOAD EXP. IMAGE DATA FOR THIS SET OF IMAGES
           IEND = MIN(NIDI,IMIT+NUMTH-1)
	   CALL AP_GETDAT(ILIP,NIMA,LSAM,LROW,LSAM,LROW,
     &                       NUMTH,EXPPAT,INPIC, IMIT,IEND,
     &                       1,LROW,1,LSAM, A,
     &                       IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9999

C          NUMTH INPUT IMAGES READY TO BE ALIGNED
c$omp      parallel do private(IMI)
	   DO IMI=IMIT,MIN(NIDI,IMIT+NUMTH-1)
              IT = IMI-IMIT+1

	      CALL APRQ2D(A(1,1,IT),BFC,TT,NUMR,
     &	            NSAM,NROW,NSI,ISTEP,
     &	            NSB,NSE,NRB,NRE,LCIRC,NRING,MAXRIN,NIMA,MODE,
     &              SA,TA(1,IMI),RANGE,
     &              DLIST(2,IT),DLIST(3,IT),
     &              DLIST(4,IT),DLIST(5,IT),DLIST(6,IT),CTYPE)
	   ENDDO

C          OUTPUT (IN DLIST POSITION IS INCREASED BY 1, NO.1 IS THE KEY).
C          1 - NUMBER OF THE MOST SIMILAR REFERENCE PROJECTION.
C          2 - NOT-NORMALIZED CORRELATION COEFFICIENT.
C          3 - PSI ANGLE. (IN=PLANE ROTATION)
C          4 - SX SHIFT
C          5 - SY SHIFT
C          6 - INPUT IMAGE NUMBER.
    
           DO ITI=IMIT,MIN(NIDI,IMIT+NUMTH-1)
              IT = ITI-IMIT+1

C             DLIST(2,IT IS LIST NUMBER OF MOST SIMILAR REF. IMAGE 
C                 (<0 IF MIRRORED, 0 IF NONE )

              IMI    = INT(DLIST(2,IT))
              IMIABS = ABS(IMI)

              DLIST(2,IT) = 0.0
              IF (IMIABS .NE. 0) THEN
C                SAVE NUMBER OF MOST SIMILAR REF. IMAGE
                 DLIST(2,IT) = ILIST(IMIABS)

C                SET NUMBER <0 IF MIRRORED
                 IF (IMI .LT. 0) DLIST(2,IT) = -DLIST(2,IT) 
              ENDIF

              DLIST(7,IT) = ILIP(ITI)
              CALL LUNDOCWRTDAT(NDOC,ITI,DLIST(2,IT),NLIST-1,IRTFLG)
	   ENDDO
	ENDDO

C       OVER AND OUT
9999    CLOSE(NDOC)

C       DEALLOCATE  ARRAYS
        IF (ALLOCATED(DLIST))      DEALLOCATE(DLIST)
	IF (ALLOCATED(A))          DEALLOCATE(A)
	IF (ALLOCATED(SA))         DEALLOCATE(SA)
	IF (ALLOCATED(TA))         DEALLOCATE(TA)

	END


C++************************************************************************
C
d26 1
a28 1

a486 380

C+**********************************************************************
C
C APRQ2D.F
C 
C  OUTPUT PARAMETERS:
C                NUMBER OF THE MOST SIMILAR REFERENCE PROJECTION.
C                CORR COEFF.(D5), ANGLE (D4), SHIFT: XSHSUM, YSHSUM
C
C-**********************************************************************

	SUBROUTINE APRQ2D(A,BFC,TT,NUMR,
     &	                NSAM,NROW,NSI,ISTEP,
     &	                NSB,NSE,NRB,NRE,LCIRC,NRING,MAXRIN,NIMA,MODE,
     &                  SA,TA,RANGE,
     &                  D2,D5,D4,XSHSUM,YSHSUM,CTYPE)

	DIMENSION A(NSAM,NROW),BFC(LCIRC,NIMA),NUMR(3,NRING) 

	DOUBLE PRECISION  FITP(-1:1,-1:1)
	DOUBLE PRECISION, DIMENSION(*)    :: TT
        CHARACTER (LEN=1)                 :: MODE
        CHARACTER (LEN=*)                 :: CTYPE
	REAL, DIMENSION(3,NIMA)           :: SA
	REAL, DIMENSION(3 )               :: TA

C       AUTOMATIC ARRAYS
	DOUBLE PRECISION  FIT(-ISTEP:ISTEP,-ISTEP:ISTEP)
	DIMENSION         ROTMP(-ISTEP:ISTEP,-ISTEP:ISTEP)
        REAL, DIMENSION(LCIRC)             :: A_CIRC

        INTEGER, ALLOCATABLE, DIMENSION(:) :: LCG

	DOUBLE PRECISION                   :: QT,QM,PEAK
	DOUBLE PRECISION                   :: TOTA,TMTA
        LOGICAL                            :: MIRRORCK

	PARAMETER (QUADPI = 3.141592653589793238462643383279502884197)
	PARAMETER (DGR_TO_RAD = (QUADPI/180))

        MIRRORCK = (CTYPE(1:2) .EQ. 'MQ' .OR. 
     &             (CTYPE(1:2) .EQ. 'RQ' .AND. CTYPE(3:3) .NE. 'N'))

        IEND = NIMA
        IF (CTYPE(1:2) .EQ. 'RQ') THEN
C          RESTRICTED RANGE SEARCH
	   ALLOCATE(LCG(NIMA),STAT=IRTFLG)
	   IF (IRTFLG.NE.0) THEN
              MWANT = NIMA
              CALL  ERRT(46,'LCG',MWANT)
              RETURN
           ENDIF

	   NIMALCG = 0
	   DO IMI=1,NIMA
	      DT = ABS(TA(1)*SA(1,IMI)+TA(2)*SA(2,IMI)+TA(3)*SA(3,IMI))
	      IF (DT .GE. RANGE) THEN
C                THIS REFERENCE IS WITHIN SEARCH RANGE
	         NIMALCG      = NIMALCG + 1
	         LCG(NIMALCG) = IMI
	      ENDIF
	   ENDDO
	   IF (NIMALCG .LE. 0) THEN
C             THERE IS NO REFERENCE WITHIN SEARCH RANGE
              XSHSUM = 0
	      YSHSUM = 0
              D2     = 0
              D4     = 0
              D5     = -1.0 
              RETURN	
           ENDIF
           IEND = NIMALCG
        ENDIF

	
	QT = -1.0D23
	QM = -1.0D23

c       GO THROUGH CENTERS FOR SHIFT ALIGNMENT
	DO JT=-NSI,NSI,ISTEP
	   CNR2 = NROW/2+1+JT
	   DO IT=-NSI,NSI,ISTEP
	      CNS2 = NSAM/2+1+IT

C             NORMALIZE UNDER THE MASK
	      
	      CALL NORMAS(A,NSB-IT,NSE-IT,NRB-JT,NRE-JT,NUMR,
     &                     NUMR(1,NRING))

C             CREATES A_CIRC (EXP. IMAGE CIRCLES) FOR THIS POSITION
	      CALL ALRQ_MS(A,NSAM,NROW,CNS2,CNR2,NUMR,A_CIRC,
     &                      LCIRC,NRING,MODE)

C             CREATES FOURIER OF: A_CIRC
	      CALL FRNGS(A_CIRC,LCIRC,NUMR,NRING)

C             COMPARE EXP. IMAGE WITH ALL REFERENCE IMAGES
	      DO IRR=1,IEND
                 IR = IRR

                 IF (CTYPE(1:2) .EQ. 'MQ' .OR. CTYPE(1:2) .EQ. 'RQ')THEN

                    IF (CTYPE(1:2) .EQ. 'RQ') IR = LCG(IRR)
	            CALL CROSRNG_MS (BFC(1,IR),A_CIRC,LCIRC,NRING,
     &		           MAXRIN,NUMR,TOTA,TOT,TMTA,TMT,TT)

	            IF (TMTA .GE. QM)  THEN
	               QM   = TMTA
	               IME  = IR
	               IMX  = IT
	               IMY  = JT
	               E4   =  ANG_N(TMT,MODE,MAXRIN)
	               IDIM = -IR
	            ENDIF

                 ELSE IF (CTYPE(1:2) .EQ. 'NQ') THEN 
	            CALL CROSRNG_DS(BFC(1,IR),A_CIRC,LCIRC,NRING,
     &		                  MAXRIN,NUMR,TOTA,TOT,TT)
                 ENDIF

	         IF (TOTA .GE. QT)  THEN
	            QT   = TOTA
	            IBE  = IR
	            ISX  = IT
	            ISY  = JT
	            D4   = ANG_N(TOT,MODE,MAXRIN)
	            IDIS = IR
	            D6   = IR
	         ENDIF

	      ENDDO 
C             END-OF-LOOP 1 OVER REFERENCE IMAGES
	   ENDDO
	ENDDO

C       TRY TO INTERPOLATE FOR NOT-MIRRORED
        DLIST2 = D6

	IF (QT .GT. QM .OR. .NOT. MIRRORCK)  THEN
C          FOR NOT-MIRRORED
           D2 = IDIS

C          DO NOT INTERPOLATE FOR POINT ON THE EDGE
	   IF (IABS(ISX).NE.NSI.AND.IABS(ISY).NE.NSI)  THEN
C             HAVE TO FIND NEIGHBOURING VALUES
	      FIT(0,0)   = QT
	      ROTMP(0,0) = D4
	      DO JT=-ISTEP,ISTEP
	         DO IT=-ISTEP,ISTEP
	            IF (IT.NE.0 .OR. JT.NE.0) THEN
	               CNR2=NROW/2+1+JT+ISY
	               CNS2=NSAM/2+1+IT+ISX

	               CALL NORMAS(A, NSB-(IT+ISX),NSE-(IT+ISX),
     &                             NRB-(JT+ISY),NRE-(JT+ISY),
     &	                           NUMR,NUMR(1,NRING))

	               CALL ALRQ_MS(A,NSAM,NROW,CNS2,CNR2,NUMR,
     &                               A_CIRC,LCIRC,NRING,MODE)

	               CALL FRNGS(A_CIRC,LCIRC,NUMR,NRING)

	               CALL CROSRNG_DS(BFC(1,IBE),A_CIRC,LCIRC,NRING,
     &		            MAXRIN,NUMR,FIT(IT,JT),ROTMP(IT,JT),TT)

                       ROTMP(IT,JT) = ANG_N(ROTMP(IT,JT),MODE,MAXRIN)

	            ENDIF
	         ENDDO
	      ENDDO

C             FIND THE MAXIMUM WITHIN +/-ISTEP
C             MAXIMUM CANNOT BE ON THE EDGE, I.E., IT,JT/=ISTEP
	      AFIT = FIT(0,0)
	      JTMA = 0
	      ITMA = 0
	      IF (ISTEP.GT.1)  THEN
	         DO JT=-ISTEP+1,ISTEP-1
	            DO IT=-ISTEP+1,ISTEP-1
	               IF (FIT(IT,JT) .GT. AFIT)  THEN
	                  AFIT = FIT(IT,JT)
	                  D4   = ROTMP(IT,JT)
	                  ITMA = IT
	                  JTMA = JT
	               ENDIF
	            ENDDO
	         ENDDO
	      ENDIF

C             COPY VALUES AROUND THE PEAK.
	      DO JT=-1,1
	         DO IT=-1,1
	            FITP(IT,JT) = FIT(ITMA+IT,JTMA+JT)
	         ENDDO
	      ENDDO

C             UPDATE LOCATION OF THE PEAK
	      QT  = AFIT
	      ISX = ISX+ITMA
	      ISY = ISY+JTMA
	      CALL  PARABLD(FITP,SX,SY,PEAK)

C             CHECK WHETHER INTERPOLATION IS OK.
	      IF (ABS(SX).LT.1.0 .AND. ABS(SY).LT.1.0)  THEN
	         SX   = SX+ISX
	         SY   = SY+ISY
	         CNR2 = NROW/2+1+SY
	         CNS2 = NSAM/2+1+SX

	         CALL NORMAS(A,NSB-ISX,NSE-ISX,NRB-ISY,NRE-ISY,
     &	                      NUMR,NUMR(1,NRING))

	         CALL ALRQ_MS(A,NSAM,NROW,CNS2,CNR2,NUMR,A_CIRC,
     &                        LCIRC,NRING,MODE)

	         CALL FRNGS(A_CIRC,LCIRC,NUMR,NRING)

	         CALL CROSRNG_DS(BFC(1,IBE),A_CIRC,LCIRC,NRING,
     &		                 MAXRIN,NUMR,QT,D4,TT)
	         D5 = QT
	         D4 = ANG_N(D4,MODE,MAXRIN)
	      ELSE
C                INTERPOLATION FAILED
	         D5  = QT
	         SX  = ISX
	         SY  = ISY
	      ENDIF
	   ELSE
	      D5 = QT
	      SX = ISX
	      SY = ISY
	   ENDIF

	ELSE
           D2 = IDIM

C          INTERPOLATE FOR MIRRORED
	   IF (IABS(IMX).NE.NSI .AND. IABS(IMY).NE.NSI)  THEN
C             HAVE TO FIND NEIGHBOURING VALUES
	      FIT(0,0)   = QM
	      ROTMP(0,0) = E4
	      DO JT=-ISTEP,ISTEP
	         DO IT=-ISTEP,ISTEP
	            IF (IT.NE.0 .OR. JT.NE.0) THEN
	               CNR2 = NROW/2+1+JT+IMY
	               CNS2 = NSAM/2+1+IT+IMX
	               CALL NORMAS(A,NSB-(IT+IMX),NSE-(IT+IMX),
     &                             NRB-(JT+IMY),NRE-(JT+IMY),
     &	                           NUMR,NUMR(1,NRING))

	               CALL ALRQ_MS(A,NSAM,NROW,CNS2,CNR2,NUMR,
     &                              A_CIRC,LCIRC,NRING,MODE)

	               CALL FRNGS(A_CIRC,LCIRC,NUMR,NRING)

	               CALL CROSRMG_DS(BFC(1,IME),A_CIRC,
     &                     LCIRC,NRING,MAXRIN,NUMR,FIT(IT,JT),
     &                     ROTMP(IT,JT),TT)

	               ROTMP(IT,JT) = ANG_N(ROTMP(IT,JT),MODEi,
     &                     MAXRIN)
	            ENDIF
	         ENDDO
	      ENDDO

C             FIND THE MAXIMUM WITHIN +/-ISTEP
C             MAXIMUM CANNOT BE ON THE EDGE, I.E., IT,JT/=ISTEP
	      AFIT = FIT(0,0)
	      JTMA = 0
	      ITMA = 0
	      IF (ISTEP.GT.1)  THEN
	         DO JT=-ISTEP+1,ISTEP-1
	            DO IT=-ISTEP+1,ISTEP-1
	               IF (FIT(IT,JT) .GT. AFIT)  THEN
	                  AFIT = FIT(IT,JT)
	                  E4   = ROTMP(IT,JT)
	                  ITMA = IT
	                  JTMA = JT
	               ENDIF
	            ENDDO
	         ENDDO
	      ENDIF

C             COPY VALUES AROUND THE PEAK.
	      DO JT=-1,1
	         DO IT=-1,1
	            FITP(IT,JT) = FIT(ITMA+IT,JTMA+JT)
	         ENDDO
	      ENDDO

C             UPDATE LOCATION OF THE PEAK
	      QM  = AFIT
	      IMX = IMX+ITMA
	      IMY = IMY+JTMA
	      CALL PARABLD(FITP,SX,SY,PEAK)

C             CHECK WHETHER INTERPOLATION IS OK.
	      IF (ABS(SX).LT.1.0 .AND. ABS(SY).LT.1.0)  THEN
	         SX=SX+IMX
	         SY=SY+IMY
	         CNR2=NROW/2+1+SY
	         CNS2=NSAM/2+1+SX

	         CALL NORMAS(A,NSB-IMX,NSE-IMX,NRB-IMY,NRE-IMY,
     &                        NUMR,NUMR(1,NRING))

	         CALL ALRQ_MS(A,NSAM,NROW,CNS2,CNR2,NUMR,A_CIRC,
     &                         LCIRC,NRING,MODE)

	         CALL FRNGS(A_CIRC,LCIRC,NUMR,NRING)

	         CALL CROSRMG_DS(BFC(1,IME),A_CIRC,LCIRC,NRING,
     &		            MAXRIN,NUMR,QM,D4,TT)
	         D5 = QM
	         D4 = ANG_N(D4,MODE,MAXRIN)

	      ELSE
C                INTERPOLATION FAILED
	         SX = IMX
	         SY = IMY
	         D4 = E4
	         D5 = QM
	      ENDIF

	   ELSE
	      SX = IMX
	      SY = IMY
	      D4 = E4
	      D5 = QM
	   ENDIF
	ENDIF
 
	SX = -SX
	SY = -SY

C       NOW HAVE TO CHANGE ORDER OF SHIFT & ROTATION.
C       IN THIS PROGRAM IMAGE IS SHIFTED FIRST, ROTATED SECOND.
C       IN 'RT SQ' IT IS ROTATION FIRST, SHIFT SECOND.
C       THIS PART CORRESPONDS TO 'SA P'.
	CO     = COS(D4*DGR_TO_RAD)
	SO     = -SIN(D4*DGR_TO_RAD)
	XSHSUM = SX*CO-SY*SO
	YSHSUM = SX*SO+SY*CO
        

9999    IF (ALLOCATED(LCG)) DEALLOCATE(LCG)

	END

C++************************************************************************
C
C  ANG.F                               
C
C **********************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK      *
C *  COPYRIGHT (C)1985, 1996 HEALTH RESEARCH INCORPORATED, ALBANY, NY. *
C * THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HEALTH            *
C * RESEARCH INC. AND ARE NOT TO BE DISCLOSED TO OTHERS OR USED        *
C * FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF       *
C * HEALTH RESEARCH INC.                                               *
C **********************************************************************
C
C  ANG_N(RKK,MODE,MAXRIN)
C
C23456789 123456789 123456789 123456789 123456789 123456789 123456789 12
C--*********************************************************************

        FUNCTION  ANG_N(RKK,MODE,MAXRIN)

        CHARACTER (LEN=1) ::  MODE
        INTEGER           :: MAXRIN

        IF (MODE .EQ. 'H')  THEN
           ANG_N  = AMOD(((RKK-1.0) / MAXRIN+1.)*180.0, 180.)

        ELSEIF (MODE .EQ. 'F')  THEN
           ANG_N  = AMOD(((RKK-1.0) / MAXRIN+1.)*360.0, 360.)
        ENDIF

        END
@


1.61
log
@changed key back to consecutive
@
text
@d8 1
d19 1
a19 1
C  MRQLI(ITYPE,MAKEREFFILE,USEREFFILE)
d21 1
a21 17
C  PARAMETERS:  MAKEREFFILE   CREATE REFER_CIRC FILE              (INPUT)
C               USEREFFILE    RUN USING EXISTING REFER_CIRC FILE  (INPUT)
C               ITYPE         SETS NRQLI=1 OR MRQLI = 0           (INPUT)
C
C  CALLS:
C     MRQLI_SS(ILIST,NIMA,IRIST,NTOTAL,NSAM,NROW,NSI,...
C     MRQLI_PS(ILIST,NIMA,IRIST,NTOTAL,NSAM,NROW,NSI,...
C     NRQLI(ILIST,NIMA,IRIST,NTOTAL,NSAM,NROW,NSI,...
C     APMQ2D(A,REFER_CIRC,TT,NUMR,...
C     NORMASC(X,Y,NS1,NS2,NR1,NR2,IR1,IR2)
C     NORMAS(X,NS1,NS2,NR1,NR2,IR1,IR2)
C     ALRQ_MS
C     CROSRNG_MS
C     CROSRMG_DS
C     FRNGS
C     APPLYWS
C     ALRQS
d27 1
a27 1
C        IMAGES. BIGGEST ARRAY ALLOCATED IS: REFER_CIRC(LCIRC,NIMA)
a31 2
C IMAGE_PROCESSING_ROUTINE
C
a34 210
	SUBROUTINE MRQLI(ITYPE,MAKEREFFILE,USEREFFILE)

	INCLUDE 'CMBLOCK.INC' 
	INCLUDE 'CMLIMIT.INC' 

C       be careful with the common, it has to agree with 64 bits...
	CHARACTER*80      FINPAT,FINPIC,FILTOA
	COMMON  /FISPEC/  FINPAT,FINPIC,FILTOA,NLET,NLETI

	COMMON /MXR/ MAXRIN

	CHARACTER(LEN=1) ::                      MODE
        CHARACTER(LEN=80) ::                     FILREF
	INTEGER, ALLOCATABLE, DIMENSION(:,:) ::  NUMR
	INTEGER, ALLOCATABLE, DIMENSION(:) ::    ILIST,IRIST
	REAL, ALLOCATABLE, DIMENSION(:,:) ::     REFER_CIRC
        LOGICAL ::                               MAKEREFFILE,USEREFFILE

	DATA  INPIC,LUNREF/77,78/

C       ALLOCATE SPACE FOR REFERENCE IMAGE FILE LIST
	NILMAX = NIMAX
	ALLOCATE(ILIST(NILMAX),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
           CALL ERRT(46,'AP MQ, NUMR',IER)
           RETURN
        ENDIF

C       ASK FOR REFERENCE IMAGE FILE LIST
	CALL FILELIST(.TRUE.,INPIC,FINPAT,NLET,ILIST,NILMAX,NIMA,
     &      'ENTER TEMPLATE FOR REFERENCE IMAGE SERIES',IRTFLG)
	IF (IRTFLG .NE. 0) GOTO 9999

        IF (NIMA .GT. 0)  THEN
           WRITE(NOUT,2001) NIMA
2001       FORMAT(' Number of reference images: ',I6)
        ELSE
           CALL ERRT(101,'No reference images!',IDUM)
           GOTO 9999
        ENDIF

C       GET FIRST REFERENCE IMAGE TO DETERMINE DIMS
        CALL  FILGET(FINPAT,FINPIC,NLET,ILIST(1),INTFLG)
        MAXIM = 0
	CALL OPFILEC(0,.FALSE.,FINPIC,INPIC,'O',IFORM,NSAM,NROW,NSLICE,
     &               MAXIM,' ',.FALSE.,IRTFLG)
        IF (IRTFLG.NE.0)  GOTO 9999
        CLOSE(INPIC)

	CALL RDPRMI(NSI,ISTEP,NOT_USED,
     &             'TRANSLATION SEARCH RANGE, STEP SIZE')
	NSI   = MAX0(NSI,1)
	ISTEP = MAX0(ISTEP,1)

        CALL  RDPRMI(MR,NR,NOT_USED,'FIRST AND LAST RING')
        IF (NR .GT. NSAM/2-1)  THEN
            NR = NSAM/2-1
            WRITE(NOUT,*)  ' Last ring limited to ',NR
        ENDIF
        MR    = MAX0(1,MIN0(NR,MR))
        ISKIP = 1
        MODE  = 'F'
        NRING = 0
        DO I=MR,NR,ISKIP
           NRING = NRING+1
	ENDDO

	ALLOCATE(NUMR(3,NRING),STAT=IRTFLG)
	IF (IRTFLG.NE.0) THEN
           CALL ERRT(46,'AP MQ, NUMR',IER)
           GOTO 9999
        ENDIF

        NRING = 0
        DO I=MR,NR,ISKIP
           NRING=NRING+1
           NUMR(1,NRING)=I
	ENDDO

C       ADJUST SEARCH RANGE AND STEP SIZE.
	IF (NSI+NR .GT. NSAM/2-2)  THEN
	   CALL ERRT(101,'SEARCH RANGE TOO LARGE',NE)
           GOTO 9999
	ENDIF

	IF (MOD(NSI,ISTEP) .NE. 0) THEN
	   CALL ERRT(101,'SEARCH RANGE MUST BE DIVISIBLE BY STEP SIZE',
     &               NE)
           GOTO 9999
	ENDIF

C       PUTS CIRCULAR RINGS IN A LINEAR ARRAY, CONCATENATED TOGETHER.
C       RETURNS NUMR & LCIRC.
        CALL  ALPRBS(NUMR,NRING,LCIRC,MODE)
        MAXRIN = NUMR(3,NRING)

C       ALLOCATE SPACE FOR REFERENCE CIRCLES ARRAY
	ALLOCATE(REFER_CIRC(LCIRC,NIMA),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
            CALL  ERRT(46,'MRQLI, REFER_CIRC',IER)
            RETURN
        ENDIF 

C       DETERMINE NUMBER OF OMP THREADS
        CALL GETTHREADS(NUMTH)
        WRITE(NOUT,*) ' NUMBER OF OMP THREADS: ',NUMTH

        IF (USEREFFILE) THEN
C          OPEN REFERENCE RINGS FILE
           MAXIM = 0
	   CALL OPFILEC(0,.TRUE.,FILREF,LUNREF,'O',IFORM,LCIRCT,NIMAT,
     &                NDUM,MAXIM,'REFERENCE RINGS',.FALSE.,IRTFLG)
           IF (IRTFLG .NE. 0)  GOTO 9999
           IF (LCIRC .NE. LCIRCT .OR. NIMA .NE. NIMAT) THEN
              CALL ERRT(102,
     &           'REFERENCE RINGS FILE SIZE NOT COMPATIBLE',NDUM)
              GOTO 9999
           ENDIF

C          RECOVER REFER_CIRC FROM REFERENCE RINGS FILE
           DO J=1,NIMA
	      CALL REDLIN(LUNREF,REFER_CIRC(1,J),LCIRC,J)
           ENDDO

           CLOSE(LUNREF)

        ELSEIF (MAKEREFFILE) THEN
C          CREATE REFERENCE RINGS FILE
           MAXIM = 0
           IFORM = 1
	   CALL OPFILEC(0,.TRUE.,FILREF,LUNREF,'N',IFORM,LCIRC,NIMA,
     &                1, MAXIM,'REFERENCE RINGS',.FALSE.,IRTFLG)
           IF (IRTFLG .NE. 0)  GOTO 9999
           CALL NORM3(LUNREF,LCIRC,NIMA,1,FMAX,FMIN,AV)

           WRITE (NOUT,2601)
2601       FORMAT (/,' ',72('-'),//,
     &               '  Multi-reference alignment, Refer-circ.',//,
     &               ' ',72('-'),/)

C          FILL REF_CIRC FILE WITH RINGS DATA AND QUIT.
           CALL INITAP(ILIST,NIMA,NSAM,NROW,
     &                MODE,LCIRC,NUMR,NRING,MAXRIN,NUMTH,LUNREF,
     &                INPIC,REFER_CIRC,IRTFLG)

           GOTO 9999

        ELSE
C          CREATE ON-DISK REFERENCE RINGS ARRAY AND USE IT
           CALL INITAP(ILIST,NIMA,NSAM,NROW,
     &                MODE,LCIRC,NUMR,NRING,MAXRIN,NUMTH,0,
     &                 INPIC,REFER_CIRC,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9999
        ENDIF
 
C       ALLOCATE SPACE FOR ALIGNED IMAGES FILE LIST
	ALLOCATE(IRIST(NILMAX),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
           CALL ERRT(46,'AP MQ, NUMR',IER)
           GOTO 9999
        ENDIF

C       GET LIST OF SAMPLE IMAGES TO BE ALIGNED
	CALL FILELIST(.TRUE.,INPIC,FILTOA,NLETI,IRIST,NILMAX,NTOTAL,
     &     'ENTER TEMPLATE FOR IMAGE SERIES TO BE ALIGNED',IRTFLG)
	IF (IRTFLG.NE.0) GOTO 9999

        IF (NTOTAL .GT. 0)  THEN
           WRITE(NOUT,2002) NTOTAL
2002       FORMAT(' Number of experimental images: ',I6/)
        ELSE
           CALL ERRT(101,'No experimental images!',IDUM)
           GOTO 9999
        ENDIF

C       NIMA NUMBER OF THE REFERENCE IMAGES
C       NTOTAL IS NUMBER OF THE SAMPLE IMAGES

        IF (ITYPE .EQ. 1) THEN
C          USE NRQLI FOR 'AP NQ'
           CALL NRQLI(ILIST,NIMA,IRIST,NTOTAL,NSAM,NROW,NSI,
     &          ISTEP,MODE,LCIRC,NUMR,NRING,MAXRIN,NUMTH,REFER_CIRC)

	ELSEIF (NTOTAL .GE. NUMTH)  THEN
C          FOR MP, LARGE NUMBER OF IMAGES TO BE ALIGNED, OR SP.
           CALL MRQLI_PS(ILIST,NIMA,IRIST,NTOTAL,NSAM,NROW,NSI,ISTEP,
     &          MODE,LCIRC,NUMR,NRING,MAXRIN,NUMTH,REFER_CIRC)
	ELSE
C          FOR SMALL NUMBER OF IMAGES TO BE ALIGNED USE DIFFERENT 
C          STRATEGY TO MAKE MP EFFICIENT.
           CALL MRQLI_SS(ILIST,NIMA,IRIST,NTOTAL,NSAM,NROW,NSI,
     &             ISTEP,MODE,LCIRC,NUMR,NRING,MAXRIN,NUMTH,REFER_CIRC)
 	ENDIF

        WRITE (NOUT,2600)
2600    FORMAT (/,' ',72('-'),//,
     &            '  Multi-reference alignment, end of computation',//,
     &            ' ',72('-'),/)

9999    IF (ALLOCATED(IRIST))      DEALLOCATE(IRIST)
        IF (ALLOCATED(ILIST))      DEALLOCATE(ILIST)
        IF (ALLOCATED(NUMR))       DEALLOCATE(NUMR)
        IF (ALLOCATED(REFER_CIRC)) DEALLOCATE(REFER_CIRC)

         RETURN
         END




d41 19
a59 3
        SUBROUTINE MRQLI_PS(ILIST,NIMA,IRIST,NTOTAL,NSAM,NROW,NSI,
     &                ISTEP,MODE,LCIRC,NUMR,NRING,MAXRIN,NUMTH,
     &                REFER_CIRC)
d61 2
a62 1
	INCLUDE 'CMBLOCK.INC'
d64 5
a68 4
	INTEGER, DIMENSION(NIMA) ::       ILIST
	INTEGER, DIMENSION(NTOTAL) ::     IRIST
	INTEGER, DIMENSION(3,NRING) ::    NUMR
	REAL, DIMENSION(LCIRC,NIMA) ::    REFER_CIRC
d70 3
a72 4
C       AUTOMATIC ARRAYS
        PARAMETER (NDLI=7)
        DIMENSION  DLIST(NDLI,NUMTH)
	INTEGER    NASSIG(NUMTH)
d74 1
a74 2
	REAL, ALLOCATABLE, DIMENSION(:,:,:) ::          A
	DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:) ::  TT
d76 2
a77 1
        CHARACTER(LEN=1)  :: MODE
d79 12
a90 2
        CHARACTER*80     FINPAT,FINPIC,FILTOA
        COMMON  /FISPEC/ FINPAT,FINPIC,FILTOA,NLET,NLETI
a91 2
        DATA  NDOC/56/,INPIC/58/

d98 6
a103 8
C       !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
C       ALIGNMENT
C       !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

	ALLOCATE(A(NSAM,NROW,NUMTH),STAT=IRTFLG)
	IF (IRTFLG.NE.0) THEN
            CALL  ERRT(46,'AM MQ, A ',IER)
            RETURN
d105 20
d126 2
a127 14
#ifdef  SP_LIBFFT
	ALLOCATE(TT(MAXRIN+15),STAT=IRTFLG)
	IF (IRTFLG.NE.0) THEN
           CALL  ERRT(46,'AM MQ, TT',IER)
           GOTO 9999
        ENDIF 
	CALL DZFFT1DUI(MAXRIN,TT)
#else
	ALLOCATE(TT(1),STAT=IRTFLG)
	IF (IRTFLG.NE.0) THEN
           CALL ERRT(46,'AM MQ, TT',IER)
           GOTO 9999
        ENDIF 
#endif
d129 7
a135 20
C       LOOP OVER IMAGES TO BE ALIGNED
 	DO  IMIT=1,NTOTAL,NUMTH
	   DO  IMI=IMIT,MIN(NTOTAL,IMIT+NUMTH-1)

	      CALL  FILGET(FILTOA,FINPIC,NLETI,IRIST(IMI),INTFLAG)
	      MAXIM = 0
	      CALL OPFILEC(0,.FALSE.,FINPIC,INPIC,'O',IFORM,NSAMT,NROWT,
     &             NSLICE, MAXIM,' ',.FALSE.,IRTFLG)
              IF (IRTFLG.NE.0) GOTO 9999

              IF (NSAMT.NE.NSAM .OR. NROWT.NE.NROW)  THEN
                 CALL ERRT(1,'AP MQ',NE)
                 CLOSE(INPIC)
	         GOTO 9999
	      ENDIF
	      DO J=1,NROW
	         CALL REDLIN(INPIC,A(1,J,IMI-IMIT+1),NSAM,J)
	      ENDDO
	      CLOSE(INPIC)
	   ENDDO
d139 2
a140 7
	   DO  IMI=IMIT,MIN(NTOTAL,IMIT+NUMTH-1)
	      CALL APMQ2D(A(1,1,IMI-IMIT+1),REFER_CIRC,TT,NUMR,
     &	         NSAM,NROW,NSI,ISTEP,
     &	         NSB,NSE,NRB,NRE,LCIRC,NRING,MAXRIN,NIMA,MODE,
     &	         NASSIG(IMI-IMIT+1),
     &	         DLIST(3,IMI-IMIT+1),DLIST(4,IMI-IMIT+1),
     &	         DLIST(5,IMI-IMIT+1),DLIST(6,IMI-IMIT+1))
d142 6
a147 3
C                OUTPUT PARAMETERS ARE:
C                NUMBER OF THE MOST SIMILAR REFERENCE PROJECTION.
C                CORR COEFF.(D5), ANGLE (D4), SHIFT: XSHSUM, YSHSUM
d154 2
a155 2
C          4 - SX
C          5 - SY
d157 18
d176 2
a177 6
	   DO  IMI=IMIT,MIN(NTOTAL,IMIT+NUMTH-1)
	      DLIST(2,IMI-IMIT+1) =
     &	      ISIGN(ILIST(IABS(NASSIG(IMI-IMIT+1))),NASSIG(IMI-IMIT+1))
              DLIST(7,IMI-IMIT+1) = IRIST(IMI)
              DLIST(1,IMI-IMIT+1) = IMI
              CALL SAVD(NDOC,DLIST(1,IMI-IMIT+1),NDLI,IRTFLG)
a178 1
C---------------------------------------------------------------------
d182 1
a182 2
	CLOSE(NDOC)
        CALL  SAVDC
d184 2
a185 2
C       DEALLOCATE LOCAL ARRAYS
9999    IF (ALLOCATED(TT))         DEALLOCATE(TT)
d187 2
d202 6
a207 3
        SUBROUTINE  MRQLI_SS(ILIST,NIMA,IRIST,NTOTAL,NSAM,NROW,NSI,
     &                ISTEP,MODE,LCIRC,NUMR,NRING,MAXRIN,NUMTH,
     &                REFER_CIRC)
d210 1
d212 9
a220 8
	PARAMETER (QUADPI = 3.141592653589793238462643383279502884197)
	PARAMETER  (DGR_TO_RAD = (QUADPI/180))
        PARAMETER         (NDLI=7)

	INTEGER, DIMENSION(NIMA) ::       ILIST
	INTEGER, DIMENSION(NTOTAL) ::     IRIST
	INTEGER, DIMENSION(3,NRING) ::    NUMR
	REAL, DIMENSION(LCIRC,NIMA) ::    REFER_CIRC
d222 2
a223 1
        DIMENSION         DLIST(NDLI)
d225 1
a225 1
	DOUBLE PRECISION  QT,QM,PEAK
d230 3
a232 3
	DIMENSION         TOT(NIMA,-NSI:NSI,-NSI:NSI),
     &                    TMT(NIMA,-NSI:NSI,-NSI:NSI)
	DOUBLE PRECISION  FIT(-ISTEP:ISTEP,-ISTEP:ISTEP)
d234 12
a245 1
	DIMENSION         WR(NRING)
d247 1
a247 19
	REAL, ALLOCATABLE, DIMENSION(:,:,:) ::          A_CIRC
	REAL, ALLOCATABLE, DIMENSION(:,:,:,:) ::        AA
	REAL, ALLOCATABLE, DIMENSION(:,:) ::            A
	DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:) ::  TT

        CHARACTER*1      MODE
        CHARACTER*80     FINPAT,FINPIC,FILTOA
        COMMON  /FISPEC/ FINPAT,FINPIC,FILTOA,NLET,NLETI

        DATA  NDOC/56/,INPIC/58/

#ifdef SP_LIBFFT
	ALLOCATE(TT(MAXRIN+15),STAT=IRTFLG)
	IF (IRTFLG.NE.0) CALL  ERRT(46,'AM MQ, TT',IER)
	CALL  DZFFT1DUI(MAXRIN,TT)
#else
	ALLOCATE(TT(1),STAT=IRTFLG)
	IF (IRTFLG.NE.0) CALL  ERRT(46,'AM MQ, TT',IER)
#endif
d249 17
d272 60
a331 27
C       !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
C       ALIGNMENT
C       !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

	ALLOCATE(A(NSAM,NROW),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) CALL  ERRT(46,'AM MQ, A',IER)

	NSIS=MAX(NSI/ISTEP,ISTEP)
	ALLOCATE(A_CIRC(LCIRC,-NSIS:NSIS,-NSIS:NSIS),STAT=IRTFLG)
	IF (IRTFLG.NE.0) CALL  ERRT(46,'AP MQ, A_CIRC',IER)

	ALLOCATE(AA(NSAM,NROW,-NSIS:NSIS,-NSIS:NSIS),STAT=IRTFLG)
	IF (IRTFLG.NE.0) CALL  ERRT(46,'AP MQ, AA',IER)

C       IMAGES TO BE ALIGNED
C       LOOP OVER IMAGES TO BE ALIGNED
	DO IMI=1,NTOTAL
           CALL  FILGET(FILTOA,FINPIC,NLETI,IRIST(IMI),INTFLAG)
           MAXIM = 0
           CALL OPFILEC(0,.FALSE.,FINPIC,INPIC,'O',IFORM,
     &             NSAMT,NROWT,NSLICE,MAXIM,' ',.FALSE.,IRTFLG)
           IF (IRTFLG.NE.0) RETURN

           IF (NSAMT.NE.NSAM.OR.NROWT.NE.NROW)  THEN
              CALL ERRT(1,'AP MQ',NE)
              CLOSE(INPIC)
              RETURN
d333 7
a339 4
           DO J=1,NROW
              CALL  REDLIN(INPIC,A(1,J),NSAM,J)
           ENDDO
           CLOSE(INPIC)
d342 1
a342 1
c$omp      parallel do private(jt,it,ir,cnr2,cns2)
d345 1
d353 1
d357 1
d360 21
a380 6
                 DO IR=1,NIMA
	            CALL CROSRNG_MS(REFER_CIRC(1,IR),
     &                 A_CIRC(1,IT/ISTEP,JT/ISTEP),LCIRC,
     &                 NRING,MAXRIN,NUMR,
     &                 TOTA(IR,IT,JT),TOT(IR,IT,JT),
     &                 TMTA(IR,IT,JT),TMT(IR,IT,JT),TT)
d392 13
a404 8
                 DO IR=1,NIMA
                    IF(TOTA(IR,IT,JT).GE.QT)  THEN
	               QT=TOTA(IR,IT,JT)
	               IBE=IR
                       ISX=IT
                       ISY=JT
                       D4=ANG(TOT(IR,IT,JT),MODE)
                       D6=ILIST(IR)
d406 8
a413 7
                    IF (TMTA(IR,IT,JT).GE.QM)  THEN
                       QM=TMTA(IR,IT,JT)
                       IME=IR
                       IMX=IT
                       IMY=JT
                       E4=ANG(TMT(IR,IT,JT),MODE)
                       E6=-ILIST(IR)
d420 3
a422 1
	   IF (QT.GT.QM)  THEN
d424 3
a426 1
              DLIST(2)=D6
d429 1
a429 1
	      IF (IABS(ISX).NE.NSI.AND.IABS(ISY).NE.NSI)  THEN
d434 3
a436 3
	         DO     JT=-ISTEP,ISTEP
	            DO     IT=-ISTEP,ISTEP
	               IF(IT.NE.0 .OR. JT.NE.0) THEN
d439 1
d443 1
d447 1
d449 2
a450 1
	                  CALL CROSRNG_DS(REFER_CIRC(1,IBE),
d453 2
a454 1
	                  ROTMP(IT,JT) = ANG(ROTMP(IT,JT),MODE)
d464 1
a464 1
	         IF (ISTEP.GT.1)  THEN
d467 5
a471 5
	                  IF (FIT(IT,JT).GT.AFIT)  THEN
	                     AFIT=FIT(IT,JT)
	                     D4=ROTMP(IT,JT)
	                     ITMA=IT
	                     JTMA=JT
d476 1
d480 1
a480 1
	               FITP(IT,JT)=FIT(ITMA+IT,JTMA+JT)
d483 1
d485 3
a487 3
	         QT=AFIT
	         ISX=ISX+ITMA
	         ISY=ISY+JTMA
d490 1
d492 6
a497 5
	         IF (ABS(SX).LT.1.0 .AND. ABS(SY).LT.1.0)  THEN
	            SX=SX+ISX
	            SY=SY+ISY
	            CNR2=NROW/2+1+SY
	            CNS2=NSAM/2+1+SX
d500 1
d503 1
d505 2
a506 1
	            CALL CROSRNG_DS(REFER_CIRC(1,IBE),A_CIRC,LCIRC,
d508 3
a510 2
	            D5=QT
	            D4=ANG(D4,MODE)
d513 3
a515 3
	            D5=QT
	            SX=ISX
	            SY=ISY
d518 3
a520 3
	         D5=QT
	         SX=ISX
	         SY=ISY
d524 2
a525 1
              DLIST(2) = E6
d527 1
a527 1
	      IF (IABS(IMX).NE.NSI.AND.IABS(IMY).NE.NSI)  THEN
d529 2
a530 2
	         FIT(0,0)=QM
	         ROTMP(0,0)=E4
d532 6
a537 5
	         DO     JT=-ISTEP,ISTEP
	            DO     IT=-ISTEP,ISTEP
	               IF(IT.NE.0 .OR. JT.NE.0) THEN
	                 CNR2=NROW/2+1+JT+IMY
	                 CNS2=NSAM/2+1+IT+IMX
d539 4
a542 3
     &	                 NSB-(IT+IMX),NSE-(IT+IMX),NRB-(JT+IMY),
     &                   NRE-(JT+IMY), NUMR,NUMR(1,NRING))
	                 CALL  ALRQ_MS
d545 5
a549 3
	                 CALL  FRNGS(A_CIRC(1,IT,JT),LCIRC,NUMR,NRING)
	                 CALL  CROSRMG_DS
     &		         (REFER_CIRC(1,IME),A_CIRC(1,IT,JT),LCIRC,NRING,
d551 2
a552 1
	                 ROTMP(IT,JT)=ANG(ROTMP(IT,JT),MODE)
d566 4
a569 4
	                     AFIT=FIT(IT,JT)
	                     E4 = ROTMP(IT,JT)
	                     ITMA=IT
	                     JTMA=JT
d574 1
d578 1
a578 1
	               FITP(IT,JT)=FIT(ITMA+IT,JTMA+JT)
d583 3
a585 3
	         QM=AFIT
	         IMX=IMX+ITMA
	         IMY=IMY+JTMA
d587 2
a588 1
	         CALL  PARABLD(FITP,SX,SY,PEAK)
d591 2
a592 2
	            SX   = SX+IMX
	            SY   = SY+IMY
d597 1
d600 1
d602 2
a603 1
	            CALL CROSRMG_DS (REFER_CIRC(1,IME),A_CIRC,LCIRC,
d605 1
d607 1
a607 1
	            D4 = ANG(D4,MODE)
d618 2
a619 2
	         D4 = E4
	         D5 = QM
d625 1
d641 1
d646 1
a646 1
           DLIST(7) = IRIST(IMI)
a647 1
           CALL SAVD(NDOC,DLIST,NDLI,IRTFLG)
d649 1
a649 1
C---------------------------------------------------------------------
d651 2
a652 2
	CLOSE(NDOC)
        CALL  SAVDC
d657 3
a659 1
	IF (ALLOCATED(TT))         DEALLOCATE(TT)
d662 1
a662 3


C++************************************************************************
d664 5
a668 1
C APMQ2D.F
d670 1
a670 1
C--************************************************************************
d672 5
a676 4
	SUBROUTINE APMQ2D(A,REFER_CIRC,TT,NUMR,
     &	     NSAM,NROW,NSI,ISTEP,
     &	     NSB,NSE,NRB,NRE,LCIRC,NRING,MAXRIN,NIMA,MODE,
     &	     IDI,D5,D4,XSHSUM,YSHSUM)
d678 1
a678 2
	PARAMETER (QUADPI = 3.141592653589793238462643383279502884197)
	PARAMETER (DGR_TO_RAD = (QUADPI/180))
a679 1
	DIMENSION  A(NSAM,NROW),REFER_CIRC(LCIRC,NIMA),NUMR(3,NRING)
d681 5
a685 2
	DOUBLE PRECISION  TT(*)
        CHARACTER*1       MODE
d690 43
a732 8
	DOUBLE PRECISION  QT,QM,PEAK
	DOUBLE PRECISION  TOTA,TMTA
	REAL, ALLOCATABLE, DIMENSION(:) ::  A_CIRC

	ALLOCATE(A_CIRC(LCIRC),STAT=IRTFLG)
	IF (IRTFLG.NE.0) THEN
           CALL  ERRT(46,'AP MQ, A_CIRC',IER)
           RETURN
d735 1
d738 1
d746 1
d758 24
a781 4
	      DO IR=1,NIMA
	         CALL CROSRNG_MS (REFER_CIRC(1,IR),A_CIRC,LCIRC,NRING,
     &		        MAXRIN,NUMR,TOTA,TOT,TMTA,TMT,TT)
	         IF (TOTA.GE.QT)  THEN
d786 1
a786 1
	            D4   = ANG(TOT,MODE)
d788 1
d790 1
a790 8
	         IF (TMTA.GE.QM)  THEN
	            QM   = TMTA
	            IME  = IR
	            IMX  = IT
	            IMY  = JT
	            E4   =  ANG(TMT,MODE)
	            IDIM = -IR
	         ENDIF
d792 1
a792 1
C             END-OF-LOOP OVER REFERENCE IMAGES
d796 4
a799 2
C       TRY TO INTERPOLATE
	IF (QT .GT. QM)  THEN
d801 2
a802 1
           IDI=IDIS
d813 1
d817 1
d820 1
d822 2
a823 2
	               CALL CROSRNG_DS
     &		            (REFER_CIRC(1,IBE),A_CIRC,LCIRC,NRING,
d825 3
a827 1
	                    ROTMP(IT,JT)=ANG(ROTMP(IT,JT),MODE)
d840 1
a840 1
	               IF (FIT(IT,JT).GT.AFIT)  THEN
d849 1
d853 1
a853 1
	            FITP(IT,JT)=FIT(ITMA+IT,JTMA+JT)
d858 1
a858 1
	      QT = AFIT
d861 1
a862 1
	      CALL  PARABLD(FITP,SX,SY,PEAK)
d869 1
d872 1
d875 1
d877 2
a878 1
	         CALL CROSRNG_DS(REFER_CIRC(1,IBE),A_CIRC,LCIRC,NRING,
d881 1
a881 1
	         D4 = ANG(D4,MODE)
d893 1
d895 2
a896 1
           IDI = IDIM
d898 1
a898 1
	   IF(IABS(IMX).NE.NSI.AND.IABS(IMY).NE.NSI)  THEN
d900 7
a906 7
	      FIT(0,0)=QM
	      ROTMP(0,0)=E4
	      DO     JT=-ISTEP,ISTEP
	         DO     IT=-ISTEP,ISTEP
	            IF(IT.NE.0 .OR. JT.NE.0) THEN
	               CNR2=NROW/2+1+JT+IMY
	               CNS2=NSAM/2+1+IT+IMX
d910 2
a911 1
	               CALL  ALRQ_MS(A,NSAM,NROW,CNS2,CNR2,NUMR,
d913 4
a916 2
	               CALL  FRNGS(A_CIRC,LCIRC,NUMR,NRING)
	               CALL  CROSRMG_DS(REFER_CIRC(1,IME),A_CIRC,
d919 3
a921 1
	               ROTMP(IT,JT)=ANG(ROTMP(IT,JT),MODE)
d928 3
a930 3
	      AFIT=FIT(0,0)
	      JTMA=0
	      ITMA=0
d934 5
a938 5
	               IF (FIT(IT,JT).GT.AFIT)  THEN
	                  AFIT=FIT(IT,JT)
	                  E4=ROTMP(IT,JT)
	                  ITMA=IT
	                  JTMA=JT
d943 1
d947 1
a947 1
	            FITP(IT,JT)=FIT(ITMA+IT,JTMA+JT)
d950 1
d952 4
a955 3
	      QM=AFIT
	      IMX=IMX+ITMA
	      IMY=IMY+JTMA
a956 1
	      CALL  PARABLD(FITP,SX,SY,PEAK)
d963 1
d966 1
d969 1
d971 2
a972 1
	         CALL CROSRMG_DS(REFER_CIRC(1,IME),A_CIRC,LCIRC,NRING,
d975 2
a976 1
	         D4 = ANG(D4,MODE)
d984 1
d995 2
a996 1
C       NOW HAVE TO CHANGE ORDER OF SHIFT&ROTATION.
d1004 3
a1007 1
9999    DEALLOCATE(A_CIRC)
d1009 33
@


1.60
log
@savd key changed to image number from consecutive
@
text
@a7 1
C                   KEY NUMBER CHANGED            JUL 03 ARDEAN LEITH
d17 1
a17 1

d352 4
a358 3
     &	         NASSIG(IMI-IMIT+1),
     &	         DLIST(3,IMI-IMIT+1),DLIST(4,IMI-IMIT+1),
     &	         DLIST(5,IMI-IMIT+1),DLIST(6,IMI-IMIT+1))
d373 1
a373 2
C             DLIST(1,IMI-IMIT+1) = IMI
              DLIST(1,IMI-IMIT+1) = IRIST(IMI)
d737 1
a737 2
C          DLIST(1) = IMI
           DLIST(1) = IRIST(IMI)
@


1.59
log
@opfilec
@
text
@d8 1
d370 1
a370 1
	      DLIST(2,IMI-IMIT+1)=
d372 3
a374 2
              DLIST(7,IMI-IMIT+1)=IRIST(IMI)
              DLIST(1,IMI-IMIT+1)=IMI
d629 1
a629 1
              DLIST(2)=E6
d658 4
a661 4
	        AFIT=FIT(0,0)
	        JTMA=0
	        ITMA=0
	        IF (ISTEP.GT.1)  THEN
d664 1
a664 1
	                  IF (FIT(IT,JT).GT.AFIT)  THEN
d666 1
a666 1
	                     E4=ROTMP(IT,JT)
d688 4
a691 4
	            SX=SX+IMX
	            SY=SY+IMY
	            CNR2=NROW/2+1+SY
	            CNS2=NSAM/2+1+SX
d699 2
a700 2
	            D5=QM
	            D4=ANG(D4,MODE)
d703 4
a706 4
	            SX=IMX
	            SY=IMY
	            D4=E4
	            D5=QM
d709 4
a712 4
	         SX=IMX
	         SY=IMY
	         D4=E4
	         D5=QM
d716 2
a717 2
	   SX=-SX
	   SY=-SY
d722 4
a725 4
	   CO=COS(D4*DGR_TO_RAD)
	   SO=-SIN(D4*DGR_TO_RAD)
	   XSHSUM=SX*CO-SY*SO
	   YSHSUM=SX*SO+SY*CO
d733 8
a740 7
           DLIST(3)=D5
           DLIST(4)=D4
           DLIST(5)=XSHSUM
           DLIST(6)=YSHSUM
           DLIST(7)=IRIST(IMI)
           DLIST(1)=IMI
           CALL  SAVD(NDOC,DLIST,NDLI,IRTFLG)
@


1.58
log
@unused AI removed
@
text
@d7 1
d96 1
a96 1
	CALL OPFILE(.FALSE.,FINPIC,INPIC,'O',IFORM,NSAM,NROW,NSLICE,
d162 1
a162 1
	   CALL OPFILE(.TRUE.,FILREF,LUNREF,'O',IFORM,LCIRCT,NIMAT,
d182 1
a182 1
	   CALL OPFILE(.TRUE.,FILREF,LUNREF,'N',IFORM,LCIRC,NIMA,
d331 1
a331 1
	      CALL OPFILE(.FALSE.,FINPIC,INPIC,'O',IFORM,NSAMT,NROWT,
d471 1
a471 1
           CALL OPFILE(.FALSE.,FINPIC,INPIC,'O',IFORM,
@


1.57
log
@numth wrong
@
text
@a427 1
	REAL, ALLOCATABLE, DIMENSION(:,:,:) ::          AI
@


1.56
log
@comment changed
@
text
@d156 1
a156 1
        WRITE(NOUT,*) ' NUMBER OF OMP THREADS: ',I3
@


1.55
log
@nloop,iloop_removed
@
text
@d206 1
a206 1
C       ALLOCATE SPACE FOR REFERENCE IMAGE FILE LIST
@


1.54
log
@*** empty log message ***
@
text
@d100 1
a100 1
	CALL RDPRMI(NSI,ISTEP,NLOOP,ILOOP,
d105 1
a105 1
        CALL  RDPRMI(MR,NR,NLOOP,ILOOP,'FIRST AND LAST RING')
@


1.53
log
@prompts changed (again)
@
text
@d220 1
a220 1
2002       FORMAT(' Number of sample images: ',I6/)
d222 1
a222 1
           CALL ERRT(101,'No sample images!',IDUM)
@


1.52
log
@unchanged
@
text
@d6 1
d81 1
a81 1
     &      'ENTER TEMPLATE FOR 2-D REFERENCE IMAGES',IRTFLG)
d215 1
a215 1
     &     'ENTER TEMPLATE FOR 2-D EXPERIMENTAL PROJECTIONS',IRTFLG)
@


1.51
log
@normass --> normas
@
text
@d785 1
a785 1
c       GO THROUGH CENTERS
a791 1

d794 2
d798 2
d801 2
a802 1
C             LOOP OVER REFERENCE IMAGES
d823 1
a823 1
C             END-OF-LOOP 1 OVER REFERENCE IMAGES
@


1.50
log
@echos number of threads
@
text
@d3 3
a5 2
C    MRQLI.F                           USED CMLIMIT AUG 00 ARDEAN LEITH
C                               ADDED REF_CIRC FILE APR 01 ARDEAN LEITH
d22 1
a22 1
C  USES:
d28 1
a28 1
C     NORMASS(X,NS1,NS2,NR1,NR2,IR1,IR2)
d80 1
a80 1
     &      'ENTER TEMPLATE FOR 2-D REFERENCE IMAGE NAME',IRTFLG)
d99 2
a100 1
	CALL RDPRMI(NSI,ISTEP,NLOOP,ILOOP,'SEARCH RANGE, STEP SIZE')
d214 1
a214 1
     &      'ENTER TEMPLATE FOR 2-D IMAGES TO BE ALIGNED',IRTFLG)
d244 1
a244 1
9998    WRITE (NOUT,2600)
d793 1
a793 1
	      CALL NORMASS(A,NSB-IT,NSE-IT,NRB-JT,NRE-JT,NUMR,
d837 1
a837 1
	               CALL NORMASS(A, NSB-(IT+ISX),NSE-(IT+ISX),
d887 1
a887 1
	         CALL NORMASS(A,NSB-ISX,NSE-ISX,NRB-ISY,NRE-ISY,
d919 1
a919 1
	               CALL NORMASS(A,NSB-(IT+IMX),NSE-(IT+IMX),
d968 1
a968 1
	         CALL NORMASS(A,NSB-IMX,NSE-IMX,NRB-IMY,NRE-IMY,
@


1.49
log
@ref rings file support
@
text
@d153 1
@


1.48
log
@comments & cosmetic
@
text
@d4 1
d6 28
a33 22
C **************************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
C *  COPYRIGHT (C)1981,1987, WADSWORTH CENTER FOR LABORATORIES AND         *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *  THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR       *
C *  LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR    *
C *  USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF     *
C *  THE CENTER FOR LABORATORIES AND RESEARCH                              *
C **************************************************************************
C
C  MRQLI
C  MRQLI_SS(ILIST,NIMA,IRIST,NTOTAL,NSAM,NROW,NSI,
C  MRQLI_PS(ILIST,NIMA,IRIST,NTOTAL,NSAM,NROW,NSI,
C  APMQ2D(A,REFER_CIRC,TT,NUMR,
C  NORMASC(X,Y,NS1,NS2,NR1,NR2,IR1,IR2)
C  NORMASS(X,NS1,NS2,NR1,NR2,IR1,IR2)
C  ALRQ_MS
C  CROSRNG_MS
C  CROSRMG_DS
C  FRNGS
C  APPLYWS
C  ALRQS
d49 1
a49 1
	SUBROUTINE MRQLI
d60 2
a61 1
	CHARACTER*1  MODE
d63 3
a65 1
	INTEGER, ALLOCATABLE, DIMENSION(:) ::   ILIST,IRIST
d67 1
a67 1
	DATA  INPIC/77/
d69 1
d84 1
a84 1
2001       FORMAT(' Number of reference images =',I5)
d90 1
a90 1
C       GET FIRST PICTURE TO DETERMINE DIMS
d139 2
d144 59
d204 1
a204 1
	IF (IRTFLG.NE.0) THEN
d213 1
d216 1
a216 1
2002       FORMAT(' Number of sample images =',I5)
d222 2
a223 1
        CALL GETTHREADS(NUMTH)
d225 4
a228 1
C       NIMA NUMBER OF THE REFERENCE IMAGES
d230 1
a230 1
	IF (NTOTAL .GE. NUMTH)  THEN
d232 2
a233 2
           CALL  MRQLI_PS(ILIST,NIMA,IRIST,NTOTAL,NSAM,NROW,NSI,
     &          ISTEP,MODE,LCIRC,NUMR,NRING,MAXRIN,NUMTH)
d237 13
a249 3
           CALL  MRQLI_SS(ILIST,NIMA,IRIST,NTOTAL,NSAM,NROW,NSI,
     &          ISTEP,MODE,LCIRC,NUMR,NRING,MAXRIN,NUMTH)
	ENDIF
a250 9
9999    IF (ALLOCATED(IRIST)) DEALLOCATE(IRIST)
        IF (ALLOCATED(ILIST)) DEALLOCATE(ILIST)
        IF (ALLOCATED(NUMR))  DEALLOCATE(NUMR)

         WRITE (NOUT,2600)
2600     FORMAT (/,' ',72('-'),//,
     &      ' ',' Multi-reference alignment, end of computation',//,
     &      ' ',72('-'),/)

d255 129
d388 2
a389 9
C **************************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
C *  COPYRIGHT (C)1981,1987, WADSWORTH CENTER FOR LABORATORIES AND         *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *  THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR       *
C *  LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR    *
C *  USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF     *
C *  THE CENTER FOR LABORATORIES AND RESEARCH                              *
C **************************************************************************
a390 3
C  THIS IS VERSION FOR MP AND A SMALL NUMBER OF IMAGES TO BE ALIGNED
C
C23456789012345678901234567890123456789012345678901234567890123456789012
d394 2
a395 1
     &                ISTEP,MODE,LCIRC,NUMR,NRING,MAXRIN,NUMTH)
d398 1
d400 9
a408 5
	PARAMETER (DGR_TO_RAD = (QUADPI/180))
        PARAMETER (NDLI=7)
        DIMENSION  ILIST(NIMA),IRIST(NTOTAL)
        DIMENSION DLIST(NDLI)
        INTEGER    NUMR(3,NRING),MAXRIN
d412 1
a412 1
C       Automatic arrays
d415 2
a416 2
	DIMENSION  TOT(NIMA,-NSI:NSI,-NSI:NSI),
     &             TMT(NIMA,-NSI:NSI,-NSI:NSI)
d418 7
a424 7
	DIMENSION  ROTMP(-ISTEP:ISTEP,-ISTEP:ISTEP)
	DIMENSION  WR(NRING)
	REAL, ALLOCATABLE, DIMENSION(:,:,:) ::  A_CIRC
	REAL, ALLOCATABLE, DIMENSION(:,:,:,:) ::  AA
	REAL, ALLOCATABLE, DIMENSION(:,:) ::  A
	REAL, ALLOCATABLE, DIMENSION(:,:,:) ::  AI
	REAL, ALLOCATABLE, DIMENSION(:,:) ::  REFER_CIRC
d427 3
a429 3
        CHARACTER*1  MODE
        COMMON  /FISPEC/  FINPAT,FINPIC,FILTOA,NLET,NLETI
        CHARACTER*80  FINPAT,FINPIC,FILTOA
a432 3
	ALLOCATE(REFER_CIRC(LCIRC,NIMA),STAT=IRTFLG)
	IF (IRTFLG.NE.0) CALL  ERRT(46,'AM MQ, REFER_CIRC',IER)

d435 1
a435 1
	IF(IRTFLG.NE.0) CALL  ERRT(46,'AM MQ, TT',IER)
d439 1
a439 1
	IF(IRTFLG.NE.0) CALL  ERRT(46,'AM MQ, TT',IER)
a440 1
	CALL  RINGWE(WR,NUMR,NRING,MAXRIN)
a441 6
	ALLOCATE(AI(NSAM,NROW,NUMTH),STAT=IRTFLG)
	IF(IRTFLG.NE.0) CALL  ERRT(46,'AM MQ, AI',IER)

	NSNR=NSAM*NROW
	LO=2*NSI+1
	LT=LO*LO
d448 3
a450 17
C       PREPARE REFERENCES

C       do it for all the reference images
	DO    IMIT=1,NIMA,NUMTH
	   DO  IMI=IMIT,MIN(NIMA,IMIT+NUMTH-1)
	      CALL  FILGET(FINPAT,FINPIC,NLET,ILIST(IMI),INTFLAG)
	      MAXIM = 0
	      CALL OPFILE(.FALSE.,FINPIC,INPIC,'O',IFORM,NSAMT,NROWT,
     &                   NSLICE, MAXIM,' ',.FALSE.,IRTFLG)
              IF (IRTFLG.NE.0)  RETURN
	      DO    J=1,NROW
	         CALL  REDLIN(INPIC,AI(1,J,IMI-IMIT+1),NSAM,J)
	      ENDDO
	      CLOSE(INPIC)
	   ENDDO

C          NORMALIZE UNDER THE MASK
a451 12
c$omp parallel do private(IMI)
	   DO  IMI=IMIT,MIN(NIMA,IMIT+NUMTH-1)
	      CALL NORMASS(AI(1,1,IMI-IMIT+1),NSB,NSE,NRB,NRE,NUMR,
     &		NUMR(1,NRING))
	      CALL  ALRQS(AI(1,1,IMI-IMIT+1),NSAM,NROW,NUMR,
     &          REFER_CIRC(1,IMI), LCIRC,NRING,MODE)
	      CALL  FRNGS(REFER_CIRC(1,IMI),LCIRC,NUMR,NRING)
	     CALL  APPLYWS(REFER_CIRC(1,IMI),LCIRC,NUMR,WR,NRING,MAXRIN)
	   ENDDO
	ENDDO

	DEALLOCATE(AI)
d453 1
a453 2
	IF(IRTFLG.NE.0) CALL  ERRT(46,'AM MQ, A',IER)

a454 3
C!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
C  alignment
C!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
d464 1
a464 1
	DO    IMI=1,NTOTAL
d482 2
a483 2
c$omp parallel do private(jt,it,ir,cnr2,cns2)
           DO    JT=-NSI,NSI,ISTEP
d485 1
a485 1
              DO    IT=-NSI,NSI,ISTEP
d491 12
a502 12
     &             NSB-IT,NSE-IT,NRB-JT,NRE-JT,NUMR,NUMR(1,NRING))
                 CALL  ALRQ_MS
     &             (AA(1,1,IT/ISTEP,JT/ISTEP),NSAM,NROW,CNS2,CNR2,NUMR,
     &              A_CIRC(1,IT/ISTEP,JT/ISTEP),LCIRC,NRING,MODE)
	         CALL  FRNGS(A_CIRC(1,IT/ISTEP,JT/ISTEP),LCIRC,
     &              NUMR,NRING)
                 DO    IR=1,NIMA
	            CALL  CROSRNG_MS
     &             (REFER_CIRC(1,IR),A_CIRC(1,IT/ISTEP,JT/ISTEP),LCIRC,
     &              NRING,MAXRIN,NUMR,
     &              TOTA(IR,IT,JT),TOT(IR,IT,JT),
     &              TMTA(IR,IT,JT),TMT(IR,IT,JT),TT)
d507 2
a508 2
C          end of the parallel section
C          Locate best match
d512 3
a514 3
           DO    JT=-NSI,NSI,ISTEP
              DO    IT=-NSI,NSI,ISTEP
                 DO    IR=1,NIMA
d523 1
a523 1
                    IF(TMTA(IR,IT,JT).GE.QM)  THEN
d536 2
a537 2
	   IF(QT.GT.QM)  THEN
C             For not-mirrored
d539 1
a539 1
C             Do not interpolate for point on the edge
d541 1
a541 1
	      IF(IABS(ISX).NE.NSI.AND.IABS(ISY).NE.NSI)  THEN
d545 1
a545 1
c$omp parallel do private(jt,it,cnr2,cns2)
d552 2
a553 2
     &	NSB-(IT+ISX),NSE-(IT+ISX),NRB-(JT+ISY),NRE-(JT+ISY),
     &	NUMR,NUMR(1,NRING))
d555 7
a561 7
     &      (AA(1,1,IT,JT),NSAM,NROW,CNS2,CNR2,NUMR,
     &      A_CIRC(1,IT,JT),LCIRC,NRING,MODE)
	    CALL  FRNGS(A_CIRC(1,IT,JT),LCIRC,NUMR,NRING)
	                  CALL  CROSRNG_DS
     &		(REFER_CIRC(1,IBE),A_CIRC(1,IT,JT),LCIRC,NRING,
     &		MAXRIN,NUMR,FIT(IT,JT),ROTMP(IT,JT),TT)
	                  ROTMP(IT,JT)=ANG(ROTMP(IT,JT),MODE)
d571 4
a574 4
	         IF(ISTEP.GT.1)  THEN
	            DO     JT=-ISTEP+1,ISTEP-1
	               DO     IT=-ISTEP+1,ISTEP-1
	                  IF(FIT(IT,JT).GT.AFIT)  THEN
d583 3
a585 3
C                Copy values around the peak.
	         DO     JT=-1,1
	            DO     IT=-1,1
d594 1
a594 1
	         CALL  PARABLD(FITP,SX,SY,PEAK)
d603 2
a604 2
	            CALL  ALRQ_M
     &              (A,NSAM,NROW,CNS2,CNR2,NUMR,A_CIRC,LCIRC,NRING,MODE)
d606 2
a607 3
	            CALL CROSRNG_DS
     &		       (REFER_CIRC(1,IBE),A_CIRC,LCIRC,NRING,
     &		    MAXRIN,NUMR,QT,D4,TT)
d625 1
a625 1
	      IF(IABS(IMX).NE.NSI.AND.IABS(IMY).NE.NSI)  THEN
d629 1
a629 1
c$omp parallel do private(jt,it,cnr2,cns2)
d644 1
a644 1
     &		         MAXRIN,NUMR,FIT(IT,JT),ROTMP(IT,JT),TT)
d739 5
a743 5
	DEALLOCATE(AA)
	DEALLOCATE(A_CIRC)
	DEALLOCATE(A)
	DEALLOCATE(TT)
	DEALLOCATE(REFER_CIRC)
d747 1
d750 1
a750 11
C  MRQLI_PS.F 
C
C **************************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
C *  COPYRIGHT (C)1981,1987, WADSWORTH CENTER FOR LABORATORIES AND         *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *  THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR       *
C *  LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR    *
C *  USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF     *
C *  THE CENTER FOR LABORATORIES AND RESEARCH                              *
C **************************************************************************
a751 2
C
C23456789012345678901234567890123456789012345678901234567890123456789012
d754 1
a754 153
        SUBROUTINE  MRQLI_PS(ILIST,NIMA,IRIST,NTOTAL,NSAM,NROW,NSI,
     &                ISTEP,MODE,LCIRC,NUMR,NRING,MAXRIN,NUMTH)

	INCLUDE 'CMBLOCK.INC'
        DIMENSION  ILIST(NIMA),IRIST(NTOTAL)
        INTEGER    NUMR(3,NRING),MAXRIN

C       AUTOMATIC ARRAYS
        PARAMETER (NDLI=7)
        DIMENSION  DLIST(NDLI,NUMTH)
	DIMENSION  WR(NRING)
	INTEGER    NASSIG(NUMTH)
	REAL, ALLOCATABLE, DIMENSION(:,:,:) ::  A
	REAL, ALLOCATABLE, DIMENSION(:,:) ::    REFER_CIRC
	DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:) ::  TT

        CHARACTER*1  MODE
        COMMON  /FISPEC/  FINPAT,FINPIC,FILTOA,NLET,NLETI
        CHARACTER*80  FINPAT,FINPIC,FILTOA
        DATA  NDOC/56/,INPIC/58/

	ALLOCATE(A(NSAM,NROW,NUMTH),REFER_CIRC(LCIRC,NIMA),STAT=IRTFLG)
	IF (IRTFLG.NE.0) THEN
            CALL  ERRT(46,'AM MQ, A & REFER_CIRC',IER)
            RETURN
        ENDIF 

#ifdef SP_LIBFFT
	ALLOCATE(TT(MAXRIN+15),STAT=IRTFLG)
	IF (IRTFLG.NE.0) THEN
            CALL  ERRT(46,'AM MQ, TT',IER)
            RETURN
        ENDIF 
	CALL  DZFFT1DUI(MAXRIN,TT)
#else
	ALLOCATE(TT(1),STAT=IRTFLG)
	IF(IRTFLG.NE.0) THEN
            CALL  ERRT(46,'AM MQ, TT',IER)
            RETURN
        ENDIF 
#endif
	CALL  RINGWE(WR,NUMR,NRING,MAXRIN)

	NSNR = NSAM*NROW
	LO   = 2*NSI+1
	LT   = LO*LO

C       CALCULATE DIMENSIONS FOR NORMAS
	NSB  = -NSAM/2
	NSE  = -NSB-1+MOD(NSAM,2)
	NRB  = -NROW/2
	NRE  = -NRB-1+MOD(NROW,2)

C       PREPARE REFERENCES
C       DO IT FOR ALL THE REFERENCE IMAGES
	DO  IMIT=1,NIMA,NUMTH
	   DO  IMI=IMIT,MIN(NIMA,IMIT+NUMTH-1)
	      CALL FILGET(FINPAT,FINPIC,NLET,ILIST(IMI),INTFLAG)
	      MAXIM = 0
	      CALL OPFILE(.FALSE.,FINPIC,INPIC,'O',IFORM,NSAMT,NROWT,
     &             NSLICE, MAXIM,' ',.FALSE.,IRTFLG)
              IF (IRTFLG .NE. 0)  GOTO 9999

	      DO J=1,NROW
	         CALL REDLIN(INPIC,A(1,J,IMI-IMIT+1),NSAM,J)
	      ENDDO
	      CLOSE(INPIC)
	   ENDDO

C          NORMALIZE UNDER THE MASK

c$omp      parallel do private(IMI)
	   DO  IMI=IMIT,MIN(NIMA,IMIT+NUMTH-1)
	      CALL NORMASS(A(1,1,IMI-IMIT+1),NSB,NSE,NRB,NRE,
     &                 NUMR,NUMR(1,NRING))
	      CALL ALRQS(A(1,1,IMI-IMIT+1),NSAM,NROW,NUMR,
     &              REFER_CIRC(1,IMI), LCIRC,NRING,MODE)
	      CALL FRNGS(REFER_CIRC(1,IMI),LCIRC,NUMR,NRING)
	      CALL APPLYWS(REFER_CIRC(1,IMI),LCIRC,NUMR,WR,NRING,MAXRIN)
	   ENDDO
	ENDDO

C!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
C  ALIGNMENT
C!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

C       LOOP OVER IMAGES TO BE ALIGNED
 	DO  IMIT=1,NTOTAL,NUMTH
	   DO  IMI=IMIT,MIN(NTOTAL,IMIT+NUMTH-1)

	      CALL  FILGET(FILTOA,FINPIC,NLETI,IRIST(IMI),INTFLAG)
	      MAXIM = 0
	      CALL OPFILE(.FALSE.,FINPIC,INPIC,'O',IFORM,NSAMT,NROWT,
     &             NSLICE, MAXIM,' ',.FALSE.,IRTFLG)
              IF (IRTFLG.NE.0)  GOTO 9999

              IF (NSAMT.NE.NSAM.OR.NROWT.NE.NROW)  THEN
                 CALL ERRT(1,'AP MQ',NE)
                 CLOSE(INPIC)
	         GOTO 9999
	      ENDIF
	      DO J=1,NROW
	         CALL  REDLIN(INPIC,A(1,J,IMI-IMIT+1),NSAM,J)
	      ENDDO
	      CLOSE(INPIC)
	   ENDDO

C          NUMTH INPUT IMAGES READY TO BE ALIGNED
c$omp      parallel do private(IMI)
	   DO  IMI=IMIT,MIN(NTOTAL,IMIT+NUMTH-1)
	      CALL APMQ2D(A(1,1,IMI-IMIT+1),REFER_CIRC,TT,NUMR,
     &	         NSAM,NROW,NSI,ISTEP,
     &	         NSB,NSE,NRB,NRE,LCIRC,NRING,MAXRIN,NIMA,MODE,
C             OUTPUT PARAMETERS ARE:
C             NUMBER OF THE MOST SIMILAR REFERENCE PROJECTION.
C             CORR COEFF.(D5), ANGLE (D4), SHIFT: XSHSUM, YSHSUM
     &	      NASSIG(IMI-IMIT+1),
     &	      DLIST(3,IMI-IMIT+1),DLIST(4,IMI-IMIT+1),
     &	      DLIST(5,IMI-IMIT+1),DLIST(6,IMI-IMIT+1))
	   ENDDO

C          OUTPUT (IN DLIST POSITION IS INCREASED BY 1, NO.1 IS THE KEY).
C          1 - NUMBER OF THE MOST SIMILAR REFERENCE PROJECTION.
C          2 - NOT-NORMALIZED CORRELATION COEFFICIENT.
C          3 - PSI ANGLE. (IN=PLANE ROTATION)
C          4 - SX
C          5 - SY
C          6 - INPUT IMAGE NUMBER.

	   DO  IMI=IMIT,MIN(NTOTAL,IMIT+NUMTH-1)
	      DLIST(2,IMI-IMIT+1)=
     &	       ISIGN(ILIST(IABS(NASSIG(IMI-IMIT+1))),NASSIG(IMI-IMIT+1))
              DLIST(7,IMI-IMIT+1)=IRIST(IMI)
              DLIST(1,IMI-IMIT+1)=IMI
              CALL SAVD(NDOC,DLIST(1,IMI-IMIT+1),NDLI,IRTFLG)
	   ENDDO
C---------------------------------------------------------------------
	ENDDO

C       OVER AND OUT
	CLOSE(NDOC)
        CALL  SAVDC

C       DEALLOCATE LOCAL ARRAYS
9999    IF (ALLOCATED(TT))         DEALLOCATE(TT)
	IF (ALLOCATED(REFER_CIRC)) DEALLOCATE(REFER_CIRC)
	IF (ALLOCATED(A))          DEALLOCATE(A)
	END


C       --------------------- APMQ2D ----------------------------------

	SUBROUTINE  APMQ2D(A,REFER_CIRC,TT,NUMR,
d761 1
d767 1
a767 1
C       Automatic arrays
@


1.47
log
@comments on memory usage
@
text
@d31 4
a34 4
C        NUMBER OF RINGS AND THEIR RADIUS.  NIMA IS NUMBER OF IMAGES.
C        BIGGEST ARRAY ALLOCATED IS REFER_CIRC(LCIRC,NIMA)
C        ANOTHER LARGE ARRAY IS: A(NSAM,NROW,NUMTH)
C        FOR 83 IMAGES of 125x125 with rings at 5...47 SIZE=45MB
a36 1
C
d66 1
a66 1
C       ASK FOR DATA FILE
d73 1
a73 1
2001       FORMAT(' Number of images =',I5)
d75 1
a75 1
           CALL ERRT(101,'No images!',IDUM)
d137 1
a137 1
C       IMAGES TO BE ALIGNED
d141 7
d191 1
a191 1
C  This is version for mp and a small number of images to be aligned
d403 2
a404 2
C  Find the maximum within +/-ISTEP
C  Maximum cannot be on the edge, i.e., IT,JT/=ISTEP
d426 1
a426 1
C                Update location of the peak
d430 1
a430 1
C
d432 2
a433 2
C CHECK WHETHER INTERPOLATION IS OK.
	         IF(ABS(SX).LT.1.0 .AND. ABS(SY).LT.1.0)  THEN
d438 2
a439 1
	CALL NORMAS(A,NSB-ISX,NSE-ISX,NRB-ISY,NRE-ISY,NUMR,NUMR(1,NRING))
d441 4
a444 4
     &           (A,NSAM,NROW,CNS2,CNR2,NUMR,A_CIRC,LCIRC,NRING,MODE)
	            CALL  FRNG(A_CIRC,LCIRC,NUMR,NRING)
	            CALL  CROSRNG_DS
     &		    (REFER_CIRC(1,IBE),A_CIRC,LCIRC,NRING,
d449 6
a454 1
C                INTERPOLATION FAILED
d458 1
a458 6
	      ENDIF
	   ELSE
	      D5=QT
	      SX=ISX
	      SY=ISY
           ENDIF
d463 4
a466 4
	 IF(IABS(IMX).NE.NSI.AND.IABS(IMY).NE.NSI)  THEN
C             HAVE TO FIND NEIGHBOURING VALUES
	      FIT(0,0)=QM
	      ROTMP(0,0)=E4
d468 16
a483 16
	      DO     JT=-ISTEP,ISTEP
	         DO     IT=-ISTEP,ISTEP
	            IF(IT.NE.0 .OR. JT.NE.0) THEN
	              CNR2=NROW/2+1+JT+IMY
	              CNS2=NSAM/2+1+IT+IMX
	              CALL NORMASC(A,AA(1,1,IT,JT),
     &	NSB-(IT+IMX),NSE-(IT+IMX),NRB-(JT+IMY),NRE-(JT+IMY),
     &	NUMR,NUMR(1,NRING))
	              CALL  ALRQ_MS
     &   (AA(1,1,IT,JT),NSAM,NROW,CNS2,CNR2,NUMR,
     &   A_CIRC(1,IT,JT),LCIRC,NRING,MODE)
	              CALL  FRNGS(A_CIRC(1,IT,JT),LCIRC,NUMR,NRING)
	              CALL  CROSRMG_DS
     &		(REFER_CIRC(1,IME),A_CIRC(1,IT,JT),LCIRC,NRING,
     &		   MAXRIN,NUMR,FIT(IT,JT),ROTMP(IT,JT),TT)
	           ROTMP(IT,JT)=ANG(ROTMP(IT,JT),MODE)
d488 2
a489 2
C               Find the maximum within +/-ISTEP
C            Maximum cannot be on the edge, i.e., IT,JT/=ISTEP
d493 4
a496 4
	        IF(ISTEP.GT.1)  THEN
	           DO     JT=-ISTEP+1,ISTEP-1
	              DO     IT=-ISTEP+1,ISTEP-1
	                  IF(FIT(IT,JT).GT.AFIT)  THEN
d505 3
a507 3
C                Copy values around the peak.
	         DO     JT=-1,1
	            DO     IT=-1,1
d512 1
a512 1
C                Update location of the peak
d519 1
a519 1
	         IF(ABS(SX).LT.1.0 .AND. ABS(SY).LT.1.0)  THEN
d524 7
a530 7
	CALL NORMAS(A,NSB-IMX,NSE-IMX,NRB-IMY,NRE-IMY,NUMR,NUMR(1,NRING))
	            CALL  ALRQ_M
     &       (A,NSAM,NROW,CNS2,CNR2,NUMR,A_CIRC,LCIRC,NRING,MODE)
	            CALL  FRNG(A_CIRC,LCIRC,NUMR,NRING)
	            CALL  CROSRMG_DS
     &		(REFER_CIRC(1,IME),A_CIRC,LCIRC,NRING,
     &		    MAXRIN,NUMR,QM,D4,TT)
d550 4
a553 4
C          Now have to change order of shift&rotation.
C          In this program image is shifted first, rotated second.
C          In RT SQ it is rotation first, shift second.
C          This part corresponds to SA P.
d559 6
a564 6
c 1 - Number of the most similar reference projection.
c 2 - Not-normalized correlation coefficient.
c 3 - Psi angle. (in=plane rotation)
c 4 - SX
c 5 - SY
c 6 - input image number.
@


1.46
log
@MR
@
text
@d15 21
a35 12
C        SUBROUTINE MRQLI
C        SUBROUTINE  MRQLI_SS(ILIST,NIMA,IRIST,NTOTAL,NSAM,NROW,NSI,
C        SUBROUTINE  MRQLI_PS(ILIST,NIMA,IRIST,NTOTAL,NSAM,NROW,NSI,
C        SUBROUTINE  APMQ2D(A,REFER_CIRC,TT,NUMR,
C        SUBROUTINE  NORMASC(X,Y,NS1,NS2,NR1,NR2,IR1,IR2)
C        SUBROUTINE  NORMASS(X,NS1,NS2,NR1,NR2,IR1,IR2)
C        SUBROUTINE  ALRQ_MS
C        SUBROUTINE  CROSRNG_MS
C        SUBROUTINE  CROSRMG_DS
C        SUBROUTINE  FRNGS
C        SUBROUTINE  APPLYWS
C        SUBROUTINE  ALRQS
d37 1
a39 1
C        1         2         3         4         5         6         7
d93 1
a93 1
        IF(NR.GT.NSAM/2-1)  THEN
d102 1
a102 1
           NRING=NRING+1
d163 1
a163 1
2600     FORMAT (/,' ',80('-'),//,
d165 1
a165 1
     &      ' ',80('-'),/)
d603 1
a603 1
C       Automatic arrays
d605 1
a605 1
        DIMENSION DLIST(NDLI,NUMTH)
d607 1
a607 1
	INTEGER  NASSIG(NUMTH)
d609 1
a609 1
	REAL, ALLOCATABLE, DIMENSION(:,:) ::  REFER_CIRC
@


1.45
log
@cosmetic & error recovery
@
text
@d88 1
a88 1
        MR    = MAX0(2,MIN0(NR,MR))
@


1.44
log
@header & cosmetic
@
text
@d65 1
a65 1
2001       FORMAT('  Number of images =',I5)
d67 1
a67 1
           CALL ERRT(101,'  No images !',IDUM)
d79 1
a79 1
	CALL  RDPRMI(NSI,ISTEP,NLOOP,ILOOP,'SEARCH RANGE, STEP SIZE')
d88 4
a91 4
        MR=MAX0(2,MIN0(NR,MR))
        ISKIP=1
        MODE='F'
        NRING=0
d102 2
a103 2
        NRING=0
        DO    I=MR,NR,ISKIP
d121 1
a121 1
        MAXRIN=NUMR(3,NRING)
d131 1
a131 1
     &   'ENTER TEMPLATE FOR 2-D IMAGES TO BE ALIGNED',IRTFLG)
d571 1
a571 1
C $$ MRQLI_PS.FOR
a586 1

d602 1
a602 1
C
d608 5
a612 4
	ALLOCATE(A(NSAM,NROW,NUMTH),STAT=IRTFLG)
	IF(IRTFLG.NE.0) CALL  ERRT(46,'AM MQ, A',IER)
	ALLOCATE(REFER_CIRC(LCIRC,NIMA),STAT=IRTFLG)
	IF(IRTFLG.NE.0) CALL  ERRT(46,'AM MQ, REFER_CIRC',IER)
d616 4
a619 1
	IF(IRTFLG.NE.0) CALL  ERRT(46,'AM MQ, TT',IER)
d623 4
a626 1
	IF(IRTFLG.NE.0) CALL  ERRT(46,'AM MQ, TT',IER)
d630 9
a638 8
	NSNR=NSAM*NROW
	LO=2*NSI+1
	LT=LO*LO
C       Calculate dimensions for NORMAS
	NSB=-NSAM/2
	NSE=-NSB-1+MOD(NSAM,2)
	NRB=-NROW/2
	NRE=-NRB-1+MOD(NROW,2)
d640 2
a641 3
C PREPARE REFERENCES
	
C do it for all the reference images
d644 1
a644 1
	  CALL  FILGET(FINPAT,FINPIC,NLET,ILIST(IMI),INTFLAG)
d646 6
a651 8
	CALL OPFILE(.FALSE.,FINPIC,INPIC,'O',IFORM,NSAMT,NROWT,NSLICE,
     &        MAXIM,' ',.FALSE.,IRTFLG)
              IF(IRTFLG.NE.0)  THEN
                 WRITE(NOUT,*)  ' FILE NOT FOUND:',FINPIC
                 RETURN
              ENDIF
	      DO    J=1,NROW
	         CALL  REDLIN(INPIC,A(1,J,IMI-IMIT+1),NSAM,J)
d656 1
a656 1
C          Normalize under the mask
d658 1
a658 1
c$omp parallel do private(IMI)
d662 4
a665 4
	  CALL  ALRQS(A(1,1,IMI-IMIT+1),NSAM,NROW,NUMR,REFER_CIRC(1,IMI),
     &		LCIRC,NRING,MODE)
	      CALL  FRNGS(REFER_CIRC(1,IMI),LCIRC,NUMR,NRING)
	  CALL  APPLYWS(REFER_CIRC(1,IMI),LCIRC,NUMR,WR,NRING,MAXRIN)
d670 1
a670 1
C  alignment
d673 1
a673 1
C Loop over images to be aligned
d679 5
a683 7
	CALL OPFILE(.FALSE.,FINPIC,INPIC,'O',IFORM,NSAMT,NROWT,NSLICE,
     &        MAXIM,' ',.FALSE.,IRTFLG)
              IF(IRTFLG.NE.0)  THEN
                 WRITE(NOUT,*)  ' FILE NOT FOUND:',FINPIC
                 RETURN
              ENDIF
              IF(NSAMT.NE.NSAM.OR.NROWT.NE.NROW)  THEN
d686 1
a686 1
	         RETURN
d688 1
a688 1
	      DO    J=1,NROW
d693 3
a695 2
C          NUMTH input images ready to be aligned
c$omp parallel do private(IMI)
d697 6
a702 6
	CALL  APMQ2D(A(1,1,IMI-IMIT+1),REFER_CIRC,TT,NUMR,
     &	   NSAM,NROW,NSI,ISTEP,
     &	   NSB,NSE,NRB,NRE,LCIRC,NRING,MAXRIN,NIMA,MODE,
C             Output parameters are:
C             Number of the most similar reference projection.
C             Corr coeff.(D5), Angle (D4), Shift: XSHSUM, YSHSUM
d708 7
a714 7
C output (in DLIST position is increased by 1, No.1 is the key).
c 1 - Number of the most similar reference projection.
c 2 - Not-normalized correlation coefficient.
c 3 - Psi angle. (in=plane rotation)
c 4 - SX
c 5 - SY
c 6 - input image number.
d718 1
a718 1
     &	    ISIGN(ILIST(IABS(NASSIG(IMI-IMIT+1))),NASSIG(IMI-IMIT+1))
d721 1
a721 1
              CALL  SAVD(NDOC,DLIST(1,IMI-IMIT+1),NDLI,IRTFLG)
d725 2
a726 1
C       Over and out
d730 4
a733 4
C       Deallocate local arrays
	DEALLOCATE(TT)
	DEALLOCATE(REFER_CIRC)
	DEALLOCATE(A)
d737 1
d740 3
a742 3
     &	   NSAM,NROW,NSI,ISTEP,
     &	   NSB,NSE,NRB,NRE,LCIRC,NRING,MAXRIN,NIMA,MODE,
     &	   IDI,D5,D4,XSHSUM,YSHSUM)
d749 2
a750 1
        CHARACTER*1  MODE
d753 1
a753 1
	DIMENSION  ROTMP(-ISTEP:ISTEP,-ISTEP:ISTEP)
d759 4
a762 1
	IF(IRTFLG.NE.0) CALL  ERRT(46,'AP MQ, A_CIRC',IER)
d764 26
a789 26
	QT=-1.0D23
	QM=-1.0D23
c       go through centers
	DO    JT=-NSI,NSI,ISTEP
	   CNR2=NROW/2+1+JT
	   DO    IT=-NSI,NSI,ISTEP
	      CNS2=NSAM/2+1+IT
C
C             Normalize under the mask
C
	CALL NORMASS(A,NSB-IT,NSE-IT,NRB-JT,NRE-JT,NUMR,NUMR(1,NRING))
	      CALL  ALRQ_MS
     &   (A,NSAM,NROW,CNS2,CNR2,NUMR,A_CIRC,LCIRC,NRING,MODE)
	      CALL  FRNGS(A_CIRC,LCIRC,NUMR,NRING)
C  Loop over reference images
	      DO    IR=1,NIMA
	         CALL  CROSRNG_MS
     &		 (REFER_CIRC(1,IR),A_CIRC,LCIRC,NRING,
     &		 MAXRIN,NUMR,TOTA,TOT,TMTA,TMT,TT)
	         IF(TOTA.GE.QT)  THEN
	            QT=TOTA
	            IBE=IR
	            ISX=IT
	            ISY=JT
	            D4=ANG(TOT,MODE)
	            IDIS=IR
d791 7
a797 7
	         IF(TMTA.GE.QM)  THEN
	            QM=TMTA
	            IME=IR
	            IMX=IT
	            IMY=JT
	            E4=ANG(TMT,MODE)
	            IDIM=-IR
d803 4
a806 3
C TRY TO INTERPOLATE
	IF(QT.GT.QM)  THEN
C  For not-mirrored
d808 8
a815 8
C  Do not interpolate for point on the edge
	   IF(IABS(ISX).NE.NSI.AND.IABS(ISY).NE.NSI)  THEN
C  HAVE TO FIND NEIGHBOURING VALUES
	      FIT(0,0)=QT
	      ROTMP(0,0)=D4
	      DO     JT=-ISTEP,ISTEP
	         DO     IT=-ISTEP,ISTEP
	            IF(IT.NE.0 .OR. JT.NE.0) THEN
d818 10
a827 10
	               CALL NORMASS(A,
     &	NSB-(IT+ISX),NSE-(IT+ISX),NRB-(JT+ISY),NRE-(JT+ISY),
     &	               NUMR,NUMR(1,NRING))
	               CALL  ALRQ_MS
     &   (A,NSAM,NROW,CNS2,CNR2,NUMR,A_CIRC,LCIRC,NRING,MODE)
	               CALL  FRNGS(A_CIRC,LCIRC,NUMR,NRING)
	               CALL  CROSRNG_DS
     &		       (REFER_CIRC(1,IBE),A_CIRC,LCIRC,NRING,
     &		       MAXRIN,NUMR,FIT(IT,JT),ROTMP(IT,JT),TT)
	               ROTMP(IT,JT)=ANG(ROTMP(IT,JT),MODE)
d832 13
a844 13
C             Find the maximum within +/-ISTEP
C             Maximum cannot be on the edge, i.e., IT,JT/=ISTEP
	      AFIT=FIT(0,0)
	      JTMA=0
	      ITMA=0
	      IF(ISTEP.GT.1)  THEN
	         DO     JT=-ISTEP+1,ISTEP-1
	            DO     IT=-ISTEP+1,ISTEP-1
	               IF(FIT(IT,JT).GT.AFIT)  THEN
	                  AFIT=FIT(IT,JT)
	                  D4=ROTMP(IT,JT)
	                  ITMA=IT
	                  JTMA=JT
d849 3
a851 3
C             Copy values around the peak.
	      DO     JT=-1,1
	         DO     IT=-1,1
d855 5
a859 4
C             Update location of the peak
	      QT=AFIT
	      ISX=ISX+ITMA
	      ISY=ISY+JTMA
d863 5
a867 5
	      IF(ABS(SX).LT.1.0 .AND. ABS(SY).LT.1.0)  THEN
	         SX=SX+ISX
	         SY=SY+ISY
	         CNR2=NROW/2+1+SY
	         CNS2=NSAM/2+1+SX
d869 8
a876 8
     &	         NUMR,NUMR(1,NRING))
	         CALL  ALRQ_MS
     &    (A,NSAM,NROW,CNS2,CNR2,NUMR,A_CIRC,LCIRC,NRING,MODE)
	 CALL    FRNGS(A_CIRC,LCIRC,NUMR,NRING)
	 CALL    CROSRNG_DS(REFER_CIRC(1,IBE),A_CIRC,LCIRC,NRING,
     &		 MAXRIN,NUMR,QT,D4,TT)
	         D5=QT
	         D4=ANG(D4,MODE)
d879 3
a881 3
	         D5=QT
	         SX=ISX
	         SY=ISY
d884 3
a886 3
	      D5=QT
	      SX=ISX
	      SY=ISY
d889 1
a889 1
           IDI=IDIM
d900 5
a904 5
	               CALL NORMASS(A,
     &	NSB-(IT+IMX),NSE-(IT+IMX),NRB-(JT+IMY),NRE-(JT+IMY),
     &	NUMR,NUMR(1,NRING))
	               CALL  ALRQ_MS
     &   (A,NSAM,NROW,CNS2,CNR2,NUMR,A_CIRC,LCIRC,NRING,MODE)
d906 3
a908 3
	               CALL  CROSRMG_DS
     &		(REFER_CIRC(1,IME),A_CIRC,LCIRC,NRING,
     &		MAXRIN,NUMR,FIT(IT,JT),ROTMP(IT,JT),TT)
d914 2
a915 2
C             Find the maximum within +/-ISTEP
C             Maximum cannot be on the edge, i.e., IT,JT/=ISTEP
d919 4
a922 4
	      IF(ISTEP.GT.1)  THEN
	         DO     JT=-ISTEP+1,ISTEP-1
	            DO     IT=-ISTEP+1,ISTEP-1
	               IF(FIT(IT,JT).GT.AFIT)  THEN
d931 3
a933 3
C             Copy values around the peak.
	      DO     JT=-1,1
	         DO     IT=-1,1
d937 1
a937 1
C             Update location of the peak
d944 1
a944 1
	      IF(ABS(SX).LT.1.0 .AND. ABS(SY).LT.1.0)  THEN
d950 8
a957 9
     &           NUMR,NUMR(1,NRING))
	         CALL  ALRQ_MS
     &   (A,NSAM,NROW,CNS2,CNR2,NUMR,A_CIRC,LCIRC,NRING,MODE)
	         CALL  FRNGS(A_CIRC,LCIRC,NUMR,NRING)
	 CALL    CROSRMG_DS
     &		(REFER_CIRC(1,IME),A_CIRC,LCIRC,NRING,
     &		 MAXRIN,NUMR,QM,D4,TT)
	         D5=QM
	         D4=ANG(D4,MODE)
d960 4
a963 4
	         SX=IMX
	         SY=IMY
	         D4=E4
	         D5=QM
d966 4
a969 4
	      SX=IMX
	      SY=IMY
	      D4=E4
	      D5=QM
d973 12
a984 12
	SX=-SX
	SY=-SY
C  Now have to change order of shift&rotation.
C  In this program image is shifted first, rotated second.
C  In RT SQ it is rotation first, shift second.
C  This part corresponds to SA P.
	CO=COS(D4*DGR_TO_RAD)
	SO=-SIN(D4*DGR_TO_RAD)
	XSHSUM=SX*CO-SY*SO
	YSHSUM=SX*SO+SY*CO
C
	DEALLOCATE(A_CIRC)
@


1.43
log
@used CMLIMIT, ALOC. traps fixed, & cosmetic
@
text
@d28 4
d87 8
a94 8
         ENDIF
         MR=MAX0(2,MIN0(NR,MR))
         ISKIP=1
         MODE='F'
         NRING=0
         DO I=MR,NR,ISKIP
            NRING=NRING+1
	 ENDDO
d102 5
a106 5
         NRING=0
         DO    I=MR,NR,ISKIP
            NRING=NRING+1
            NUMR(1,NRING)=I
	 ENDDO
d108 2
a109 2
C        ADJUST SEARCH RANGE AND STEP SIZE.
	 IF (NSI+NR .GT. NSAM/2-2)  THEN
d245 3
a247 3
	     CALL  FILGET(FINPAT,FINPIC,NLET,ILIST(IMI),INTFLAG)
	     MAXIM = 0
	     CALL OPFILE(.FALSE.,FINPIC,INPIC,'O',IFORM,NSAMT,NROWT,
d249 6
a254 6
             IF (IRTFLG.NE.0)  RETURN
	     DO    J=1,NROW
	        CALL  REDLIN(INPIC,AI(1,J,IMI-IMIT+1),NSAM,J)
	     ENDDO
	     CLOSE(INPIC)
	  ENDDO
d256 1
a256 1
C         NORMALIZE UNDER THE MASK
d259 2
a260 2
	  DO  IMI=IMIT,MIN(NIMA,IMIT+NUMTH-1)
	     CALL NORMASS(AI(1,1,IMI-IMIT+1),NSB,NSE,NRB,NRE,NUMR,
d262 1
a262 1
	     CALL  ALRQS(AI(1,1,IMI-IMIT+1),NSAM,NROW,NUMR,
d264 1
a264 1
	     CALL  FRNGS(REFER_CIRC(1,IMI),LCIRC,NUMR,NRING)
d266 1
a266 1
	  ENDDO
d318 3
a320 3
     &                NUMR,NRING)
	         DO    IR=1,NIMA
	           CALL  CROSRNG_MS
d322 5
a326 5
     &             NRING,MAXRIN,NUMR,
     &             TOTA(IR,IT,JT),TOT(IR,IT,JT),
     &             TMTA(IR,IT,JT),TMT(IR,IT,JT),TT)
	        ENDDO
             ENDDO
d362 1
d368 6
a373 6
	  DO     JT=-ISTEP,ISTEP
	   DO     IT=-ISTEP,ISTEP
	   IF(IT.NE.0 .OR. JT.NE.0) THEN
	    CNR2=NROW/2+1+JT+ISY
	    CNS2=NSAM/2+1+IT+ISX
	    CALL NORMASC(A,AA(1,1,IT,JT),
d376 3
a378 3
	    CALL  ALRQ_MS
     &   (AA(1,1,IT,JT),NSAM,NROW,CNS2,CNR2,NUMR,
     &   A_CIRC(1,IT,JT),LCIRC,NRING,MODE)
d380 1
a380 1
	    CALL  CROSRNG_DS
d383 5
a387 5
	    ROTMP(IT,JT)=ANG(ROTMP(IT,JT),MODE)
	   ENDIF
	   ENDDO
	  ENDDO

d390 25
a414 25
	  AFIT=FIT(0,0)
	  JTMA=0
	  ITMA=0
	  IF(ISTEP.GT.1)  THEN
	   DO     JT=-ISTEP+1,ISTEP-1
	    DO     IT=-ISTEP+1,ISTEP-1
	     IF(FIT(IT,JT).GT.AFIT)  THEN
	      AFIT=FIT(IT,JT)
	      D4=ROTMP(IT,JT)
	      ITMA=IT
	      JTMA=JT
	     ENDIF
	    ENDDO
	   ENDDO
	  ENDIF
C  Copy values around the peak.
	  DO     JT=-1,1
	   DO     IT=-1,1
	    FITP(IT,JT)=FIT(ITMA+IT,JTMA+JT)
	   ENDDO
	  ENDDO
C Update location of the peak
	  QT=AFIT
	  ISX=ISX+ITMA
	  ISY=ISY+JTMA
d416 1
a416 1
	  CALL  PARABLD(FITP,SX,SY,PEAK)
d418 5
a422 5
	  IF(ABS(SX).LT.1.0 .AND. ABS(SY).LT.1.0)  THEN
	   SX=SX+ISX
	   SY=SY+ISY
	   CNR2=NROW/2+1+SY
	   CNS2=NSAM/2+1+SX
d424 23
a446 22
	   CALL  ALRQ_M
     &          (A,NSAM,NROW,CNS2,CNR2,NUMR,A_CIRC,LCIRC,NRING,MODE)
	   CALL  FRNG(A_CIRC,LCIRC,NUMR,NRING)
	   CALL  CROSRNG_DS
     &		(REFER_CIRC(1,IBE),A_CIRC,LCIRC,NRING,
     &		MAXRIN,NUMR,QT,D4,TT)
	   D5=QT
	   D4=ANG(D4,MODE)
	  ELSE
C INTERPOLATION FAILED
	   D5=QT
	   SX=ISX
	   SY=ISY
	  ENDIF
	 ELSE
	  D5=QT
	  SX=ISX
	  SY=ISY
	 ENDIF
	ELSE
         DLIST(2)=E6
C INTERPOLATE FOR MIRRORED
d448 3
a450 3
C  HAVE TO FIND NEIGHBOURING VALUES
	  FIT(0,0)=QM
	  ROTMP(0,0)=E4
d452 6
a457 6
	  DO     JT=-ISTEP,ISTEP
	   DO     IT=-ISTEP,ISTEP
	    IF(IT.NE.0 .OR. JT.NE.0) THEN
	     CNR2=NROW/2+1+JT+IMY
	     CNS2=NSAM/2+1+IT+IMX
	     CALL NORMASC(A,AA(1,1,IT,JT),
d460 1
a460 1
	     CALL  ALRQ_MS
d463 2
a464 2
	     CALL  FRNGS(A_CIRC(1,IT,JT),LCIRC,NUMR,NRING)
	     CALL  CROSRMG_DS
d466 42
a507 41
     &		MAXRIN,NUMR,FIT(IT,JT),ROTMP(IT,JT),TT)
	     ROTMP(IT,JT)=ANG(ROTMP(IT,JT),MODE)
	    ENDIF
	   ENDDO
	  ENDDO
C
C  Find the maximum within +/-ISTEP
C  Maximum cannot be on the edge, i.e., IT,JT/=ISTEP
	  AFIT=FIT(0,0)
	  JTMA=0
	  ITMA=0
	  IF(ISTEP.GT.1)  THEN
	   DO     JT=-ISTEP+1,ISTEP-1
	    DO     IT=-ISTEP+1,ISTEP-1
	     IF(FIT(IT,JT).GT.AFIT)  THEN
	      AFIT=FIT(IT,JT)
	      E4=ROTMP(IT,JT)
	      ITMA=IT
	      JTMA=JT
	     ENDIF
	    ENDDO
	   ENDDO
	  ENDIF
C  Copy values around the peak.
	   DO     JT=-1,1
	    DO     IT=-1,1
	     FITP(IT,JT)=FIT(ITMA+IT,JTMA+JT)
	    ENDDO
	   ENDDO
C Update location of the peak
	   QM=AFIT
	   IMX=IMX+ITMA
	   IMY=IMY+JTMA
C
	   CALL  PARABLD(FITP,SX,SY,PEAK)
C CHECK WHETHER INTERPOLATION IS OK.
	   IF(ABS(SX).LT.1.0 .AND. ABS(SY).LT.1.0)  THEN
	    SX=SX+IMX
	    SY=SY+IMY
	    CNR2=NROW/2+1+SY
	    CNS2=NSAM/2+1+SX
d509 4
a512 4
	    CALL  ALRQ_M
     &   (A,NSAM,NROW,CNS2,CNR2,NUMR,A_CIRC,LCIRC,NRING,MODE)
	    CALL  FRNG(A_CIRC,LCIRC,NUMR,NRING)
	    CALL  CROSRMG_DS
d514 29
a542 29
     &		MAXRIN,NUMR,QM,D4,TT)
	    D5=QM
	    D4=ANG(D4,MODE)
	   ELSE
C INTERPOLATION FAILED
	    SX=IMX
	    SY=IMY
	    D4=E4
	    D5=QM
	   ENDIF
	  ELSE
	   SX=IMX
	   SY=IMY
	   D4=E4
	   D5=QM
	  ENDIF
	 ENDIF
C
	 SX=-SX
	 SY=-SY
C  Now have to change order of shift&rotation.
C  In this program image is shifted first, rotated second.
C  In RT SQ it is rotation first, shift second.
C  This part corresponds to SA P.
	 CO=COS(D4*DGR_TO_RAD)
	 SO=-SIN(D4*DGR_TO_RAD)
	 XSHSUM=SX*CO-SY*SO
	 YSHSUM=SX*SO+SY*CO
C
d549 8
a556 7
         DLIST(3)=D5
         DLIST(4)=D4
         DLIST(5)=XSHSUM
         DLIST(6)=YSHSUM
         DLIST(7)=IRIST(IMI)
         DLIST(1)=IMI
         CALL  SAVD(NDOC,DLIST,NDLI,IRTFLG)
d627 1
a627 1
C  Calculate dimensions for NORMAS
d634 1
a634 1

d637 1
a637 1
	 DO  IMI=IMIT,MIN(NIMA,IMIT+NUMTH-1)
d639 1
a639 1
	  MAXIM = 0
d641 9
a649 7
     &               MAXIM,' ',.FALSE.,IRTFLG)
           IF(IRTFLG.NE.0)  THEN
            WRITE(NOUT,*)  ' FILE NOT FOUND:',FINPIC
            RETURN
           ENDIF
	   DO    J=1,NROW
	    CALL  REDLIN(INPIC,A(1,J,IMI-IMIT+1),NSAM,J)
a650 2
	   CLOSE(INPIC)
	 ENDDO
d652 1
a652 1
C  Normalize under the mask
d655 2
a656 2
	 DO  IMI=IMIT,MIN(NIMA,IMIT+NUMTH-1)
	  CALL NORMASS(A(1,1,IMI-IMIT+1),NSB,NSE,NRB,NRE,
d660 1
a660 1
	  CALL  FRNGS(REFER_CIRC(1,IMI),LCIRC,NUMR,NRING)
d662 1
a662 1
	 ENDDO
d664 1
d670 2
a671 2
	DO  IMIT=1,NTOTAL,NUMTH
	 DO  IMI=IMIT,MIN(NTOTAL,IMIT+NUMTH-1)
d673 2
a674 2
	  CALL  FILGET(FILTOA,FINPIC,NLETI,IRIST(IMI),INTFLAG)
	  MAXIM = 0
d676 16
a691 16
     &               MAXIM,' ',.FALSE.,IRTFLG)
          IF(IRTFLG.NE.0)  THEN
            WRITE(NOUT,*)  ' FILE NOT FOUND:',FINPIC
            RETURN
          ENDIF
          IF(NSAMT.NE.NSAM.OR.NROWT.NE.NROW)  THEN
            CALL ERRT(1,'AP MQ',NE)
            CLOSE(INPIC)
	    RETURN
	  ENDIF
	  DO    J=1,NROW
	   CALL  REDLIN(INPIC,A(1,J,IMI-IMIT+1),NSAM,J)
	  ENDDO
	  CLOSE(INPIC)
	 ENDDO
C NUMTH input images ready to be aligned
d693 2
a694 2
	 DO  IMI=IMIT,MIN(NTOTAL,IMIT+NUMTH-1)
	  CALL  APMQ2D(A(1,1,IMI-IMIT+1),REFER_CIRC,TT,NUMR,
d697 7
a703 7
C Output parameters are:
C Number of the most similar reference projection.
C Corr coeff.(D5), Angle (D4), Shift: XSHSUM, YSHSUM
     &		NASSIG(IMI-IMIT+1),
     &		DLIST(3,IMI-IMIT+1),DLIST(4,IMI-IMIT+1),
     &		DLIST(5,IMI-IMIT+1),DLIST(6,IMI-IMIT+1))
	 ENDDO
d713 2
a714 2
	 DO  IMI=IMIT,MIN(NTOTAL,IMIT+NUMTH-1)
	  DLIST(2,IMI-IMIT+1)=
d716 4
a719 4
          DLIST(7,IMI-IMIT+1)=IRIST(IMI)
          DLIST(1,IMI-IMIT+1)=IMI
          CALL  SAVD(NDOC,DLIST(1,IMI-IMIT+1),NDLI,IRTFLG)
	 ENDDO
d759 3
a761 3
	CNR2=NROW/2+1+JT
	DO    IT=-NSI,NSI,ISTEP
	CNS2=NSAM/2+1+IT
d763 1
a763 1
C       Normalize under the mask
d766 1
a766 1
	CALL  ALRQ_MS
d768 1
a768 1
	CALL  FRNGS(A_CIRC,LCIRC,NUMR,NRING)
d770 23
a792 23
	 DO    IR=1,NIMA
	 CALL  CROSRNG_MS
     &		(REFER_CIRC(1,IR),A_CIRC,LCIRC,NRING,
     &		MAXRIN,NUMR,TOTA,TOT,TMTA,TMT,TT)
	  IF(TOTA.GE.QT)  THEN
	   QT=TOTA
	   IBE=IR
	   ISX=IT
	   ISY=JT
	   D4=ANG(TOT,MODE)
	   IDIS=IR
	  ENDIF
	  IF(TMTA.GE.QM)  THEN
	   QM=TMTA
	   IME=IR
	   IMX=IT
	   IMY=JT
	   E4=ANG(TMT,MODE)
	   IDIM=-IR
	  ENDIF
	 ENDDO 
C  END-OF-LOOP 1 OVER REFERENCE IMAGES
	ENDDO
d797 1
a797 1
        IDI=IDIS
d799 1
a799 1
	IF(IABS(ISX).NE.NSI.AND.IABS(ISY).NE.NSI)  THEN
d801 8
a808 8
	 FIT(0,0)=QT
	 ROTMP(0,0)=D4
	 DO     JT=-ISTEP,ISTEP
	  DO     IT=-ISTEP,ISTEP
	   IF(IT.NE.0 .OR. JT.NE.0) THEN
	    CNR2=NROW/2+1+JT+ISY
	    CNS2=NSAM/2+1+IT+ISX
	    CALL NORMASS(A,
d810 2
a811 2
     &	NUMR,NUMR(1,NRING))
	    CALL  ALRQ_MS
d813 63
a875 22
	    CALL  FRNGS(A_CIRC,LCIRC,NUMR,NRING)
	    CALL  CROSRNG_DS
     &		(REFER_CIRC(1,IBE),A_CIRC,LCIRC,NRING,
     &		MAXRIN,NUMR,FIT(IT,JT),ROTMP(IT,JT),TT)
	    ROTMP(IT,JT)=ANG(ROTMP(IT,JT),MODE)
	  ENDIF
	 ENDDO
	ENDDO
C
C  Find the maximum within +/-ISTEP
C  Maximum cannot be on the edge, i.e., IT,JT/=ISTEP
	AFIT=FIT(0,0)
	JTMA=0
	ITMA=0
	IF(ISTEP.GT.1)  THEN
	 DO     JT=-ISTEP+1,ISTEP-1
	  DO     IT=-ISTEP+1,ISTEP-1
	   IF(FIT(IT,JT).GT.AFIT)  THEN
	    AFIT=FIT(IT,JT)
	    D4=ROTMP(IT,JT)
	    ITMA=IT
	    JTMA=JT
a876 36
	  ENDDO
	 ENDDO
	ENDIF
C  Copy values around the peak.
	DO     JT=-1,1
	 DO     IT=-1,1
	  FITP(IT,JT)=FIT(ITMA+IT,JTMA+JT)
	 ENDDO
	ENDDO
C Update location of the peak
	QT=AFIT
	ISX=ISX+ITMA
	ISY=ISY+JTMA
C
	CALL  PARABLD(FITP,SX,SY,PEAK)
C CHECK WHETHER INTERPOLATION IS OK.
	IF(ABS(SX).LT.1.0 .AND. ABS(SY).LT.1.0)  THEN
	 SX=SX+ISX
	 SY=SY+ISY
	 CNR2=NROW/2+1+SY
	 CNS2=NSAM/2+1+SX
	 CALL NORMASS(A,NSB-ISX,NSE-ISX,NRB-ISY,NRE-ISY,
     &	              NUMR,NUMR(1,NRING))
	 CALL  ALRQ_MS
     &    (A,NSAM,NROW,CNS2,CNR2,NUMR,A_CIRC,LCIRC,NRING,MODE)
	 CALL  FRNGS(A_CIRC,LCIRC,NUMR,NRING)
	 CALL  CROSRNG_DS(REFER_CIRC(1,IBE),A_CIRC,LCIRC,NRING,
     &		MAXRIN,NUMR,QT,D4,TT)
	 D5=QT
	 D4=ANG(D4,MODE)
	ELSE
C INTERPOLATION FAILED
	 D5=QT
	 SX=ISX
	 SY=ISY
	ENDIF
d878 12
a889 17
	D5=QT
	SX=ISX
	SY=ISY
	ENDIF
	ELSE
        IDI=IDIM
C INTERPOLATE FOR MIRRORED
	IF(IABS(IMX).NE.NSI.AND.IABS(IMY).NE.NSI)  THEN
C  HAVE TO FIND NEIGHBOURING VALUES
	 FIT(0,0)=QM
	 ROTMP(0,0)=E4
	 DO     JT=-ISTEP,ISTEP
	  DO     IT=-ISTEP,ISTEP
	   IF(IT.NE.0 .OR. JT.NE.0) THEN
	    CNR2=NROW/2+1+JT+IMY
	    CNS2=NSAM/2+1+IT+IMX
	    CALL NORMASS(A,
d892 1
a892 1
	    CALL  ALRQ_MS
d894 2
a895 2
	   CALL  FRNGS(A_CIRC,LCIRC,NUMR,NRING)
	   CALL  CROSRMG_DS
d898 43
a940 43
	    ROTMP(IT,JT)=ANG(ROTMP(IT,JT),MODE)
	   ENDIF
	  ENDDO
	 ENDDO
C
C  Find the maximum within +/-ISTEP
C  Maximum cannot be on the edge, i.e., IT,JT/=ISTEP
	AFIT=FIT(0,0)
	JTMA=0
	ITMA=0
	IF(ISTEP.GT.1)  THEN
	 DO     JT=-ISTEP+1,ISTEP-1
	  DO     IT=-ISTEP+1,ISTEP-1
	   IF(FIT(IT,JT).GT.AFIT)  THEN
	    AFIT=FIT(IT,JT)
	    E4=ROTMP(IT,JT)
	    ITMA=IT
	    JTMA=JT
	   ENDIF
	  ENDDO
	 ENDDO
	ENDIF
C  Copy values around the peak.
	DO     JT=-1,1
	 DO     IT=-1,1
	  FITP(IT,JT)=FIT(ITMA+IT,JTMA+JT)
	 ENDDO
	ENDDO
C Update location of the peak
	QM=AFIT
	IMX=IMX+ITMA
	IMY=IMY+JTMA
C
	CALL  PARABLD(FITP,SX,SY,PEAK)
C CHECK WHETHER INTERPOLATION IS OK.
	IF(ABS(SX).LT.1.0 .AND. ABS(SY).LT.1.0)  THEN
	 SX=SX+IMX
	 SY=SY+IMY
	 CNR2=NROW/2+1+SY
	 CNS2=NSAM/2+1+SX
	 CALL NORMASS(A,NSB-IMX,NSE-IMX,NRB-IMY,NRE-IMY,
     &   NUMR,NUMR(1,NRING))
	 CALL  ALRQ_MS
d942 2
a943 2
	 CALL  FRNGS(A_CIRC,LCIRC,NUMR,NRING)
	 CALL  CROSRMG_DS
d945 16
a960 15
     &		MAXRIN,NUMR,QM,D4,TT)
	 D5=QM
	 D4=ANG(D4,MODE)
	ELSE
C INTERPOLATION FAILED
	 SX=IMX
	 SY=IMY
	 D4=E4
	 D5=QM
	ENDIF
	ELSE
	SX=IMX
	SY=IMY
	D4=E4
	D5=QM
d962 1
a962 2
	ENDIF
C
@


1.42
log
@used getthreads & format 2600 changed to add ,s
@
text
@d3 1
a3 1
C    MRQLI.F
d15 1
a15 1
C       SUBROUTINE MRQLI
d24 1
a24 1
C         SUBROUTINE  FRNGS
d31 1
a31 1
	PARAMETER  (NILMAX=99998)
d33 4
a36 1
C be careful with the common, it has to agree with 64 bits...
d38 1
a38 1
	CHARACTER*80  FINPAT,FINPIC,FILTOA
d40 1
a40 1
	INTEGER  MAXRIN
d43 2
a44 1
	INTEGER, ALLOCATABLE, DIMENSION(:) ::  ILIST,IRIST
d46 9
a54 3
C
	ALLOCATE(ILIST(NILMAX))
C  ASK FOR DATA FILE
d56 15
a70 13
     &   'ENTER TEMPLATE FOR 2-D REFERENCE IMAGE NAME',IRTFLG)
	IF (IRTFLG .NE. 0) RETURN
         IF(NIMA.GT.0)  THEN
         WRITE(NOUT,2001) NIMA
2001     FORMAT('  Number of images =',I5)
         ELSE
         WRITE(NOUT,*)  '  No images !'
         RETURN
         ENDIF
C     GET FIRST PICTURE TO DETERMINE DIMS
         CALL  FILGET(FINPAT,FINPIC,NLET,ILIST(1),INTFLG)
	 MAXIM = 0
	 CALL OPFILE(.FALSE.,FINPIC,INPIC,'O',IFORM,NSAM,NROW,NSLICE,
d72 3
a74 6
         IF(IRTFLG.NE.0)  THEN
          CALL ERRT(4,'AP MQ ',NE)
          RETURN
         ENDIF
         CLOSE(INPIC)
C
d76 7
a82 7
	NSI=MAX0(NSI,1)
	ISTEP=MAX0(ISTEP,1)
C
         CALL  RDPRMI(MR,NR,NLOOP,ILOOP,'FIRST AND LAST RING')
         IF(NR.GT.NSAM/2-1)  THEN
          NR=NSAM/2-1
          WRITE(NOUT,*)  ' Last ring limited to ',NR
d88 2
a89 2
         DO    I=MR,NR,ISKIP
          NRING=NRING+1
d91 1
d93 5
a97 1
	IF(IRTFLG.NE.0) CALL ERRT(46,'AP MQ, NUMR',IER)
d100 2
a101 2
          NRING=NRING+1
          NUMR(1,NRING)=I
d103 5
a107 4
C  Adjust search range and step size.
	 IF(NSI+NR.GT.NSAM/2-2)  THEN
	  CALL ERRT(101,'Search range too large',NE)
	  RETURN
d109 5
a113 3
	IF(MOD(NSI,ISTEP).NE.0) THEN
	CALL ERRT(101,'Search range has to be divisible by step size',NE)
	RETURN
d115 11
a125 7
C
         CALL  ALPRBS(NUMR,NRING,LCIRC,MODE)
         MAXRIN=NUMR(3,NRING)
C
	ALLOCATE(IRIST(NILMAX))
C
C  images to be aligned
d128 1
a128 1
	IF(IRTFLG.NE.0) RETURN
d132 5
a136 5
C NIMA number of the reference images
C
	IF(NTOTAL.GE.NUMTH)  THEN
C for mp, large number of images to be aligned, or sp.
         CALL  MRQLI_PS(ILIST,NIMA,IRIST,NTOTAL,NSAM,NROW,NSI,
d139 3
a141 3
C  For a small number of images to be aligned use different strategy
C  to make mp efficient.
         CALL  MRQLI_SS(ILIST,NIMA,IRIST,NTOTAL,NSAM,NROW,NSI,
d144 5
a148 4
C
	 DEALLOCATE(IRIST)
	 DEALLOCATE(ILIST)
	 DEALLOCATE(NUMR)
a149 1
         RETURN
d153 2
d156 2
a157 1
C
d160 1
a160 1
C $$ MRQLI_SS.FOR
d176 1
a176 3
C
C $$ MRQLI_SS.FOR
C
d179 1
d189 2
a190 1
C Automatic arrays
d204 1
a204 1
C
d208 1
d210 1
a210 3
C
C -------------------------
C
d212 2
a213 2
	IF(IRTFLG.NE.0) CALL  ERRT(46,'AM MQ, REFER_CIRC',IER)
C -------------------------
d223 1
a223 1
C
d226 1
a226 1
C
d230 1
a230 1
C  Calculate dimensions for NORMAS
d235 4
a238 4
C
C PREPARE REFERENCES
C
C do it for all the reference images
d240 14
a253 17
	 DO  IMI=IMIT,MIN(NIMA,IMIT+NUMTH-1)
	  CALL  FILGET(FINPAT,FINPIC,NLET,ILIST(IMI),INTFLAG)
	  MAXIM = 0
	CALL OPFILE(.FALSE.,FINPIC,INPIC,'O',IFORM,NSAMT,NROWT,NSLICE,
     &               MAXIM,' ',.FALSE.,IRTFLG)
           IF(IRTFLG.NE.0)  THEN
            WRITE(NOUT,*)  ' FILE NOT FOUND:',FINPIC
            RETURN
           ENDIF
	   DO    J=1,NROW
	    CALL  REDLIN(INPIC,AI(1,J,IMI-IMIT+1),NSAM,J)
	   ENDDO
	   CLOSE(INPIC)
	 ENDDO
C
C  Normalize under the mask
C
d255 2
a256 2
	 DO  IMI=IMIT,MIN(NIMA,IMIT+NUMTH-1)
	  CALL NORMASS(AI(1,1,IMI-IMIT+1),NSB,NSE,NRB,NRE,NUMR,
d258 1
a258 1
	  CALL  ALRQS(AI(1,1,IMI-IMIT+1),NSAM,NROW,NUMR,
d260 3
a262 3
	  CALL  FRNGS(REFER_CIRC(1,IMI),LCIRC,NUMR,NRING)
	  CALL  APPLYWS(REFER_CIRC(1,IMI),LCIRC,NUMR,WR,NRING,MAXRIN)
	 ENDDO
d264 1
a264 1
C
d268 2
d275 2
a276 1
	IF(IRTFLG.NE.0) CALL  ERRT(46,'AP MQ, A_CIRC',IER)
d278 4
a281 4
	IF(IRTFLG.NE.0) CALL  ERRT(46,'AP MQ, AA',IER)
C
C  images to be aligned
C Loop over images to be aligned
d283 14
a296 11
C
	CALL  FILGET(FILTOA,FINPIC,NLETI,IRIST(IMI),INTFLAG)
	  MAXIM = 0
	CALL OPFILE(.FALSE.,FINPIC,INPIC,'O',IFORM,NSAMT,NROWT,NSLICE,
     &               MAXIM,' ',.FALSE.,IRTFLG)
          IF(IRTFLG.NE.0)  THEN
            WRITE(NOUT,*)  ' FILE NOT FOUND:',FINPIC
            RETURN
          ENDIF
          IF(NSAMT.NE.NSAM.OR.NROWT.NE.NROW)  THEN
           CALL ERRT(1,'AP MQ',NE)
d298 2
a299 8
	   RETURN
	  ENDIF
	  DO    J=1,NROW
	   CALL  REDLIN(INPIC,A(1,J),NSAM,J)
	   ENDDO
	   CLOSE(INPIC)
C
c go through reference images and centers
d301 13
a313 13
	DO    JT=-NSI,NSI,ISTEP
	 CNR2=NROW/2+1+JT
	 DO    IT=-NSI,NSI,ISTEP
	  CNS2=NSAM/2+1+IT
C
C  Normalize under the mask
C
	 CALL NORMASC(A,AA(1,1,IT/ISTEP,JT/ISTEP),
     &    NSB-IT,NSE-IT,NRB-JT,NRE-JT,NUMR,NUMR(1,NRING))
	  CALL  ALRQ_MS
     &    (AA(1,1,IT/ISTEP,JT/ISTEP),NSAM,NROW,CNS2,CNR2,NUMR,
     &    A_CIRC(1,IT/ISTEP,JT/ISTEP),LCIRC,NRING,MODE)
	  CALL  FRNGS(A_CIRC(1,IT/ISTEP,JT/ISTEP),LCIRC,
d315 47
a361 46
	   DO    IR=1,NIMA
	    CALL  CROSRNG_MS
     &		(REFER_CIRC(1,IR),A_CIRC(1,IT/ISTEP,JT/ISTEP),LCIRC,
     &          NRING,MAXRIN,NUMR,
     &	        TOTA(IR,IT,JT),TOT(IR,IT,JT),
     &	        TMTA(IR,IT,JT),TMT(IR,IT,JT),TT)
	   ENDDO
	 ENDDO
	ENDDO
C end of the parallel section
C Locate best match
C
	QT=-1.0D23
	QM=-1.0D23
	DO    JT=-NSI,NSI,ISTEP
	 DO    IT=-NSI,NSI,ISTEP
	  DO    IR=1,NIMA
	  IF(TOTA(IR,IT,JT).GE.QT)  THEN
	   QT=TOTA(IR,IT,JT)
	   IBE=IR
	   ISX=IT
	   ISY=JT
	   D4=ANG(TOT(IR,IT,JT),MODE)
	   D6=ILIST(IR)
	  ENDIF
	  IF(TMTA(IR,IT,JT).GE.QM)  THEN
	   QM=TMTA(IR,IT,JT)
	   IME=IR
	   IMX=IT
	   IMY=JT
	   E4=ANG(TMT(IR,IT,JT),MODE)
	   E6=-ILIST(IR)
	  ENDIF
	  ENDDO
	 ENDDO
	ENDDO
C
C TRY TO INTERPOLATE
	IF(QT.GT.QM)  THEN
C  For not-mirrored
         DLIST(2)=D6
C  Do not interpolate for point on the edge
	 IF(IABS(ISX).NE.NSI.AND.IABS(ISY).NE.NSI)  THEN
C  HAVE TO FIND NEIGHBOURING VALUES
	  FIT(0,0)=QT
	  ROTMP(0,0)=D4
d382 1
a382 1
C
d559 2
a560 2
C
C
a575 1
C
d578 2
a579 3
C
C $$ MRQLI_PS.FOR
C
d582 1
d586 2
a587 1
C Automatic arrays
d600 1
a600 1
C -------------------------
d605 1
a605 1
C -------------------------
d615 1
a615 1
C
d624 1
a624 1
C
d626 1
a626 1
C
d643 1
a643 1
C
d645 1
a645 1
C
d659 1
a659 1
C
d663 1
a663 1
C
d695 1
d703 1
a703 1
C
d713 1
a713 1
C Over and out
d716 2
a717 1
C  Deallocate local arrays
d722 3
a724 1
C
d729 1
d736 1
a736 1
C Automatic arrays
d742 1
a742 1
C
d745 1
a745 1
C
d748 1
a748 1
c go through centers
d754 1
a754 1
C  Normalize under the mask
@


1.41
log
@reverted to r1.37
@
text
@d46 1
a46 1
     &   'Enter template for 2-D reference image name',IRTFLG)
d66 1
a66 1
	CALL  RDPRMI(NSI,ISTEP,NLOOP,ILOOP,'Search range, step size')
d106 1
a106 1
     &   'Enter template for 2-D images to be aligned',IRTFLG)
d108 3
a110 12
C
#ifdef SP_MP
c$omp parallel private(np)
        np = OMP_GET_NUM_THREADS()
c$omp single
        NUMTH=np
c$omp end single
c$omp end parallel
#else
         NUMTH=1
#endif
C
d129 3
a131 2
2600     FORMAT (/' ',80('-')//' ',' Multi-reference alignment,  ',
     &   'end of computation',//' ',80('-')/)
@


1.40
log
@Used getthreads & cosmetic
@
text
@d15 1
a15 3
C   MRQLI.
C
C        SUBROUTINE  MRQLI
d24 1
a24 1
C        SUBROUTINE  FRNGS
a30 1

a40 1

d42 1
a42 1

d44 1
a44 1
C       ASK FOR DATA FILE
d46 1
a46 1
     &   'ENTER TEMPLATE FOR 2-D REFERENCE IMAGE NAME',IRTFLG)
d48 11
a58 14

        IF (NIMA .GT. 0)  THEN
           WRITE(NOUT,2001) NIMA
2001       FORMAT(' NUMBER OF IMAGES =',I5)
        ELSE
           WRITE(NOUT,*)  ' NO IMAGES !'
           RETURN
        ENDIF

C       GET FIRST PICTURE TO DETERMINE DIMS
        CALL  FILGET(FINPAT,FINPIC,NLET,ILIST(1),INTFLG)

	MAXIM = 0
	CALL OPFILE(.FALSE.,FINPIC,INPIC,'O',IFORM,NSAM,NROW,NSLICE,
d60 10
a69 10
        IF (IRTFLG .NE. 0)  THEN
            CALL ERRT(4,'AP MQ ',NE)
            RETURN
        ENDIF
        CLOSE(INPIC)

	CALL  RDPRMI(NSI,ISTEP,NLOOP,ILOOP,'SEARCH RANGE, STEP SIZE')
	NSI   = MAX0(NSI,1)
	ISTEP = MAX0(ISTEP,1)

d71 3
a73 3
         IF (NR .GT. NSAM/2-1)  THEN
            NR = NSAM/2-1
            WRITE(NOUT,*)  ' LAST RING LIMITED TO ',NR
d79 2
a80 2
         DO I=MR,NR,ISKIP
            NRING=NRING+1
d82 2
a83 4

	 ALLOCATE(NUMR(3,NRING),STAT=IRTFLG)
	 IF(IRTFLG.NE.0) CALL ERRT(46,'AP MQ, NUMR',IER)

d95 1
a95 2
	CALL ERRT(101,
     &     'Search range has to be divisible by step size',NE)
d98 1
a98 1

d101 24
a124 16

	 ALLOCATE(IRIST(NILMAX))

C        IMAGES TO BE ALIGNED
	 CALL FILELIST(.TRUE.,INPIC,FILTOA,NLETI,IRIST,NILMAX,NTOTAL,
     &     'ENTER TEMPLATE FOR 2-D IMAGES TO BE ALIGNED',IRTFLG)
	 IF(IRTFLG.NE.0) RETURN

C        FIND NUMBER OF OMP THREADS
         CALL GETTHREADS(NUMTH)

C        NIMA NUMBER OF THE REFERENCE IMAGES

	IF (NTOTAL.GE.NUMTH)  THEN
C          FOR MP, LARGE NUMBER OF IMAGES TO BE ALIGNED, OR SP.
           CALL  MRQLI_PS(ILIST,NIMA,IRIST,NTOTAL,NSAM,NROW,NSI,
d127 3
a129 3
C          FOR A SMALL NUMBER OF IMAGES TO BE ALIGNED USE DIFFERENT 
C          STRATEGY TO MAKE MP EFFICIENT.
           CALL  MRQLI_SS(ILIST,NIMA,IRIST,NTOTAL,NSAM,NROW,NSI,
d138 2
a139 5

2600     FORMAT (/' ',80('-'),//,
     &            ' ',' MULTI-REFERENCE ALIGNMENT,  ',
     &                'END OF COMPUTATION',//,
     &            ' ',80('-')/)
d141 1
a141 2


d144 1
a144 1
C    MRQLI_SS.F 
d160 3
a162 1

a164 1

d247 1
a247 1
     &           REFER_CIRC(1,IMI), LCIRC,NRING,MODE)
d301 2
a302 1
	  CALL  FRNGS(A_CIRC(1,IT/ISTEP,JT/ISTEP),LCIRC,NUMR,NRING)
d305 2
a306 3
     &		(REFER_CIRC(1,IR),A_CIRC(1,IT/ISTEP,JT/ISTEP),
     &          LCIRC,NRING,
     &		MAXRIN,NUMR,
d405 1
a405 2
	CALL NORMAS(A,NSB-ISX,NSE-ISX,NRB-ISY,NRE-ISY,
     &              NUMR,NUMR(1,NRING))
d407 1
a407 1
     &   (A,NSAM,NROW,CNS2,CNR2,NUMR,A_CIRC,LCIRC,NRING,MODE)
d488 1
a488 2
	CALL NORMAS(A,NSB-IMX,NSE-IMX,NRB-IMY,NRE-IMY,NUMR,
     &              NUMR(1,NRING))
d546 2
a547 2


d550 1
a550 1
C MRQLI_PS.F
d562 2
d566 3
a568 1

a570 1

d582 1
a582 1

d602 1
a602 1

d611 1
a611 1

d613 1
a613 1

d630 1
a630 1

d632 1
a632 1

d635 3
a637 4
	  CALL NORMASS(A(1,1,IMI-IMIT+1),NSB,NSE,NRB,NRE,NUMR,
     &                NUMR(1,NRING))
	  CALL  ALRQS(A(1,1,IMI-IMIT+1),NSAM,NROW,NUMR,
     &                REFER_CIRC(1,IMI),
d643 1
a643 1

d645 2
a646 1

d682 1
a682 1
C output (in DLIST position is increased by 1, #1 is the key).
@


1.39
log
@ibm did not like line length, etc
@
text
@d3 1
a3 1
C    MRQLI.FOR
d15 1
a15 1
C   MRQLI.FOR
d17 1
a17 1
C       SUBROUTINE MRQLI
d26 1
a26 1
C         SUBROUTINE  FRNGS
d33 1
d44 1
d46 1
a46 1
C
d48 1
a48 1
C  ASK FOR DATA FILE
d50 1
a50 1
     &   'Enter template for 2-D reference image name',IRTFLG)
d52 14
a65 11
         IF(NIMA.GT.0)  THEN
         WRITE(NOUT,2001) NIMA
2001     FORMAT('  Number of images =',I5)
         ELSE
         WRITE(NOUT,*)  '  No images !'
         RETURN
         ENDIF
C     GET FIRST PICTURE TO DETERMINE DIMS
         CALL  FILGET(FINPAT,FINPIC,NLET,ILIST(1),INTFLG)
	 MAXIM = 0
	 CALL OPFILE(.FALSE.,FINPIC,INPIC,'O',IFORM,NSAM,NROW,NSLICE,
d67 10
a76 10
         IF(IRTFLG.NE.0)  THEN
          CALL ERRT(4,'AP MQ ',NE)
          RETURN
         ENDIF
         CLOSE(INPIC)
C
	CALL  RDPRMI(NSI,ISTEP,NLOOP,ILOOP,'Search range, step size')
	NSI=MAX0(NSI,1)
	ISTEP=MAX0(ISTEP,1)
C
d78 3
a80 3
         IF(NR.GT.NSAM/2-1)  THEN
          NR=NSAM/2-1
          WRITE(NOUT,*)  ' Last ring limited to ',NR
d86 2
a87 2
         DO    I=MR,NR,ISKIP
          NRING=NRING+1
d89 4
a92 2
	ALLOCATE(NUMR(3,NRING),STAT=IRTFLG)
	IF(IRTFLG.NE.0) CALL ERRT(46,'AP MQ, NUMR',IER)
d108 1
a108 1
C
d111 16
a126 24
C
	ALLOCATE(IRIST(NILMAX))
C
C  images to be aligned
	CALL FILELIST(.TRUE.,INPIC,FILTOA,NLETI,IRIST,NILMAX,NTOTAL,
     &   'ENTER TEMPLATE FOR 2-D IMAGES TO BE ALIGNED',IRTFLG)
	IF(IRTFLG.NE.0) RETURN
C
#ifdef SP_MP
c$omp parallel private(np)
        np = OMP_GET_NUM_THREADS()
c$omp single
        NUMTH=np
c$omp end single
c$omp end parallel
#else
         NUMTH=1
#endif
C
C NIMA number of the reference images
C
	IF(NTOTAL.GE.NUMTH)  THEN
C for mp, large number of images to be aligned, or sp.
         CALL  MRQLI_PS(ILIST,NIMA,IRIST,NTOTAL,NSAM,NROW,NSI,
d129 3
a131 3
C  For a small number of images to be aligned use different strategy
C  to make mp efficient.
         CALL  MRQLI_SS(ILIST,NIMA,IRIST,NTOTAL,NSAM,NROW,NSI,
d140 5
a144 2
2600     FORMAT (/' ',80('-')//' ',' Multi-reference alignment,  ',
     &   'end of computation',//' ',80('-')/)
d146 2
a147 1
C
d150 1
a150 1
C $$ MRQLI_SS.FOR
d166 1
a166 3
C
C $$ MRQLI_SS.FOR
C
d169 1
d553 2
a554 2
C
C
d648 1
a648 1
C
d650 1
a650 2
C
C
@


1.38
log
@*** empty log message ***
@
text
@d3 1
a3 1
C    MRQLI.F
d15 2
d97 2
a98 1
	CALL ERRT(101,'Search range has to be divisible by step size',NE)
d109 1
a109 1
     &   'Enter template for 2-D images to be aligned',IRTFLG)
d250 1
a250 1
     &          REFER_CIRC(1,IMI), LCIRC,NRING,MODE)
d304 1
a304 2
	  CALL  FRNGS(A_CIRC(1,IT/ISTEP,JT/ISTEP),LCIRC,
     &                NUMR,NRING)
d307 3
a309 2
     &		(REFER_CIRC(1,IR),A_CIRC(1,IT/ISTEP,JT/ISTEP),LCIRC,
     &          NRING,MAXRIN,NUMR,
d408 2
a409 1
	CALL NORMAS(A,NSB-ISX,NSE-ISX,NRB-ISY,NRE-ISY,NUMR,NUMR(1,NRING))
d411 1
a411 1
     &          (A,NSAM,NROW,CNS2,CNR2,NUMR,A_CIRC,LCIRC,NRING,MODE)
d492 2
a493 1
	CALL NORMAS(A,NSB-IMX,NSE-IMX,NRB-IMY,NRE-IMY,NUMR,NUMR(1,NRING))
d555 1
a555 1
C $$ MRQLI_PS.FOR
a566 2
C
C
d569 1
a569 3
C
C $$ MRQLI_PS.FOR
C
d572 1
d584 1
a584 1
C
d604 1
a604 1
C
d613 1
a613 1
C
d615 1
a615 1
C
d632 1
a632 1
C
d634 1
a634 2
C
         ITEMP = IMIT+NUMTH-1
d636 3
a638 3
	 DO  IMI=IMIT,MIN(NIMA,ITEMP)
	  CALL NORMASS(A(1,1,IMI-IMIT+1),NSB,NSE,NRB,NRE,
     &                 NUMR,NUMR(1,NRING))
d640 2
a641 1
     &                REFER_CIRC(1,IMI), LCIRC,NRING,MODE)
d646 1
a646 1
C!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
d648 1
a648 1
C!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
d685 1
a685 1
C output (in DLIST position is increased by 1, No.1 is the key).
@


1.37
log
@line length over 72
@
text
@d633 1
d635 1
a635 1
	 DO  IMI=IMIT,MIN(NIMA,IMIT+NUMTH-1)
d638 2
a639 2
	  CALL  ALRQS(A(1,1,IMI-IMIT+1),NSAM,NROW,NUMR,REFER_CIRC(1,IMI),
     &		LCIRC,NRING,MODE)
@


1.36
log
@ # continue char fails on NT f90
@
text
@d177 2
a178 1
	DIMENSION  TOT(NIMA,-NSI:NSI,-NSI:NSI),TMT(NIMA,-NSI:NSI,-NSI:NSI)
d246 2
a247 2
	  CALL  ALRQS(AI(1,1,IMI-IMIT+1),NSAM,NROW,NUMR,REFER_CIRC(1,IMI),
     &		LCIRC,NRING,MODE)
d635 2
a636 1
	  CALL NORMASS(A(1,1,IMI-IMIT+1),NSB,NSE,NRB,NRE,NUMR,NUMR(1,NRING))
@


1.35
log
@overlength lines fixed
@
text
@d3 1
a3 1
C    MRQLI.FOR
a14 2
C   MRQLI.FOR
C
d139 1
a139 1
     #   'end of computation',//' ',80('-')/)
d680 1
a680 1
C output (in DLIST position is increased by 1, #1 is the key).
@


1.34
log
@negative mirror
@
text
@d302 2
a303 1
	  CALL  FRNGS(A_CIRC(1,IT/ISTEP,JT/ISTEP),LCIRC,NUMR,NRING)
d306 2
a307 2
     &		(REFER_CIRC(1,IR),A_CIRC(1,IT/ISTEP,JT/ISTEP),LCIRC,NRING,
     &		MAXRIN,NUMR,
d408 1
a408 1
     &   (A,NSAM,NROW,CNS2,CNR2,NUMR,A_CIRC,LCIRC,NRING,MODE)
@


1.33
log
@*** empty log message ***
@
text
@a256 2
c find max element on ILIST
	MAXIMA=MAXVAL(ILIST)
d334 1
a334 1
	   E6=ILIST(IR)
d426 1
a426 1
         DLIST(2)=E6+MAXIMA
d578 1
a641 2
c find max element on ILIST
	MAXIMA=MAXVAL(ILIST)
d673 1
a673 1
     &	   NSB,NSE,NRB,NRE,LCIRC,NRING,MAXRIN,ILIST,NIMA,MAXIMA,MODE,
d677 1
a677 1
     &		DLIST(2,IMI-IMIT+1),
d690 2
d709 2
a710 2
     &	   NSB,NSE,NRB,NRE,LCIRC,NRING,MAXRIN,ILIST,NIMA,MAXIMA,MODE,
     &	   DLIST2,D5,D4,XSHSUM,YSHSUM)
a712 1
	INTEGER  ILIST(NIMA)
d752 1
a752 1
	   D6=ILIST(IR)
d760 1
a760 1
	   E6=ILIST(IR)
d769 1
a769 1
        DLIST2=D6
d850 1
a850 1
        DLIST2=E6+MAXIMA
@


1.32
log
@*** empty log message ***
@
text
@d676 1
a676 1
     &	   NSB,NSE,NRB,NRE,LCIRC,NRING,MAXRIN,NIMA,MAXIMA,MODE,
d710 1
a710 1
     &	   NSB,NSE,NRB,NRE,LCIRC,NRING,MAXRIN,NIMA,MAXIMA,MODE,
d714 1
d754 1
a754 1
	   D6=IR
d762 1
a762 1
	   E6=IR
@


1.31
log
@*** empty log message ***
@
text
@a948 603
C
        SUBROUTINE  NORMASC(X,Y,NS1,NS2,NR1,NR2,IR1,IR2)
        DIMENSION  X(NS1:NS2,NR1:NR2),Y(NS1:NS2,NR1:NR2)
        INTEGER  IR1,IR2
        REAL*8  AV,VR
        R1=IR1
        R2=IR2
        AV=0.0
        VR=0.0
        N=0
        DO    J=NR1,NR2
         DO    I=NS1,NS2
          R=SQRT(FLOAT(J*J+I*I))
          IF(R.GE.R1.AND.R.LE.R2)  THEN
	   N=N+1
           AV=AV+X(I,J)
           VR=VR+X(I,J)*X(I,J)
          ENDIF
        ENDDO
        ENDDO
C
        AV=AV/N
        VR=DSQRT((VR-N*AV*AV)/(N-1))
C
        Y=(X-AV)/VR
        END
C
        SUBROUTINE  NORMASS(X,NS1,NS2,NR1,NR2,IR1,IR2)
        DIMENSION  X(NS1:NS2,NR1:NR2)
        INTEGER  IR1,IR2
        REAL*8  AV,VR
        R1=IR1
        R2=IR2
        AV=0.0
        VR=0.0
        N=0
        DO    J=NR1,NR2
         DO    I=NS1,NS2
          R=SQRT(FLOAT(J*J+I*I))
          IF(R.GE.R1.AND.R.LE.R2)  THEN
	   N=N+1
           AV=AV+X(I,J)
           VR=VR+X(I,J)*X(I,J)
          ENDIF
        ENDDO
        ENDDO
C
        AV=AV/N
        VR=DSQRT((VR-N*AV*AV)/(N-1))
C
        X=(X-AV)/VR
        END
C
        SUBROUTINE  ALRQ_MS
     &  (XIM,NSAM,NROW,CNS2,CNR2,NUMR,CIRC,LCIRC,NRING,MODE)
        DIMENSION  XIM(NSAM,NROW),CIRC(LCIRC)
        INTEGER  NUMR(3,NRING)
        CHARACTER*1  MODE
        DOUBLE PRECISION  PI,DFI
C
C  INTERPOLATION INTO POLAR COORDINATES
C
C        CNS2 and CNR2 are predefined centers
CC no need to set to zero, all elements are defined
C        DO  10  I=1,LCIRC
C 10     CIRC(I)=0.0
C
        PI=2*DATAN(1.0D0)
        DO  I=1,NRING
C
C  RADIUS OF THE RING
        INR=NUMR(1,I)
        YQ=INR
C
        L=NUMR(3,I)
        IF(MODE.EQ.'H')  THEN
        LT=L/2
        ENDIF
        IF(MODE.EQ.'F')  THEN
        LT=L/4
        ENDIF
        NSIM=LT-1
        DFI=PI/(NSIM+1)
        KCIRC=NUMR(2,I)
        XOLD=0.0
        YOLD=INR
        CIRC(KCIRC)=QUADRI(XOLD+CNS2,YOLD+CNR2,NSAM,NROW,XIM)
        XOLD=INR
        YOLD=0.0
        CIRC(LT+KCIRC)=QUADRI(XOLD+CNS2,YOLD+CNR2,NSAM,NROW,XIM)
        IF(MODE.EQ.'F')  THEN
        XOLD=0.0
        YOLD=-INR
        CIRC(LT+LT+KCIRC)=QUADRI(XOLD+CNS2,YOLD+CNR2,NSAM,NROW,XIM)
        XOLD=-INR
        YOLD=0.0
        CIRC(LT+LT+LT+KCIRC)=QUADRI(XOLD+CNS2,YOLD+CNR2,NSAM,NROW,XIM)
        ENDIF
        DO   J=1,NSIM
        FI=DFI*J
        X=SIN(FI)*YQ
        Y=COS(FI)*YQ
C
        XOLD=X
        YOLD=Y
        CIRC(J+KCIRC)=QUADRI(XOLD+CNS2,YOLD+CNR2,NSAM,NROW,XIM)
        XOLD=Y
        YOLD=-X
        CIRC(J+LT+KCIRC)=QUADRI(XOLD+CNS2,YOLD+CNR2,NSAM,NROW,XIM)
        IF(MODE.EQ.'F')  THEN
        XOLD=-X
        YOLD=-Y
        CIRC(J+LT+LT+KCIRC)=QUADRI(XOLD+CNS2,YOLD+CNR2,NSAM,NROW,XIM)
        XOLD=-Y
        YOLD=X
        CIRC(J+LT+LT+LT+KCIRC)=QUADRI(XOLD+CNS2,YOLD+CNR2,NSAM,NROW,XIM)
        ENDIF
	ENDDO
	ENDDO
C
        END
C++************************************************************************
C
C $$ CROSRNG_MS.FOR
C
C **************************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
C *  COPYRIGHT (C)1981,1987, WADSWORTH CENTER FOR LABORATORIES AND         *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *  THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR       *
C *  LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR    *
C *  USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF     *
C *  THE CENTER FOR LABORATORIES AND RESEARCH                              *
C **************************************************************************
C
C
C
C23456789012345678901234567890123456789012345678901234567890123456789012
C--************************************************************************
C
C $$ CROSRNG_MS.FOR
C
	SUBROUTINE  CROSRNG_MS
     &   (CIRC1,CIRC2,LCIRC,NRING,MAXRIN,NUMR,QN,TOT,QM,TMT,TT)
C
C  INPUT - Fourier transforms of rings!!!
C  CIRC1 already multiplied by weights!!
C
	INTEGER  NUMR(3,NRING),MAXRIN,NUMR3I,NUMR2I
	DIMENSION  CIRC1(LCIRC),CIRC2(LCIRC)
	DOUBLE PRECISION  TT(*)
	DOUBLE PRECISION  QN,QM,T7(-3:3)
C  Automatic arrays
	DOUBLE PRECISION  T(MAXRIN+2),Q(MAXRIN+2)
	IP=MAXRIN
#ifdef SP_LIBFFT
#else
	IP=-LOG2_P(IP)
#endif
C
C C - straight  = CIRC1*CONJG(CIRC2)
	Q=0.0D0
C T - mirrored  = CONJG(CIRC1)*CONJG(CIRC2)
	T=0.0D0
C
	DO    I=1,NRING
	NUMR3I=NUMR(3,I)
	NUMR2I=NUMR(2,I)
C
	T1=CIRC1(NUMR2I)*CIRC2(NUMR2I)
	Q(1)=Q(1)+T1
	T(1)=T(1)+T1
C
	IF(NUMR3I.EQ.MAXRIN)  THEN
	T1=CIRC1(NUMR2I+1)*CIRC2(NUMR2I+1)
	Q(2)=Q(2)+T1
	T(2)=T(2)+T1
C
	ELSE
	T1=CIRC1(NUMR2I+1)*CIRC2(NUMR2I+1)
	Q(NUMR3I+1)=Q(NUMR3I+1)+T1
C###
	ENDIF
C
	DO   J=3,NUMR3I,2
	JC=J+NUMR2I-1
	C1=CIRC1(JC)
	C2=CIRC1(JC+1)
	T1=C1*CIRC2(JC)
	T2=C2*CIRC2(JC+1)
	T3=C1*CIRC2(JC+1)
	T4=C2*CIRC2(JC)
	Q(J)=Q(J)+T1+T2
	Q(J+1)=Q(J+1)-T3+T4
	T(J)=T(J)+T1-T2
	T(J+1)=T(J+1)-T3-T4
	ENDDO
	ENDDO
C  STRAIGHT
#ifdef SP_LIBFFT
	INV=-1
	LDA=1
	Q(MAXRIN+1)=Q(2)
	Q(2)=0.0
	Q(MAXRIN+2)=0.0
	CALL  ZDFFT1DU(INV,IP,Q,LDA,TT)
C skip the normalization, divide the maximum instead.
C	CALL  DSCAL1D(IP,1.0D0/DBLE(FLOAT(IP)),Q,LDA)
#else
	CALL  FFTR_D(Q,IP)
#endif
C
	QN=-1.0D20
	DO    J=1,MAXRIN
	IF(Q(J).GE.QN)  THEN
	QN=Q(J)
	JTOT=J
	ENDIF
	ENDDO
#ifdef SP_LIBFFT
	QN=QN/MAXRIN
#endif
C
	DO    K=-3,3
        J=MOD(JTOT+K+MAXRIN-1,MAXRIN)+1
	T7(K)=Q(J)
	ENDDO
	CALL  PRB1D(T7,7,POS)
	TOT=FLOAT(JTOT)+POS
C  MIRRORED
#ifdef SP_LIBFFT
 	T(MAXRIN+1)=T(2)
	T(2)=0.0
	T(MAXRIN+2)=0.0
	CALL  ZDFFT1DU(INV,IP,T,LDA,TT)
C skip the normalization, divide the maximum instead.
C	CALL  DSCAL1D(IP,1.0D0/DBLE(FLOAT(IP)),T,LDA)
#else
	CALL  FFTR_D(T,IP)
#endif
C
	QM=-1.0D20
	DO    J=1,MAXRIN
	IF(T(J).GE.QM)  THEN
	QM=T(J)
	JTOT=J
	ENDIF
	ENDDO
#ifdef SP_LIBFFT
	QM=QM/MAXRIN
#endif
C
	DO    K=-3,3
        J=MOD(JTOT+K+MAXRIN-1,MAXRIN)+1
	T7(K)=T(J)
	ENDDO
	CALL  PRB1D(T7,7,POS)
	TMT=FLOAT(JTOT)+POS
	END
C++************************************************************************
C
C $$ CROSRMG_DS.FOR
C
C **************************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
C *  COPYRIGHT (C)1981,1987, WADSWORTH CENTER FOR LABORATORIES AND         *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *  THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR       *
C *  LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR    *
C *  USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF     *
C *  THE CENTER FOR LABORATORIES AND RESEARCH                              *
C **************************************************************************
C
C
C
C23456789012345678901234567890123456789012345678901234567890123456789012
C--************************************************************************
C
C $$ CROSRMG_DS.FOR
C
	SUBROUTINE  CROSRMG_DS
     &   (CIRC1,CIRC2,LCIRC,NRING,MAXRIN,NUMR,QN,TOT,TT)
C
C  INPUT - Fourier transforms of rings!!!
C  First set is conjugated (mirrored)
C  CIRC1 already multiplied by weights!!
C
	INTEGER  NUMR(3,NRING),MAXRIN,NUMR3I,NUMR2I
	DIMENSION  CIRC1(LCIRC),CIRC2(LCIRC)
	DOUBLE PRECISION  TT(*)
	DOUBLE PRECISION  QN,T7(-3:3)
C  Automatic arrays
	DIMENSION  T(MAXRIN+2)
	DOUBLE PRECISION  Q(MAXRIN+2)
	IP=MAXRIN
#ifdef SP_LIBFFT
#else
	IP=-LOG2_P(IP)
#endif
C
	Q=0.0D0
	T(MAXRIN+1)=0.0
	T(MAXRIN+2)=0.0
C
	DO    I=1,NRING
	NUMR3I=NUMR(3,I)
	NUMR2I=NUMR(2,I)
C
	T(1)=(CIRC1(NUMR2I))*CIRC2(NUMR2I)
	IF(NUMR3I.EQ.MAXRIN)  THEN
	T(2)=(CIRC1(NUMR2I+1))*CIRC2(NUMR2I+1)
	DO    J=3,MAXRIN,2
	JC=J+NUMR2I-1
	T(J)=(CIRC1(JC))*CIRC2(JC)-(CIRC1(JC+1))*CIRC2(JC+1)
	T(J+1)=-(CIRC1(JC))*CIRC2(JC+1)-(CIRC1(JC+1))*CIRC2(JC)
	ENDDO
	Q=Q+T
	ELSE
	T(NUMR3I+1)=(CIRC1(NUMR2I+1))*CIRC2(NUMR2I+1)
	T(2)=0.0
	DO    J=3,NUMR3I,2
	JC=J+NUMR2I-1
	T(J)=(CIRC1(JC))*CIRC2(JC)-(CIRC1(JC+1))*CIRC2(JC+1)
	T(J+1)=-(CIRC1(JC))*CIRC2(JC+1)-(CIRC1(JC+1))*CIRC2(JC)
	ENDDO
C  ###
	DO    J=1,NUMR3I+1
	Q(J)=Q(J)+T(J)
	ENDDO
	ENDIF
	ENDDO
C
#ifdef SP_LIBFFT
	INV=-1
	LDA=1
	Q(MAXRIN+1)=Q(2)
	Q(2)=0.0
	Q(MAXRIN+2)=0.0
	CALL  ZDFFT1DU(INV,IP,Q,LDA,TT)
C skip the normalization, divide the maximum instead.
C	CALL  DSCAL1D(IP,1.0D0/DBLE(FLOAT(IP)),Q,LDA)
#else
	CALL  FFTR_D(Q,IP)
#endif
C
	QN=-1.0D20
	DO    J=1,MAXRIN
	IF(Q(J).GE.QN)  THEN
	QN=Q(J)
	JTOT=J
	ENDIF
	ENDDO
#ifdef SP_LIBFFT
	QN=QN/MAXRIN
#endif
	DO    K=-3,3
        J=MOD(JTOT+K+MAXRIN-1,MAXRIN)+1
	T7(K)=Q(J)
	ENDDO
	CALL  PRB1D(T7,7,POS)
	TOT=FLOAT(JTOT)+POS
	END
C++************************************************************************
C
C $$ CROSRNG_DS.FOR
C
C **************************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
C *  COPYRIGHT (C)1981,1987, WADSWORTH CENTER FOR LABORATORIES AND         *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *  THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR       *
C *  LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR    *
C *  USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF     *
C *  THE CENTER FOR LABORATORIES AND RESEARCH                              *
C **************************************************************************
C
C
C
C23456789012345678901234567890123456789012345678901234567890123456789012
C--************************************************************************
C
C $$ CROSRNG_DS.FOR
C
	SUBROUTINE  CROSRNG_DS
     &   (CIRC1,CIRC2,LCIRC,NRING,MAXRIN,NUMR,QN,TOT,TT)
C
C  INPUT - Fourier transforms of rings!!!
C  CIRC1 already multiplied by weights!!
C
	INTEGER  NUMR(3,NRING),MAXRIN,NUMR3I,NUMR2I
	DIMENSION  CIRC1(LCIRC),CIRC2(LCIRC)
	DOUBLE PRECISION  TT(*)
	DOUBLE PRECISION  QN,T7(-3:3)
C Automatic arrays
	DIMENSION  T(MAXRIN+2)
	DOUBLE PRECISION  Q(MAXRIN+2)
C
	IP=MAXRIN
#ifdef SP_LIBFFT
#else
	IP=-LOG2_P(IP)
#endif
C
	Q=0.0D0
	T(MAXRIN+1)=0.0
	T(MAXRIN+2)=0.0
C
	DO    I=1,NRING
	NUMR3I=NUMR(3,I)
	NUMR2I=NUMR(2,I)
C
	T(1)=(CIRC1(NUMR2I))*CIRC2(NUMR2I)
	IF(NUMR3I.EQ.MAXRIN)  THEN
	T(2)=(CIRC1(NUMR2I+1))*CIRC2(NUMR2I+1)
	DO    J=3,MAXRIN,2
	JC=J+NUMR2I-1
	T(J)=(CIRC1(JC))*CIRC2(JC)+(CIRC1(JC+1))*CIRC2(JC+1)
	T(J+1)=-(CIRC1(JC))*CIRC2(JC+1)+(CIRC1(JC+1))*CIRC2(JC)
	ENDDO
	Q=Q+T
	ELSE
	T(NUMR3I+1)=(CIRC1(NUMR2I+1))*CIRC2(NUMR2I+1)
	T(2)=0.0
	DO    J=3,NUMR3I,2
	JC=J+NUMR2I-1
	T(J)=(CIRC1(JC))*CIRC2(JC)+(CIRC1(JC+1))*CIRC2(JC+1)
	T(J+1)=-(CIRC1(JC))*CIRC2(JC+1)+(CIRC1(JC+1))*CIRC2(JC)
	ENDDO
C###
	DO    J=1,NUMR3I+1
	Q(J)=Q(J)+T(J)
	ENDDO
	ENDIF
	ENDDO
C
#ifdef SP_LIBFFT
	INV=-1
	LDA=1
	Q(MAXRIN+1)=Q(2)
	Q(2)=0.0
	Q(MAXRIN+2)=0.0
	CALL  ZDFFT1DU(INV,IP,Q,LDA,TT)
C skip the normalization, divide the maximum instead.
C	CALL  DSCAL1D(IP,1.0D0/DBLE(FLOAT(IP)),Q,LDA)
#else
	CALL  FFTR_D(Q,IP)
#endif
C
	QN=-1.0D20
	DO    J=1,MAXRIN
	IF(Q(J).GE.QN)  THEN
	QN=Q(J)
	JTOT=J
	ENDIF
	ENDDO
#ifdef SP_LIBFFT
	QN=QN/MAXRIN
#endif
C
	DO    K=-3,3
        J=MOD(JTOT+K+MAXRIN-1,MAXRIN)+1
	T7(K)=Q(J)
	ENDDO
	CALL  PRB1D(T7,7,POS)
	TOT=FLOAT(JTOT)+POS
	END
C++************************************************************************
C
C $$ FRNGS.FOR
C
C **************************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
C *  COPYRIGHT (C)1981,1987, WADSWORTH CENTER FOR LABORATORIES AND         *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *  THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR       *
C *  LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR    *
C *  USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF     *
C *  THE CENTER FOR LABORATORIES AND RESEARCH   			   *
C **************************************************************************
C
C
C
C23456789012345678901234567890123456789012345678901234567890123456789012
C--************************************************************************
C
C $$ FRNGS.FOR
C
         SUBROUTINE  FRNGS(CIRC,LCIRC,NUMR,NRING)
         INTEGER  NUMR(3,NRING)
         DIMENSION  CIRC(LCIRC)
         DO    I=1,NRING
          L=LOG2_P(NUMR(3,I))
          CALL  FFTR_Q(CIRC(NUMR(2,I)),L)
	 ENDDO
         END
C++************************************************************************
C
C $$ APPLYWS.FOR
C
C **************************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
C *  COPYRIGHT (C)1981,1987, WADSWORTH CENTER FOR LABORATORIES AND         *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *  THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR       *
C *  LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR    *
C *  USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF     *
C *  THE CENTER FOR LABORATORIES AND RESEARCH   			   *
C **************************************************************************
C
C
C
C23456789012345678901234567890123456789012345678901234567890123456789012
C--************************************************************************
C
C $$ APPLYWS.FOR
C
	SUBROUTINE  APPLYWS(CIRC,LCIRC,NUMR,WR,NRING,MAXRIN)
	INTEGER  NUMR(3,NRING),MAXRIN,NUMR3I,NUMR2I
	DIMENSION  CIRC(LCIRC),WR(NRING)
	DO    I=1,NRING
	 NUMR3I=NUMR(3,I)
	 NUMR2I=NUMR(2,I)
	 W=WR(I)
	 CIRC(NUMR2I)=CIRC(NUMR2I)*W
	 IF(NUMR3I.EQ.MAXRIN)  THEN
	  CIRC(NUMR2I+1)=CIRC(NUMR2I+1)*W
	 ELSE
	  CIRC(NUMR2I+1)=CIRC(NUMR2I+1)*0.5*W
	 ENDIF
C
	 DO    J=3,NUMR3I
	  JC=J+NUMR2I-1
	  CIRC(JC)=CIRC(JC)*W
	 ENDDO
	ENDDO
	END
C
 	SUBROUTINE  ALRQS
     &	(XIM,NSAM,NROW,NUMR,CIRC,LCIRC,NRING,MODE)
	DIMENSION  XIM(NSAM,NROW),CIRC(LCIRC)
	INTEGER  NUMR(3,NRING)
	CHARACTER*1  MODE
	DOUBLE PRECISION  PI,DFI
C
C  INTERPOLATION INTO POLAR COORDINATES
CC no need to set CIRC to zero, all elements are defined
C
	NS2=NSAM/2+1
	NR2=NROW/2+1
	PI=2*DATAN(1.0D0)
	DO I=1,NRING
C
C  RADIUS OF THE RING
	INR=NUMR(1,I)
	YQ=INR
C
	L=NUMR(3,I)
	IF(MODE.EQ.'H')  THEN
	LT=L/2
	ENDIF
	IF(MODE.EQ.'F')  THEN
	LT=L/4
	ENDIF
	NSIM=LT-1
	DFI=PI/(NSIM+1)
	KCIRC=NUMR(2,I)
	XOLD=0.0
	YOLD=INR
	CIRC(KCIRC)=QUADRI(XOLD+NS2,YOLD+NR2,NSAM,NROW,XIM)
	XOLD=INR
	YOLD=0.0
	CIRC(LT+KCIRC)=QUADRI(XOLD+NS2,YOLD+NR2,NSAM,NROW,XIM)
	IF(MODE.EQ.'F')  THEN
	XOLD=0.0
	YOLD=-INR
	CIRC(LT+LT+KCIRC)=QUADRI(XOLD+NS2,YOLD+NR2,NSAM,NROW,XIM)
	XOLD=-INR
	YOLD=0.0
	CIRC(LT+LT+LT+KCIRC)=QUADRI(XOLD+NS2,YOLD+NR2,NSAM,NROW,XIM)
	ENDIF
	DO  J=1,NSIM
	FI=DFI*J
	X=SIN(FI)*YQ
	Y=COS(FI)*YQ
C
	XOLD=X
	YOLD=Y
	CIRC(J+KCIRC)=QUADRI(XOLD+NS2,YOLD+NR2,NSAM,NROW,XIM)
	XOLD=Y
	YOLD=-X
	CIRC(J+LT+KCIRC)=QUADRI(XOLD+NS2,YOLD+NR2,NSAM,NROW,XIM)
	IF(MODE.EQ.'F')  THEN
	XOLD=-X
	YOLD=-Y
	CIRC(J+LT+LT+KCIRC)=QUADRI(XOLD+NS2,YOLD+NR2,NSAM,NROW,XIM)
	XOLD=-Y
	YOLD=X
	CIRC(J+LT+LT+LT+KCIRC)=QUADRI(XOLD+NS2,YOLD+NR2,NSAM,NROW,XIM)
	ENDIF
	ENDDO
	ENDDO
C
	END
@


1.30
log
@*** empty log message ***
@
text
@d248 1
a248 1
     &		LCIRC,NRING,MODE,IPIC)
d638 1
a638 1
     &		LCIRC,NRING,MODE,IPIC)
d1487 1
a1487 1
     &	(XIM,NSAM,NROW,NUMR,CIRC,LCIRC,NRING,MODE,IPIC)
@


1.29
log
@bugs in PARABL fixed
@
text
@d17 1
a17 1
C       SUBROUTINE MRQLI(MAXMEM)
d32 1
a32 1
	SUBROUTINE MRQLI(MAXMEM)
@


1.28
log
@*** empty log message ***
@
text
@d483 1
a483 1
	   CALL  PARABLD(FIT,SX,SY,PEAK)
d904 1
a904 1
	CALL  PARABLD(FIT,SX,SY,PEAK)
@


1.27
log
@prints removed
@
text
@d524 1
a524 13



c	  CALL  APMQ2S(A,REFER_CIRC,TT,NUMR,
c     &	   NSAM,NROW,NSI,ISTEP,ILIST,
c     &	   NSB,NSE,NRB,NRE,LCIRC,NRING,MAXRIN,NIMA,MAXIMA,MODE,
C Output parameters are:
C Number of the most similar reference projection.
C Corr coeff.(D5), Angle (D4), Shift: XSHSUM, YSHSUM
c     &		DLIST(2),
c     &		DLIST(3),DLIST(4),
c     &		DLIST(5),DLIST(6))
C output (in DLIST position is increased by 1, #1 is the key).
@


1.26
log
@New f90 version
@
text
@a199 1
	print  *,' MRQLI_SS'
a599 1
	print  *,' MRQLI_PS'
@


1.25
log
@Last version that has f77 code included
@
text
@a0 2
C   f77 code is at the very end of this file.
#ifdef SP_F90
d17 8
a24 3
C        SUBROUTINE MRQLI(MAXMEM)
C         SUBROUTINE  MRQLI_P(ILIST,NSAM,NROW,NSI,NIMA,MODE,
C        SUBROUTINE  CROSRNG_DS
d26 3
a28 5
C        SUBROUTINE  FOURING_M(CIRC,LCIRC,NUMR,NRING)
C        SUBROUTINE  ALRQ_M
C	CALL NORMAS(A,-NSAM/2,NSAM/2,-NROW/2,NROW/2,
C	CALL  ALRQ(A,NSAM,NROW,NUMR,REFER_CIRC(1,IMI),
C	CALL  FOURING
d33 1
a33 3
	PARAMETER  (NILMAX=21000)
	PARAMETER  (MNUMR=480)
        INTEGER    NUMR(3,MNUMR)
a34 5
	COMMON  BUF(1024),ILIST(NILMAX),NUMR,BAF(1)
        INCLUDE 'F90ALLOC.INC'
        REAL, DIMENSION(:), POINTER :: IPQ
        REAL, DIMENSION(:), POINTER :: Q
	LOGICAL         RUNTIME
d36 2
a37 2
	COMMON  /FISPEC/  FINPAT,FINPIC,DOCFIL,NLET,NLETI
	CHARACTER*80  FINPAT,FINPIC,DOCFIL
d40 3
a42 1
	CHARACTER*1  NULL,MODE
d44 2
a45 1
	NULL=CHAR(0)
d47 1
a47 1
	CALL  FILERD(FINPAT,NLET,NULL,
d49 1
a49 18
	CALL  FILERD(DOCFIL,NLETI,NULL,'Selection doc',IRTFLG)
         K=0
         K2=1
         NIMA=0
778      LERR=-1
         IF(NIMA.EQ.NILMAX)  THEN
         WRITE(NOUT,*) '  Too many images, list truncated'
         GOTO  779
         ENDIF
         KP1=K+1
         CALL  UNSAV(DOCFIL,K,INPIC,KP1,BUF,1,LERR,K2)
         IF(LERR.EQ.0)  THEN
         NIMA=NIMA+1
         ILIST(NIMA)=BUF(1)
         K=K+1
         GOTO  778
         ENDIF
779      CLOSE(INPIC)
d52 1
a52 1
2001     FORMAT('  Number of images =',i5)
d57 1
d59 6
a64 4
         CALL  OPENFB(BUF,FINPIC,INPIC,NSAM,NROW,'O',NF,NSL)
         IF(NF.NE.2)  THEN
         CALL ERRT(4,'AP MQ ',NE)
         RETURN
d74 2
a75 2
         NR=NSAM/2-1
         WRITE(NOUT,*)  ' Last ring limited to ',NR
d82 8
a89 2
         NRING=NRING+1
         NUMR(1,NRING)=I
d92 3
a94 3
	IF(NSI+NR.GT.NSAM/2-2)  THEN
	CALL ERRT(101,'Search range too large',NE)
	RETURN
d104 7
a110 27
C   memory division    K
C       numr           1  !int*2
C       a              2
C       refer_circ     4
C       rotmpp         5 
C       fitp           6  !double precision *9
C       tt             7  !double precision 
C       tota           9 !double precision 
C       tot           10
C       tmta          11 !double precision 
C       tmt           12
C
C
C K1 not used
        K1=-1
        K2=1
         K3=IPALIGN64(K2+NSAM*NROW)
         K4=IPALIGN64(K3)
         K5=IPALIGN64(K4+LCIRC*NIMA)
         K6=IPALIGN64(K5)
         K7=IPALIGN64(K6+2*9)
#ifdef SP_LIBFFT
         K8=IPALIGN64(K7+(LCIRC+15)*2)
#else
         K8=K7
#endif
         K9=IPALIGN64(K8)
d112 6
a117 11
	NUMTH=mp_numthreads()
	IF(NIMA.GT.NUMTH)  THEN
         K10=IPALIGN64(K9+NIMA*2)
         K11=IPALIGN64(K10+NIMA)
         K12=IPALIGN64(K11+NIMA*2)
         K13=IPALIGN64(K12+NIMA)
	ELSE
C For small number of reference images do not need these
C arrays.
         K13=K9
	ENDIF
d119 1
a119 4
         K10=IPALIGN64(K9+NIMA*2)
         K11=IPALIGN64(K10+NIMA)
         K12=IPALIGN64(K11+NIMA*2)
         K13=IPALIGN64(K12+NIMA)
a120 10
        MEMTOT=K13
        MAXM=MAXMEM-1024-NILMAX-3*MNUMR
        CALL CHKMEM(MEMTOT,BAF,MAXM,RUNTIME,IPQ,IRTFLG)
              IF(IRTFLG.NE.0)  THEN
                CLOSE(INPIC)
                CALL  ERRT(6,'AP MQ',NE)
                RETURN
              ENDIF
         Q = >IPQ
	WRITE (NOUT,2500)  MEMTOT
d124 4
a127 7
#ifdef SP_MP
	IF(NIMA.GT.NUMTH)  THEN
         CALL  MRQLI_PS(ILIST,NSAM,NROW,NSI,ISTEP,NIMA,MODE,
     &          Q(K2),Q(K4),
     &          Q(K6),Q(K7),
     &          Q(K9),Q(K10),Q(K11),Q(K12),
     &          LCIRC,NUMR,NRING,MAXRIN)
d129 1
a129 1
C  For a small number of reference images use different strategy
d131 2
a132 4
         CALL  MRQLI_SS(ILIST,NSAM,NROW,NSI,ISTEP,NIMA,MODE,
     &          Q(K2),Q(K4),
     &          Q(K6),Q(K7),
     &          LCIRC,NUMR,NRING,MAXRIN)
a133 7
#else
         CALL  MRQLI_PS(ILIST,NSAM,NROW,NSI,ISTEP,NIMA,MODE,
     &          Q(K2),Q(K4),
     &          Q(K6),Q(K7),
     &          Q(K9),Q(K10),Q(K11),Q(K12),
     &          LCIRC,NUMR,NRING,MAXRIN)
#endif
d135 3
a137 1
      IF(RUNTIME)  CALL ALLOCIT(0,RUNTIME,IPQ,'AP MQ',IRTFLG)
a139 2
2500     FORMAT (/,' MEMORY RESERVATION: YOU HAVE',
     #   ' ALLOCATED ',I8)
d158 1
a158 1
C  This is version for mp and small number of reference images
d165 3
a167 4
         SUBROUTINE  MRQLI_SS(ILIST,NSAM,NROW,NSI,ISTEP,NIMA,MODE,
     &   A,REFER_CIRC,
     &	 FITP,TT,
     &   LCIRC,NUMR,NRING,MAXRIN)
d171 1
a171 1
        COMMON  BUF(1024)
a172 2
	INCLUDE 'CMBLOCK.INC'
        DIMENSION  A(NSAM,NROW),WRK(1),ILIST(NIMA)
a173 2
	DOUBLE PRECISION TT(*)
	DIMENSION  REFER_CIRC(LCIRC,NIMA)
d177 3
a179 2
	DOUBLE PRECISION  TOTA(-NSI:NSI,-NSI:NSI),TMTA(-NSI:NSI,-NSI:NSI)
	DIMENSION  TOT(-NSI:NSI,-NSI:NSI),TMT(-NSI:NSI,-NSI:NSI)
a181 2
        DIMENSION  AA(NSAM,NROW)
        DIMENSION  A_CIRC(LCIRC)
d183 11
a194 4
        CHARACTER*1  MODE,NULL
        COMMON  /FISPEC/  FINPAT,FINPIC,DOCFIL,NLET,NLETI
        CHARACTER*80  FINPAT,FINPIC,DOCFIL
        DATA  NDOC/56/,INDOC/57/,INPIC/58/
d196 5
a200 1
	CALL  RINGWE(WR,NUMR,NRING,MAXRIN)
d202 2
d205 3
d209 4
d226 15
a240 13
	DO    IMI=1,NIMA
	L=ILIST(IMI)
	NULL=CHAR(0)
	CALL  FILGET(FINPAT,FINPIC,NLET,L,INTFLAG)
	CALL  OPENFB(BUF,FINPIC,INPIC,NSAMT,NROWT,'O',NF,NSL)
         IF(NF.NE.2)  THEN
         WRITE(NOUT,*)  ' FILE NOT FOUND:',FINPIC
         RETURN
         ENDIF
	DO    J=1,NROW
	CALL  REDLIN(INPIC,A(1,J),NSAM,J)
	ENDDO
	CLOSE(INPIC)
d244 5
a248 2
	CALL NORMAS(A,NSB,NSE,NRB,NRE,NUMR,NUMR(1,NRING))
	CALL  ALRQ(A,NSAM,NROW,NUMR,REFER_CIRC(1,IMI),
d250 3
a252 2
	CALL  FRNG(REFER_CIRC(1,IMI),LCIRC,NUMR,NRING)
	CALL  APPLYW(REFER_CIRC(1,IMI),LCIRC,NUMR,WR,NRING,MAXRIN)
d254 6
a259 5
c find max element on  ILIST
	MAXIMA=ILIST(1)
	DO  IMI=1,NIMA
	MAXIMA=MAX(MAXIMA,ILIST(IMI))
	ENDDO
d263 5
d270 23
a292 37
        NULL=CHAR(0)
	CALL  FILERD(FINPAT,NLET,NULL,
     &   'Enter template for 2-D image name',IRTFLG)
	CALL  FILERD(DOCFIL,NLETI,NULL,'Selection doc',IRTFLG)
	K=0
	K2=1
	IMI=0
878      LERR=-1
         KP1=K+1
	CALL  UNSAV(DOCFIL,K,INDOC,KP1,WRK,1,LERR,K2)
	IF(LERR.EQ.0)  THEN
	IMI=IMI+1
C
	LIM=WRK(1)
	NULL=CHAR(0)
	CALL  FILGET(FINPAT,FINPIC,NLET,LIM,INTFLAG)
	CALL  OPENFB(BUF,FINPIC,INPIC,NSAMT,NROWT,'O',NF,NSL)
         IF(NF.NE.2)  THEN
         WRITE(NOUT,*)  ' FILE NOT FOUND:',FINPIC
         RETURN
         ENDIF
        IF(NSAMT.NE.NSAM.OR.NROWT.NE.NROW)  THEN
        CALL ERRT(1,'AP MQ',NE)
        CLOSE(INPIC)
	RETURN
	ENDIF
	DO    J=1,NROW
	CALL  REDLIN(INPIC,A(1,J),NSAM,J)
	ENDDO
	CLOSE(INPIC)
        DLIST(5)=-1.0E23
	QT=-1.0D23
	QM=-1.0D23
	DO    IR=1,NIMA
c go through centers
c$omp parallel do private(jt,it,cnr2,cns2,aa,a_circ),
c$omp&  shared(lcirc,nring,maxrin)
d296 1
a296 3
	 CNS2=NSAM/2+1+IT
C put A in a private array
	 AA=A
d300 9
a308 6
	 CALL NORMASS(AA,NSB-IT,NSE-IT,NRB-JT,NRE-JT,NUMR,NUMR(1,NRING))
	 CALL  ALRQ_MS
     &   (AA,NSAM,NROW,CNS2,CNR2,NUMR,A_CIRC,LCIRC,NRING,MODE)
	 CALL  FRNGS(A_CIRC,LCIRC,NUMR,NRING)
	 CALL  CROSRNG_MS
     &		(REFER_CIRC(1,IR),A_CIRC,LCIRC,NRING,
d310 3
a312 1
     &		TOTA(IT,JT),TOT(IT,JT),TMTA(IT,JT),TMT(IT,JT),TT)
d316 5
a320 1
	 DO    JT=-NSI,NSI,ISTEP
d322 3
a324 2
	  IF(TOTA(IT,JT).GE.QT)  THEN
	   QT=TOTA(IT,JT)
d328 1
a328 1
	   D4=ANG(TOT(IT,JT),MODE)
d331 2
a332 2
	  IF(TMTA(IT,JT).GE.QM)  THEN
	   QM=TMTA(IT,JT)
d336 1
a336 1
	   E4=ANG(TMT(IT,JT),MODE)
d339 1
a339 1
	 ENDDO
a340 1
C  END-OF-LOOP 1 OVER REFERENCE IMAGES
d342 1
d346 1
a346 1
        DLIST(2)=D6
d348 1
a348 1
	IF(IABS(ISX).NE.NSI.AND.IABS(ISY).NE.NSI)  THEN
d350 9
a358 11
	FIT(0,0)=QT
	ROTMP(0,0)=D4
c$omp parallel do private(jt,it,aa,a_circ,cnr2,cns2)
	DO     JT=-ISTEP,ISTEP
	DO     IT=-ISTEP,ISTEP
	IF(IT.NE.0 .OR. JT.NE.0) THEN
C put A in a private array
	AA=A
	CNR2=NROW/2+1+JT+ISY
	CNS2=NSAM/2+1+IT+ISX
	CALL NORMASS(AA,
d361 6
a366 5
	CALL  ALRQ_MS
     &   (AA,NSAM,NROW,CNS2,CNR2,NUMR,A_CIRC,LCIRC,NRING,MODE)
	CALL  FRNGS(A_CIRC,LCIRC,NUMR,NRING)
	CALL  CROSRNG_DS
     &		(REFER_CIRC(1,IBE),A_CIRC,LCIRC,NRING,
d368 4
a371 4
	ROTMP(IT,JT)=ANG(ROTMP(IT,JT),MODE)
	ENDIF
	ENDDO
	ENDDO
d375 15
a389 15
	AFIT=FIT(0,0)
	JTMA=0
	ITMA=0
	IF(ISTEP.GT.1)  THEN
	DO     JT=-ISTEP+1,ISTEP-1
	DO     IT=-ISTEP+1,ISTEP-1
	 IF(FIT(IT,JT).GT.AFIT)  THEN
	  AFIT=FIT(IT,JT)
	  D4=ROTMP(IT,JT)
	  ITMA=IT
	  JTMA=JT
	 ENDIF
	ENDDO
	ENDDO
	ENDIF
d391 5
a395 5
	DO     JT=-1,1
	DO     IT=-1,1
	  FITP(IT,JT)=FIT(ITMA+IT,JTMA+JT)
	ENDDO
	ENDDO
d397 3
a399 3
	QT=AFIT
	ISX=ISX+ITMA
	ISY=ISY+JTMA
d401 1
a401 1
	CALL  PARABLD(FITP,SX,SY,PEAK)
d403 5
a407 5
	IF(ABS(SX).LT.1.0 .AND. ABS(SY).LT.1.0)  THEN
	SX=SX+ISX
	SY=SY+ISY
	CNR2=NROW/2+1+SY
	CNS2=NSAM/2+1+SX
d409 1
a409 1
	CALL  ALRQ_M
d411 2
a412 2
	CALL  FRNG(A_CIRC,LCIRC,NUMR,NRING)
	CALL  CROSRNG_DS
d415 3
a417 3
	D5=QT
	D4=ANG(D4,MODE)
	ELSE
d419 9
a427 9
	D5=QT
	SX=ISX
	SY=ISY
	ENDIF
	ELSE
	D5=QT
	SX=ISX
	SY=ISY
	ENDIF
d429 1
a429 1
        DLIST(2)=E6+MAXIMA
d431 1
a431 1
	IF(IABS(IMX).NE.NSI.AND.IABS(IMY).NE.NSI)  THEN
d433 9
a441 11
	FIT(0,0)=QM
	ROTMP(0,0)=E4
c$omp parallel do private(jt,it,aa,a_circ,cnr2,cns2)
	DO     JT=-ISTEP,ISTEP
	DO     IT=-ISTEP,ISTEP
	IF(IT.NE.0 .OR. JT.NE.0) THEN
C put A in a private array
	AA=A
	CNR2=NROW/2+1+JT+IMY
	CNS2=NSAM/2+1+IT+IMX
	CALL NORMASS(AA,
d444 6
a449 5
	CALL  ALRQ_MS
     &   (AA,NSAM,NROW,CNS2,CNR2,NUMR,A_CIRC,LCIRC,NRING,MODE)
	CALL  FRNGS(A_CIRC,LCIRC,NUMR,NRING)
	CALL  CROSRMG_DS
     &		(REFER_CIRC(1,IME),A_CIRC,LCIRC,NRING,
d451 4
a454 4
	ROTMP(IT,JT)=ANG(ROTMP(IT,JT),MODE)
	ENDIF
	ENDDO
	ENDDO
d458 15
a472 15
	AFIT=FIT(0,0)
	JTMA=0
	ITMA=0
	IF(ISTEP.GT.1)  THEN
	DO     JT=-ISTEP+1,ISTEP-1
	DO     IT=-ISTEP+1,ISTEP-1
	IF(FIT(IT,JT).GT.AFIT)  THEN
	  AFIT=FIT(IT,JT)
	  E4=ROTMP(IT,JT)
	  ITMA=IT
	  JTMA=JT
	ENDIF
	ENDDO
	ENDDO
	ENDIF
d474 5
a478 5
	DO     JT=-1,1
	DO     IT=-1,1
	  FITP(IT,JT)=FIT(ITMA+IT,JTMA+JT)
	ENDDO
	ENDDO
d480 3
a482 3
	QM=AFIT
	IMX=IMX+ITMA
	IMY=IMY+JTMA
d484 1
a484 1
	CALL  PARABLD(FIT,SX,SY,PEAK)
d486 5
a490 5
	IF(ABS(SX).LT.1.0 .AND. ABS(SY).LT.1.0)  THEN
	SX=SX+IMX
	SY=SY+IMY
	CNR2=NROW/2+1+SY
	CNS2=NSAM/2+1+SX
d492 1
a492 1
	CALL  ALRQ_M
d494 2
a495 2
	CALL  FRNG(A_CIRC,LCIRC,NUMR,NRING)
	CALL  CROSRMG_DS
d498 3
a500 3
	D5=QM
	D4=ANG(D4,MODE)
	ELSE
d502 12
a513 12
	SX=IMX
	SY=IMY
	D4=E4
	D5=QM
	ENDIF
	ELSE
	SX=IMX
	SY=IMY
	D4=E4
	D5=QM
	ENDIF
	ENDIF
d515 2
a516 2
	SX=-SX
	SY=-SY
d521 16
a536 4
	CO=COS(D4*DGR_TO_RAD)
	SO=-SIN(D4*DGR_TO_RAD)
	XSHSUM=SX*CO-SY*SO
	YSHSUM=SX*SO+SY*CO
d544 7
a550 7
        DLIST(3)=D5
        DLIST(4)=D4
        DLIST(5)=XSHSUM
        DLIST(6)=YSHSUM
        DLIST(7)=LIM
        DLIST(1)=IMI
        CALL  SAVD(NDOC,DLIST,NDLI,IRTFLG)
d552 1
a552 4
	K=K+1
	GOTO  878
	ENDIF
879	CLOSE(INDOC)
d555 5
d584 2
a585 10
         SUBROUTINE  MRQLI_PS(ILIST,NSAM,NROW,NSI,ISTEP,NIMA,MODE,
     &   A,REFER_CIRC,
     &	 FITP,TT,
     &	 TOTA,TOT,TMTA,TMT,
     &   LCIRC,NUMR,NRING,MAXRIN)
	PARAMETER (QUADPI = 3.141592653589793238462643383279502884197)
	PARAMETER (DGR_TO_RAD = (QUADPI/180))
        PARAMETER (NDLI=7)
        COMMON  BUF(1024)
        DIMENSION DLIST(NDLI)
d587 1
a587 1
        DIMENSION  A(NSAM,NROW),WRK(1),ILIST(NIMA)
a588 6
	DOUBLE PRECISION TT(*)
	DIMENSION  REFER_CIRC(LCIRC,NIMA)
	DOUBLE PRECISION  TOTA(NIMA),TMTA(NIMA)
	DIMENSION  TOT(NIMA),TMT(NIMA)
	DOUBLE PRECISION  FITP(-1:1,-1:1)
	DOUBLE PRECISION  QT,QM,PEAK
d590 2
a591 4
	DOUBLE PRECISION  FIT(-ISTEP:ISTEP,-ISTEP:ISTEP)
	DIMENSION  ROTMP(-ISTEP:ISTEP,-ISTEP:ISTEP)
        DIMENSION  AA(NSAM,NROW)
        DIMENSION  A_CIRC(LCIRC)
d593 3
d597 10
a606 4
        CHARACTER*1  MODE,NULL
        COMMON  /FISPEC/  FINPAT,FINPIC,DOCFIL,NLET,NLETI
        CHARACTER*80  FINPAT,FINPIC,DOCFIL
        DATA  NDOC/56/,INDOC/57/,INPIC/58/
a607 1
	CALL  RINGWE(WR,NUMR,NRING,MAXRIN)
d609 2
d612 3
d616 1
d630 15
a644 13
	DO    IMI=1,NIMA
	L=ILIST(IMI)
	NULL=CHAR(0)
	CALL  FILGET(FINPAT,FINPIC,NLET,L,INTFLAG)
	CALL  OPENFB(BUF,FINPIC,INPIC,NSAMT,NROWT,'O',NF,NSL)
         IF(NF.NE.2)  THEN
         WRITE(NOUT,*)  ' FILE NOT FOUND:',FINPIC
         RETURN
         ENDIF
	DO    J=1,NROW
	CALL  REDLIN(INPIC,A(1,J),NSAM,J)
	ENDDO
	CLOSE(INPIC)
d648 4
a651 2
	CALL NORMAS(A,NSB,NSE,NRB,NRE,NUMR,NUMR(1,NRING))
	CALL  ALRQ(A,NSAM,NROW,NUMR,REFER_CIRC(1,IMI),
d653 3
a655 7
	CALL  FRNG(REFER_CIRC(1,IMI),LCIRC,NUMR,NRING)
	CALL  APPLYW(REFER_CIRC(1,IMI),LCIRC,NUMR,WR,NRING,MAXRIN)
	ENDDO
c find max element on  ILIST
	MAXIMA=ILIST(1)
	DO  IMI=1,NIMA
	MAXIMA=MAX(MAXIMA,ILIST(IMI))
d657 2
d663 49
a711 29
C  images to be aligned
        NULL=CHAR(0)
	CALL  FILERD(FINPAT,NLET,NULL,
     &   'Enter template for 2-D image name',IRTFLG)
	CALL  FILERD(DOCFIL,NLETI,NULL,'Selection doc',IRTFLG)
	K=0
	K2=1
	IMI=0
878      LERR=-1
         KP1=K+1
	CALL  UNSAV(DOCFIL,K,INDOC,KP1,WRK,1,LERR,K2)
	IF(LERR.EQ.0)  THEN
	IMI=IMI+1
C
	LIM=WRK(1)
	NULL=CHAR(0)
	CALL  FILGET(FINPAT,FINPIC,NLET,LIM,INTFLAG)
	CALL  OPENFB(BUF,FINPIC,INPIC,NSAMT,NROWT,'O',NF,NSL)
         IF(NF.NE.2)  THEN
         WRITE(NOUT,*)  ' FILE NOT FOUND:',FINPIC
         RETURN
         ENDIF
        IF(NSAMT.NE.NSAM.OR.NROWT.NE.NROW)  THEN
        CALL ERRT(1,'AP MQ',NE)
        CLOSE(INPIC)
	RETURN
	ENDIF
	DO    J=1,NROW
	CALL  REDLIN(INPIC,A(1,J),NSAM,J)
d713 29
a741 2
	CLOSE(INPIC)
        DLIST(5)=-1.0E23
d752 2
a753 2
	CALL NORMAS(A,NSB-IT,NSE-IT,NRB-JT,NRE-JT,NUMR,NUMR(1,NRING))
	CALL  ALRQ_M
d755 2
a756 2
	CALL  FRNG(A_CIRC,LCIRC,NUMR,NRING)
c$omp parallel do private(ir),shared(lcirc,nring,maxrin)
d760 3
a762 6
     &		MAXRIN,NUMR,TOTA(IR),TOT(IR),TMTA(IR),TMT(IR),TT)
	 ENDDO 
C  END-OF-LOOP 1 OVER REFERENCE IMAGES
	 DO    IR=1,NIMA
	  IF(TOTA(IR).GE.QT)  THEN
	   QT=TOTA(IR)
d766 2
a767 2
	   D4=ANG(TOT(IR),MODE)
	   D6=ILIST(IR)
d769 2
a770 2
	  IF(TMTA(IR).GE.QM)  THEN
	   QM=TMTA(IR)
d774 2
a775 2
	   E4=ANG(TMT(IR),MODE)
	   E6=ILIST(IR)
d777 2
a778 1
	 ENDDO
d784 1
a784 1
        DLIST(2)=D6
d788 8
a795 11
	FIT(0,0)=QT
	ROTMP(0,0)=D4
c$omp parallel do private(jt,it,aa,a_circ,cnr2,cns2)
	DO     JT=-ISTEP,ISTEP
	DO     IT=-ISTEP,ISTEP
	IF(IT.NE.0 .OR. JT.NE.0) THEN
C put A in a private array
	AA=A
	CNR2=NROW/2+1+JT+ISY
	CNS2=NSAM/2+1+IT+ISX
	CALL NORMASS(AA,
d798 4
a801 4
	CALL  ALRQ_MS
     &   (AA,NSAM,NROW,CNS2,CNR2,NUMR,A_CIRC,LCIRC,NRING,MODE)
	CALL  FRNGS(A_CIRC,LCIRC,NUMR,NRING)
	CALL  CROSRNG_DS
d804 3
a806 3
	ROTMP(IT,JT)=ANG(ROTMP(IT,JT),MODE)
	ENDIF
	ENDDO
d815 10
a824 10
	DO     JT=-ISTEP+1,ISTEP-1
	DO     IT=-ISTEP+1,ISTEP-1
	 IF(FIT(IT,JT).GT.AFIT)  THEN
	  AFIT=FIT(IT,JT)
	  D4=ROTMP(IT,JT)
	  ITMA=IT
	  JTMA=JT
	 ENDIF
	ENDDO
	ENDDO
d828 1
a828 1
	DO     IT=-1,1
d830 1
a830 1
	ENDDO
d840 10
a849 10
	SX=SX+ISX
	SY=SY+ISY
	CNR2=NROW/2+1+SY
	CNS2=NSAM/2+1+SX
	CALL NORMAS(A,NSB-ISX,NSE-ISX,NRB-ISY,NRE-ISY,NUMR,NUMR(1,NRING))
	CALL  ALRQ_M
     &   (A,NSAM,NROW,CNS2,CNR2,NUMR,A_CIRC,LCIRC,NRING,MODE)
	CALL  FRNG(A_CIRC,LCIRC,NUMR,NRING)
	CALL  CROSRNG_DS
     &		(REFER_CIRC(1,IBE),A_CIRC,LCIRC,NRING,
d851 2
a852 2
	D5=QT
	D4=ANG(D4,MODE)
d855 3
a857 3
	D5=QT
	SX=ISX
	SY=ISY
d865 1
a865 1
        DLIST(2)=E6+MAXIMA
d869 8
a876 11
	FIT(0,0)=QM
	ROTMP(0,0)=E4
c$omp parallel do private(jt,it,aa,a_circ,cnr2,cns2)
	DO     JT=-ISTEP,ISTEP
	DO     IT=-ISTEP,ISTEP
	IF(IT.NE.0 .OR. JT.NE.0) THEN
C put A in a private array
	AA=A
	CNR2=NROW/2+1+JT+IMY
	CNS2=NSAM/2+1+IT+IMX
	CALL NORMASS(AA,
d879 4
a882 4
	CALL  ALRQ_MS
     &   (AA,NSAM,NROW,CNS2,CNR2,NUMR,A_CIRC,LCIRC,NRING,MODE)
	CALL  FRNGS(A_CIRC,LCIRC,NUMR,NRING)
	CALL  CROSRMG_DS
d885 4
a888 4
	ROTMP(IT,JT)=ANG(ROTMP(IT,JT),MODE)
	ENDIF
	ENDDO
	ENDDO
d896 10
a905 10
	DO     JT=-ISTEP+1,ISTEP-1
	DO     IT=-ISTEP+1,ISTEP-1
	IF(FIT(IT,JT).GT.AFIT)  THEN
	  AFIT=FIT(IT,JT)
	  E4=ROTMP(IT,JT)
	  ITMA=IT
	  JTMA=JT
	ENDIF
	ENDDO
	ENDDO
d909 1
a909 1
	DO     IT=-1,1
d911 1
a912 1
	ENDDO
d921 7
a927 6
	SX=SX+IMX
	SY=SY+IMY
	CNR2=NROW/2+1+SY
	CNS2=NSAM/2+1+SX
	CALL NORMAS(A,NSB-IMX,NSE-IMX,NRB-IMY,NRE-IMY,NUMR,NUMR(1,NRING))
	CALL  ALRQ_M
d929 2
a930 2
	CALL  FRNG(A_CIRC,LCIRC,NUMR,NRING)
	CALL  CROSRMG_DS
d933 2
a934 2
	D5=QM
	D4=ANG(D4,MODE)
d937 4
a940 4
	SX=IMX
	SY=IMY
	D4=E4
	D5=QM
d960 2
a961 21
C output (in DLIST position is increased by 1, #1 is the key).
c 1 - Number of the most similar reference projection.
c 2 - Not-normalized correlation coefficient.
c 3 - Psi angle. (in=plane rotation)
c 4 - SX
c 5 - SY
c 6 - input image number.
        DLIST(3)=D5
        DLIST(4)=D4
        DLIST(5)=XSHSUM
        DLIST(6)=YSHSUM
        DLIST(7)=LIM
        DLIST(1)=IMI
        CALL  SAVD(NDOC,DLIST,NDLI,IRTFLG)
C---------------------------------------------------------------------
	K=K+1
	GOTO  878
	ENDIF
879	CLOSE(INDOC)
	CLOSE(NDOC)
        CALL  SAVDC
d964 26
d1000 7
a1006 7
        DO    I=NS1,NS2
        R=SQRT(FLOAT(J*J+I*I))
        IF(R.GE.R1.AND.R.LE.R2)  THEN
	N=N+1
        AV=AV+X(I,J)
        VR=VR+X(I,J)*X(I,J)
        ENDIF
d1454 2
a1455 2
         L=LOG2_P(NUMR(3,I))
         CALL  FFTR_Q(CIRC(NUMR(2,I)),L)
a1457 1
#else
d1460 1
a1460 1
C    MRQLI.FOR
d1469 1
a1469 1
C *  THE CENTER FOR LABORATORIES AND RESEARCH                              *
a1471 1
C   MRQLI.FOR
a1472 9
C        SUBROUTINE MRQLI(MAXMEM)
C         SUBROUTINE  MRQLI_P(ILIST,NSAM,NROW,NSI,NIMA,MODE,
C        SUBROUTINE  CROSRNG_D
C        SUBROUTINE  CROSRMG_D
C        SUBROUTINE  FOURING_M(CIRC,LCIRC,NUMR,NRING)
C        SUBROUTINE  ALRQ_M
C	CALL NORMAS(A,-NSAM/2,NSAM/2,-NROW/2,NROW/2,
C	CALL  ALRQ(A,NSAM,NROW,NUMR,REFER_CIRC(1,IMI),
C	CALL  FOURING
d1474 1
d1476 2
a1477 59

	SUBROUTINE MRQLI(MAXMEM)
	PARAMETER  (NILMAX=21000)
	PARAMETER  (MNUMR=480)
        INTEGER    NUMR(3,MNUMR)
	INCLUDE 'CMBLOCK.INC' 
	COMMON  BUF(1024),ILIST(NILMAX),NUMR,BAF(1)
#ifdef SP_F90
        INCLUDE 'F90ALLOC.INC'
        REAL, DIMENSION(:), POINTER :: IPQ
        REAL, DIMENSION(:), POINTER :: Q
#else
	DIMENSION Q(1)
	POINTER   (IPQ,Q) 
#endif
	LOGICAL         RUNTIME
C be careful with the common, it has to agree with 64 bits...
	COMMON  /FISPEC/  FINPAT,FINPIC,DOCFIL,NLET,NLETI
	CHARACTER*80  FINPAT,FINPIC,DOCFIL
	COMMON /MXR/ MAXRIN
	INTEGER     MAXRIN
	CHARACTER*1  NULL,MODE
	DATA  INPIC/77/
	NULL=CHAR(0)
C  ASK FOR DATA FILE
	CALL  FILERD(FINPAT,NLET,NULL,
     &   'Enter template for 2-D reference image name',IRTFLG)
	CALL  FILERD(DOCFIL,NLETI,NULL,'Selection doc',IRTFLG)
         K=0
         K2=1
         NIMA=0
778      LERR=-1
         IF(NIMA.EQ.NILMAX)  THEN
         WRITE(NOUT,*) '  Too many images, list truncated'
         GOTO  779
         ENDIF
         KP1=K+1
         CALL  UNSAV(DOCFIL,K,INPIC,KP1,BUF,1,LERR,K2)
         IF(LERR.EQ.0)  THEN
         NIMA=NIMA+1
         ILIST(NIMA)=BUF(1)
         K=K+1
         GOTO  778
         ENDIF
779      CLOSE(INPIC)
         IF(NIMA.GT.0)  THEN
         WRITE(NOUT,2001) NIMA
2001     FORMAT('  Number of images =',i5)
         ELSE
         WRITE(NOUT,*)  '  No images !'
         RETURN
         ENDIF
         CALL  FILGET(FINPAT,FINPIC,NLET,ILIST(1),INTFLG)
         CALL  OPENFB(BUF,FINPIC,INPIC,NSAM,NROW,'O',NF,NSL)
         IF(NF.NE.2)  THEN
         CALL ERRT(4,'AP MQ ',NE)
         RETURN
         ENDIF
         CLOSE(INPIC)
d1479 13
a1491 3
	CALL  RDPRMI(NSI,ISTEP,NLOOP,ILOOP,'Search range, step size')
	NSI=MAX0(NSI,1)
	ISTEP=MAX0(ISTEP,1)
d1493 3
a1495 12
         CALL  RDPRMI(MR,NR,NLOOP,ILOOP,'FIRST AND LAST RING')
         IF(NR.GT.NSAM/2-1)  THEN
         NR=NSAM/2-1
         WRITE(NOUT,*)  ' Last ring limited to ',NR
         ENDIF
         MR=MAX0(2,MIN0(NR,MR))
         ISKIP=1
         MODE='F'
         NRING=0
         DO    I=MR,NR,ISKIP
         NRING=NRING+1
         NUMR(1,NRING)=I
d1497 9
a1505 9
C  Adjust search range and step size.
	IF(NSI+NR.GT.NSAM/2-2)  THEN
	CALL ERRT(101,'Search range too large',NE)
	RETURN
	ENDIF
	IF(MOD(NSI,ISTEP).NE.0) THEN
	CALL ERRT(101,'Search range has to be divisible by step size',NE)
	RETURN
	ENDIF
d1507 2
a1508 2
         CALL  ALPRBS(NUMR,NRING,LCIRC,MODE)
         MAXRIN=NUMR(3,NRING)
d1510 4
a1513 56
C   memory division    K
C       numr           1  !int*2
C       a              2
C       a_circ         3
C       refer_circ     4
C       rotmpp         5 
C       fitp           6  !double precision *9
C       tt             7  !double precision 
C       wr             8  
C       tota           9 !double precision 
C       tot           10
C       tmta          11 !double precision 
C       tmt           12
C       rotmp         13
C       fit           14
C       temp          15   !double precision (not in MP)
C
C
C K1 not used
        K1=-1
        K2=1
         K3=IPALIGN64(K2+NSAM*NROW)
         K4=IPALIGN64(K3+LCIRC)
         K5=IPALIGN64(K4+LCIRC*NIMA)
         K6=IPALIGN64(K5)
         K7=IPALIGN64(K6+2*9)
#ifdef SP_LIBFFT
         K8=IPALIGN64(K7+(LCIRC+15)*2)
#else
         K8=K7
#endif
         K9=IPALIGN64(K8+NRING)
         K10=IPALIGN64(K9+NIMA*2)
         K11=IPALIGN64(K10+NIMA)
         K12=IPALIGN64(K11+NIMA*2)
         K13=IPALIGN64(K12+NIMA)
         K14=IPALIGN64(K13+(2*ISTEP+1)**2)
         K15=IPALIGN64(K14+2*(2*ISTEP+1)**2)
#ifdef SP_MP
         K16=K15
#else
C  have to add 2 due to libfft
         K16=IPALIGN64(K15+4*(MAXRIN+2))
#endif
        MEMTOT=K16
        MAXM=MAXMEM-1024-NILMAX-3*MNUMR
        CALL CHKMEM(MEMTOT,BAF,MAXM,RUNTIME,IPQ,IRTFLG)
              IF(IRTFLG.NE.0)  THEN
                CLOSE(INPIC)
                CALL  ERRT(6,'AP MQ',NE)
                RETURN
              ENDIF
#ifdef SP_F90
         Q = >IPQ
#endif
	WRITE (NOUT,2500)  MEMTOT
d1515 3
a1517 1
C NIMA number of the reference images
d1519 45
a1563 7
         CALL  MRQLI_P(ILIST,NSAM,NROW,NSI,ISTEP,NIMA,MODE,
     &          Q(K2),Q(K3),Q(K4),
     &          Q(K6),Q(K7),Q(K8),
     &          Q(K13),Q(K14),
     &          Q(K9),Q(K10),Q(K11),Q(K12),
     &          Q(K15),
     &          LCIRC,NUMR,NRING,MAXRIN)
d1565 1
a1565 9
      IF(RUNTIME)  CALL ALLOCIT(0,RUNTIME,IPQ,'AP MQ',IRTFLG)
         WRITE (NOUT,2600)
         RETURN
2500     FORMAT (/,' MEMORY RESERVATION: YOU HAVE',
     #   ' ALLOCATED ',I8)
2600     FORMAT (/' ',80('-')//' ',' Multi-reference alignment,  ',
     #   'end of computation',//' ',80('-')/)
         END
#endif
@


1.24
log
@mistake for mirrored particles fixed
@
text
@d1 1
a1 1
C  f77 code is at the very end of this file.
@


1.23
log
@OpenMP
@
text
@d524 2
a525 2
	ISX=ISX+ITMA
	ISY=ISY+JTMA
d534 1
a534 1
	CALL NORMAS(A,NSB-ISX,NSE-ISX,NRB-ISY,NRE-ISY,NUMR,NUMR(1,NRING))
d539 1
a539 1
     &		(REFER_CIRC(1,IBE),A_CIRC,LCIRC,NRING,
d905 2
a906 2
	ISX=ISX+ITMA
	ISY=ISY+JTMA
d915 1
a915 1
	CALL NORMAS(A,NSB-ISX,NSE-ISX,NRB-ISY,NRE-ISY,NUMR,NUMR(1,NRING))
d920 1
a920 1
     &		(REFER_CIRC(1,IBE),A_CIRC,LCIRC,NRING,
@


1.22
log
@*** empty log message ***
@
text
@a89 13
C
	IF(MR.LE.0.OR.NR.GE.MIN0(((NSAM-1)/2)*2+1,((NROW-1)/2)*2+1))THEN
	CALL ERRT(31,'OR 2',NE)
	RETURN
	ENDIF
	IF(MR.LT.5)  WRITE(NOUT,7021)  MR
7021	FORMAT(' Small value of the first ring given (',I1,') may'
     &	' result in numerical errors',/,
     & ' Please verify the results or increase FIRST RING value to 5')
C
C	CALL  RDPRMI(ISKIP,NDUMP,NLOOP,ILOOP,'SKIP')
	ISKIP=MAX0(1,ISKIP)
C
d340 2
a341 1
c$doacross local(jt,it,cnr2,cns2,aa,a_circ),shared(lcirc,nring,maxrin)
d346 1
a346 1
C put A in a local array
d393 1
a393 1
c$doacross local(jt,it,aa,a_circ,cnr2,cns2)
d397 1
a397 1
C put A in a local array
d477 1
a477 1
c$doacross local(jt,it,aa,a_circ,cnr2,cns2)
d481 1
a481 1
C put A in a local array
d738 1
a738 1
c$doacross local(ir),shared(lcirc,nring,maxrin)
d774 1
a774 1
c$doacross local(jt,it,aa,a_circ,cnr2,cns2)
d778 1
a778 1
C put A in a local array
d858 1
a858 1
c$doacross local(jt,it,aa,a_circ,cnr2,cns2)
d862 1
a862 1
C put A in a local array
a1532 13
C
	IF(MR.LE.0.OR.NR.GE.MIN0(((NSAM-1)/2)*2+1,((NROW-1)/2)*2+1))THEN
	CALL ERRT(31,'OR 2',NE)
	RETURN
	ENDIF
	IF(MR.LT.5)  WRITE(NOUT,7021)  MR
7021	FORMAT(' Small value of the first ring given (',I1,') may'
     &	' result in numerical errors',/,
     & ' Please verify the results or increase FIRST RING value to 5')
C
C	CALL  RDPRMI(ISKIP,NDUMP,NLOOP,ILOOP,'SKIP')
C	ISKIP=MAX0(1,ISKIP)
C
@


1.21
log
@*** empty log message ***
@
text
@d100 1
a100 1
	CALL  RDPRMI(ISKIP,NDUMP,NLOOP,ILOOP,'SKIP')
d1555 2
a1556 2
	CALL  RDPRMI(ISKIP,NDUMP,NLOOP,ILOOP,'SKIP')
	ISKIP=MAX0(1,ISKIP)
@


1.20
log
@*** empty log message ***
@
text
@d90 13
d1545 13
@


1.19
log
@*** empty log message ***
@
text
@a127 1
#ifdef SP_ALLOC
a130 4
#else
         K1=1
         K2=IPALIGN64(K1+3*NRING)
#endif
a255 1
CNO_SAVE
a974 1
CNO_SAVE
a1097 1
CNO_SAVE
a1237 1
CNO_SAVE
a1574 1
#ifdef SP_ALLOC
a1577 4
#else
         K1=1
         K2=IPALIGN64(K1+3*NRING)
#endif
@


1.18
log
@ff
@
text
@d33 2
a34 1
	INTEGER  NUMR(3,480)
d166 1
a166 1
        MAXM=MAXMEM-1024-NILMAX-3*480/2
d1479 2
a1480 1
	INTEGER  NUMR(3,480)
d1616 1
a1616 1
        MAXM=MAXMEM-1024-NILMAX-3*480/2
@


1.17
log
@fixed
@
text
@d33 1
a33 1
	INTEGER*2  NUMR(3,480)
d44 1
a44 1
	INTEGER*2  MAXRIN
a46 1
CNO_SAVE
d133 1
a133 1
         K2=IPALIGN64(K1+(3*NRING+3)/2)
d241 1
a241 1
        INTEGER*2  NUMR(3,NRING),MAXRIN
d263 1
a263 2
	IP=MAXRIN
	CALL  DZFFT1DUI(IP,TT)
d629 1
a629 1
        INTEGER*2  NUMR(3,NRING),MAXRIN
a647 1
CNO_SAVE
d650 1
a650 2
	IP=MAXRIN
	CALL  DZFFT1DUI(IP,TT)
d978 1
a978 1
        INTEGER*2  IR1,IR2
d1006 1
a1006 1
        INTEGER*2  NUMR(3,NRING)
a1008 1
CNO_SAVE
d1098 1
a1098 1
	INTEGER*2  NUMR(3,NRING),MAXRIN,NUMR3I,NUMR2I,CMP
d1175 1
a1175 2
        CMP = JTOT+K+MAXRIN-1
        J=MOD(CMP,MAXRIN)+1
d1204 1
a1204 2
        CMP = JTOT+K+MAXRIN-1
        J=MOD(CMP,MAXRIN)+1
d1238 1
a1238 1
	INTEGER*2  NUMR(3,NRING),MAXRIN,NUMR3I,NUMR2I,CMP
d1308 1
a1308 5
C
C Use of additional variable to convert type
C
        CMP = JTOT+K+MAXRIN-1
        J=MOD(CMP,MAXRIN)+1
d1341 1
a1341 1
	INTEGER*2  NUMR(3,NRING),MAXRIN,NUMR3I,NUMR2I,CMP
a1348 1
CNO_SAVE
d1412 1
a1412 5
C
C Use of additional variable to convert type
C
        CMP = JTOT+K+MAXRIN-1
        J=MOD(CMP,MAXRIN)+1
d1440 1
a1440 1
         INTEGER*2  NUMR(3,NRING)
a1441 1
CNO_SAVE
d1443 1
a1443 2
         NSIRT=NUMR(3,I)
         L=LOG2_P(NSIRT)
d1478 1
a1478 1
	INTEGER*2  NUMR(3,480)
d1494 1
a1494 1
	INTEGER*2  MAXRIN
a1496 1
CNO_SAVE
d1588 1
a1588 1
         K2=IPALIGN64(K1+(3*NRING+3)/2)
@


1.16
log
@*** empty log message ***
@
text
@d139 1
a139 1
         K6=IPALIGN64(K5+9)
d155 1
a155 1
C For small number of refernce images do not need these
d182 1
a182 1
     &          Q(K5),Q(K6),Q(K7),
d190 1
a190 1
     &          Q(K5),Q(K6),Q(K7),
d196 1
a196 1
     &          Q(K5),Q(K6),Q(K7),
d233 1
a233 1
     &	 ROTMPP,FITP,TT,
a244 1
	DIMENSION  ROTMPP(-1:1,-1:1)
a419 17
C make all the angles in ROTMP similar to the central one
C  (problem of modulus 360 degs)
C  It is assumed that angles have range (-180,180), as given by ANG()
	DIPX=ROTMP(0,0)
	DO     JT=-ISTEP,ISTEP
	DO     IT=-ISTEP,ISTEP
	 IF(IT.NE.0 .OR. JT.NE.0) THEN
	  IF(ABS(ROTMP(IT,JT)-DIPX).GE.180.0) THEN
	   IF(ROTMP(IT,JT).GT.0.0)  THEN
	    ROTMP(IT,JT)=ROTMP(IT,JT)-360.0
	   ELSE
	    ROTMP(IT,JT)=ROTMP(IT,JT)+360.0
	   ENDIF
	  ENDIF
	 ENDIF
	ENDDO
	ENDDO
d431 1
a441 1
	  ROTMPP(IT,JT)=ROTMP(ITMA+IT,JTMA+JT)
a451 11
	IQX=IFIX(SX+1.0)
	DIPX=SX+1-IQX
	IQY=IFIX(SY+1.0)
	DIPY=SY+1-IQY
	IQX=IQX-1
	IQY=IQY-1
	D4=
     1     +ROTMPP(IQX,IQY)+DIPY*(ROTMPP(IQX,IQY+1)-ROTMPP(IQX,IQY))
     2     +DIPX*(ROTMPP(IQX+1,IQY)-ROTMPP(IQX,IQY)
     3          +DIPY*(ROTMPP(IQX+1,IQY+1)-ROTMPP(IQX+1,IQY)
     4          -ROTMPP(IQX,IQY+1)+ROTMPP(IQX,IQY)))
d454 11
a464 1
	D5=PEAK
a503 17
C make all the angles in ROTMP similar to the central one
C  (problem of modulus 360 degs)
C  It is assumed that angles have range (-180,180), as given by ANG()
	DIPX=ROTMP(0,0)
	DO     JT=-ISTEP,ISTEP
	DO     IT=-ISTEP,ISTEP
	IF(IT.NE.0 .OR. JT.NE.0) THEN
	IF(ABS(ROTMP(IT,JT)-DIPX).GE.180.0) THEN
	IF(ROTMP(IT,JT).GT.0.0)  THEN
	ROTMP(IT,JT)=ROTMP(IT,JT)-360.0
	ELSE
	ROTMP(IT,JT)=ROTMP(IT,JT)+360.0
	ENDIF
	ENDIF
	ENDIF
	ENDDO
	ENDDO
d515 1
a525 1
	  ROTMPP(IT,JT)=ROTMP(ITMA+IT,JTMA+JT)
a535 11
	IQX=IFIX(SX+1.0)
	DIPX=SX+1-IQX
	IQY=IFIX(SY+1.0)
	DIPY=SY+1-IQY
	IQX=IQX-1
	IQY=IQY-1
	D4=
     1     +ROTMPP(IQX,IQY)+DIPY*(ROTMPP(IQX,IQY+1)-ROTMPP(IQX,IQY))
     2     +DIPX*(ROTMPP(IQX+1,IQY)-ROTMPP(IQX,IQY)
     3          +DIPY*(ROTMPP(IQX+1,IQY+1)-ROTMPP(IQX+1,IQY)
     4          -ROTMPP(IQX,IQY+1)+ROTMPP(IQX,IQY)))
d538 11
a548 1
	D5=PEAK
d621 1
a621 1
     &	 ROTMPP,FITP,TT,
a635 1
	DIMENSION  ROTMPP(-1:1,-1:1)
a802 17
C make all the angles in ROTMP similar to the central one
C  (problem of modulus 360 degs)
C  It is assumed that angles have range (-180,180), as given by ANG()
	DIPX=ROTMP(0,0)
	DO     JT=-ISTEP,ISTEP
	DO     IT=-ISTEP,ISTEP
	 IF(IT.NE.0 .OR. JT.NE.0) THEN
	  IF(ABS(ROTMP(IT,JT)-DIPX).GE.180.0) THEN
	   IF(ROTMP(IT,JT).GT.0.0)  THEN
	    ROTMP(IT,JT)=ROTMP(IT,JT)-360.0
	   ELSE
	    ROTMP(IT,JT)=ROTMP(IT,JT)+360.0
	   ENDIF
	  ENDIF
	 ENDIF
	ENDDO
	ENDDO
d814 1
a824 1
	  ROTMPP(IT,JT)=ROTMP(ITMA+IT,JTMA+JT)
a834 11
	IQX=IFIX(SX+1.0)
	DIPX=SX+1-IQX
	IQY=IFIX(SY+1.0)
	DIPY=SY+1-IQY
	IQX=IQX-1
	IQY=IQY-1
	D4=
     1     +ROTMPP(IQX,IQY)+DIPY*(ROTMPP(IQX,IQY+1)-ROTMPP(IQX,IQY))
     2     +DIPX*(ROTMPP(IQX+1,IQY)-ROTMPP(IQX,IQY)
     3          +DIPY*(ROTMPP(IQX+1,IQY+1)-ROTMPP(IQX+1,IQY)
     4          -ROTMPP(IQX,IQY+1)+ROTMPP(IQX,IQY)))
d837 11
a847 1
	D5=PEAK
a886 17
C make all the angles in ROTMP similar to the central one
C  (problem of modulus 360 degs)
C  It is assumed that angles have range (-180,180), as given by ANG()
	DIPX=ROTMP(0,0)
	DO     JT=-ISTEP,ISTEP
	DO     IT=-ISTEP,ISTEP
	IF(IT.NE.0 .OR. JT.NE.0) THEN
	IF(ABS(ROTMP(IT,JT)-DIPX).GE.180.0) THEN
	IF(ROTMP(IT,JT).GT.0.0)  THEN
	ROTMP(IT,JT)=ROTMP(IT,JT)-360.0
	ELSE
	ROTMP(IT,JT)=ROTMP(IT,JT)+360.0
	ENDIF
	ENDIF
	ENDIF
	ENDDO
	ENDDO
d898 1
a908 1
	  ROTMPP(IT,JT)=ROTMP(ITMA+IT,JTMA+JT)
a918 11
	IQX=IFIX(SX+1.0)
	DIPX=SX+1-IQX
	IQY=IFIX(SY+1.0)
	DIPY=SY+1-IQY
	IQX=IQX-1
	IQY=IQY-1
	D4=
     1     +ROTMPP(IQX,IQY)+DIPY*(ROTMPP(IQX,IQY+1)-ROTMPP(IQX,IQY))
     2     +DIPX*(ROTMPP(IQX+1,IQY)-ROTMPP(IQX,IQY)
     3          +DIPY*(ROTMPP(IQX+1,IQY+1)-ROTMPP(IQX+1,IQY)
     4          -ROTMPP(IQX,IQY+1)+ROTMPP(IQX,IQY)))
d921 11
a931 1
	D5=PEAK
d1612 1
a1612 1
         K6=IPALIGN64(K5+9)
d1649 1
a1649 1
     &          Q(K5),Q(K6),Q(K7),Q(K8),
@


1.15
log
@trig
@
text
@d236 1
a236 1
	PARAMETER (DRG_TO_RAD = (QUADPI/180))
d607 2
a608 2
	CO=COS(D4*DRG_TO_RAD)
	SO=-SIN(D4*DRG_TO_RAD)
d662 1
a662 1
	PARAMETER (DRG_TO_RAD = (QUADPI/180))
d1027 2
a1028 2
	CO=COS(D4*DRG_TO_RAD)
	SO=-SIN(D4*DRG_TO_RAD)
@


1.14
log
@buffer 99999
@
text
@d235 2
d607 2
a608 2
	CO=COSD(D4)
	SO=-SIND(D4)
d661 2
d1027 2
a1028 2
	CO=COSD(D4)
	SO=-SIND(D4)
@


1.13
log
@range changed
@
text
@d32 1
a32 1
	PARAMETER  (NILMAX=10000)
d1565 1
a1565 1
	PARAMETER  (NILMAX=10000)
@


1.12
log
@small number of images added
@
text
@d103 1
a103 1
	IF(NSI+NR.GE.NSAM/2-2)  THEN
d1641 1
a1641 1
	IF(NSI+NR.GE.NSAM/2-2)  THEN
@


1.11
log
@inserted f90-only code
@
text
@d147 3
d154 11
d178 16
d199 1
d209 423
@


1.10
log
@TEMP fixed
@
text
@d1 1081
d1279 1
@


1.9
log
@new version
@
text
@d164 2
a165 1
         K16=IPALIGN64(K15+4*MAXRIN)
@


1.8
log
@f90 alloc
@
text
@d88 3
a90 9
	CALL  RDPRMI(NSI,NR,NLOOP,ILOOP,'EXPECTED SIZE OF THE OBJECT')
	IF(NSI.GE.NSAM)  THEN
         WRITE(NOUT,*) ' Object size cannot be larger than window size'
         NSI=NSAM
         WRITE(NOUT,*) ' Object size set to',NSI
	ENDIF
	NSI=MAX0(0,NSAM-NSI)/2
	LTR=(2*NSI+1)**2
	WRITE(NOUT,*) ' Shifts will be in the range +/-',NSI
d105 9
d123 2
a124 2
C       rotmp          5 
C       fit            6  !double precision *9
d131 2
d148 1
a148 1
         K7=IPALIGN64(K6+9*2)
d159 2
a160 2
         K14=K13
         K15=K14
d181 1
a181 1
         CALL  MRQLI_P(ILIST,NSAM,NROW,NSI,NIMA,MODE,
d184 1
@


1.7
log
@R
@
text
@d34 5
d41 1
d169 3
@


1.6
log
@*** empty log message ***
@
text
@d75 1
a75 1
         CALL  OPENFB(BUF,FINPIC,INPIC,NSAM,NROW,'R',NF,NSL)
@


1.5
log
@*** empty log message ***
@
text
@d101 1
a101 1
         DO  1  I=MR,NR,ISKIP
d103 2
a104 1
1        NUMR(1,NRING)=I
@


1.4
log
@*** empty log message ***
@
text
@d155 1
a155 1
        MAXM=MAXMEM-1024-NILMAX-3*1000/2
@


1.3
log
@ipalign64
@
text
@d30 2
a31 2
	PARAMETER  (NILMAX=9998)
	INTEGER*2  NUMR(3,1000)
@


1.2
log
@libfft
@
text
@d130 1
a130 3
         K2=K1+(3*NRING+3)/2
        K2=K2/4
        K2=K2*4+5
d132 5
a136 15
         K3=K2+NSAM*NROW
        K3=K3/4
        K3=K3*4+5
         K4=K3+LCIRC
        K4=K4/4
        K4=K4*4+5
         K5=K4+LCIRC*NIMA
        K5=K5/4
        K5=K5*4+5
         K6=K5+9
        K6=K6/4
        K6=K6*4+5
         K7=K6+9*2
        K7=K7/4
        K7=K7*4+5
d138 1
a138 3
         K8=K7+(LCIRC+15)*2
        K8=K8/4
        K8=K8*4+5
d142 5
a146 15
         K9=K8+NRING
        K9=K9/4
        K9=K9*4+5
         K10=K9+NIMA*2
        K10=K10/4
        K10=K10*4+5
         K11=K10+NIMA
        K11=K11/4
        K11=K11*4+5
         K12=K11+NIMA*2
        K12=K12/4
        K12=K12*4+5
         K13=K12+NIMA
        K13=K13/4
        K13=K13*4+5
a147 2
        K14=K14/4
        K14=K14*4+5
a148 2
        K15=K15/4
        K15=K15*4+5
d152 1
a152 3
         K16=K15+4*MAXRIN
        K16=K16/4
        K16=K16*4+5
@


1.1
log
@Initial revision
@
text
@d113 9
a121 6
C       rotmp          5
C       ibe            6
C       totmin         7
C       tota           8  !double precision 
C       tot            9
C       temp          10   !double precision (not in MP)
d143 1
a143 1
         K6=K5+LTR
d146 1
a146 1
         K7=K6+LTR
d149 2
a150 1
         K8=K7+LTR*2
d153 4
a156 1
         K9=K8+NIMA*2
d159 1
a159 1
         K10=K9+NIMA
d162 1
a162 1
         K11=K10+LTR
d165 1
a165 1
         K12=K11+LTR
d168 1
a168 1
         K13=K12+LTR*2
d171 1
a171 1
         K14=K13+NIMA*2
d174 1
a174 1
         K15=K14+NIMA
d198 2
a199 2
     &          Q(K5),Q(K6),Q(K7),Q(K8),Q(K9),
     &          Q(K10),Q(K11),Q(K12),Q(K13),Q(K14),
@
