head	1.82;
access;
symbols
	pre_mrcs:1.81
	healthdept_2018:1.81
	pre_getangas:1.70
	GPL2010:1.64
	pre_GPL2010:1.63
	pre_var_equation:1.63
	pre_fftwrings:1.58
	pre_opfiles:1.57
	src:1.57
	best-code:1.57
	x-named-regs:1.57
	x:1.57
	v13-00:1.56
	pre_GPL:1.54
	prec_CA:1.44
	noindx:1.40
	Bproc:1.22
	oct21:1.12
	last77:1.8;
locks; strict;
comment	@c @;


1.82
date	2025.11.10.22.31.59;	author dean;	state Exp;
branches;
next	1.81;

1.81
date	2018.10.03.14.33.55;	author leith;	state Exp;
branches;
next	1.80;

1.80
date	2015.04.24.14.04.33;	author leith;	state Exp;
branches;
next	1.79;

1.79
date	2012.05.09.17.36.03;	author leith;	state Exp;
branches;
next	1.78;

1.78
date	2012.04.16.11.47.31;	author leith;	state Exp;
branches;
next	1.77;

1.77
date	2012.01.18.13.37.59;	author leith;	state Exp;
branches;
next	1.76;

1.76
date	2012.01.11.14.48.04;	author leith;	state Exp;
branches;
next	1.75;

1.75
date	2011.12.02.14.36.58;	author leith;	state Exp;
branches;
next	1.74;

1.74
date	2011.12.02.14.29.47;	author leith;	state Exp;
branches;
next	1.73;

1.73
date	2011.02.17.14.36.55;	author leith;	state Exp;
branches;
next	1.72;

1.72
date	2011.02.17.13.23.17;	author leith;	state Exp;
branches;
next	1.71;

1.71
date	2011.02.16.20.22.56;	author leith;	state Exp;
branches;
next	1.70;

1.70
date	2011.02.08.16.57.19;	author leith;	state Exp;
branches;
next	1.69;

1.69
date	2011.01.21.16.03.56;	author leith;	state Exp;
branches;
next	1.68;

1.68
date	2011.01.21.15.34.40;	author leith;	state Exp;
branches;
next	1.67;

1.67
date	2010.10.12.18.31.51;	author leith;	state Exp;
branches;
next	1.66;

1.66
date	2010.07.13.18.16.33;	author leith;	state Exp;
branches;
next	1.65;

1.65
date	2010.06.29.18.23.35;	author leith;	state Exp;
branches;
next	1.64;

1.64
date	2010.06.24.13.25.29;	author leith;	state Exp;
branches;
next	1.63;

1.63
date	2008.11.25.15.47.24;	author leith;	state Exp;
branches;
next	1.62;

1.62
date	2008.10.31.15.18.59;	author leith;	state Exp;
branches;
next	1.61;

1.61
date	2008.06.03.15.30.10;	author leith;	state Exp;
branches;
next	1.60;

1.60
date	2008.05.19.12.02.34;	author leith;	state Exp;
branches;
next	1.59;

1.59
date	2008.05.16.18.49.08;	author leith;	state Exp;
branches;
next	1.58;

1.58
date	2008.03.19.12.49.50;	author leith;	state Exp;
branches;
next	1.57;

1.57
date	2005.12.01.23.34.27;	author cyang;	state Exp;
branches;
next	1.56;

1.56
date	2005.10.17.20.06.57;	author leith;	state Exp;
branches;
next	1.55;

1.55
date	2005.10.17.18.01.46;	author leith;	state Exp;
branches;
next	1.54;

1.54
date	2005.03.23.15.34.52;	author leith;	state Exp;
branches;
next	1.53;

1.53
date	2005.03.09.20.57.02;	author leith;	state Exp;
branches;
next	1.52;

1.52
date	2005.03.09.16.45.26;	author leith;	state Exp;
branches;
next	1.51;

1.51
date	2005.02.09.18.52.18;	author leith;	state Exp;
branches;
next	1.50;

1.50
date	2005.01.20.15.58.38;	author leith;	state Exp;
branches;
next	1.49;

1.49
date	2004.10.07.14.33.11;	author leith;	state Exp;
branches;
next	1.48;

1.48
date	2004.09.20.18.42.18;	author leith;	state Exp;
branches;
next	1.47;

1.47
date	2004.08.18.14.54.14;	author leith;	state Exp;
branches;
next	1.46;

1.46
date	2004.03.31.15.10.06;	author leith;	state Exp;
branches;
next	1.45;

1.45
date	2004.03.18.14.48.29;	author leith;	state Exp;
branches;
next	1.44;

1.44
date	2003.08.27.14.48.43;	author leith;	state Exp;
branches;
next	1.43;

1.43
date	2003.08.07.18.54.04;	author leith;	state Exp;
branches;
next	1.42;

1.42
date	2003.07.23.20.52.27;	author leith;	state Exp;
branches;
next	1.41;

1.41
date	2003.02.19.21.31.50;	author leith;	state Exp;
branches;
next	1.40;

1.40
date	2002.11.20.20.38.37;	author leith;	state Exp;
branches;
next	1.39;

1.39
date	2002.10.17.20.35.06;	author leith;	state Exp;
branches;
next	1.38;

1.38
date	2002.03.11.14.08.05;	author leith;	state Exp;
branches;
next	1.37;

1.37
date	2002.01.22.20.56.46;	author leith;	state Exp;
branches;
next	1.36;

1.36
date	2002.01.14.21.28.30;	author leith;	state Exp;
branches;
next	1.35;

1.35
date	2001.10.19.18.43.10;	author leith;	state Exp;
branches;
next	1.34;

1.34
date	2001.10.09.16.57.27;	author leith;	state Exp;
branches;
next	1.33;

1.33
date	2001.07.17.13.25.56;	author leith;	state Exp;
branches;
next	1.32;

1.32
date	2001.07.12.19.53.55;	author leith;	state Exp;
branches;
next	1.31;

1.31
date	2001.07.11.12.42.40;	author leith;	state Exp;
branches;
next	1.30;

1.30
date	2001.07.05.16.31.42;	author leith;	state Exp;
branches;
next	1.29;

1.29
date	2001.05.24.18.18.04;	author leith;	state Exp;
branches;
next	1.28;

1.28
date	2001.04.06.14.53.50;	author leith;	state Exp;
branches;
next	1.27;

1.27
date	2001.01.26.19.04.11;	author leith;	state Exp;
branches;
next	1.26;

1.26
date	2001.01.17.20.00.18;	author leith;	state Exp;
branches;
next	1.25;

1.25
date	2001.01.17.19.36.43;	author leith;	state Exp;
branches;
next	1.24;

1.24
date	2000.10.31.17.34.33;	author leith;	state Exp;
branches;
next	1.23;

1.23
date	2000.09.28.13.53.17;	author leith;	state Exp;
branches;
next	1.22;

1.22
date	2000.09.11.19.24.58;	author pawel;	state Exp;
branches;
next	1.21;

1.21
date	2000.08.04.20.57.28;	author bimal;	state Exp;
branches;
next	1.20;

1.20
date	2000.06.12.19.23.00;	author bimal;	state Exp;
branches;
next	1.19;

1.19
date	2000.03.28.16.34.58;	author leith;	state Exp;
branches;
next	1.18;

1.18
date	2000.03.01.16.03.05;	author leith;	state Exp;
branches;
next	1.17;

1.17
date	2000.03.01.15.54.01;	author leith;	state Exp;
branches;
next	1.16;

1.16
date	2000.02.24.19.23.38;	author leith;	state Exp;
branches;
next	1.15;

1.15
date	2000.01.27.15.56.47;	author leith;	state Exp;
branches;
next	1.14;

1.14
date	99.12.03.20.33.22;	author leith;	state Exp;
branches;
next	1.13;

1.13
date	99.10.25.18.22.33;	author pawel;	state Exp;
branches;
next	1.12;

1.12
date	99.10.20.21.31.17;	author pawel;	state Exp;
branches;
next	1.11;

1.11
date	99.08.06.19.32.56;	author pawel;	state Exp;
branches;
next	1.10;

1.10
date	99.08.05.21.04.50;	author pawel;	state Exp;
branches;
next	1.9;

1.9
date	99.04.16.14.11.56;	author pawel;	state Exp;
branches;
next	1.8;

1.8
date	99.03.25.20.09.03;	author pawel;	state Exp;
branches;
next	1.7;

1.7
date	99.03.19.14.58.15;	author pawel;	state Exp;
branches;
next	1.6;

1.6
date	99.03.01.18.48.14;	author pawel;	state Exp;
branches;
next	1.5;

1.5
date	99.03.01.14.33.11;	author pawel;	state Exp;
branches;
next	1.4;

1.4
date	98.12.03.16.56.35;	author pawel;	state Exp;
branches;
next	1.3;

1.3
date	98.11.30.19.20.12;	author pawel;	state Exp;
branches;
next	1.2;

1.2
date	98.11.02.20.39.57;	author pawel;	state Exp;
branches;
next	1.1;

1.1
date	98.10.31.19.45.49;	author pawel;	state Exp;
branches;
next	;


desc
@AP RN - calling program
@


1.82
log
@*** empty log message ***
@
text
@
C++*********************************************************************
C
C APREF_P.F
C                   CROSRNG_E SPEEDS UP           AUG 04 ARDEAN LEITH
C                   AP_END CALL HAS PARLIST       OCT 04 ARDEAN LEITH
C                   SPIDER REF_RINGS FILE         FEB 05 ARDEAN LEITH
C                   CCROT STATISTICS              FEB 05 ARDEAN LEITH
C                   NON-INCORE PARALLEL           FEB 05 ARDEAN LEITH
C                   APRINGS_ONE                   MAR 05 ARDEAN LEITH
C                   FFTW_PLANS                    MAR 08 ARDEAN LEITH
C                   APRINGS_ONE_NEW               MAR 08 ARDEAN LEITH
C                   MPI PARTAB BUG FIXED          OCT 08 ARDEAN LEITH
C                   MPI LOCAL READ NOW            NOV 08 ARDEAN LEITH
C                   AP_STAT_ADD                   NOV 08 ARDEAN LEITH
C                   CROSRNG_2, TT REMOVED         JUN 10 ARDEAN LEITH
C                   AP_STAT NBORDER               OCT 10 ARDEAN LEITH
C                   RENAMED FROM DSGR_P           JAN 11 ARDEAN LEITH
C                   MAKE_CLOSE_LIST, GETANGAS     FEB 11 ARDEAN LEITH
C                   AP_GETDATA USED               NOV 11 ARDEAN LEITH  
C                   FBS_WANTED                    JAN 12 ARDEAN LEITH
C
C **********************************************************************
C=*                                                                    *
C=* This file is part of:   SPIDER - Modular Image Processing System.  *
C=* SPIDER System Authors:  Joachim Frank & ArDean Leith               *
C=* Copyright 1985-2012  Health Research Inc.,                         *
C=* Riverview Center, 150 Broadway, Suite 560, Menands, NY 12204.      *
C=* Email: spider@@wadsworth.org                                        *
C=*                                                                    *
C=* SPIDER is free software; you can redistribute it and/or            *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* SPIDER is distributed in the hope that it will be useful,          *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* merchantability or fitness for a particular purpose.  See the GNU  *
C=* General Public License for more details.                           *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program. If not, see <http://www.gnu.org/licenses> *
C=*                                                                    *
C **********************************************************************
C
C  APREF_P(IREFLIST,NUMREF,IEXPLIST,NUMEXP,
C         NSAM,NROW,NR,RANGE,
C         NRING,LCIRC,NUMR,CIRCREF,CIRCREF_IN_CORE,
C         MODE,REFANGDOC,EXPANGDOC,SCRFILE,FFTW_PLANS,
C         REFPAT,EXPPAT,CKMIRROR,CTYPE,ISHRANGE,LUNDOC)
C
C  PURPOSE: FIND ROTATIONAL AND SHIFT PARAMETERS TO ALIGN A SERIES OF
C           REFERENCE IMAGES WITH SAMPLE IMAGES
C
C  ORDER OF PROCESSING:
C 1 - CONVERT EACH REFERENCE IMAGE TO RINGS, FFT ALL THE RINGS.
C     HIGHEST FREQUENCY FOR ALL THE RINGS EXCEPT LAST ARE DIVIDED 
C     BY 2., STORE RINGS IN CIRCREF. APPLY WEIGHTS TO THE RINGS, 
C 2 - CONVERT EACH INPUT IMAGE TO RINGS, FFT ALL THE RINGS.
C 3 - COMPARE EACH INPUT IMAGE WITH ALL THE REFERENCE IMAGES
C     USING CROSRNG_**. 
C     SINCE Y WERE PRE-WEIGHTED THE RESULT IS ALREADY CORRECT.
C
C PARAMETERS:
C       IREFLIST            LIST OF REF. IMAGE FILE NUMBERS   (INPUT)
C       NUMREF              NO. OF IMAGES                     (INPUT)
C       IEXPLIST            LIST OF EXP. IMAGE FILE NUMBERS   (INPUT)
C       NUMEXP              NO. OF IMAGES                     (INPUT)
C       REFANGDOC           REF. ANGLES FILE NAME             (INPUT)
C       EXPANGDOC           EXP. ANGLES FILE NAME             (INPUT)
C       REFPAT              REF. IMAGE SERIES FILE TEMPLATE   (INPUT)
C       EXPPAT              EXP. IMAGE SERIES FILE TEMPLATE   (INPUT)
C
C  OPERATIONS:  'AP REF', 'AP RD', 'AP RN'
C
C--*********************************************************************

#ifndef USE_MPI
C ---------------------  NON-MPI CODE --------------------------------

         SUBROUTINE APREF_P(IREFLIST,NUMREF, IEXPLIST,NUMEXP,
     &          NSAM,NROW,RANGE,ANGDIFTHR,
     &          NRING,LCIRC,NUMR,CIRCREF,CIRCREF_IN_CORE,
     &          MODE,REFANGDOC,EXPANGDOC,SCRFILE,FFTW_PLANS,
     &          REFPAT,EXPPAT,CKMIRROR,CTYPE,
     &          ROTFIRST,ISHRANGE,LUNDOC,FBS_WANTED)

        INCLUDE 'MAKE_CLOSE_LIST.INC'  
        INCLUDE 'CMLIMIT.INC'
        INCLUDE 'CMBLOCK.INC'

	INTEGER                      :: IREFLIST(NUMREF) 
	INTEGER                      :: NUMREF 
	INTEGER                      :: IEXPLIST(NUMEXP) 
	INTEGER                      :: NUMEXP 
	INTEGER                      :: NSAM,NROW
        REAL                         :: RANGE,ANGDIFTHR 
	INTEGER                      :: NRING,LCIRC 
        INTEGER                      :: NUMR(3,NRING)
	REAL                         :: CIRCREF(LCIRC,NUMREF)
	LOGICAL                      :: CIRCREF_IN_CORE
	CHARACTER (LEN=1)            :: MODE 
        CHARACTER (LEN=*)            :: REFANGDOC
        CHARACTER (LEN=*)            :: EXPANGDOC
        CHARACTER (LEN=*)            :: SCRFILE
        INTEGER *8                   :: FFTW_PLANS(*)
        CHARACTER (LEN=*)            :: REFPAT,EXPPAT 
	LOGICAL                      :: CKMIRROR
        CHARACTER (LEN=*)            :: CTYPE 
        LOGICAL                      :: ROTFIRST,FBS_WANTED
        INTEGER                      :: ISHRANGE,LUNDOC

        CHARACTER (LEN=74)           :: COMMENT 
	DOUBLE PRECISION             :: CCROTD
	CHARACTER (LEN=1)            :: NULL
        LOGICAL                      :: MIRRORNEW
	LOGICAL                      :: GOTREFANG,GOTEXPANG
	LOGICAL                      :: ONLYMIRROR
        LOGICAL                      :: LIMITRANGE
        LOGICAL                      :: MIRRORED
        LOGICAL                      :: USE_UN,USE_MIR
        LOGICAL                      :: ANGINHEADER

C       ALLOCATABLE ARRAYS
	REAL, ALLOCATABLE            :: EXPBUF(:) 
        REAL, ALLOCATABLE            :: CIRCEXP(:)
	REAL, ALLOCATABLE            :: TMPBUF(:,:)

C       AUTOMATIC ARRAYS
 	DOUBLE PRECISION             :: TOTMIN(NUMREF)
 	LOGICAL                      :: ISMIRRORED(NUMREF)
 	REAL                         :: ROTANGT(NUMREF) 
	REAL                         :: DLIST(6)
	REAL                         :: ANGEXP(8,NUMEXP)
	REAL                         :: ANGREF(3,NUMREF)
	REAL                         :: REFDIR(3,NUMREF)
	REAL                         :: EXPDIR(3)
	INTEGER, POINTER             :: LCG(:)
        INTEGER, PARAMETER           :: NLISTMAX = 15
        REAL                         :: PARLIST(NLISTMAX) 

        INTEGER                      :: NSAID = 0

        LOGICAL, PARAMETER           :: USE_OMP = .FALSE.

        REAL, PARAMETER              :: QUADPI     = 3.1415926535
        REAL, PARAMETER              :: DGR_TO_RAD = (QUADPI/180)

        INTEGER                      :: NBORDER = 0       ! UNUSED
        INTEGER                      :: NSUBPIX = 0       ! UNUSED

        INTEGER, PARAMETER           :: INPIC   = 77
        INTEGER, PARAMETER           :: LUNANG  = 78
        INTEGER, PARAMETER           :: LUNRING = 50

        MYPID = -1                 ! NOT USING MPI
        NULL  = CHAR(0)

        MAXRIN = NUMR(3,NRING)     ! ACTUAL LENGTH OF LONGEST RING
#ifdef SP_LIBFFTW3
        MAXRIN = NUMR(3,NRING) - 2
#endif

	RANGECOS  = COS(RANGE*DGR_TO_RAD)

C       FIND NUMBER OF OMP THREADS
        CALL GETTHREADS(NUMTH)

        IF (MODE .EQ. 'H')  THEN
           DIVAS = 180.0
        ELSE
           DIVAS = 360.0
        ENDIF

C       MAKE EXPBUF AT LEAST NSAM*NROW FOR USE BY APSHIFT
        MWANTX = NSAM * NROW
	ALLOCATE(EXPBUF(MWANTX), CIRCEXP(LCIRC),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
           CALL ERRT(46,'APREF_P; EXPBUF, CIRCEXP',MWANTX+LCIRC)
           GOTO 9999
        ENDIF

        ANGINHEADER = .FALSE. ! unfinished !!!!!!!!!!!
        IF (ROTFIRST) THEN
	   ALLOCATE(TMPBUF(NSAM,NROW), STAT=IRTFLG)
	   IF (IRTFLG .NE. 0) THEN
              CALL ERRT(46,'APREF_P; TMPBUF',NSAM*NROW)
              GOTO 9999
           ENDIF
           !anginheader = (rotfirst .and. expangdoc .eq. '*') ! unfinished !!!!!!!!!!!
           IF (FBS_WANTED) THEN
            WRITE(NOUT,*)' ALIGNING INPUT IMAGES WITH FBS INTERPOLATION'
           ELSE
           WRITE(NOUT,*)' ALIGNING INPUT IMAGES WITH QUAD INTERPOLATION'
           ENDIF
        ENDIF 

C       LOAD REF. PROJ. ANGLES FROM DOC. FILE  OR IMAGE HEAD (IF WANTED)
C       CONVERT REF. ANGLES TO UNITARY DIRECTIONAL VECTORS (REFDIR).
	CALL AP_GETANGAS(IREFLIST,NUMREF,0,REFANGDOC,REFPAT,
     &                   INPIC,LUNANG,3,ANGREF,GOTREFANG,NGOTREF,
     &                   .TRUE.,REFDIR,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9999

C       READ REFERENCE IMAGES INTO REFERENCE RINGS (CIRCREF) ARRAY OR
C       CREATE REFERENCE RINGS FILE FOR LATER READING 
        CALL APRINGS_NEW(IREFLIST,NUMREF, NSAM,NROW,
     &               NRING,LCIRC,NUMR,MODE,FFTW_PLANS, 
     &               REFPAT,INPIC,CIRCREF,CIRCREF_IN_CORE,
     &               LUNRING,SCRFILE,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9999

        IF (NSAID .LE. 0) THEN
           IF (CIRCREF_IN_CORE) THEN
              WRITE(NOUT,91)NUMTH
91            FORMAT('  Ref. rings in core,  Threads: ',I4)
           ELSE
              WRITE(NOUT,92)NUMTH
92            FORMAT('  Ref. rings not in core,  Threads: ',I4)
           ENDIF
           NSAID = NSAID + 1
        ENDIF

C       LOAD EXP. ANGLES & ALIGNMENT PARAM. FROM DOC. FILE OR 
C       HEADER (IF WANTED) 
        CALL AP_GETANGAS(IEXPLIST,NUMEXP,0,EXPANGDOC,EXPPAT,
     &                   INPIC,LUNANG,8,ANGEXP,GOTEXPANG,NGOTPAR,
     &                   .FALSE.,FDUM,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9999

C       INITIALIZE CCROT STATISTICS
        CALL  AP_STAT_ADD(-1,CCROT,ANGDIF,ANGDIFTHR,CCROTLAS,
     &                   CCROTAVG,IBIGANGDIF,ANGDIFAVG,IMPROVCCROT,
     &                   CCROTIMPROV,IWORSECCROT,CCROTWORSE)

C       CALCULATE DIMENSIONS FOR APRINGS
        CNS2 = NSAM / 2 + 1
        CNR2 = NROW / 2 + 1

        DO IEXP=1,NUMEXP
C         LOOP OVER ALL EXPERIMENTAL (SAMPLE) IMAGES ------------------
    
C         CONVERT EXP. ANGLE TO UNITARY DIRECTIONAL VECTORS (EXPDIR).
	  CALL AP_GETSATA(ANGEXP(1,IEXP),EXPDIR,8,1,IRTFLG)

C         LOAD CURRENT (SINGLE) EXPERIMENTAL IMAGE INTO ARRAY EXPBUF
          IF (ROTFIRST) THEN
C            WANT TO ROTATE/SHIFT EXP IMAGES WHEN READING THEM
	     CALL AP_GETDATA_RTSQ(IEXPLIST,NUMEXP,
     &                        NSAM,NROW, NSAM,NROW, 0.0,
     &                        1,EXPPAT,INPIC, IEXP,IEXP,
     &                        ANGINHEADER, ANGEXP(1,IEXP), 
     &                        .TRUE., TMPBUF,EXPBUF,
     &                        .TRUE.,AVI,SIGI, FBS_WANTED,IRTFLG)
          ELSE
 	     CALL AP_GETDATA(IEXPLIST,NUMEXP,
     &                       NSAM,NROW, NSAM,NROW, 0.0,
     &                       1,EXPPAT,INPIC, IEXP,IEXP,
     &                       .TRUE., EXPBUF,
     &                       .TRUE.,AVI,SIGI, IRTFLG)
          ENDIF
          IF (IRTFLG .NE. 0) GOTO 9999

C         EXTRACT EXP. IMAGE POLAR COORD. RINGS, NORMALIZE & FFT THEM
	  CALL APRINGS_ONE_NEW(NSAM,NROW,  CNS2,CNR2, EXPBUF,.FALSE.,
     &                         MODE,NUMR,NRING,LCIRC, 0.0,FFTW_PLANS,
     &                         CIRCEXP,IRTFLG)
          IF (IRTFLG .NE. 0) GOTO 9999

C         DETERMINE WHICH REF IMAGES ARE TO BE COMPARED
          IEND       = NUMREF
          CCROTD     = -1.0D20
          LIMITRANGE = (RANGECOS < 1.0)
          NULLIFY(LCG)  ! FOR INTEL COMPILER

C         IF LIMITRANGE, LIST NEARBY REF IMAGES, RETURNS: NUMREFLCG
          CALL MAKE_CLOSE_LIST(NUMREF,LIMITRANGE,
     &                         REFDIR,EXPDIR,
     &                         RANGECOS, .TRUE., 
     &                         LCG, NUMREFLCG, IRTFLG)

          IF (NUMREFLCG <= 0) THEN
C            NO REF. IMAGE WITHIN COMPARISON ANGLE
             IREF = 0 
             GOTO 1000
          ENDIF

          IEND = NUMREFLCG

C         REF. IMAGES FOUND WITHIN COMPARISION RANGE

          IF (CIRCREF_IN_CORE) THEN
C            USE CIRCREF FOR REFERENCE RINGS

c$omp        parallel do private(imil,imi,use_un,use_mir)
             DO IMIL=1,IEND
                IMI = IMIL
	        IF (LIMITRANGE) IMI = ABS(LCG(IMIL))

                IF (CKMIRROR .AND. LIMITRANGE) THEN
C                   ONLY SEARCH EITHER MIRRORED OR NON-MIRRORED
                    USE_UN  = (LCG(IMIL) >= 0)
                    USE_MIR = (LCG(IMIL) <  0)
                ELSE
C                   SEARCH BOTH MIRRORED & NON-MIRRORED IF CHKMIR
                    USE_UN  = .TRUE.
                    USE_MIR = CKMIRROR
                ENDIF

C               CHECK MIRRORED/ NON-MIRRORED POSITION 
                CALL CROSRNG_2(CIRCREF(1,IMI),CIRCEXP,
     &                         LCIRC,NRING, MAXRIN,NUMR,
     &                         .FALSE.,FFTW_PLANS(1),
     &                         USE_UN,USE_MIR,
     &                         ISMIRRORED(IMI),
     &                         TOTMIN(IMI),ROTANGT(IMI))
	     ENDDO
c$omp        end parallel do
         ELSE
C            USE REFERENCE RINGS FILE (MIGHT BE AN INCORE FILE)
             
c$omp        parallel do private(imil,imi,ithread,use_un,use_mir)
c$omp&       schedule(static,1)
             DO IMIL=1,IEND     !LOOP OVER ALL REFERENCE IMAGES
                IMI = IMIL
	        IF (LIMITRANGE) IMI = ABS(LCG(IMIL))

C               FIND THREAD NUMBER 
                ITHREAD = MOD((IMIL-1),NUMTH) + 1
 
C               FILL CIRCREF FROM REFERENCE RINGS FILE
c$omp           critical
                CALL REDLIN(LUNRING,CIRCREF(1,ITHREAD),LCIRC,IMI)
c$omp           end critical

                IF (CKMIRROR .AND. LIMITRANGE) THEN
C                   ONLY SEARCH EITHER MIRRORED OR NON-MIRRORED
                    USE_UN  = (LCG(IMIL) .GE. 0)
                    USE_MIR = (LCG(IMIL) .LT. 0)
                ELSE
C                   SEARCH BOTH MIRRORED & NON-MIRRORED IF CHKMIR
                    USE_UN  = .TRUE.
                    USE_MIR = CKMIRROR
                ENDIF

C               CHECK EITHER MIRRORED/ NON-MIRRORED POSITION 
                CALL CROSRNG_2(CIRCREF(1,ITHREAD),CIRCEXP,
     &                          LCIRC,NRING, MAXRIN,NUMR,
     &                          .FALSE.,FFTW_PLANS(1),
     &                          USE_UN,USE_MIR,
     &                          ISMIRRORED(IMI),
     &                          TOTMIN(IMI),ROTANGT(IMI))
	     ENDDO
comp         end parallel do
          ENDIF

C         LOOP OVER ALL RELEVANT REF. IMAGES -------------------------
          IREF   = 0
          CCROTD = -1.0D20

          DO IMIL=1,IEND
             IMI = IMIL
	     IF (LIMITRANGE) IMI = ABS(LCG(IMIL))

             IF (TOTMIN(IMI) >= CCROTD) THEN
C               GOOD MATCH WITH TOTMIN (MIRRORED OR NOT)  POSITION 
                CCROTD    = TOTMIN(IMI)
                RANGNEW   = ROTANGT(IMI)
                MIRRORNEW = ISMIRRORED(IMI)
                IREF      = IMI
	     ENDIF
          ENDDO   ! END OF: DO IMIL=1,IEND -------------------------


1000      RANGNEW  = (RANGNEW-1) / MAXRIN * DIVAS
          CCROT    = CCROTD
          IMGEXP   = IEXPLIST(IEXP)
          PEAKV    = 0.0
          XSHNEW   = 0.0
          YSHNEW   = 0.0

          IF (IREF <= 0) THEN
C             NO NEARBY REFERENCE IMAGE
              IMGREF = 0
C             IREFT IS FOR REFDIR INDEX
              IREFT  = 1
          ELSE
              IMGREF = IREFLIST(IREF)
C             IREFT IS FOR REFDIR INDEX
              IREFT  = IREF
          ENDIF
         
          IF (IMGREF > 0 .AND. ISHRANGE > 0) THEN
C            DETERMINE SHIFT PARAMETERS, NO NEED TO RELOAD EXP. IMAGE  
             NSAMP = 2*NSAM+2
             NROWP = 2*NROW

             CALL APSHIFT(INPIC, REFPAT,IMGREF,
     &                  NSAM,NROW, NSAMP,NROWP,
     &                  EXPBUF,AVI,SIGI, ISHRANGE,
     &                  RANGNEW,XSHNEW,YSHNEW,MIRRORNEW,PEAKV,IRTFLG)
             IF (IRTFLG .NE. 0) RETURN
          ENDIF

C         AP_END WRITES ALIGNMENT PARAMETERS TO DOC FILE 
          NPROJ = NUMREF
          IF (LIMITRANGE) NPROJ = NUMREFLCG 
 
          CALL AP_END(IEXP,IMGEXP,IMGREF, 
     &         ANGREF(1,IREFT),REFDIR(1,IREFT),
     &         ANGEXP(1,IEXP),EXPDIR,ISHRANGE,
     &         GOTREFANG, NGOTPAR, CCROT,PEAKV,
     &         RANGNEW,XSHNEW,YSHNEW,MIRRORNEW,REFPAT,
     &         NPROJ,CTYPE, LUNDOC,PARLIST)

C         WRITE DATA TO IMAGE HEADER 
          CALL AP_END_HEAD(IMGEXP,EXPPAT,INPIC,PARLIST,8,IRTFLG)

          CALL  AP_STAT_ADD(NGOTPAR,CCROT,PARLIST(10),
     &                    ANGDIFTHR,ANGEXP(8,IEXP),
     &                    CCROTAVG,IBIGANGDIF,ANGDIFAVG,IMPROVCCROT,
     &                    CCROTIMPROV,IWORSECCROT,CCROTWORSE)

       ENDDO  ! END OF: DO IEXP=1,NUMEXP  LOOP OVER ALL EXP. IMAGES ----

      IF (NUMEXP > 1) THEN
C         SAVE CCROT & ANGULAR DISPLACEMENT STATISTICS
          CALL AP_STAT(NUMEXP,ANGDIFTHR,IBIGANGDIF,
     &                 ANGDIFAVG, CCROTAVG,
     &                 IMPROVCCROT,CCROTIMPROV,
     &                 IWORSECCROT,CCROTWORSE,
     &                 NBORDER,NSUBPIX,LUNDOC)
       ENDIF

9999  CLOSE(LUNANG)
      IF (.NOT. CIRCREF_IN_CORE) CLOSE(LUNRING)

      IF (ALLOCATED(EXPBUF)) DEALLOCATE(EXPBUF)
      IF (ALLOCATED(CIRCEXP))DEALLOCATE(CIRCEXP)
      IF (ALLOCATED(TMPBUF)) DEALLOCATE(TMPBUF)
      IF (ASSOCIATED(LCG))   DEALLOCATE(LCG)
      NULLIFY(LCG)

      END





#else

C------------------------  MPI SPECIFIC SUBROUTINE --------------------

         SUBROUTINE APREF_P(IREFLIST,NUMREF,IEXPLIST,NUMEXP,
     &              NSAM,NROW,RANGE,ANGDIFTHR,
     &              NRING,LCIRC,NUMR,CIRCREF,CIRCREF_IN_CORE,
     &              MODE,REFANGDOC,EXPANGDOC,SCRFILE,FFTW_PLANS,
     &              REFPAT,EXPPAT,CKMIRROR,CTYPE,
     &              ROTFIRST,ISHRANGE,LUNDOC,FBS_WANTED)

        INCLUDE 'MAKE_CLOSE_LIST.INC'  
        INCLUDE 'CMLIMIT.INC'
        INCLUDE 'CMBLOCK.INC'

	INTEGER                          :: IREFLIST(NUMREF) 
	INTEGER                          :: IEXPLIST(NUMEXP) 
        INTEGER                          :: NUMR(3,NRING)
	REAL                             :: CIRCREF(LCIRC,NUMREF)
	CHARACTER (LEN=1)                :: MODE 
        CHARACTER (LEN=*)                :: REFANGDOC
        CHARACTER (LEN=*)                :: EXPANGDOC
        CHARACTER (LEN=*)                :: SCRFILE
        CHARACTER (LEN=*)                :: REFPAT,EXPPAT 
        CHARACTER (LEN=*)                :: CTYPE 
	LOGICAL                          :: ROTFIRST
        CHARACTER (LEN=74)               :: COMMENT 
        LOGICAL                          :: FBS_WANTED

	DOUBLE PRECISION                 :: CCROTD
	CHARACTER(LEN=1)                 :: NULL = CHAR(0)
	LOGICAL                          :: CIRCREF_IN_CORE
	LOGICAL                          :: CKMIRROR
        LOGICAL                          :: MIRRORNEW
	LOGICAL                          :: GOTREFANG,GOTEXPANG
	LOGICAL                          :: ONLYMIRROR
        LOGICAL                          :: LIMITRANGE
        LOGICAL                          :: MIRRORED
        LOGICAL                          :: USE_UN,USE_MIR
        INTEGER *8                       :: FFTW_PLANS(*)

C       ALLOCATABLE ARRAYS
	REAL, ALLOCATABLE                :: EXPBUF(:) 
 	REAL, ALLOCATABLE                :: CIRCEXP(:) 

C       AUTOMATIC ARRAYS
 	DOUBLE PRECISION                 :: TOTMIN(NUMREF)
 	LOGICAL                          :: ISMIRRORED(NUMREF)

 	REAL                             :: ROTANGT(NUMREF) 

	REAL                             :: DLIST(6)
	REAL                             :: EXPDIR(3)
	REAL                             :: ANGEXP(8,NUMEXP)
	REAL                             :: ANGREF(3,NUMREF)
	REAL                             :: REFDIR(3,NUMREF)
	INTEGER, POINTER                 :: LCG(:)
        INTEGER                          :: NSAID = 0
        INTEGER, PARAMETER               :: NLISTMAX = 15
        REAL                             :: PARLIST(NLISTMAX)

        REAL, PARAMETER                  :: QUADPI     = 3.141592653589
        REAL, PARAMETER                  :: DGR_TO_RAD = (QUADPI/180)

        INTEGER, PARAMETER               :: INPIC   = 77
        INTEGER, PARAMETER               :: LUNANG  = 78
        INTEGER, PARAMETER               :: LUNRING = 50

        INCLUDE 'mpif.h'
        INTEGER, ALLOCATABLE             :: PSIZE(:)
        INTEGER, ALLOCATABLE             :: NBASE(:)
        REAL, ALLOCATABLE                :: PARTAB(:,:),PARTABLOC(:,:)

#ifdef MPI_DEBUG
        DOUBLE PRECISION                 :: TCOM0, TCOM1
#endif

        LOGICAL                          :: ONLYONE_RED,ONLYONE_WRT
        COMMON /COMM_MPI/ONLYONE_RED,ONLYONE_WRT

        ICOMM = MPI_COMM_WORLD
        CALL MPI_COMM_RANK(ICOMM, MYPID, MPIERR)
        CALL MPI_COMM_SIZE(ICOMM, NPROCS, MPIERR)

        NR     = NUMR(1,NRING)     ! OUTER RING NUMBER
        MAXRIN = NUMR(3,NRING)     ! ACTUAL LENGTH OF LONGEST RING
#ifdef SP_LIBFFTW3
        MAXRIN = NUMR(3,NRING) - 2
#endif
        IF (ROTFIRST) THEN
           CALL ERRT(101,'ROTFIRST NOT SUPPORTED UNDER MPI',IDUM)
           STOP
        ENDIF

	RANGECOS  = COS(RANGE*DGR_TO_RAD)

C       FIND NUMBER OF OMP THREADS
        CALL GETTHREADS(NUMTH)

        IF (MODE .EQ. 'H')  THEN
           DIVAS = 180.0
        ELSE
           DIVAS = 360.0
        ENDIF

	ALLOCATE(CIRCEXP(LCIRC),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
           CALL ERRT(46,'APREF_P; CIRCEXP',LCIRC)
           GOTO 9999
        ENDIF

C       LOAD REF. PROJ. ANGLES (ANGREF) FROM DOC. FILE (REFANGDOC) OR
C       REF. IMAGE FILE (REFPAT) HEAD (IF WANTED)
C       CONVERT REF. ANGLES TO UNITARY DIRECTIONAL VECTORS (REFDIR).
	CALL AP_GETANGAS(IREFLIST,NUMREF,0,REFANGDOC,REFPAT,
     &                  INPIC,LUNANG,3,ANGREF,GOTREFANG,NGOTREF,
     &                  .TRUE.,REFDIR,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9999

C       READ REFERENCE IMAGES INTO REFERENCE RINGS (CIRCREF) ARRAY OR
C       CREATE REFERENCE RINGS FILE FOR LATER READING 
        CALL APRINGS_NEW(IREFLIST,NUMREF, NSAM,NROW,
     &               NRING,LCIRC,NUMR,MODE,FFTW_PLANS, 
     &               REFPAT,INPIC,CIRCREF,CIRCREF_IN_CORE,
     &               LUNRING,SCRFILE,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9999

        IF (NSAID .LE. 0) THEN
           IF (CIRCREF_IN_CORE) THEN
              IF (MYPID .LE. 0) WRITE(NOUT,91)NUMTH
91            FORMAT('  Ref. rings in core,  Threads: ',I4)
           ELSE
              IF (MYPID .LE. 0) WRITE(NOUT,92)NUMTH
92            FORMAT('  Ref. rings not in core,  Threads: ',I4)
           ENDIF
           NSAID = NSAID + 1
        ENDIF

C       LOAD EXP. PROJ. ANGLES & ALIGNMENT PARAMETERS 
C       FROM DOC. FILE OR IMAGE HEADER (IF WANTED)
        CALL AP_GETANGAS(IEXPLIST,NUMEXP,0,EXPANGDOC,EXPPAT,
     &                   INPIC,LUNANG,8,ANGEXP,GOTEXPANG,NGOTPAR,
     &                   .FALSE.,EXPDIR,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9999

C       INITIALIZE CCROT STATISTICS
        CALL  AP_STAT_ADD(-1,CCROT,ANGDIF,ANGDIFTHR,CCROTLAS,
     &                   CCROTAVG,IBIGANGDIF,ANGDIFAVG,IMPROVCCROT,
     &                   CCROTIMPROV,IWORSECCROT,CCROTWORSE)

C       DISTRIBUTE EXPERIMENTAL IMAGES 
        ALLOCATE(PSIZE(NPROCS), NBASE(NPROCS), STAT=IRTFLG)
        IF (IRTFLG .NE. 0) THEN
           CALL ERRT(46,'APREF_P; NBASE',2*NPROCS)
           GOTO 9999
        ENDIF

C       FILL PSIZE WITH PARTITION LIMITS, PSIZE(1) = NUMEXP / NPROCS
        CALL SETPART(NUMEXP, PSIZE, NBASE)

#ifdef MPI_DEBUG
        WRITE(6,111) NBASE(MYPID+1), MYPID
 111    FORMAT('  APREF_P; NBASE(MYPID+1): ', I5, ' MYPID: ', I5)
        CALL FLUSHFILE(6)
        CALL MPI_BARRIER(ICOMM,MPIERR)
#endif

        NLOC = PSIZE(MYPID+1)
        ALLOCATE(EXPBUF(NSAM*NROW),
     &           PARTAB(15,NUMEXP), 
     &           PARTABLOC(15,NLOC),
     &           STAT=IRTFLG)
        IF (IRTFLG .NE. 0) THEN
           MWANT = NSAM*NROW + 15*(NUMEXP+NLOC) 
           CALL ERRT(46,'APREF_P: PARTAB...',MWANT)
           GOTO 9999
        ENDIF

C       ZERO THE ARRAYS
        PARTAB    = 0.0
        PARTABLOC = 0.0

C       CALCULATE DIMENSIONS FOR APRINGS
        CNS2 = NSAM / 2 + 1
        CNR2 = NROW / 2 + 1

C       FOLLOWING LOOP PERFORMED BY ALL PROCESSORS ON LOCAL DATA

c       write(0,*)' APREF_p; barrier 0,nloc,nprocs: ',nloc,nprocs,mypid
        CALL MPI_BARRIER(ICOMM,MPIERR)

        ONLYONE_RED = .FALSE.  ! DO NOT BROADCAST LOADED DATA
        ONLYONE_WRT = .FALSE.  ! USED TO be NEEDED FOR NORM3 IN AP_GETDATS
                               ! BUT AP_GETDATA DOES NOT WRITE ANYWAY!!

        DO JLOC = 1, NLOC   ! ---------------------------------------
          INUM   = NBASE(MYPID+1) + JLOC
          IMGEXP = IEXPLIST(INUM)
          !write(0,*)' APREF_p;  jloc,inum: ',jloc,inum,imgexp,mypid
         
C         LOAD CURRENT EXPERIMENTAL IMAGE INTO ARRAY EXPBUF
	  CALL AP_GETDATA(IEXPLIST,NUMEXP,
     &                    NSAM,NROW, NSAM,NROW,0.0,
     &                    1,EXPPAT,INPIC, INUM,INUM,
     &                    ONLYONE_RED,EXPBUF,
     &                    .TRUE.,AVI,SIGI, IRTFLG)
          IF (IRTFLG .NE. 0) GOTO 9999

C         CONVERT EXP. ANGLE TO UNITARY DIRECTIONAL VECTORS (EXPDIR).
          CALL AP_GETSATA(ANGEXP(1,INUM),EXPDIR,8,1,IRTFLG)

C         EXTRACT EXP. IMAGE POLAR COORD. RINGS, NORMALIZE & FFT THEM
	  CALL APRINGS_ONE_NEW(NSAM,NROW, CNS2,CNR2, EXPBUF,
     &                   .FALSE.,MODE,NUMR,NRING,LCIRC, 0.0,FFTW_PLANS,
     &                   CIRCEXP,IRTFLG)
          IF (IRTFLG .NE. 0) GOTO 9999

C         DETERMINE WHICH REF IMAGES ARE TO BE COMPARED
          IEND       = NUMREF
          CCROTD     = -1.0D20
          LIMITRANGE = RANGECOS .LT. 1.0
          NULLIFY(LCG)  ! FOR INTEL COMPILER
 
C         IF LIMITRANGE, MAKE LIST OF NEARBY REF IMAGES, RETURNS: NUMREFLCG
          CALL MAKE_CLOSE_LIST(NUMREF,LIMITRANGE,
     &                         REFDIR,EXPDIR,
     &                         RANGECOS, .TRUE., 
     &                         LCG, NUMREFLCG, IRTFLG)

          IF (NUMREFLCG <= 0) THEN
C            NO REF. IMAGE WITHIN COMPARISON ANGLE
             IREF = 0 
             GOTO 1000
          ENDIF

          IEND = NUMREFLCG

C         REF. IMAGES FOUND WITHIN COMPARISION RANGE

          IF (CIRCREF_IN_CORE) THEN
C            USE CIRCREF FOR REFERENCE RINGS

             DO IMIL=1,IEND
                IMI = IMIL
	        IF (LIMITRANGE) IMI = ABS(LCG(IMIL))

                IF (CKMIRROR .AND. LIMITRANGE) THEN
C                   ONLY SEARCH EITHER MIRRORED OR NON-MIRRORED
                    USE_UN  = (LCG(IMIL) .GE. 0)
                    USE_MIR = (LCG(IMIL) .LT. 0)
                ELSE
C                   SEARCH BOTH MIRRORED & NON-MIRRORED IF CHKMIR
                    USE_UN  = .TRUE.
                    USE_MIR = CKMIRROR
                ENDIF

C               CHECK MIRRORED / NON-MIRRORED POSITION 
                CALL CROSRNG_2(CIRCREF(1,IMI),CIRCEXP,
     &                         LCIRC,NRING, MAXRIN,NUMR,
     &                         .FALSE.,FFTW_PLANS(1),
     &                         USE_UN,USE_MIR,
     &                         ISMIRRORED(IMI),
     &                         TOTMIN(IMI),ROTANGT(IMI))

	     ENDDO  ! END OF:   DO IMIL=1,IEND 
          ELSE
C            USE REFERENCE RINGS FILE (MIGHT BE AN INCORE FILE)

             DO IMIL=1,IEND     !LOOP OVER ALL REFERENCE IMAGES
                IMI = IMIL
	        IF (LIMITRANGE) IMI = ABS(LCG(IMIL))

C               FIND THREAD NUMBER 
                ITHREAD = MOD((IMIL-1),NUMTH) + 1
 
C               FILL CIRCREF FROM REFERENCE RINGS FILE
                CALL REDLIN(LUNRING,CIRCREF(1,ITHREAD),LCIRC,IMI)

                IF (CKMIRROR .AND. LIMITRANGE) THEN
C                   ONLY SEARCH EITHER MIRRORED OR NON-MIRRORED
                    USE_UN  = (LCG(IMIL) .GE. 0)
                    USE_MIR = (LCG(IMIL) .LT. 0)
                ELSE
C                   SEARCH BOTH MIRRORED & NON-MIRRORED IF CHKMIR
                    USE_UN  = .TRUE.
                    USE_MIR = CKMIRROR
                ENDIF

C               CHECK EITHER MIRRORED/ NON-MIRRORED POSITION 
                CALL CROSRNG_2(CIRCREF(1,ITHREAD),CIRCEXP,
     &                         LCIRC,NRING, MAXRIN,NUMR,
     &                         .FALSE.,FFTW_PLANS(1),
     &                         USE_UN,USE_MIR,
     &                         ISMIRRORED(IMI),
     &                         TOTMIN(IMI),ROTANGT(IMI))

	     ENDDO     ! END OF:   DO IMIL=1,IEND     
          ENDIF

C         LOOP OVER ALL RELEVANT REF. IMAGES
          IREF   = 0
          CCROTD = -1.0D20

          DO IMIL=1,IEND
             IMI = IMIL
	     IF (LIMITRANGE) IMI = ABS(LCG(IMIL))

             IF (TOTMIN(IMI) .GE. CCROTD) THEN
C               GOOD MATCH WITH TOTMIN (MIRRORED OR NOT)  POSITION 
                CCROTD    = TOTMIN(IMI)
                RANGNEW   = ROTANGT(IMI)
                MIRRORNEW = ISMIRRORED(IMI)
                IREF      = IMI
	     ENDIF
          ENDDO   ! END OF: DO IMIL=1,IEND


1000      RANGNEW  = (RANGNEW-1) / MAXRIN * DIVAS
          CCROT    = CCROTD
          PEAKV    = 0.0
          XSHNEW   = 0.0
          YSHNEW   = 0.0

          IF (IREF .LE. 0) THEN
C             NO NEARBY REFERENCE IMAGE
              IMGREF = 0
C             IREFT IS FOR REFDIR INDEX
              IREFT  = 1
          ELSE
              IMGREF = IREFLIST(IREF)
C             IREFT IS FOR REFDIR INDEX
              IREFT  = IREF
          ENDIF

c         write(0,*)' APREF_p; above apshiftn,imgexp: ',imgexp,mypid
          IF (IMGREF .GT. 0 .AND. ISHRANGE .GT. 0) THEN
C            DETERMINE SHIFT PARAMETERS FOR EXP IMAGE IN EXPBUF 
             NSAMP = 2*NSAM+2
             NROWP = 2*NROW

             CALL APSHIFT(INPIC, REFPAT,IMGREF,
     &                   NSAM,NROW, NSAMP,NROWP,
     &                   EXPBUF,AVI,SIGI, ISHRANGE,
     &                   RANGNEW,XSHNEW,YSHNEW,MIRRORNEW,PEAKV,IRTFLG)
             IF (IRTFLG .NE. 0) RETURN
          ENDIF

          NPROJ = NUMREF
          IF (LIMITRANGE) NPROJ = NUMREFLCG   

C         AP_END PUTS ALIGNMENT PARAMETERS FOR THIS IMAGE IN PARTABLOC

          CALL AP_END(IMGEXP,IMGEXP,IMGREF, 
     &         ANGREF(1,IREFT),REFDIR(1,IREFT),
     &         ANGEXP(1,INUM),EXPDIR,ISHRANGE,
     &         GOTREFANG, NGOTPAR, CCROT,PEAKV,
     &         RANGNEW,XSHNEW,YSHNEW,MIRRORNEW,REFPAT,
     &         NPROJ, CTYPE, LUNDOC,PARTABLOC(1,JLOC))

          CALL AP_STAT_ADD(NGOTPAR,CCROT,PARTABLOC(10,JLOC),
     &                    ANGDIFTHR,ANGEXP(8,INUM),
     &                    CCROTAVG,IBIGANGDIF,ANGDIFAVG,IMPROVCCROT,
     &                    CCROTIMPROV,IWORSECCROT,CCROTWORSE)

        ENDDO     ! END OF:  DO JLOC = 1, NLOC ----------------------

c       write(0,*) ' APREF_p, barrier 2, mypid: ' ,mypid

        CALL MPI_BARRIER(ICOMM,MPIERR)
        ONLYONE_RED = .TRUE.  ! SET BCAST FLAG BACK TO DEFAULT
        ONLYONE_WRT = .TRUE.  ! SET BCAST FLAG BACK TO DEFAULT

C       COLLECT ALL ALIGNMENT PARAMETERS INTO PARTAB
   
        DO IPROC = 1, NPROCS
           PSIZE(IPROC) = 15 * PSIZE(IPROC)
           NBASE(IPROC) = 15 * NBASE(IPROC)
        ENDDO
        CALL MPI_ALLGATHERV(PARTABLOC, PSIZE(MYPID+1),
     &                      MPI_REAL, PARTAB, PSIZE, NBASE,
     &                      MPI_REAL, ICOMM,  MPIERR)

C       WRITE IS SYNCHRONIZED WITHIN LUNDOCWRTDAT
        IF (LUNDOC .GT. 0) THEN
C          SAVE IN ALIGNMENT DOC FILE
C          <,<,<, MIR-REF#,IMG#,INPLANE<, SX,SY,NPROJ,
C                <DIF,CCROT,INPLANE<,SX,SY
           NWANT = 15 
           DO IT = 1, NUMEXP
              CALL LUNDOCWRTDAT(LUNDOC,IT,PARTAB(1,IT),NWANT,IRTFLG)
           ENDDO
        ENDIF

        IF (NUMEXP .GT. 1) THEN   ! I SUSPECT SUMS ARE WRONG FOR MPI!
C         SAVE CCROT & ANGULAR DISPLACEMENT STATISTICS
          CALL AP_STAT(NUMEXP,ANGDIFTHR,IBIGANGDIF,
     &                 ANGDIFAVG, CCROTAVG,
     &                 IMPROVCCROT,CCROTIMPROV,
     &                 IWORSECCROT,CCROTWORSE,
     &                 NBORDER,NSUBPIX,LUNDOC)
        ENDIF

9999   IF (ALLOCATED(PSIZE))     DEALLOCATE(PSIZE)
       IF (ALLOCATED(NBASE))     DEALLOCATE(NBASE)
       IF (ALLOCATED(PARTABLOC)) DEALLOCATE(PARTABLOC)
       IF (ALLOCATED(PARTAB))    DEALLOCATE(PARTAB)
       IF (ALLOCATED(EXPBUF))    DEALLOCATE(EXPBUF)
       IF (ALLOCATED(CIRCEXP))   DEALLOCATE(CIRCEXP)
       IF (ASSOCIATED(LCG))      DEALLOCATE(LCG)
       NULLIFY(LCG)

       CLOSE(LUNANG)
       IF (.NOT. CIRCREF_IN_CORE) CLOSE(LUNRING)

       END

#endif
C ------------------------- END OF MPI CODE -----------------------









@


1.81
log
@email_health_dept
@
text
@d29 1
a29 1
C=* Email: spider@@health.ny.gov                                        *
@


1.80
log
@undefined anginheader
@
text
@d29 1
a29 1
C=* Email: spider@@wadsworth.org                                        *
@


1.79
log
@NULLIFY(LCG)  ! FOR INTEL COMPILER
@
text
@d182 1
d189 1
a189 1
           anginheader = (rotfirst .and. expangdoc .eq. '*') ! unfinished !!!!!!!!!!!
@


1.78
log
@fbs_wanted = logical
@
text
@a237 1

d272 1
d669 1
@


1.77
log
@added rtsq call msg.
@
text
@d109 2
a110 2
        LOGICAL                      :: ROTFIRST
        INTEGER                      :: ISHRANGE,LUNDOC,FBS_WANTED
d475 1
a487 1
        LOGICAL                          :: FBS_WANTED
@


1.76
log
@FBS_WANTED
@
text
@d181 1
d188 6
a237 1
        anginheader = (rotfirst .and. expangdoc .eq. '*') ! unfinished !!!!!!!!!!!
d251 1
a251 1
     &                        ANGINHEADER, ANGEXP, 
d457 1
a457 1
     &              ROTFIRST,ISHRANGE,LUNDOC)
d487 1
d537 4
@


1.75
log
@comment
@
text
@d21 1
d27 1
a27 1
C=* Copyright 1985-2011  Health Research Inc.,                         *
d85 1
a85 1
     &          ROTFIRST,ISHRANGE,LUNDOC)
d110 1
a110 1
        INTEGER                      :: ISHRANGE,LUNDOC
d247 1
a247 1
     &                        .TRUE.,AVI,SIGI, IRTFLG)
@


1.74
log
@MPIBCAST  = .TRUE. now on AP_GETDATA call for non mpi
@
text
@d20 1
d628 1
a628 1
        ONLYONE_WRT = .FALSE.  ! NEEDED FOR NORM3 IN AP_GETDATS
@


1.73
log
@limitrange instead of rangecos check needed
@
text
@d240 2
a241 1
	     CALL AP_GETDATS_RTSQ(IEXPLIST,NUMEXP,NSAM,NROW,
d244 2
a245 1
     &                        TMPBUF,EXPBUF,AVI,SIGI,IRTFLG)
d247 5
a251 3
 	     CALL AP_GETDATS(IEXPLIST,NUMEXP,NSAM,NROW,
     &                        1,EXPPAT,INPIC, IEXP,IEXP,
     &                        EXPBUF,AVI,SIGI,IRTFLG)
d628 1
d636 5
a640 3
	  CALL AP_GETDATS(IEXPLIST,NUMEXP,NSAM,NROW,
     &                   1,EXPPAT,INPIC, INUM,INUM,
     &                   EXPBUF,AVI,SIGI, IRTFLG)
@


1.72
log
@MAKE_CLOSE_LIST, GETANGAS
@
text
@a84 1

a130 1
	REAL                         :: EXPDIR(3)
d134 1
d213 2
a214 2
C       LOAD EXP. PROJ. ANGLES & ALIGNMENT PARAMETERS (ANGEXP) 
C       FROM DOC. FILE OR HEADER (IF WANTED) 
d217 1
a217 1
     &                   .FALSE.,EXPDIR,IRTFLG)
a257 1
	  NUMREFLCG  = 0
d260 1
a260 1
          LIMITRANGE = (RANGECOS .LT. 1.0)
d268 1
a268 1
          IF (NUMREFLCG .LE. 0) THEN
d288 2
a289 2
                    USE_UN  = (LCG(IMIL) .GE. 0)
                    USE_MIR = (LCG(IMIL) .LT. 0)
d298 5
a302 5
     &                          LCIRC,NRING, MAXRIN,NUMR,
     &                          .FALSE.,FFTW_PLANS(1),
     &                          USE_UN,USE_MIR,
     &                          ISMIRRORED(IMI),
     &                          TOTMIN(IMI),ROTANGT(IMI))
d305 1
a305 2

          ELSE
d349 1
a349 1
	     IF (NUMREFLCG .GT. 0) IMI = ABS(LCG(IMIL))
d351 1
a351 1
             IF (TOTMIN(IMI) .GE. CCROTD) THEN
d368 1
a368 1
          IF (IREF .LE. 0) THEN
d379 1
a379 1
          IF (IMGREF .GT. 0 .AND. ISHRANGE .GT. 0) THEN
d412 1
a412 1
      IF (NUMEXP .GT. 1) THEN
a645 1
 	  NUMREFLCG  = 0
d656 1
a656 1
          IF (NUMREFLCG .LE. 0) THEN
d732 1
a732 1
	     IF (NUMREFLCG .GT. 0) IMI = ABS(LCG(IMIL))
@


1.71
log
@MAKE_CLOSE_LIST, GETANGAS, AP_ --> APREF
@
text
@d548 1
a548 1
	CALL AP_GETANGA(IREFLIST,NUMREF,0,REFANGDOC,REFPAT,
@


1.70
log
@rotfirst added, ap_getdat_rtsq
@
text
@d4 1
a4 1
C AP_REF_P.F
d19 1
d25 1
a25 1
C=* Copyright 1985-2010  Health Research Inc.,                         *
d43 1
a43 1
C  AP_REF_P(IREFLIST,NUMREF,IEXPLIST,NUMEXP,
d78 1
a78 1
         SUBROUTINE AP_REF_P(IREFLIST,NUMREF, IEXPLIST,NUMEXP,
d86 1
d115 1
a115 1
	LOGICAL                      :: GOTREFANG
d136 1
a136 1
	INTEGER                      :: LCG(NUMREF)
d162 1
a162 2
C       THIS ALTERS RANGE!
	RANGE  = COS(RANGE*DGR_TO_RAD)
d177 1
a177 1
           CALL ERRT(46,'AP_REF_P; EXPBUF, CIRCEXP',MWANTX+LCIRC)
d183 1
a183 1
              CALL ERRT(46,'AP_REF_P; TMPBUF',NSAM*NROW)
d188 1
a188 6
C       LOAD REF. PROJ. ANGLES (ANGREF) FROM DOC. FILE (REFANGDOC) OR
C       REF. IMAGE FILE (REFPAT) HEAD
	CALL AP_GETANGA(IREFLIST,NUMREF,0,REFANGDOC,REFPAT,
     &                    INPIC,LUNANG,3,ANGREF,NGOTREF,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9999

d190 3
a192 1
	CALL AP_GETSATA(ANGREF,REFDIR,3,NUMREF,IRTFLG)
a193 1
        GOTREFANG = .TRUE.
d215 5
a219 12
C       FROM DOC. FILE (EXPANGDOC)
 
        NGOTPAR = 0
        IF (EXPANGDOC .NE. NULL) THEN
C          LOAD EXP. PROJ. ANGLES & ALIGNMENT PARAMETERS (ANGEXP) 
C          FROM DOC. FILE (EXPANGDOC) 
           CALL AP_GETANGA(IEXPLIST,NUMEXP,0,EXPANGDOC,EXPPAT,
     &                       INPIC,LUNANG,8,ANGEXP,NGOTPAR,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9999
        ELSE
           ANGEXP = 0.0
        ENDIF
d262 1
a262 1
          LIMITRANGE = (RANGE .LT. 1.0)
d264 11
a274 21
          IF (LIMITRANGE) THEN
C            DETERMINE WHICH REF IMAGES ARE TO BE COMPARED

             DO IMI=1,NUMREF
C               LOOP OVER ALL REF. IMAGES
C               ABS - DIRECTIONS AT 180 DEGREES ARE DIFFERENT 
C                     (- DO NOT CHECK MIRRORED)
C               DT NEAR 1.0 = NOT-MIRRORED, DT NEAR -1.0 = MIRRORED

                DT =    (EXPDIR(1) * REFDIR(1,IMI) + 
     &                   EXPDIR(2) * REFDIR(2,IMI) + 
     &                   EXPDIR(3) * REFDIR(3,IMI))
	        DTABS = ABS(DT)

	        IF (DTABS .GE. RANGE)  THEN
C                  NON-MIRRORED OR MIRRORED REF. IS WITHIN RANGE
	           NUMREFLCG      = NUMREFLCG + 1
	           LCG(NUMREFLCG) = IMI
                   IF (DT .LT. 0) LCG(NUMREFLCG) = -IMI
                ENDIF
	     ENDDO
d276 1
a276 8
             IF (NUMREFLCG .LE. 0) THEN
C               NO REF. IMAGE WITHIN COMPARISON ANGLE
                IREF = 0 
                GOTO 1000
             ENDIF

             IEND = NUMREFLCG
          ENDIF
d425 1
a425 1
      IF (.NOT. CIRCREF_IN_CORE)  CLOSE(LUNRING)
d430 2
d443 1
a443 1
         SUBROUTINE AP_REF_P(IREFLIST,NUMREF,IEXPLIST,NUMEXP,
d450 1
d472 1
a472 1
	LOGICAL                          :: GOTREFANG
d494 1
a494 1
	INTEGER                          :: LCG(NUMREF)
d528 1
a528 2
C       THIS ALTERS RANGE!
	RANGE  = COS(RANGE*DGR_TO_RAD)
d541 1
a541 1
           CALL ERRT(46,'AP_REF_P; CIRCEXP',LCIRC)
d546 2
a547 2
C       REF. IMAGE FILE (REFPAT) HEAD

d549 2
a550 5
     &                    INPIC,LUNANG,3,ANGREF,NGOTREF,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9999

C       CONVERT REF. ANGLES TO UNITARY DIRECTIONAL VECTORS (REFDIR).
	CALL AP_GETSATA(ANGREF,REFDIR,3,NUMREF,IRTFLG)
a551 1
        GOTREFANG = .TRUE.
d572 6
a577 13
C       LOAD EXP. PROJ. ANGLES & ALIGNMENT PARAMETERS (ANGEXP) 
C       FROM DOC. FILE (EXPANGDOC)

        NGOTPAR = 0
        IF (EXPANGDOC .NE. NULL) THEN
C          LOAD EXP. PROJ. ANGLES & ALIGNMENT PARAMETERS (ANGEXP) 
C          FROM DOC. FILE (EXPANGDOC) 
           CALL AP_GETANGA(IEXPLIST,NUMEXP,0,EXPANGDOC,EXPPAT,
     &                       INPIC,LUNANG,8,ANGEXP,NGOTPAR,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9999
        ELSE
           ANGEXP = 0.0
        ENDIF
d587 1
a587 1
           CALL ERRT(46,'AP_REF_P; NBASE',2*NPROCS)
d596 1
a596 1
 111    FORMAT('  AP_REF_P; NBASE(MYPID+1): ', I5, ' MYPID: ', I5)
d608 1
a608 1
           CALL ERRT(46,'AP_REF_P: PARTAB...',MWANT)
d622 1
a622 1
c       write(0,*)' AP_REF_p; barrier 0,nloc,nprocs: ',nloc,nprocs,mypid
d631 1
a631 1
          !write(0,*)' AP_REF_p;  jloc,inum: ',jloc,inum,imgexp,mypid
d652 1
a652 1
          LIMITRANGE = RANGE .LT. 1.0
d654 11
a664 2
          IF (LIMITRANGE) THEN
C            DETERMINE WHICH REF IMAGES ARE TO BE COMPARED
d666 1
a666 27
             DO IMI=1,NUMREF
C               LOOP OVER ALL REF. IMAGES
C               ABS - DIRECTIONS AT 180 DEGREES ARE DIFFERENT 
C                     (- DO NOT CHECK MIRRORED)
C               DT NEAR 1.0 = NOT-MIRRORED, DT NEAR -1.0 = MIRRORED

                DT =    (EXPDIR(1) * REFDIR(1,IMI) + 
     &                   EXPDIR(2) * REFDIR(2,IMI) + 
     &                   EXPDIR(3) * REFDIR(3,IMI))
	        DTABS = ABS(DT)

	        IF (DTABS .GE. RANGE)  THEN
C                  NON-MIRRORED OR MIRRORED REF. IS WITHIN RANGE
	           NUMREFLCG      = NUMREFLCG + 1
	           LCG(NUMREFLCG) = IMI
                   IF (DT .LT. 0) LCG(NUMREFLCG) = -IMI
                ENDIF
	     ENDDO

             IF (NUMREFLCG .LE. 0) THEN
C               NO REF. IMAGE WITHIN COMPARISON ANGLE
                IREF = 0 
                GOTO 1000
             ENDIF

             IEND = NUMREFLCG
          ENDIF
d765 1
a765 1
c         write(0,*)' AP_REF_p; above apshiftn,imgexp: ',imgexp,mypid
d797 1
a797 1
c       write(0,*) ' AP_REF_p, barrier 2, mypid: ' ,mypid
d839 2
@


1.69
log
@renamed
@
text
@d81 2
a82 1
     &          REFPAT,EXPPAT,CKMIRROR,CTYPE,ISHRANGE,LUNDOC)
d89 1
d91 4
d97 1
d102 1
d104 1
d106 3
a109 1

a111 2
	LOGICAL                      :: CIRCREF_IN_CORE
	LOGICAL                      :: CKMIRROR
d118 1
a118 1
        INTEGER *8                   :: FFTW_PLANS(*)
d123 1
a128 1

d132 2
a133 2
	REAL                         :: ANGREF(3,NUMREF),REFDIR(3,NUMREF)

d135 2
a141 3
        INTEGER, PARAMETER           :: NLISTMAX = 15
        REAL                         :: PARLIST(NLISTMAX) 

d148 3
a150 1
	DATA  INPIC,LUNANG,LUNRING/77,78,50/
d179 7
d240 2
d249 11
a259 3
	  CALL AP_GETDATS(IEXPLIST,NUMEXP,NSAM,NROW,
     &                   1,EXPPAT,INPIC, IEXP,IEXP,
     &                   EXPBUF,AVI,SIGI,IRTFLG)
d269 1
a269 1
	  NUMREFLCG    = 0
d272 1
a272 1
          LIMITRANGE = RANGE .LT. 1.0
d432 3
d456 1
d469 5
a473 4
     &          NSAM,NROW,RANGE,ANGDIFTHR,
     &          NRING,LCIRC,NUMR,CIRCREF,CIRCREF_IN_CORE,
     &          MODE,REFANGDOC,EXPANGDOC,SCRFILE,FFTW_PLANS,
     &          REFPAT,EXPPAT,CKMIRROR,CTYPE,ISHRANGE,LUNDOC)
d478 24
a501 23
	INTEGER                                     :: IREFLIST(NUMREF) 
	INTEGER                                     :: IEXPLIST(NUMEXP) 
        INTEGER                                     :: NUMR(3,NRING)
	REAL, DIMENSION(LCIRC,NUMREF)               :: CIRCREF
	CHARACTER(LEN=1)                            :: MODE 
        CHARACTER (LEN=*)                           :: REFANGDOC
        CHARACTER (LEN=*)                           :: EXPANGDOC
        CHARACTER (LEN=*)                           :: SCRFILE
        CHARACTER (LEN=*)                           :: REFPAT,EXPPAT 
        CHARACTER (LEN=*)                           :: CTYPE 
        CHARACTER (LEN=74)                          :: COMMENT 

	DOUBLE PRECISION                            :: CCROTD
	CHARACTER(LEN=1)                            :: NULL
	LOGICAL                                     :: CIRCREF_IN_CORE
	LOGICAL                                     :: CKMIRROR
        LOGICAL                                     :: MIRRORNEW
	LOGICAL                                     :: GOTREFANG
	LOGICAL                                     :: ONLYMIRROR
        LOGICAL                                     :: LIMITRANGE
        LOGICAL                                     :: MIRRORED
        LOGICAL                                     :: USE_UN,USE_MIR
        INTEGER *8                                  :: FFTW_PLANS(*)
d504 2
a505 2
	REAL, ALLOCATABLE                           :: EXPBUF(:) 
 	REAL, ALLOCATABLE                           :: CIRCEXP(:) 
d508 2
a509 4
 	DOUBLE PRECISION                            :: TOTMIN(NUMREF)
 	LOGICAL                                    :: ISMIRRORED(NUMREF)

 	REAL                                        :: ROTANGT(NUMREF) 
d511 1
a511 4
	REAL                                        :: DLIST(6)
	REAL                                        :: EXPDIR(3)
	REAL                                        :: ANGEXP(8,NUMEXP)
	REAL, DIMENSION(3,NUMREF)                   :: ANGREF,REFDIR
d513 16
a528 11
	INTEGER                                     :: LCG(NUMREF)

        INTEGER                                     :: NSAID = 0

        INTEGER, PARAMETER                          :: NLISTMAX = 15
        REAL                                        :: PARLIST(NLISTMAX)

	PARAMETER (QUADPI = 3.1415926535897932384626)
	PARAMETER (DGR_TO_RAD = (QUADPI/180))

	DATA  INPIC,LUNANG,LUNRING/77,78,50/
d531 3
a533 3
        INTEGER, ALLOCATABLE, DIMENSION(:) :: PSIZE
        INTEGER, ALLOCATABLE, DIMENSION(:) :: NBASE
        REAL, ALLOCATABLE, DIMENSION(:,:)  :: PARTAB,PARTABLOC
d536 1
a536 1
        DOUBLE PRECISION TCOM0, TCOM1
d539 1
a539 1
        LOGICAL            :: ONLYONE_RED,ONLYONE_WRT
a545 2
        NULL  = CHAR(0)

a619 1

d667 1
a667 1
c          write(0,*)' AP_REF_p;  jloc,inum: ',jloc,inum,imgexp,mypid
@


1.68
log
@renamed from: dsgr_p.f
@
text
@d87 23
a109 23
	INTEGER, DIMENSION(NUMREF)                  :: IREFLIST 
	INTEGER, DIMENSION(NUMEXP)                  :: IEXPLIST 
        INTEGER, DIMENSION(3,NRING)                 :: NUMR
	REAL, DIMENSION(LCIRC,NUMREF)               :: CIRCREF
	CHARACTER (LEN=1)                           :: MODE 
        CHARACTER (LEN=*)                           :: REFANGDOC
        CHARACTER (LEN=*)                           :: EXPANGDOC
        CHARACTER (LEN=*)                           :: SCRFILE
        CHARACTER (LEN=*)                           :: REFPAT,EXPPAT 
        CHARACTER (LEN=*)                           :: CTYPE 
        CHARACTER (LEN=74)                          :: COMMENT 

	DOUBLE PRECISION                            :: CCROTD
	CHARACTER (LEN=1)                           :: NULL
	LOGICAL                                     :: CIRCREF_IN_CORE
	LOGICAL                                     :: CKMIRROR
        LOGICAL                                     :: MIRRORNEW
	LOGICAL                                     :: GOTREFANG
	LOGICAL                                     :: ONLYMIRROR
        LOGICAL                                     :: LIMITRANGE
        LOGICAL                                     :: MIRRORED
        LOGICAL                                     :: USE_UN,USE_MIR
        INTEGER *8                                  :: FFTW_PLANS(*)
d112 2
a113 1
	REAL, ALLOCATABLE, DIMENSION(:)             :: EXPBUF 
d116 8
a123 9
 	DOUBLE PRECISION, DIMENSION(NUMREF)         :: TOTMIN
 	LOGICAL, DIMENSION(NUMREF)                  :: ISMIRRORED
 	REAL, DIMENSION(NUMREF)                     :: ROTANGT 
 	REAL, DIMENSION(LCIRC)                      :: CIRCEXP 

	REAL, DIMENSION(6)                          :: DLIST
	REAL, DIMENSION(3)                          :: EXPDIR
	REAL, DIMENSION(8,NUMEXP)                   :: ANGEXP
	REAL, DIMENSION(3,NUMREF)                   :: ANGREF,REFDIR
d125 1
a125 1
	INTEGER, DIMENSION(NUMREF)                  :: LCG
d127 1
a127 1
        INTEGER                                     :: NSAID = 0
d129 1
a129 1
        LOGICAL, PARAMETER                          :: USE_OMP = .FALSE.
d131 2
a132 2
        INTEGER, PARAMETER                          :: NLISTMAX = 15
        REAL, DIMENSION(NLISTMAX)                   :: PARLIST
d134 2
a135 2
        REAL, PARAMETER      :: QUADPI     = 3.1415926535
        REAL, PARAMETER      :: DGR_TO_RAD = (QUADPI/180)
d137 2
a138 2
        INTEGER              :: NBORDER = 0       ! UNUSED
        INTEGER              :: NSUBPIX = 0       ! UNUSED
d164 1
a164 1
	ALLOCATE(EXPBUF(MWANTX),STAT=IRTFLG)
d166 1
a166 1
           CALL ERRT(46,'DSGR_P, EXPBUF',MWANTX)
d425 1
d446 3
a448 3
	INTEGER, DIMENSION(NUMREF)                  :: IREFLIST 
	INTEGER, DIMENSION(NUMEXP)                  :: IEXPLIST 
        INTEGER, DIMENSION(3,NRING)                 :: NUMR
d467 1
a467 1
         LOGICAL                                    :: USE_UN,USE_MIR
d471 2
a472 1
	REAL, ALLOCATABLE, DIMENSION(:)             :: EXPBUF 
d475 2
a476 2
 	DOUBLE PRECISION, DIMENSION(NUMREF)         :: TOTMIN
 	LOGICAL, DIMENSION(NUMREF)                  :: ISMIRRORED
d478 1
a478 2
 	REAL, DIMENSION(NUMREF)                     :: ROTANGT 
 	REAL, DIMENSION(LCIRC)                      :: CIRCEXP 
d480 3
a482 3
	REAL, DIMENSION(6)                          :: DLIST
	REAL, DIMENSION(3)                          :: EXPDIR
	REAL, DIMENSION(8,NUMEXP)                   :: ANGEXP
d485 1
a485 1
	INTEGER, DIMENSION(NUMREF)                  :: LCG
d490 1
a490 1
        REAL, DIMENSION(NLISTMAX)                   :: PARLIST
d533 6
d861 1
@


1.67
log
@AP_STAT NBORDER
@
text
@d4 1
a4 1
C DSGR_P.F
d18 1
d42 1
a42 1
C  DSGR_P(IREFLIST,NUMREF,IEXPLIST,NUMEXP,
d77 1
a77 1
         SUBROUTINE DSGR_P(IREFLIST,NUMREF, IEXPLIST,NUMEXP,
d436 1
a436 1
         SUBROUTINE DSGR_P(IREFLIST,NUMREF,IEXPLIST,NUMEXP,
d586 1
a586 1
           CALL ERRT(46,'DSGR_P: NBASE',2*NPROCS)
d595 1
a595 1
 111    FORMAT('  DSGR_P: NBASE(MYPID+1): ', I5, ' MYPID: ', I5)
d607 1
a607 1
           CALL ERRT(46,'DSGR_P: PARTAB...',MWANT)
d621 1
a621 1
c       write(0,*)' dsgr_p; barrier 0,nloc,nprocs: ',nloc,nprocs,mypid
d630 1
a630 1
c          write(0,*)' dsgr_p;  jloc,inum: ',jloc,inum,imgexp,mypid
d781 1
a781 1
c         write(0,*)' dsgr_p; above apshiftn,imgexp: ',imgexp,mypid
d813 1
a813 1
c       write(0,*) ' dsgr_p, barrier 2, mypid: ' ,mypid
@


1.66
log
@LCG(IRR) bug
@
text
@d17 1
d51 5
a55 6
C 1 - CONVERT EACH REFERENCE IMAGE TO RINGS, DO THE FFTS
C     FOR ALL THE RINGS, APPLY WEIGHTS TO THE RINGS, STORE IT IN CIRCREF.
C     IN ADDITION, HIGHEST FREQUENCY FOR ALL THE RINGS EXCEPT
C     MAXRING ARE DIVIDED BY 2.
C 2 - CONVERT EACH INPUT IMAGE TO RINGS, DO THE FFTS,
C     COMPARE EACH INPUT IMAGE WITH ALL THE REFERENCE IMAGES
d57 1
a57 1
C     SINCE Y WERE PRE-WEIGHTED THE RESULT ARE ALREADY CORRECT.
d133 5
a137 2
        REAL, PARAMETER                   :: QUADPI = 3.1415926535
        REAL, PARAMETER                   :: DGR_TO_RAD = (QUADPI/180)
d416 2
a417 1
     &                 IWORSECCROT,CCROTWORSE,LUNDOC)
d844 2
a845 1
     &                 IWORSECCROT,CCROTWORSE,LUNDOC)
@


1.65
log
@CROSRNG_2, TT REMOVED
@
text
@d286 2
a287 2
                    USE_UN  = (LCG(IRR) .GE. 0)
                    USE_MIR = (LCG(IRR) .LT. 0)
d323 2
a324 2
                    USE_UN  = (LCG(IRR) .GE. 0)
                    USE_MIR = (LCG(IRR) .LT. 0)
d690 2
a691 2
                    USE_UN  = (LCG(IRR) .GE. 0)
                    USE_MIR = (LCG(IRR) .LT. 0)
d722 2
a723 2
                    USE_UN  = (LCG(IRR) .GE. 0)
                    USE_MIR = (LCG(IRR) .LT. 0)
d753 1
a753 1
                MIRRORNEW = (ISMIRRORED(IMI)
@


1.64
log
@GPL_2010
@
text
@d15 2
a16 1
C                    AP_STAT_ADD                  NOV 08 ARDEAN LEITH
d41 1
a41 1
C         NSAM,NROW,NR,LENTT,RANGE,
d77 1
a77 1
     &          NSAM,NROW,LENTT,RANGE,ANGDIFTHR,
d90 1
a90 1
	CHARACTER(LEN=1)                            :: MODE 
d99 1
a99 1
	CHARACTER(LEN=1)                            :: NULL
d107 1
d114 3
a116 4
 	DOUBLE PRECISION, DIMENSION(NUMREF)         :: TOTMIN,TOTMIR
	DOUBLE PRECISION, DIMENSION(LENTT)          :: TT 

 	REAL, DIMENSION(NUMREF)                     :: ROTANGT,ROTANGM 
d128 2
d133 2
a134 2
	PARAMETER (QUADPI = 3.1415926535897932384626)
	PARAMETER (DGR_TO_RAD = (QUADPI/180))
a214 1

d279 1
a279 1
c$omp        parallel do private(imil,imi,mirrored)
d284 4
a287 10
                IF ((CKMIRROR .AND. LIMITRANGE)  .OR.
     &              (.NOT. CKMIRROR)) THEN
                   IF (.NOT. CKMIRROR) MIRRORED = .FALSE. 
                   IF (LIMITRANGE)     MIRRORED = (LCG(IMIL) .LT. 0) 

C                  CHECK EITHER MIRRORED OR NON-MIRRORED POSITION 
	           CALL CROSRNG_EP_NEW(CIRCREF(1,IMI),CIRCEXP,
     &                              LCIRC,NRING, MAXRIN,NUMR,
     &                              TOTMIN(IMI),ROTANGT(IMI),
     &                              TT,MIRRORED,FFTW_PLANS(1))
d289 3
a291 6
C                  CHECK BOTH NON-MIRRORED & MIRRORED POSITIONS 
	           CALL CROSRNG_MSP_NEW(CIRCREF(1,IMI),CIRCEXP,
     &                              LCIRC,NRING, MAXRIN,NUMR, 
     &                              TOTMIN(IMI),ROTANGT(IMI),
     &                              TOTMIR(IMI),ROTANGM(IMI), 
     &                              TT,FFTW_PLANS(1))
d293 8
d307 1
a307 1
c$omp        parallel do private(imil,imi,mirrored,ithread)
d321 4
a324 10
                IF ((CKMIRROR .AND. LIMITRANGE)  .OR.
     &              (.NOT. CKMIRROR)) THEN
                   IF (.NOT. CKMIRROR) MIRRORED = .FALSE. 
                   IF (LIMITRANGE)     MIRRORED = (LCG(IMIL) .LT. 0) 

C                  CHECK EITHER MIRRORED OR NON-MIRRORED POSITION 
	           CALL CROSRNG_EP_NEW(CIRCREF(1,ITHREAD),CIRCEXP,
     &                              LCIRC,NRING, MAXRIN,NUMR,
     &                              TOTMIN(IMI),ROTANGT(IMI),
     &                              TT,MIRRORED,FFTW_PLANS(1))
d326 4
a329 1
C                  CHECK BOTH NON-MIRRORED & MIRRORED POSITIONS 
d331 7
a337 6
                   CALL CROSRNG_MSP_NEW(CIRCREF(1,ITHREAD),CIRCEXP,
     &                        LCIRC,NRING, MAXRIN,NUMR,
     &                        TOTMIN(IMI),ROTANGT(IMI),
     &                        TOTMIR(IMI),ROTANGM(IMI), 
     &                        TT,FFTW_PLANS(1))
                ENDIF
d354 1
a354 1
                MIRRORNEW = (LIMITRANGE .AND. (LCG(IMIL) .LT. 0))
a356 11
 
             IF (CKMIRROR .AND. .NOT. LIMITRANGE) THEN 
C               HAVE TO COMPARE WITH MIRRORED POSITION 
                IF (TOTMIR(IMI) .GE. CCROTD) THEN
C                  GOOD MATCH, MIRRORED POSITION IS BETTER
                   CCROTD    = TOTMIR(IMI)
                   RANGNEW   = ROTANGM(IMI)
                   MIRRORNEW = .TRUE.
                   IREF      = IMI
                ENDIF
             ENDIF   ! END OF: IF (CKMIRROR)
d432 1
a432 1
     &          NSAM,NROW,LENTT,RANGE,ANGDIFTHR,
d461 1
d468 2
a469 2
 	DOUBLE PRECISION, DIMENSION(NUMREF)         :: TOTMIN,TOTMIR
	DOUBLE PRECISION, DIMENSION(LENTT)          :: TT 
d471 1
a471 1
 	REAL, DIMENSION(NUMREF)                     :: ROTANGT,ROTANGM 
d683 1
d688 4
a691 10
                IF ((CKMIRROR .AND. LIMITRANGE)  .OR.
     &              (.NOT. CKMIRROR)) THEN
                   IF (.NOT. CKMIRROR) MIRRORED = .FALSE. 
                   IF (LIMITRANGE)     MIRRORED = (LCG(IMIL) .LT. 0) 

C                   CHECK EITHER MIRRORED OR NON-MIRRORED POSITION 
	            CALL CROSRNG_EP_NEW(CIRCREF(1,IMI),CIRCEXP,
     &                              LCIRC,NRING, MAXRIN,NUMR,
     &                              TOTMIN(IMI),ROTANGT(IMI),
     &                              TT,MIRRORED,FFTW_PLANS(1))
d693 3
a695 5
C                  CHECK BOTH NON-MIRRORED & MIRRORED POSITIONS 
	           CALL CROSRNG_MSP_NEW(CIRCREF(1,IMI),CIRCEXP,
     &                   LCIRC,NRING, MAXRIN,NUMR, 
     &                   TOTMIN(IMI),ROTANGT(IMI),
     &                   TOTMIR(IMI),ROTANGM(IMI), TT,FFTW_PLANS(1))
d697 9
d720 9
a728 4
                IF ((CKMIRROR .AND. LIMITRANGE)  .OR.
     &              (.NOT. CKMIRROR)) THEN
                   IF (.NOT. CKMIRROR) MIRRORED = .FALSE. 
                   IF (LIMITRANGE)     MIRRORED = (LCG(IMIL) .LT. 0) 
d730 7
a736 1
C                  CHECK EITHER MIRRORED OR NON-MIRRORED POSITION 
a737 12
                   CALL CROSRNG_EP_NEW(CIRCREF(1,ITHREAD),CIRCEXP,
     &                         LCIRC,NRING, MAXRIN,NUMR,
     &                         TOTMIN(IMI),ROTANGT(IMI),
     &                         TT,MIRRORED,FFTW_PLANS(1))
                ELSE
C                  CHECK BOTH NON-MIRRORED & MIRRORED POSITIONS 
                   CALL CROSRNG_MSP_NEW(CIRCREF(1,ITHREAD),CIRCEXP,
     &                        LCIRC,NRING, MAXRIN,NUMR,
     &                        TOTMIN(IMI),ROTANGT(IMI),
     &                        TOTMIR(IMI),ROTANGM(IMI), 
     &                        TT,FFTW_PLANS(1))
                ENDIF
d753 1
a753 1
                MIRRORNEW = (LIMITRANGE .AND. (LCG(IMIL) .LT. 0))
a755 11
 
             IF (CKMIRROR .AND. .NOT. LIMITRANGE) THEN 
C               HAVE TO COMPARE WITH MIRRORED POSITION 
                IF (TOTMIR(IMI) .GE. CCROTD) THEN
C                  GOOD MATCH, MIRRORED POSITION IS BETTER
                   CCROTD    = TOTMIR(IMI)
                   RANGNEW   = ROTANGM(IMI)
                   MIRRORNEW = .TRUE.
                   IREF      = IMI
                ENDIF
             ENDIF   ! END OF: IF (CKMIRROR)
@


1.63
log
@ apstat,mpi
@
text
@a17 2
C=* FROM: SPIDER - MODULAR IMAGE PROCESSING SYSTEM.   AUTHOR: J.FRANK  *
C=* Copyright (C) 1985-2008  Health Research Inc.                      *
d19 5
a23 2
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *   
C=* ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
d25 1
a25 3
C=* Email:  spider@@wadsworth.org                                       *
C=*                                                                    *
C=* This program is free software; you can redistribute it and/or      *
d30 1
a30 1
C=* This program is distributed in the hope that it will be useful,    *
d32 1
a32 1
C=* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
a33 1
C=*                                                                    *
d35 1
a35 3
C=* along with this program; if not, write to the                      *
C=* Free Software Foundation, Inc.,                                    *
C=* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.      *
@


1.62
log
@mpi changes
@
text
@d14 2
d43 1
a43 1
C  DSGR_P(ILIST,NIMA,ILIP,NIDI,
d63 4
a66 4
C       ILIST               LIST OF REF. IMAGE FILE NUMBERS   (INPUT)
C       NIMA                NO. OF IMAGES                     (INPUT)
C       ILIP                LIST OF EXP. IMAGE FILE NUMBERS   (INPUT)
C       NIDI                NO. OF IMAGES                     (INPUT)
d79 1
a79 1
         SUBROUTINE DSGR_P(ILIST,NIMA, ILIP,NIDI,
d89 2
a90 2
	INTEGER, DIMENSION(NIMA)                    :: ILIST 
	INTEGER, DIMENSION(NIDI)                    :: ILIP 
d92 1
a92 1
	REAL, DIMENSION(LCIRC,NIMA)                 :: CIRCREF
d113 1
a113 1
	REAL, ALLOCATABLE, DIMENSION(:)             :: XBUF 
d116 1
a116 1
 	DOUBLE PRECISION, DIMENSION(NIMA)           :: TOTMIN,TOTMIR
d119 1
a119 1
 	REAL, DIMENSION(NIMA)                       :: ROTANGT,ROTANGM 
d124 2
a125 2
	REAL, DIMENSION(8,NIDI)                     :: ANGEXP
	REAL, DIMENSION(3,NIMA)                     :: ANGREF,REFDIR
d127 1
a127 1
	INTEGER, DIMENSION(NIMA)                    :: LCG
d159 1
a159 1
C       MAKE XBUF AT LEAST NSAM*NROW FOR USE BY AP_SHIFT
d161 1
a161 1
	ALLOCATE(XBUF(MWANTX),STAT=IRTFLG)
d163 1
a163 1
           CALL ERRT(46,'XBUF',MWANTX)
d169 1
a169 1
	CALL AP_GETANGA(ILIST,NIMA,0,REFANGDOC,REFPAT,
d174 1
a174 1
	CALL AP_GETSATA(ANGREF,REFDIR,3,NIMA,IRTFLG)
d180 1
a180 1
        CALL APRINGS_NEW(ILIST,NIMA, NSAM,NROW,
d204 1
a204 1
           CALL AP_GETANGA(ILIP,NIDI,0,EXPANGDOC,EXPPAT,
d211 5
a215 8
C       INITIALIZE CCROT STATISTICS        
        CCROTAVG    = 0.0
        IMPROVCCROT = 0
        CCROTIMPROV = 0.0
        IWORSECCROT = 0
        CCROTWORSE  = 0.0
        ANGDIFAVG   = 0.0
        IBIGANGDIF  = 0
d221 2
a222 2
        DO IEXP=1,NIDI
C         LOOP OVER ALL EXPERIMENTAL (SAMPLE) IMAGES
d227 2
a228 2
C         LOAD CURRENT EXPERIMENTAL IMAGE INTO ARRAY XBUF
	  CALL AP_GETDATS(ILIP,NIDI,NSAM,NROW,
d230 1
a230 1
     &                   XBUF, IRTFLG)
d234 1
a234 1
	  CALL APRINGS_ONE_NEW(NSAM,NROW,  CNS2,CNR2, XBUF,.FALSE.,
d240 2
a241 2
	  NIMALCG    = 0
          IEND       = NIMA
d248 1
a248 1
             DO IMI=1,NIMA
d261 3
a263 3
	           NIMALCG      = NIMALCG + 1
	           LCG(NIMALCG) = IMI
                   IF (DT .LT. 0) LCG(NIMALCG) = -IMI
d267 1
a267 1
             IF (NIMALCG .LE. 0) THEN
d273 1
a273 1
             IEND = NIMALCG
d347 1
a347 1
C         LOOP OVER ALL RELEVANT REF. IMAGES
d353 1
a353 1
	     IF (NIMALCG .GT. 0) IMI = ABS(LCG(IMIL))
d373 1
a373 1
          ENDDO   ! END OF: DO IMIL=1,IEND
d378 1
a378 1
          IMGEXP   = ILIP(IEXP)
d389 1
a389 1
              IMGREF = ILIST(IREF)
d394 16
a409 3
C         AP_END DETERMINES SHIFT PARAMETERS AND WRITES TO DOC FILE 
          NPROJ = NIMA
          IF (LIMITRANGE) NPROJ = NIMALCG  
d413 8
a420 23
     &         GOTREFANG, NGOTPAR,NSAM,NROW,CCROT,PEAKV,
     &         RANGNEW,XSHNEW,YSHNEW,MIRRORNEW,EXPPAT,REFPAT,
     &         NPROJ, CTYPE, XBUF,LUNDOC,PARLIST)

          CCROTAVG = CCROTAVG + CCROT
          IF (NGOTPAR .GE. 8) THEN
C            COMPILE CCROT CHANGE STATISTICS
             ANGDIF = PARLIST(10)

             IF (ANGDIF .GT. ANGDIFTHR)IBIGANGDIF = IBIGANGDIF + 1
  
             CCROTLAS  = ANGEXP(8,IEXP)
             ANGDIFAVG = ANGDIFAVG + PARLIST(10)

             CCROTAVG = CCROTAVG + CCROT
             IF (CCROT .GE. CCROTLAS) THEN
                IMPROVCCROT = IMPROVCCROT + 1
                CCROTIMPROV = CCROTIMPROV + CCROT
             ELSE
                IWORSECCROT = IWORSECCROT + 1
                CCROTWORSE  = CCROTWORSE + CCROT
             ENDIF
          ENDIF
d422 1
a422 1
       ENDDO
d424 1
a424 1
      IF (NIDI .GT. 1) THEN
d426 1
a426 1
          CALL AP_STAT(NIDI,ANGDIFTHR,IBIGANGDIF,
d435 1
a435 1
      IF (ALLOCATED(XBUF)) DEALLOCATE(XBUF)
d447 1
a447 1
         SUBROUTINE DSGR_P(ILIST,NIMA,ILIP,NIDI,
d456 2
a457 2
	INTEGER, DIMENSION(NIMA)                    :: ILIST 
	INTEGER, DIMENSION(NIDI)                    :: ILIP 
d459 1
a459 1
	REAL, DIMENSION(LCIRC,NIMA)                 :: CIRCREF
d480 1
a480 1
	REAL, ALLOCATABLE, DIMENSION(:)             :: XBUF 
d483 1
a483 1
 	DOUBLE PRECISION, DIMENSION(NIMA)           :: TOTMIN,TOTMIR
d486 1
a486 1
 	REAL, DIMENSION(NIMA)                       :: ROTANGT,ROTANGM 
d491 2
a492 2
	REAL, DIMENSION(8,NIDI)                     :: ANGEXP
	REAL, DIMENSION(3,NIMA)                     :: ANGREF,REFDIR
d494 1
a494 1
	INTEGER, DIMENSION(NIMA)                    :: LCG
a506 1
        INTEGER                            :: IGRPS(3)
a509 1
        REAL, ALLOCATABLE, DIMENSION(:,:)  :: ALOC, ABUF
d515 2
a516 2
        LOGICAL            :: USEBCAST
        COMMON /COMM_MPI/USEBCAST
a541 8
C       MAKE XBUF AT LEAST NSAM*NROW FOR USE BY AP_SHIFTS
        MWANTX = NSAM*NROW
	ALLOCATE(XBUF(MWANTX),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
           CALL ERRT(46,'XBUF',MWANTX)
           GOTO 9999
        ENDIF

d545 1
a545 1
	CALL AP_GETANGA(ILIST,NIMA,0,REFANGDOC,REFPAT,
d550 1
a550 1
	CALL AP_GETSATA(ANGREF,REFDIR,3,NIMA,IRTFLG)
d556 1
a556 1
        CALL APRINGS_NEW(ILIST,NIMA, NSAM,NROW,
d564 1
a564 1
              WRITE(NOUT,91)NUMTH
d567 1
a567 1
              WRITE(NOUT,92)NUMTH
d580 1
a580 1
           CALL AP_GETANGA(ILIP,NIDI,0,EXPANGDOC,EXPPAT,
d587 5
a591 8
C       INITIALIZE CCROT STATISTICS        
        CCROTAVG    = 0.0
        IMPROVCCROT = 0
        CCROTIMPROV = 0.0
        IWORSECCROT = 0
        CCROTWORSE  = 0.0
        ANGDIFAVG   = 0.0
        IBIGANGDIF  = 0
d600 2
a601 2
C       FILL PSIZE WITH PARTITION LIMITS
        CALL SETPART(NIDI, PSIZE, NBASE)
d611 2
a612 3
        ALLOCATE(ALOC(NSAM*NROW,NLOC),
     &           ABUF(NSAM*NROW,PSIZE(1)),
     &           PARTAB(15,NIDI), 
d616 3
a618 3
           MWANT = NSAM*NROW*NLOC + NSAM*NROW*PSIZE(1) + 15*(NIDI+NLOC)
           CALL ERRT(46,'DSGR_P: ALOC...',MWANT)
           RETURN
a621 2
        ALOC      = 0.0
        ABUF      = 0.0
a624 60
#ifdef MPI_DEBUG
        TCOM0 = MPI_WTIME()
#endif
        DO IPROC = 1, NPROCS
           NLOCP = PSIZE(IPROC)  

C          === CALCULATE THE GLOBAL INDEX ===
           IBEG = NBASE(IPROC) + 1
           IEND = NBASE(IPROC) + NLOCP 

C          ALTHOUGH THE FOLLOWING IS CALLED BY ALL PROCESSORS,
C          ONLY ONE PROCESSOR (MYPID=0) READS IMAGES INTO ABUF

           CALL AP_GETDATS(ILIP,NIDI,NSAM,NROW,
     &                     1,EXPPAT,INPIC, IBEG,IEND,
     &                     ABUF, IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9999

           CALL MPI_BARRIER(ICOMM, MPIERR)

           IF (IPROC .GT. 1) THEN
              IF (MYPID .EQ. 0) THEN
#ifdef MPI_DEBUG
                WRITE(6,*)' DSGR_P: SENDING TO MYPID: ',IPROC-1
                CALL FLUSHFILE(6)
#endif
                CALL SEND_MPI('DSGR_P','ABUF', ABUF, NSAM*NROW*NLOCP, 
     &                        'R',IPROC-1,IPROC-1, ICOMM)

              ELSE IF (MYPID .EQ. IPROC-1) THEN

C                === SLAVES RECEIVE LOCAL PIECES ===
                 CALL RECV_MPI('DSGR_P','ALOC', ALOC, NSAM*NROW*NLOCP, 
     &                         'R', 0,0, ICOMM)

#ifdef MPI_DEBUG
                 WRITE(6,*) ' DSGR_P: RECEIVED BY MYPID;', MYPID
                 CALL FLUSHFILE(6)
#endif
              ENDIF
           ELSE IF (MYPID .EQ. 0) THEN  
C             === SIMPLY COPY FROM ABUF TO ALOC ===
              DO JLOC = 1, NLOCP
                 DO IROW = 1, NSAM*NROW
                    ALOC(IROW,JLOC) = ABUF(IROW,JLOC)
                 ENDDO
              ENDDO
           ENDIF
        ENDDO       ! END OF:  DO IPROC = 1, NPROCS


 
        IF (ALLOCATED(ABUF)) DEALLOCATE(ABUF)

#ifdef MPI_DEBUG_never
        TCOM1 = MPI_WTIME()
        IF (MYPID .EQ. 0) WRITE(6,440) TCOM1-TCOM0
 440    FORMAT('  DSGR_P: DATA DIST TIME = ', 1PE11.3)
#endif

d629 1
a629 2
C       THE FOLLOWING LOOP IS SIMULTANEOUSLY PERFORMED BY ALL PROCESSORS
C       ON DISTRIBUTED DATA
d634 3
a636 1
        USEBCAST = .FALSE.
d638 9
a646 1
          IEXP = NBASE(MYPID+1) + JLOC
d649 1
a649 1
          CALL AP_GETSATA(ANGEXP(1,IEXP),EXPDIR,8,1,IRTFLG)
d652 1
a652 1
	  CALL APRINGS_ONE_NEW(NSAM,NROW, CNS2,CNR2, ALOC(1,JLOC),
d658 2
a659 2
 	  NIMALCG    = 0
          IEND       = NIMA
d666 1
a666 1
             DO IMI=1,NIMA
d679 3
a681 3
	           NIMALCG      = NIMALCG + 1
	           LCG(NIMALCG) = IMI
                   IF (DT .LT. 0) LCG(NIMALCG) = -IMI
d685 1
a685 1
             IF (NIMALCG .LE. 0) THEN
d691 1
a691 1
             IEND = NIMALCG
a730 1

a745 1

d761 1
a761 1
	     IF (NIMALCG .GT. 0) IMI = ABS(LCG(IMIL))
a785 1
          IMGEXP   = ILIP(IEXP)
d796 1
a796 1
              IMGREF = ILIST(IREF)
d801 15
a815 2
          NPROJ = NIMA
          IF (LIMITRANGE) NPROJ = NIMALCG   
d817 1
a817 1
C         AP_END RETURNS PARTABLOC PARAMETERS FOR THIS IMAGE
d819 1
a819 1
          CALL AP_END(IEXP,IMGEXP,IMGREF, 
d821 10
a830 24
     &         ANGEXP(1,IEXP),EXPDIR,ISHRANGE,
     &         GOTREFANG, NGOTPAR,NSAM,NROW,CCROT,PEAKV,
     &         RANGNEW,XSHNEW,YSHNEW,MIRRORNEW,EXPPAT,REFPAT,
     &         NPROJ, CTYPE, ALOC(1,JLOC), LUNDOC, PARTABLOC(1,JLOC))

          CCROTAVG = CCROTAVG + CCROT
          IF (NGOTPAR .GE. 8) THEN
C            COMPILE CCROT CHANGE STATISTICS
             ANGDIF = PARTABLOC(10,JLOC)

             IF (ANGDIF .GT. ANGDIFTHR)IBIGANGDIF = IBIGANGDIF + 1
  
             CCROTLAS  = ANGEXP(8,IEXP)
             ANGDIFAVG = ANGDIFAVG + PARTABLOC(10,JLOC)

             CCROTAVG = CCROTAVG + CCROT
             IF (CCROT .GE. CCROTLAS) THEN
                IMPROVCCROT = IMPROVCCROT + 1
                CCROTIMPROV = CCROTIMPROV + CCROT
             ELSE
                IWORSECCROT = IWORSECCROT + 1
                CCROTWORSE  = CCROTWORSE + CCROT
             ENDIF
           ENDIF
d833 1
a833 1
c        write(0,*) ' dsgr_p, barrier 2, mypid: ' ,mypid
d836 2
a837 1
        USEBCAST = .TRUE.
d855 1
a855 1
           DO IT = 1, NIDI
d860 1
a860 1
        IF (NIDI .GT. 1) THEN   ! I SUSPECT SUMS ARE WRONG FOR MPI!
d862 1
a862 1
          CALL AP_STAT(NIDI,ANGDIFTHR,IBIGANGDIF,
a869 1
       IF (ALLOCATED(ALOC))      DEALLOCATE(ALOC)
d872 1
a872 1
       IF (ALLOCATED(XBUF))      DEALLOCATE(XBUF)
@


1.61
log
@LCG(IMIL) .LT. 0
@
text
@d13 1
d74 1
a75 1
#ifndef USE_MPI
a156 6
#ifdef SP_LIBFFT
         IF (LENTT .GT. 15) THEN
             CALL DZFFT1DUI(LENTT-15,TT)
         ENDIF
#endif

d395 1
d397 1
a397 1
          IF (LIMITRANGE) NPROJ = NIMALCG   
d438 1
a438 1
      IF (ALLOCATED(XBUF))   DEALLOCATE(XBUF)
d445 1
a449 3



d510 1
a510 3
        INTEGER MPIERR, COMM, MYPID, NPROCS, RC
        INTEGER MPISTAT(MPI_STATUS_SIZE)
        INTEGER JLOC, IPROC, NLOC, IROW, JCOL, IBEG, IEND, NWANTOUT
d515 1
d519 7
a525 4
C
        COMM = MPI_COMM_WORLD
        CALL MPI_COMM_RANK(COMM, MYPID, MPIERR)
        CALL MPI_COMM_SIZE(COMM, NPROCS, MPIERR)
a546 6
#ifdef SP_LIBFFT
         IF (LENTT .GT. 15) THEN
             CALL DZFFT1DUI(LENTT-15,TT)
         ENDIF
#endif

d557 1
d588 1
a588 1
 
d610 1
a610 1
        ALLOCATE(PSIZE(NPROCS),STAT=IRTFLG)
d612 2
a613 2
           WRITE(6,*) 'DSGR_P: FAILED TO ALLOCATE PSIZE'
           RETURN
d616 1
a616 5
        ALLOCATE(NBASE(NPROCS), STAT=IRTFLG)
        IF (IRTFLG .NE. 0) THEN
           WRITE(6,*) 'DSGR_P: FAILED TO ALLOCATE NBASE'
           RETURN
        ENDIF
d621 1
d623 1
a623 2
 111    FORMAT('DSGR_P: NBASE = ', I5, ' MYPID = ', I5)
        CALL MPI_BARRIER(COMM,MPIERR)
d625 1
d627 4
a630 1
        ALLOCATE(ALOC(NSAM*NROW,NLOC),ABUF(NSAM*NROW,PSIZE(1)),
d633 2
a634 1
           WRITE(6,*) 'DSGR_P: FAILED TO ALLOCATE ALOC, ABUF'
d636 7
a642 3
        END IF
        ALOC = 0.0
        ABUF = 0.0
d648 1
a648 1
           NLOC = PSIZE(IPROC)
a650 1

d652 1
a652 1
           IEND = NBASE(IPROC) + NLOC 
d661 2
a662 1
           CALL MPI_BARRIER(COMM, MPIERR)
d667 2
a668 3
                 WRITE(6,222) IPROC-1
                 CALL FLUSHFILE(6)
 222             FORMAT('DSGR_P: SENDING TO PID = ', I3)
d670 3
a672 3
                 CALL MPI_SEND(ABUF   , NSAM*NROW*NLOC, MPI_REAL,
     &                         IPROC-1, IPROC-1       , COMM    ,
     &                         MPIERR)
d676 2
a678 7
                 CALL MPI_RECV(ALOC , NSAM*NROW*NLOC, MPI_REAL,
     &                         0    , MPI_ANY_TAG   , COMM    ,
     &                         ISTAT, MPIERR)
                 IF (MPIERR .NE. 0) THEN
                     WRITE(6,*) ' RECV FAILED'
                     STOP
                 ENDIF
d680 1
a680 1
                 WRITE(6,223) MYPID
a681 1
 223             FORMAT('DSGR_P: RECEIVED BY MYPID = ', I3)
a684 1

d686 1
a686 2

              DO JLOC = 1, NLOC
d692 4
a695 2
           CALL MPI_BARRIER(COMM,MPIERR)
        ENDDO
d697 2
a698 1
#ifdef MPI_DEBUG
d701 1
a701 1
 440    FORMAT(1X,'DSGR_P: DATA DIST TIME = ', 1PE11.3)
d704 6
a709 9
        NLOC = PSIZE(MYPID+1)
        ALLOCATE(PARTAB(15,NIDI), PARTABLOC(15,NLOC),
     &           STAT=IRTFLG)
        IF (IRTFLG .NE. 0) THEN
           WRITE(6,*) 'DSGR_P: FAILED TO ALLOCATE PARTAB, PARTABLOC'
           STOP
        ENDIF
        PARTAB     = 0.0
        PARTABLOC = 0.0
d711 2
a712 2
C       THE FOLLOWING LOOP IS PERFORMED BY ALL PROCESSORS
C       SIMULTANEOUSLY ON DISTRIBUTED DATA
d714 2
a715 1
        DO JLOC = 1, NLOC
a720 4
C         CALCULATE DIMENSIONS FOR APRINGS
	  CNS2 = NSAM / 2+ 1
	  CNR2 = NROW / 2+ 1

d722 1
a722 1
	  CALL APRINGS_ONE_NEW(NSAM,NROW,CNS2,CNR2, ALOC(1,JLOC),
d789 1
a789 1
	     ENDDO
d824 1
a824 1
	     ENDDO
d855 1
d876 3
d884 1
a884 1
     &         NPROJ, CTYPE, ALOC,LUNDOC,PARTABLOC(1,JLOC))
d886 1
d904 4
a907 1
          ENDIF
d909 2
a910 2
        ENDDO 
        CALL MPI_BARRIER(COMM,MPIERR)
d915 2
a916 2
           PSIZE(IPROC) = 15*PSIZE(IPROC)
           NBASE(IPROC) = 15*NBASE(IPROC)
d920 11
a930 24
     &                      MPI_REAL, COMM  , MPIERR)
C
C       WRITE HAS BEEN SYNCHRONIZED WITHIN LUNDOCWRTDAT
C
        NWANTOUT = 15 
        IF (NWANTOUT .GT. 7) THEN
           IF (LUNDOC .GT. 0) THEN
C             SAVE IN ALIGNMENT DOC FILE
C             <,<,<, MIR-REF#,IMG#,INPLANE<, SX,SY,NPROJ,
C             <DIF,CCROT,INPLANE<,SX,SY
              DO IT = 1, NIDI
                 CALL LUNDOCWRTDAT(LUNDOC,IT,PARTAB(1,IT),
     &                             NWANTOUT,IRTFLG)
              ENDDO
           ENDIF
        ELSE
           IF (LUNDOC .GT. 0) THEN
C             SAVE IN ALIGNMENT DOC FILE
C             MIR-REF#, CCROT, INPLANE<, SX,SY, IMG#, < DIFF
              DO IT = 1, NIDI
                 CALL LUNDOCWRTDAT(LUNDOC,IT,PARTAB(1,IT),
     &                             NWANTOUT,IRTFLG)
              ENDDO
           ENDIF
d933 1
a933 8
        IF (ALLOCATED(PSIZE))     DEALLOCATE(PSIZE)
        IF (ALLOCATED(NBASE))     DEALLOCATE(NBASE)
        IF (ALLOCATED(ALOC))      DEALLOCATE(ALOC)
        IF (ALLOCATED(PARTABLOC)) DEALLOCATE(PARTABLOC)
        IF (ALLOCATED(PARTAB))    DEALLOCATE(PARTAB)


       IF (NIDI .GT. 1) THEN
d939 1
a939 1
       ENDIF
d941 6
a946 2
9999  CLOSE(LUNANG)
      IF (.NOT. CIRCREF_IN_CORE)  CLOSE(LUNRING)
d948 2
a949 1
      IF (ALLOCATED(XBUF))   DEALLOCATE(XBUF)
d951 1
a951 1
      END
@


1.60
log
@FFTW3 plan changes, FFTW aprings
@
text
@d295 1
a295 1
                   IF (LIMITRANGE)     MIRRORED = (LCG(IRR) .LT. 0) 
d333 1
a333 1
                   IF (LIMITRANGE)     MIRRORED = (LCG(IRR) .LT. 0) 
d791 1
a791 1
                   IF (LIMITRANGE)     MIRRORED = (LCG(IRR) .LT. 0) 
d823 1
a823 1
                   IF (LIMITRANGE)     MIRRORED = (LCG(IRR) .LT. 0) 
@


1.59
log
@*** empty log message ***
@
text
@d11 2
d16 1
a16 1
C=* Copyright (C) 1985-2005  Health Research Inc.                      *
d43 1
a43 1
C         MODE,REFANGDOC,EXPANGDOC,SCRFILE,
d46 409
a454 24
C  ORDER OF PROCESSING:
C 1 - CALCULATE WEIGHTS FOR RINGS IN RINGWE, STORE IN WR
C 2 - CONVERT EACH REFERENCE IMAGE TO RINGS, DO THE FFTS
C     FOR ALL THE RINGS, APPLY WEIGHTS TO THE RINGS, STORE IT IN CIRCREF.
C     IN ADDITION, HIGHEST FREQUENCY FOR ALL THE RINGS EXCEPT
C     MAXRING ARE DIVIDED BY 2.
C 3 - CONVERT EACH INPUT IMAGE TO RINGS, DO THE FFTS,
C     COMPARE EACH INPUT IMAGE WITH ALL THE REFERENCE IMAGES
C     USING CROSRNG_**. 
C     SINCE Y WERE PRE-WEIGHTED THE RESULT ARE ALREADY CORRECT.
C
C PARAMETERS:
C       ILIST               LIST OF REF. IMAGE FILE NUMBERS   (INPUT)
C       NIMA                NO. OF IMAGES                     (INPUT)
C       ILIP                LIST OF EXP. IMAGE FILE NUMBERS   (INPUT)
C       NIDI                NO. OF IMAGES                     (INPUT)
C       REFANGDOC           REF. ANGLES FILE NAME             (INPUT)
C       EXPANGDOC           EXP. ANGLES FILE NAME             (INPUT)
C       REFPAT              REF. IMAGE SERIES FILE TEMPLATE   (INPUT)
C       EXPPAT              EXP. IMAGE SERIES FILE TEMPLATE   (INPUT)
C
C  OPERATIONS:  'AP REF', 'AP RD', 'AP RN'
C
C--*********************************************************************
d459 1
a459 1
     &          MODE,REFANGDOC,EXPANGDOC,SCRFILE,
d486 1
d514 1
a514 1
#ifdef USE_MPI
a529 3
#else 
        MYPID = -1
#endif
d534 4
a537 1
        MAXRIN = NUMR(3,NRING)
d578 2
a579 3
        CALL APRINGS(ILIST,NIMA, 
     &               NSAM,NROW,NDUM,NDUM,
     &               NRING,LCIRC,NUMR,MODE, 
a617 2
#ifdef USE_MPI

d733 4
d738 3
a740 3
          CALL APRINGS_ONE(NSAM,NROW,0.0,
     &                     ALOC(1,JLOC),CIRCEXP,MODE,NUMR,NRING,LCIRC,
     &                     IRTFLG)
d788 4
a791 3
                IF (CKMIRROR) THEN
                   IF (LIMITRANGE) THEN
                       MIRRORED = (LCG(IMIL) .LT. 0) 
d793 2
a794 2
C                      CHECK EITHER MIRRORED OR NON-MIRRORED POSITION 
	               CALL CROSRNG_E(CIRCREF(1,IMI),CIRCEXP,
d797 4
a800 4
     &                              TT,MIRRORED)
                   ELSE
C                     CHECK BOTH NON-MIRRORED & MIRRORED POSITIONS 
	              CALL CROSRNG_MS(CIRCREF(1,IMI),CIRCEXP,
d803 1
a803 8
     &                   TOTMIR(IMI),ROTANGM(IMI), TT)
                   ENDIF
                ELSE
C                  DO NOT CHECK MIRRORED POSITION
	           CALL CROSRNG_E(CIRCREF(1,IMI),CIRCEXP,
     &                  LCIRC,NRING,  MAXRIN,NUMR, 
     &                  TOTMIN(IMI),ROTANGT(IMI),
     &                  TT, .FALSE.)
d820 13
a832 11
                IF (CKMIRROR) THEN
                   IF (LIMITRANGE) THEN
                       MIRRORED = (LCG(IMIL) .LT. 0) 

C                      CHECK EITHER MIRRORED OR NON-MIRRORED POSITION 
	               CALL CROSRNG_E(CIRCREF(1,ITHREAD),CIRCEXP,
     &                              LCIRC,NRING, MAXRIN,NUMR,
     &                              TOTMIN(IMI),ROTANGT(IMI),
     &                              TT,MIRRORED)
                   ELSE
C                     CHECK BOTH NON-MIRRORED & MIRRORED POSITIONS 
d834 1
a834 1
                      CALL CROSRNG_MS(CIRCREF(1,ITHREAD),CIRCEXP,
d837 2
a838 8
     &                        TOTMIR(IMI),ROTANGM(IMI), TT)
                   ENDIF
                ELSE
C                  DO NOT CHECK MIRRORED POSITION
	           CALL CROSRNG_E(CIRCREF(1,ITHREAD),CIRCEXP,
     &                    LCIRC,NRING, MAXRIN,NUMR, 
     &                    TOTMIN(IMI),ROTANGT(IMI), 
     &                    TT, .FALSE.)
a958 212
#else
        DO IEXP=1,NIDI
C         LOOP OVER ALL EXPERIMENTAL (SAMPLE) IMAGES
    
C         CONVERT EXP. ANGLE TO UNITARY DIRECTIONAL VECTORS (EXPDIR).
	  CALL AP_GETSATA(ANGEXP(1,IEXP),EXPDIR,8,1,IRTFLG)

C         LOAD CURRENT EXPERIMENTAL IMAGE INTO ARRAY XBUF
	  CALL AP_GETDATS(ILIP,NIDI,NSAM,NROW,
     &                   1,EXPPAT,INPIC, IEXP,IEXP,
     &                   XBUF, IRTFLG)
          IF (IRTFLG .NE. 0) GOTO 9999

C         EXTRACT EXP. IMAGE POLAR COORD. RINGS, NORMALIZE & FFT THEM
	  CALL APRINGS_ONE(NSAM,NROW,0.0,
     &                   XBUF,CIRCEXP,MODE,NUMR,NRING,LCIRC,
     &                  IRTFLG)
          IF (IRTFLG .NE. 0) GOTO 9999

C         DETERMINE WHICH REF IMAGES ARE TO BE COMPARED
	  NIMALCG    = 0
          IEND       = NIMA
          CCROTD     = -1.0D20
          LIMITRANGE = RANGE .LT. 1.0

          IF (LIMITRANGE) THEN
C            DETERMINE WHICH REF IMAGES ARE TO BE COMPARED

             DO IMI=1,NIMA
C               LOOP OVER ALL REF. IMAGES
C               ABS - DIRECTIONS AT 180 DEGREES ARE DIFFERENT 
C                     (- DO NOT CHECK MIRRORED)
C               DT NEAR 1.0 = NOT-MIRRORED, DT NEAR -1.0 = MIRRORED

                DT =    (EXPDIR(1) * REFDIR(1,IMI) + 
     &                   EXPDIR(2) * REFDIR(2,IMI) + 
     &                   EXPDIR(3) * REFDIR(3,IMI))
	        DTABS = ABS(DT)

	        IF (DTABS .GE. RANGE)  THEN
C                  NON-MIRRORED OR MIRRORED REF. IS WITHIN RANGE
	           NIMALCG      = NIMALCG + 1
	           LCG(NIMALCG) = IMI
                   IF (DT .LT. 0) LCG(NIMALCG) = -IMI
                ENDIF
	     ENDDO

             IF (NIMALCG .LE. 0) THEN
C               NO REF. IMAGE WITHIN COMPARISON ANGLE
                IREF = 0 
                GOTO 1000
             ENDIF

             IEND = NIMALCG
          ENDIF

C         REF. IMAGES FOUND WITHIN COMPARISION RANGE

          IF (CIRCREF_IN_CORE) THEN
C            USE CIRCREF FOR REFERENCE RINGS

c$omp        parallel do private(imil,imi,mirrored)
             DO IMIL=1,IEND
                IMI = IMIL
	        IF (LIMITRANGE) IMI = ABS(LCG(IMIL))

                IF (CKMIRROR) THEN
                   IF (LIMITRANGE) THEN
                       MIRRORED = (LCG(IMIL) .LT. 0) 

C                      CHECK EITHER MIRRORED OR NON-MIRRORED POSITION 
	               CALL CROSRNG_E(CIRCREF(1,IMI),CIRCEXP,
     &                              LCIRC,NRING, MAXRIN,NUMR,
     &                              TOTMIN(IMI),ROTANGT(IMI),
     &                              TT,MIRRORED)
                   ELSE
C                     CHECK BOTH NON-MIRRORED & MIRRORED POSITIONS 
	              CALL CROSRNG_MS(CIRCREF(1,IMI),CIRCEXP,
     &                   LCIRC,NRING, MAXRIN,NUMR, 
     &                   TOTMIN(IMI),ROTANGT(IMI),
     &                   TOTMIR(IMI),ROTANGM(IMI), TT)
                   ENDIF
                ELSE
C                  DO NOT CHECK MIRRORED POSITION
	           CALL CROSRNG_E(CIRCREF(1,IMI),CIRCEXP,
     &                  LCIRC,NRING,  MAXRIN,NUMR, 
     &                  TOTMIN(IMI),ROTANGT(IMI),
     &                  TT, .FALSE.)
                ENDIF
	     ENDDO
c$omp        end parallel do

          ELSE
C            USE REFERENCE RINGS FILE (MIGHT BE AN INCORE FILE)
             
c$omp        parallel do private(imil,imi,mirrored,ithread)
c$omp&       schedule(static,1)
             DO IMIL=1,IEND     !LOOP OVER ALL REFERENCE IMAGES
                IMI = IMIL
	        IF (LIMITRANGE) IMI = ABS(LCG(IMIL))

C               FIND THREAD NUMBER 
                ITHREAD = MOD((IMIL-1),NUMTH) + 1
 
C               FILL CIRCREF FROM REFERENCE RINGS FILE
c$omp           critical
                CALL REDLIN(LUNRING,CIRCREF(1,ITHREAD),LCIRC,IMI)
c$omp           end critical
c          if(imil.lt.2) 
c     & write(6,*) 'b',ITHREAD,CIRCREF(1,ITHREAD),CIRCREF(5000,ITHREAD)
                IF (CKMIRROR) THEN
                   IF (LIMITRANGE) THEN
                       MIRRORED = (LCG(IMIL) .LT. 0) 

C                      CHECK EITHER MIRRORED OR NON-MIRRORED POSITION 
	               CALL CROSRNG_E(CIRCREF(1,ITHREAD),CIRCEXP,
     &                              LCIRC,NRING, MAXRIN,NUMR,
     &                              TOTMIN(IMI),ROTANGT(IMI),
     &                              TT,MIRRORED)
                   ELSE
C                     CHECK BOTH NON-MIRRORED & MIRRORED POSITIONS 

                      CALL CROSRNG_MS(CIRCREF(1,ITHREAD),CIRCEXP,
     &                        LCIRC,NRING, MAXRIN,NUMR,
     &                        TOTMIN(IMI),ROTANGT(IMI),
     &                        TOTMIR(IMI),ROTANGM(IMI), TT)
                   ENDIF
                ELSE
C                  DO NOT CHECK MIRRORED POSITION
	           CALL CROSRNG_E(CIRCREF(1,ITHREAD),CIRCEXP,
     &                    LCIRC,NRING, MAXRIN,NUMR, 
     &                    TOTMIN(IMI),ROTANGT(IMI), 
     &                    TT, .FALSE.)
                ENDIF
	     ENDDO
comp        end parallel do
          ENDIF

C         LOOP OVER ALL RELEVANT REF. IMAGES
          IREF   = 0
          CCROTD = -1.0D20

          DO IMIL=1,IEND
             IMI = IMIL
	     IF (NIMALCG .GT. 0) IMI = ABS(LCG(IMIL))

             IF (TOTMIN(IMI) .GE. CCROTD) THEN
C               GOOD MATCH WITH TOTMIN (MIRRORED OR NOT)  POSITION 
                CCROTD    = TOTMIN(IMI)
                RANGNEW   = ROTANGT(IMI)
                MIRRORNEW = (LIMITRANGE .AND. (LCG(IMIL) .LT. 0))
                IREF      = IMI
	     ENDIF
 
             IF (CKMIRROR .AND. .NOT. LIMITRANGE) THEN 
C               HAVE TO COMPARE WITH MIRRORED POSITION 
                IF (TOTMIR(IMI) .GE. CCROTD) THEN
C                  GOOD MATCH, MIRRORED POSITION IS BETTER
                   CCROTD    = TOTMIR(IMI)
                   RANGNEW   = ROTANGM(IMI)
                   MIRRORNEW = .TRUE.
                   IREF      = IMI
                ENDIF
             ENDIF   ! END OF: IF (CKMIRROR)
          ENDDO   ! END OF: DO IMIL=1,IEND


1000      RANGNEW  = (RANGNEW-1) / MAXRIN * DIVAS
          CCROT    = CCROTD
          IMGEXP   = ILIP(IEXP)
          PEAKV    = 0.0
          XSHNEW   = 0.0
          YSHNEW   = 0.0

          IF (IREF .LE. 0) THEN
C             NO NEARBY REFERENCE IMAGE
              IMGREF = 0
C             IREFT IS FOR REFDIR INDEX
              IREFT  = 1
          ELSE
              IMGREF = ILIST(IREF)
C             IREFT IS FOR REFDIR INDEX
              IREFT  = IREF
          ENDIF
         
          NPROJ = NIMA
          IF (LIMITRANGE) NPROJ = NIMALCG   
          CALL AP_END(IEXP,IMGEXP,IMGREF, 
     &         ANGREF(1,IREFT),REFDIR(1,IREFT),
     &         ANGEXP(1,IEXP),EXPDIR,ISHRANGE,
     &         GOTREFANG, NGOTPAR,NSAM,NROW,CCROT,PEAKV,
     &         RANGNEW,XSHNEW,YSHNEW,MIRRORNEW,EXPPAT,REFPAT,
     &         NPROJ, CTYPE, XBUF,LUNDOC,PARLIST)

          IF (NGOTPAR .GE. 8) THEN
C            COMPILE CCROT CHANGE STATISTICS
             ANGDIF = PARLIST(10)

             IF (ANGDIF .GT. ANGDIFTHR)IBIGANGDIF = IBIGANGDIF + 1
  
             CCROTLAS  = ANGEXP(8,IEXP)
             ANGDIFAVG = ANGDIFAVG + PARLIST(10)

             CCROTAVG = CCROTAVG + CCROT
             IF (CCROT .GE. CCROTLAS) THEN
                IMPROVCCROT = IMPROVCCROT + 1
                CCROTIMPROV = CCROTIMPROV + CCROT
             ELSE
                IWORSECCROT = IWORSECCROT + 1
                CCROTWORSE  = CCROTWORSE + CCROT
             ENDIF
          ENDIF
a959 2
       ENDDO
#endif
d961 1
a961 1
       IF (NGOTPAR .GE. 8 .AND. NIDI .GT. 1) THEN
d976 8
@


1.58
log
@plan added to call
@
text
@a10 1
C                   FFTW3PLAN                     MAR 08 ARDEAN LEITH
d14 1
a14 1
C=* Copyright (C) 1985-2008  Health Research Inc.                      *
d41 1
a41 1
C         MODE,REFANGDOC,EXPANGDOC,SCRFILE,FFTW3PLAN,
a43 3
C  PURPOSE: FIND ROTATIONAL AND SHIFT PARAMETERS TO ALIGN A SERIES OF
C           REFERENCE IMAGES WITH SAMPLE IMAGES
C
a68 389
C ---------------------  NON-MPI CODE --------------------------------
#ifndef USE_MPI

         SUBROUTINE DSGR_P(ILIST,NIMA,ILIP,NIDI,
     &          NSAM,NROW,LENTT,RANGE,ANGDIFTHR,
     &          NRING,LCIRC,NUMR,CIRCREF,CIRCREF_IN_CORE,
     &          MODE,REFANGDOC,EXPANGDOC,SCRFILE,FFTW3PLAN,
     &          REFPAT,EXPPAT,CKMIRROR,CTYPE,ISHRANGE,LUNDOC)


        INCLUDE 'CMLIMIT.INC'
        INCLUDE 'CMBLOCK.INC'

	INTEGER, DIMENSION(NIMA)                    :: ILIST 
	INTEGER, DIMENSION(NIDI)                    :: ILIP 
        INTEGER, DIMENSION(3,NRING)                 :: NUMR
	REAL, DIMENSION(LCIRC,NIMA)                 :: CIRCREF
	CHARACTER(LEN=1)                            :: MODE 
        CHARACTER (LEN=*)                           :: REFANGDOC
        CHARACTER (LEN=*)                           :: EXPANGDOC
        CHARACTER (LEN=*)                           :: SCRFILE
        CHARACTER (LEN=*)                           :: REFPAT,EXPPAT 
        CHARACTER (LEN=*)                           :: CTYPE 
        CHARACTER (LEN=74)                          :: COMMENT 

	DOUBLE PRECISION                            :: CCROTD
	CHARACTER(LEN=1)                            :: NULL
	LOGICAL                                     :: CIRCREF_IN_CORE
	LOGICAL                                     :: CKMIRROR
        LOGICAL                                     :: MIRRORNEW
	LOGICAL                                     :: GOTREFANG
	LOGICAL                                     :: ONLYMIRROR
        LOGICAL                                     :: LIMITRANGE
        LOGICAL                                     :: MIRRORED

C       ALLOCATABLE ARRAYS
	REAL, ALLOCATABLE, DIMENSION(:)             :: XBUF 

C       AUTOMATIC ARRAYS
 	DOUBLE PRECISION, DIMENSION(NIMA)           :: TOTMIN,TOTMIR
	DOUBLE PRECISION, DIMENSION(LENTT)          :: TT 

 	REAL, DIMENSION(NIMA)                       :: ROTANGT,ROTANGM 
 	REAL, DIMENSION(LCIRC)                      :: CIRCEXP 

	REAL, DIMENSION(6)                          :: DLIST
	REAL, DIMENSION(3)                          :: EXPDIR
	REAL, DIMENSION(8,NIDI)                     :: ANGEXP
	REAL, DIMENSION(3,NIMA)                     :: ANGREF,REFDIR

	INTEGER, DIMENSION(NIMA)                    :: LCG

        INTEGER                                     :: NSAID = 0

        INTEGER, PARAMETER                          :: NLISTMAX = 15
        REAL, DIMENSION(NLISTMAX)                   :: PARLIST

	PARAMETER (QUADPI = 3.1415926535897932384626)
	PARAMETER (DGR_TO_RAD = (QUADPI/180))

	DATA  INPIC,LUNANG,LUNRING/77,78,50/

        MYPID = -1


        NULL  = CHAR(0)

        NR     = NUMR(1,NRING)     ! OUTER RING NUMBER
        MAXRIN = NUMR(3,NRING)

C       THIS ALTERS RANGE!
	RANGE  = COS(RANGE*DGR_TO_RAD)

C       FIND NUMBER OF OMP THREADS
        CALL GETTHREADS(NUMTH)

        IF (MODE .EQ. 'H')  THEN
           DIVAS = 180.0
        ELSE
           DIVAS = 360.0
        ENDIF

#ifdef SP_LIBFFT
         IF (LENTT .GT. 15) THEN
             CALL DZFFT1DUI(LENTT-15,TT)
         ENDIF
#endif

C       MAKE XBUF AT LEAST NSAM*NROW FOR USE BY AP_SHIFTS
        MWANTX = NSAM*NROW
	ALLOCATE(XBUF(MWANTX),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
           CALL ERRT(46,'XBUF',MWANTX)
           GOTO 9999
        ENDIF

C       LOAD REF. PROJ. ANGLES (ANGREF) FROM DOC. FILE (REFANGDOC) OR
C       REF. IMAGE FILE (REFPAT) HEAD
	CALL AP_GETANGA(ILIST,NIMA,0,REFANGDOC,REFPAT,
     &                    INPIC,LUNANG,3,ANGREF,NGOTREF,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9999

C       CONVERT REF. ANGLES TO UNITARY DIRECTIONAL VECTORS (REFDIR).
	CALL AP_GETSATA(ANGREF,REFDIR,3,NIMA,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9999
        GOTREFANG = .TRUE.

C       READ REFERENCE IMAGES INTO REFERENCE RINGS (CIRCREF) ARRAY OR
C       CREATE REFERENCE RINGS FILE FOR LATER READING 
        CALL APRINGS(ILIST,NIMA, 
     &               NSAM,NROW,NDUM,NDUM,
     &               NRING,LCIRC,NUMR,MODE, 
     &               REFPAT,INPIC,CIRCREF,CIRCREF_IN_CORE,
     &               LUNRING,SCRFILE,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9999

        IF (NSAID .LE. 0) THEN
           IF (CIRCREF_IN_CORE) THEN
              WRITE(NOUT,91)NUMTH
91            FORMAT('  Ref. rings in core,  Threads: ',I4)
           ELSE
              WRITE(NOUT,92)NUMTH
92            FORMAT('  Ref. rings not in core,  Threads: ',I4)
           ENDIF
           NSAID = NSAID + 1
        ENDIF

C       LOAD EXP. PROJ. ANGLES & ALIGNMENT PARAMETERS (ANGEXP) 
C       FROM DOC. FILE (EXPANGDOC)
 
        NGOTPAR = 0
        IF (EXPANGDOC .NE. NULL) THEN
C          LOAD EXP. PROJ. ANGLES & ALIGNMENT PARAMETERS (ANGEXP) 
C          FROM DOC. FILE (EXPANGDOC) 
           CALL AP_GETANGA(ILIP,NIDI,0,EXPANGDOC,EXPPAT,
     &                       INPIC,LUNANG,8,ANGEXP,NGOTPAR,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9999
        ELSE
           ANGEXP = 0.0
        ENDIF

C       INITIALIZE CCROT STATISTICS        
        CCROTAVG    = 0.0
        IMPROVCCROT = 0
        CCROTIMPROV = 0.0
        IWORSECCROT = 0
        CCROTWORSE  = 0.0
        ANGDIFAVG   = 0.0
        IBIGANGDIF  = 0

        DO IEXP=1,NIDI
C         LOOP OVER ALL EXPERIMENTAL (SAMPLE) IMAGES
    
C         CONVERT EXP. ANGLE TO UNITARY DIRECTIONAL VECTORS (EXPDIR).
	  CALL AP_GETSATA(ANGEXP(1,IEXP),EXPDIR,8,1,IRTFLG)

C         LOAD CURRENT EXPERIMENTAL IMAGE INTO ARRAY XBUF
	  CALL AP_GETDATS(ILIP,NIDI,NSAM,NROW,
     &                   1,EXPPAT,INPIC, IEXP,IEXP,
     &                   XBUF, IRTFLG)
          IF (IRTFLG .NE. 0) GOTO 9999

C         EXTRACT EXP. IMAGE POLAR COORD. RINGS, NORMALIZE & FFT THEM
	  CALL APRINGS_ONE(NSAM,NROW,0.0,
     &                   XBUF,CIRCEXP,MODE,NUMR,NRING,LCIRC,
     &                  IRTFLG)
          IF (IRTFLG .NE. 0) GOTO 9999

C         DETERMINE WHICH REF IMAGES ARE TO BE COMPARED
	  NIMALCG    = 0
          IEND       = NIMA
          CCROTD     = -1.0D20
          LIMITRANGE = RANGE .LT. 1.0

          IF (LIMITRANGE) THEN
C            DETERMINE WHICH REF IMAGES ARE TO BE COMPARED

             DO IMI=1,NIMA
C               LOOP OVER ALL REF. IMAGES
C               ABS - DIRECTIONS AT 180 DEGREES ARE DIFFERENT 
C                     (- DO NOT CHECK MIRRORED)
C               DT NEAR 1.0 = NOT-MIRRORED, DT NEAR -1.0 = MIRRORED

                DT =    (EXPDIR(1) * REFDIR(1,IMI) + 
     &                   EXPDIR(2) * REFDIR(2,IMI) + 
     &                   EXPDIR(3) * REFDIR(3,IMI))
	        DTABS = ABS(DT)

	        IF (DTABS .GE. RANGE)  THEN
C                  NON-MIRRORED OR MIRRORED REF. IS WITHIN RANGE
	           NIMALCG      = NIMALCG + 1
	           LCG(NIMALCG) = IMI
                   IF (DT .LT. 0) LCG(NIMALCG) = -IMI
                ENDIF
	     ENDDO

             IF (NIMALCG .LE. 0) THEN
C               NO REF. IMAGE WITHIN COMPARISON ANGLE
                IREF = 0 
                GOTO 1000
             ENDIF

             IEND = NIMALCG
          ENDIF

C         REF. IMAGES FOUND WITHIN COMPARISION RANGE

          IF (CIRCREF_IN_CORE) THEN
C            USE CIRCREF FOR REFERENCE RINGS

c$omp        parallel do private(imil,imi,mirrored)
             DO IMIL=1,IEND
                IMI = IMIL
	        IF (LIMITRANGE) IMI = ABS(LCG(IMIL))

                IF (CKMIRROR) THEN
                   IF (LIMITRANGE) THEN
                       MIRRORED = (LCG(IMIL) .LT. 0) 

C                      CHECK EITHER MIRRORED OR NON-MIRRORED POSITION 
	               CALL CROSRNG_EP(CIRCREF(1,IMI),CIRCEXP,
     &                              LCIRC,NRING, MAXRIN,NUMR,
     &                              TOTMIN(IMI),ROTANGT(IMI),
     &                              TT,MIRRORED,FFTW3PLAN)
                   ELSE
C                     CHECK BOTH NON-MIRRORED & MIRRORED POSITIONS 
	              CALL CROSRNG_MSP(CIRCREF(1,IMI),CIRCEXP,
     &                   LCIRC,NRING, MAXRIN,NUMR, 
     &                   TOTMIN(IMI),ROTANGT(IMI),
     &                   TOTMIR(IMI),ROTANGM(IMI), TT,FFTW3PLAN)
                   ENDIF
                ELSE
C                  DO NOT CHECK MIRRORED POSITION
	           CALL CROSRNG_EP(CIRCREF(1,IMI),CIRCEXP,
     &                  LCIRC,NRING,  MAXRIN,NUMR, 
     &                  TOTMIN(IMI),ROTANGT(IMI),
     &                  TT, .FALSE.,FFTW3PLAN)
                ENDIF
	     ENDDO
c$omp        end parallel do

          ELSE
C            USE REFERENCE RINGS FILE (MIGHT BE AN INCORE FILE)
             
c$omp        parallel do private(imil,imi,mirrored,ithread)
c$omp&       schedule(static,1)
             DO IMIL=1,IEND     !LOOP OVER ALL REFERENCE IMAGES
                IMI = IMIL
	        IF (LIMITRANGE) IMI = ABS(LCG(IMIL))

C               FIND THREAD NUMBER 
                ITHREAD = MOD((IMIL-1),NUMTH) + 1
 
C               FILL CIRCREF FROM REFERENCE RINGS FILE
c$omp           critical
                CALL REDLIN(LUNRING,CIRCREF(1,ITHREAD),LCIRC,IMI)
c$omp           end critical
c          if(imil.lt.2) 
c     & write(6,*) 'b',ITHREAD,CIRCREF(1,ITHREAD),CIRCREF(5000,ITHREAD)
                IF (CKMIRROR) THEN
                   IF (LIMITRANGE) THEN
                       MIRRORED = (LCG(IMIL) .LT. 0) 

C                      CHECK EITHER MIRRORED OR NON-MIRRORED POSITION 
	               CALL CROSRNG_EP(CIRCREF(1,ITHREAD),CIRCEXP,
     &                              LCIRC,NRING, MAXRIN,NUMR,
     &                              TOTMIN(IMI),ROTANGT(IMI),
     &                              TT,MIRRORED,FFTW3PLAN)
                   ELSE
C                     CHECK BOTH NON-MIRRORED & MIRRORED POSITIONS 

                      CALL CROSRNG_MSP(CIRCREF(1,ITHREAD),CIRCEXP,
     &                        LCIRC,NRING, MAXRIN,NUMR,
     &                        TOTMIN(IMI),ROTANGT(IMI),
     &                        TOTMIR(IMI),ROTANGM(IMI), TT,FFTW3PLAN)
                   ENDIF
                ELSE
C                  DO NOT CHECK MIRRORED POSITION
	           CALL CROSRNG_EP(CIRCREF(1,ITHREAD),CIRCEXP,
     &                    LCIRC,NRING, MAXRIN,NUMR, 
     &                    TOTMIN(IMI),ROTANGT(IMI), 
     &                    TT, .FALSE.,FFTW3PLAN)
                ENDIF
	     ENDDO
comp        end parallel do
          ENDIF

C         LOOP OVER ALL RELEVANT REF. IMAGES
          IREF   = 0
          CCROTD = -1.0D20

          DO IMIL=1,IEND
             IMI = IMIL
	     IF (NIMALCG .GT. 0) IMI = ABS(LCG(IMIL))

             IF (TOTMIN(IMI) .GE. CCROTD) THEN
C               GOOD MATCH WITH TOTMIN (MIRRORED OR NOT)  POSITION 
                CCROTD    = TOTMIN(IMI)
                RANGNEW   = ROTANGT(IMI)
                MIRRORNEW = (LIMITRANGE .AND. (LCG(IMIL) .LT. 0))
                IREF      = IMI
	     ENDIF
 
             IF (CKMIRROR .AND. .NOT. LIMITRANGE) THEN 
C               HAVE TO COMPARE WITH MIRRORED POSITION 
                IF (TOTMIR(IMI) .GE. CCROTD) THEN
C                  GOOD MATCH, MIRRORED POSITION IS BETTER
                   CCROTD    = TOTMIR(IMI)
                   RANGNEW   = ROTANGM(IMI)
                   MIRRORNEW = .TRUE.
                   IREF      = IMI
                ENDIF
             ENDIF   ! END OF: IF (CKMIRROR)
          ENDDO   ! END OF: DO IMIL=1,IEND


1000      RANGNEW  = (RANGNEW-1) / MAXRIN * DIVAS
          CCROT    = CCROTD
          IMGEXP   = ILIP(IEXP)
          PEAKV    = 0.0
          XSHNEW   = 0.0
          YSHNEW   = 0.0

          IF (IREF .LE. 0) THEN
C             NO NEARBY REFERENCE IMAGE
              IMGREF = 0
C             IREFT IS FOR REFDIR INDEX
              IREFT  = 1
          ELSE
              IMGREF = ILIST(IREF)
C             IREFT IS FOR REFDIR INDEX
              IREFT  = IREF
          ENDIF
         
          NPROJ = NIMA
          IF (LIMITRANGE) NPROJ = NIMALCG   
          CALL AP_END(IEXP,IMGEXP,IMGREF, 
     &         ANGREF(1,IREFT),REFDIR(1,IREFT),
     &         ANGEXP(1,IEXP),EXPDIR,ISHRANGE,
     &         GOTREFANG, NGOTPAR,NSAM,NROW,CCROT,PEAKV,
     &         RANGNEW,XSHNEW,YSHNEW,MIRRORNEW,EXPPAT,REFPAT,
     &         NPROJ, CTYPE, XBUF,LUNDOC,PARLIST)

          IF (NGOTPAR .GE. 8) THEN
C            COMPILE CCROT CHANGE STATISTICS
             ANGDIF = PARLIST(10)

             IF (ANGDIF .GT. ANGDIFTHR)IBIGANGDIF = IBIGANGDIF + 1
  
             CCROTLAS  = ANGEXP(8,IEXP)
             ANGDIFAVG = ANGDIFAVG + PARLIST(10)

             CCROTAVG = CCROTAVG + CCROT
             IF (CCROT .GE. CCROTLAS) THEN
                IMPROVCCROT = IMPROVCCROT + 1
                CCROTIMPROV = CCROTIMPROV + CCROT
             ELSE
                IWORSECCROT = IWORSECCROT + 1
                CCROTWORSE  = CCROTWORSE + CCROT
             ENDIF
          ENDIF

       ENDDO

       IF (NGOTPAR .GE. 8 .AND. NIDI .GT. 1) THEN
C         SAVE CCROT & ANGULAR DISPLACEMENT STATISTICS
          CALL AP_STAT(NIDI,ANGDIFTHR,IBIGANGDIF,
     &                 ANGDIFAVG, CCROTAVG,
     &                 IMPROVCCROT,CCROTIMPROV,
     &                 IWORSECCROT,CCROTWORSE,LUNDOC)
       ENDIF

9999  CLOSE(LUNANG)
      IF (.NOT. CIRCREF_IN_CORE)  CLOSE(LUNRING)

      IF (ALLOCATED(XBUF))   DEALLOCATE(XBUF)

      END




#else

C------------------------  MPI SPECIFIC SUBROUTINE --------------------




d72 1
a72 1
     &          MODE,REFANGDOC,EXPANGDOC,SCRFILE,FFTW3PLAN,
d126 1
a126 1

d142 3
d231 2
d404 1
a404 1
	               CALL CROSRNG_EP(CIRCREF(1,IMI),CIRCEXP,
d407 1
a407 1
     &                              TT,MIRRORED,FFTW3PLAN)
d410 1
a410 1
	              CALL CROSRNG_MSP(CIRCREF(1,IMI),CIRCEXP,
d413 1
a413 1
     &                   TOTMIR(IMI),ROTANGM(IMI), TT,FFTW3PLAN)
d417 1
a417 1
	           CALL CROSRNG_EP(CIRCREF(1,IMI),CIRCEXP,
d420 1
a420 1
     &                  TT, .FALSE.,FFTW3PLAN)
d442 1
a442 1
	               CALL CROSRNG_EP(CIRCREF(1,ITHREAD),CIRCEXP,
d445 1
a445 1
     &                              TT,MIRRORED,FFTW3PLAN)
d449 1
a449 1
                      CALL CROSRNG_MSP(CIRCREF(1,ITHREAD),CIRCEXP,
d452 1
a452 1
     &                        TOTMIR(IMI),ROTANGM(IMI), TT,FFTW3PLAN)
d456 1
a456 1
	           CALL CROSRNG_EP(CIRCREF(1,ITHREAD),CIRCEXP,
d459 1
a459 1
     &                    TT, .FALSE.,FFTW3PLAN)
d580 212
d793 2
a810 8
#endif
C ------------------------- END OF MPI CODE -----------------------






@


1.57
log
@parallelized AP REF using MPI
@
text
@d11 1
d15 1
a15 1
C=* Copyright (C) 1985-2005  Health Research Inc.                      *
d42 1
a42 1
C         MODE,REFANGDOC,EXPANGDOC,SCRFILE,
d45 416
a460 24
C  ORDER OF PROCESSING:
C 1 - CALCULATE WEIGHTS FOR RINGS IN RINGWE, STORE IN WR
C 2 - CONVERT EACH REFERENCE IMAGE TO RINGS, DO THE FFTS
C     FOR ALL THE RINGS, APPLY WEIGHTS TO THE RINGS, STORE IT IN CIRCREF.
C     IN ADDITION, HIGHEST FREQUENCY FOR ALL THE RINGS EXCEPT
C     MAXRING ARE DIVIDED BY 2.
C 3 - CONVERT EACH INPUT IMAGE TO RINGS, DO THE FFTS,
C     COMPARE EACH INPUT IMAGE WITH ALL THE REFERENCE IMAGES
C     USING CROSRNG_**. 
C     SINCE Y WERE PRE-WEIGHTED THE RESULT ARE ALREADY CORRECT.
C
C PARAMETERS:
C       ILIST               LIST OF REF. IMAGE FILE NUMBERS   (INPUT)
C       NIMA                NO. OF IMAGES                     (INPUT)
C       ILIP                LIST OF EXP. IMAGE FILE NUMBERS   (INPUT)
C       NIDI                NO. OF IMAGES                     (INPUT)
C       REFANGDOC           REF. ANGLES FILE NAME             (INPUT)
C       EXPANGDOC           EXP. ANGLES FILE NAME             (INPUT)
C       REFPAT              REF. IMAGE SERIES FILE TEMPLATE   (INPUT)
C       EXPPAT              EXP. IMAGE SERIES FILE TEMPLATE   (INPUT)
C
C  OPERATIONS:  'AP REF', 'AP RD', 'AP RN'
C
C--*********************************************************************
d465 1
a465 1
     &          MODE,REFANGDOC,EXPANGDOC,SCRFILE,
d519 1
a519 1
#ifdef USE_MPI
a534 3
#else 
        MYPID = -1
#endif
a620 2
#ifdef USE_MPI

d792 1
a792 1
	               CALL CROSRNG_E(CIRCREF(1,IMI),CIRCEXP,
d795 1
a795 1
     &                              TT,MIRRORED)
d798 1
a798 1
	              CALL CROSRNG_MS(CIRCREF(1,IMI),CIRCEXP,
d801 1
a801 1
     &                   TOTMIR(IMI),ROTANGM(IMI), TT)
d805 1
a805 1
	           CALL CROSRNG_E(CIRCREF(1,IMI),CIRCEXP,
d808 1
a808 1
     &                  TT, .FALSE.)
d830 1
a830 1
	               CALL CROSRNG_E(CIRCREF(1,ITHREAD),CIRCEXP,
d833 1
a833 1
     &                              TT,MIRRORED)
d837 1
a837 1
                      CALL CROSRNG_MS(CIRCREF(1,ITHREAD),CIRCEXP,
d840 1
a840 1
     &                        TOTMIR(IMI),ROTANGM(IMI), TT)
d844 1
a844 1
	           CALL CROSRNG_E(CIRCREF(1,ITHREAD),CIRCEXP,
d847 1
a847 1
     &                    TT, .FALSE.)
a967 212
#else
        DO IEXP=1,NIDI
C         LOOP OVER ALL EXPERIMENTAL (SAMPLE) IMAGES
    
C         CONVERT EXP. ANGLE TO UNITARY DIRECTIONAL VECTORS (EXPDIR).
	  CALL AP_GETSATA(ANGEXP(1,IEXP),EXPDIR,8,1,IRTFLG)

C         LOAD CURRENT EXPERIMENTAL IMAGE INTO ARRAY XBUF
	  CALL AP_GETDATS(ILIP,NIDI,NSAM,NROW,
     &                   1,EXPPAT,INPIC, IEXP,IEXP,
     &                   XBUF, IRTFLG)
          IF (IRTFLG .NE. 0) GOTO 9999

C         EXTRACT EXP. IMAGE POLAR COORD. RINGS, NORMALIZE & FFT THEM
	  CALL APRINGS_ONE(NSAM,NROW,0.0,
     &                   XBUF,CIRCEXP,MODE,NUMR,NRING,LCIRC,
     &                  IRTFLG)
          IF (IRTFLG .NE. 0) GOTO 9999

C         DETERMINE WHICH REF IMAGES ARE TO BE COMPARED
	  NIMALCG    = 0
          IEND       = NIMA
          CCROTD     = -1.0D20
          LIMITRANGE = RANGE .LT. 1.0

          IF (LIMITRANGE) THEN
C            DETERMINE WHICH REF IMAGES ARE TO BE COMPARED

             DO IMI=1,NIMA
C               LOOP OVER ALL REF. IMAGES
C               ABS - DIRECTIONS AT 180 DEGREES ARE DIFFERENT 
C                     (- DO NOT CHECK MIRRORED)
C               DT NEAR 1.0 = NOT-MIRRORED, DT NEAR -1.0 = MIRRORED

                DT =    (EXPDIR(1) * REFDIR(1,IMI) + 
     &                   EXPDIR(2) * REFDIR(2,IMI) + 
     &                   EXPDIR(3) * REFDIR(3,IMI))
	        DTABS = ABS(DT)

	        IF (DTABS .GE. RANGE)  THEN
C                  NON-MIRRORED OR MIRRORED REF. IS WITHIN RANGE
	           NIMALCG      = NIMALCG + 1
	           LCG(NIMALCG) = IMI
                   IF (DT .LT. 0) LCG(NIMALCG) = -IMI
                ENDIF
	     ENDDO

             IF (NIMALCG .LE. 0) THEN
C               NO REF. IMAGE WITHIN COMPARISON ANGLE
                IREF = 0 
                GOTO 1000
             ENDIF

             IEND = NIMALCG
          ENDIF

C         REF. IMAGES FOUND WITHIN COMPARISION RANGE

          IF (CIRCREF_IN_CORE) THEN
C            USE CIRCREF FOR REFERENCE RINGS

c$omp        parallel do private(imil,imi,mirrored)
             DO IMIL=1,IEND
                IMI = IMIL
	        IF (LIMITRANGE) IMI = ABS(LCG(IMIL))

                IF (CKMIRROR) THEN
                   IF (LIMITRANGE) THEN
                       MIRRORED = (LCG(IMIL) .LT. 0) 

C                      CHECK EITHER MIRRORED OR NON-MIRRORED POSITION 
	               CALL CROSRNG_E(CIRCREF(1,IMI),CIRCEXP,
     &                              LCIRC,NRING, MAXRIN,NUMR,
     &                              TOTMIN(IMI),ROTANGT(IMI),
     &                              TT,MIRRORED)
                   ELSE
C                     CHECK BOTH NON-MIRRORED & MIRRORED POSITIONS 
	              CALL CROSRNG_MS(CIRCREF(1,IMI),CIRCEXP,
     &                   LCIRC,NRING, MAXRIN,NUMR, 
     &                   TOTMIN(IMI),ROTANGT(IMI),
     &                   TOTMIR(IMI),ROTANGM(IMI), TT)
                   ENDIF
                ELSE
C                  DO NOT CHECK MIRRORED POSITION
	           CALL CROSRNG_E(CIRCREF(1,IMI),CIRCEXP,
     &                  LCIRC,NRING,  MAXRIN,NUMR, 
     &                  TOTMIN(IMI),ROTANGT(IMI),
     &                  TT, .FALSE.)
                ENDIF
	     ENDDO
c$omp        end parallel do

          ELSE
C            USE REFERENCE RINGS FILE (MIGHT BE AN INCORE FILE)
             
c$omp        parallel do private(imil,imi,mirrored,ithread)
c$omp&       schedule(static,1)
             DO IMIL=1,IEND     !LOOP OVER ALL REFERENCE IMAGES
                IMI = IMIL
	        IF (LIMITRANGE) IMI = ABS(LCG(IMIL))

C               FIND THREAD NUMBER 
                ITHREAD = MOD((IMIL-1),NUMTH) + 1
 
C               FILL CIRCREF FROM REFERENCE RINGS FILE
c$omp           critical
                CALL REDLIN(LUNRING,CIRCREF(1,ITHREAD),LCIRC,IMI)
c$omp           end critical
c          if(imil.lt.2) 
c     & write(6,*) 'b',ITHREAD,CIRCREF(1,ITHREAD),CIRCREF(5000,ITHREAD)
                IF (CKMIRROR) THEN
                   IF (LIMITRANGE) THEN
                       MIRRORED = (LCG(IMIL) .LT. 0) 

C                      CHECK EITHER MIRRORED OR NON-MIRRORED POSITION 
	               CALL CROSRNG_E(CIRCREF(1,ITHREAD),CIRCEXP,
     &                              LCIRC,NRING, MAXRIN,NUMR,
     &                              TOTMIN(IMI),ROTANGT(IMI),
     &                              TT,MIRRORED)
                   ELSE
C                     CHECK BOTH NON-MIRRORED & MIRRORED POSITIONS 

                      CALL CROSRNG_MS(CIRCREF(1,ITHREAD),CIRCEXP,
     &                        LCIRC,NRING, MAXRIN,NUMR,
     &                        TOTMIN(IMI),ROTANGT(IMI),
     &                        TOTMIR(IMI),ROTANGM(IMI), TT)
                   ENDIF
                ELSE
C                  DO NOT CHECK MIRRORED POSITION
	           CALL CROSRNG_E(CIRCREF(1,ITHREAD),CIRCEXP,
     &                    LCIRC,NRING, MAXRIN,NUMR, 
     &                    TOTMIN(IMI),ROTANGT(IMI), 
     &                    TT, .FALSE.)
                ENDIF
	     ENDDO
comp        end parallel do
          ENDIF

C         LOOP OVER ALL RELEVANT REF. IMAGES
          IREF   = 0
          CCROTD = -1.0D20

          DO IMIL=1,IEND
             IMI = IMIL
	     IF (NIMALCG .GT. 0) IMI = ABS(LCG(IMIL))

             IF (TOTMIN(IMI) .GE. CCROTD) THEN
C               GOOD MATCH WITH TOTMIN (MIRRORED OR NOT)  POSITION 
                CCROTD    = TOTMIN(IMI)
                RANGNEW   = ROTANGT(IMI)
                MIRRORNEW = (LIMITRANGE .AND. (LCG(IMIL) .LT. 0))
                IREF      = IMI
	     ENDIF
 
             IF (CKMIRROR .AND. .NOT. LIMITRANGE) THEN 
C               HAVE TO COMPARE WITH MIRRORED POSITION 
                IF (TOTMIR(IMI) .GE. CCROTD) THEN
C                  GOOD MATCH, MIRRORED POSITION IS BETTER
                   CCROTD    = TOTMIR(IMI)
                   RANGNEW   = ROTANGM(IMI)
                   MIRRORNEW = .TRUE.
                   IREF      = IMI
                ENDIF
             ENDIF   ! END OF: IF (CKMIRROR)
          ENDDO   ! END OF: DO IMIL=1,IEND


1000      RANGNEW  = (RANGNEW-1) / MAXRIN * DIVAS
          CCROT    = CCROTD
          IMGEXP   = ILIP(IEXP)
          PEAKV    = 0.0
          XSHNEW   = 0.0
          YSHNEW   = 0.0

          IF (IREF .LE. 0) THEN
C             NO NEARBY REFERENCE IMAGE
              IMGREF = 0
C             IREFT IS FOR REFDIR INDEX
              IREFT  = 1
          ELSE
              IMGREF = ILIST(IREF)
C             IREFT IS FOR REFDIR INDEX
              IREFT  = IREF
          ENDIF
         
          NPROJ = NIMA
          IF (LIMITRANGE) NPROJ = NIMALCG   
          CALL AP_END(IEXP,IMGEXP,IMGREF, 
     &         ANGREF(1,IREFT),REFDIR(1,IREFT),
     &         ANGEXP(1,IEXP),EXPDIR,ISHRANGE,
     &         GOTREFANG, NGOTPAR,NSAM,NROW,CCROT,PEAKV,
     &         RANGNEW,XSHNEW,YSHNEW,MIRRORNEW,EXPPAT,REFPAT,
     &         NPROJ, CTYPE, XBUF,LUNDOC,PARLIST)

          IF (NGOTPAR .GE. 8) THEN
C            COMPILE CCROT CHANGE STATISTICS
             ANGDIF = PARLIST(10)

             IF (ANGDIF .GT. ANGDIFTHR)IBIGANGDIF = IBIGANGDIF + 1
  
             CCROTLAS  = ANGEXP(8,IEXP)
             ANGDIFAVG = ANGDIFAVG + PARLIST(10)

             CCROTAVG = CCROTAVG + CCROT
             IF (CCROT .GE. CCROTLAS) THEN
                IMPROVCCROT = IMPROVCCROT + 1
                CCROTIMPROV = CCROTIMPROV + CCROT
             ELSE
                IWORSECCROT = IWORSECCROT + 1
                CCROTWORSE  = CCROTWORSE + CCROT
             ENDIF
          ENDIF
a968 2
       ENDDO
#endif
d985 8
@


1.56
log
@GPL License fixed
@
text
@d126 19
d231 350
d794 1
@


1.55
log
@HRI GPL License used
@
text
@a12 1
C * SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK       *
d16 1
a16 1
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *  
a35 6

C * COPYRIGHT (C)1985, 2005. HEALTH RESEARCH INCORPORATED (HRI),       *
C * ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C * THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HRI AND ARE NOT   *
C * TO BE DISCLOSED TO OTHERS OR USED FOR PURPOSES OTHER THAN INTENDED *
C * WITHOUT WRITTEN APPROVAL OF HRI.                                   *
@


1.54
log
@removed windowing in getdats call
@
text
@d14 24
@


1.53
log
@GOTO 999 bad
@
text
@d202 1
a202 1
	  CALL AP_GETDATS(ILIP,NIDI,NSAM,NROW,NSAM,NROW,
@


1.52
log
@APRINGS_ONE AP_STAT
@
text
@d211 1
a211 1
          IF (IRTFLG .NE. 0) GOTO 999
@


1.51
log
@spider rings file & cosmetic
@
text
@d6 1
a6 1
C                   AP_END CALL HAS DUMLIST       OCT 04 ARDEAN LEITH
d8 3
d22 2
a23 2
C         LSAM,LROW,NR,LENTT,RANGE,
C         NRING,LCIRC,NUMR,BFC,BFC_IN_CORE,
d26 1
a26 1

d30 1
a30 1
C     FOR ALL THE RINGS, APPLY WEIGHTS TO THE RINGS, STORE IT IN BFC.
d35 2
a36 2
C     USING CROSRNG_DS. 
C     SINCE Y WERE PRE-WEIGHTED THE RESULTS IS ALREADY CORRECT.
d53 2
a54 2
     &          LSAM,LROW,NR,LENTT,RANGE,
     &          NRING,LCIRC,NUMR,BFC,BFC_IN_CORE,
d64 1
a64 1
	REAL, DIMENSION(LCIRC,NIMA)                 :: BFC
d71 1
d75 1
a75 1
	LOGICAL                                     :: BFC_IN_CORE
d91 1
a91 1
 	REAL, DIMENSION(LCIRC)                      :: CIROLD,CIRC 
d93 1
d95 1
a95 1
	REAL, DIMENSION(7,NIDI)                     :: ANGEXP
d100 2
d103 1
a103 1
        REAL, DIMENSION(NLISTMAX)                   :: DUMLIST
d112 1
d114 1
d118 14
a131 3
C       FIND DIVAS, NUMTH, NSAM, & NROW
	CALL APMASTER_1(MODE,DIVAS,NR,NUMTH,LSAM,LROW,NSAM,NROW,
     &                   TT,LENTT)
d133 2
a134 2
C       MAKE XBUF AT LEAST LSAM*LROW FOR USE BY AP_SHIFTS
        MWANTX = MAX((NSAM*NROW*NUMTH),(LSAM*LROW))
d137 1
a137 1
           CALL ERRT(46,'XBUF...',MWANTX)
d152 2
a153 1
C       READ REFERENCE IMAGES INTO REFERENCE RINGS (BFC) ARRAY 
d155 1
a155 1
     &               LSAM,LROW,NSAM,NROW,
d157 1
a157 1
     &               REFPAT,INPIC,BFC,BFC_IN_CORE,
d161 10
a170 6

        IF (BFC_IN_CORE) THEN
           WRITE(6,*) 'BFC IN CORE,  THREADS: ',NUMTH
        ELSE
           WRITE(6,*) 'BFC NOT IN CORE,   THREADS: ',NUMTH
        Endif
d180 1
a180 1
     &                       INPIC,LUNANG,7,ANGEXP,NGOTPAR,IRTFLG)
d186 9
d196 1
a196 1
C          LOOP OVER ALL EXPERIMENTAL (SAMPLE) IMAGES
d198 2
a199 2
C          CONVERT EXP. ANGLE TO UNITARY DIRECTIONAL VECTORS (EXPDIR).
	   CALL AP_GETSATA(ANGEXP(1,IEXP),EXPDIR,7,1,IRTFLG)
d201 3
a203 3
C          LOAD EXPERIMENTAL IMAGE INTO ARRAY XBUF
	   CALL AP_GETDATS(ILIP,NIDI,LSAM,LROW,NSAM,NROW,
     &                   NUMTH,EXPPAT,INPIC, IEXP,IEXP,
d207 5
a211 9
C         NORMALIZE UNDER THE MASK (IN PARALLEL)
	  CALL NORMAS(XBUF,-NSAM/2,NSAM/2, -NROW/2,NROW/2,
     &                NUMR(1,1),NUMR(1,NRING))

C         INTERPOLATION INTO POLAR COORDINATES (IN PARALLEL)
	  CALL ALRQ(XBUF,NSAM,NROW,NUMR,CIROLD,LCIRC,NRING,MODE,IDUM)

C         FOURIER TRANSFORM OF EXP. IMAGE RINGS (IN PARALLEL)
	  CALL FRNG(CIROLD,LCIRC,NUMR,NRING)
d252 2
a253 2
          IF (BFC_IN_CORE) THEN
C            USE BFC FOR REFERENCE RINGS
d265 2
a266 2
	               CALL CROSRNG_E(BFC(1,IMI),CIROLD,LCIRC,NRING,
     &		                    MAXRIN,NUMR,
d271 2
a272 2
	              CALL CROSRNG_MS(BFC(1,IMI),CIROLD,LCIRC,NRING,
     &	                 MAXRIN,NUMR, 
d278 2
a279 2
	           CALL CROSRNG_E(BFC(1,IMI),CIROLD,LCIRC,NRING,
     &	                MAXRIN,NUMR, 
d287 5
a291 3
C            USE REFERENCE RINGS FILE (MIGHT BE INCORE FILE)

             DO IMIL=1,IEND
d295 9
a303 3
C               FILL CIRC FROM REFERENCE RINGS FILE
                CALL REDLIN(LUNRING,CIRC,LCIRC,IMI)

d309 2
a310 2
	               CALL CROSRNG_E(CIRC,CIROLD,LCIRC,NRING,
     &		                    MAXRIN,NUMR,
d316 2
a317 2
                      CALL CROSRNG_MS(CIRC,CIROLD,LCIRC,NRING,
     &	                      MAXRIN,NUMR,
d323 3
a325 2
	           CALL CROSRNG_E(CIRC,CIROLD,LCIRC,NRING,
     &	                  MAXRIN,NUMR, TOTMIN(IMI),ROTANGT(IMI), 
d329 1
d358 1
a358 2

         ENDDO   ! END OF: DO IMIL=1,IEND
d378 3
a380 1
            
d384 1
a384 1
     &         GOTREFANG, NGOTPAR,LSAM,LROW,CCROT,PEAKV,
d386 20
a405 1
     &         NIMALCG, CTYPE, XBUF,LUNDOC,DUMLIST)
d409 8
d418 1
a418 1
      IF (.NOT.BFC_IN_CORE)  CLOSE(LUNRING)
@


1.50
log
@removed CALL SETTHREADS(2)
@
text
@d2 1
a2 1
C++************************************************************************
d7 1
d11 1
a11 1
C * COPYRIGHT (C)1985, 2003. HEALTH RESEARCH INCORPORATED (HRI),       *
d47 1
a47 1
C--************************************************************************
d101 1
a101 1
	DATA  INPIC/77/,INANG/78/,NSCF/50/
d110 1
a110 1
	CALL  APMASTER_1(MODE,DIVAS,NR,NUMTH,LSAM,LROW,NSAM,NROW,
d124 1
a124 1
     &                    INPIC,INANG,3,ANGREF,NGOTREF,IRTFLG)
d137 1
a137 1
     &               NSCF,SCRFILE,IRTFLG)
d140 7
d155 1
a155 1
     &                       INPIC,INANG,7,ANGEXP,NGOTPAR,IRTFLG)
d173 3
a175 3
C         NORMALIZE UNDER THE MASK
	  CALL NORMAS(XBUF,-NSAM/2,NSAM/2,-NROW/2,NROW/2,
     &                NUMR,NUMR(1,NRING))
d177 2
a178 2
C         INTERPOLATION INTO POLAR COORDINATES
	  CALL ALRQ(XBUF,NSAM,NROW,NUMR,CIROLD,LCIRC,NRING,MODE,IEXP)
d180 1
a180 1
C         FOURIER TRANSFORM OF EXP. IMAGE RINGS
a188 1

d224 2
a225 1
c$omp        parallel do private(imil,imi)
d249 3
a251 2
     &	                  MAXRIN,NUMR, TOTMIN(IMI),ROTANGT(IMI), TT,
     &                    .FALSE.)
d254 1
d257 1
a257 2
C            FILL CIRC FROM REFERENCE RINGS FILE
             REWIND(NSCF)
d263 2
a264 1
                READ(NSCF) CIRC
d349 2
a350 2
9999  CLOSE(INANG)
      IF (.NOT.BFC_IN_CORE)  CLOSE(NSCF)
@


1.49
log
@AP_END CALL HAS DLIST
@
text
@a119 7
#ifdef SP_MP
        IF (.NOT. BFC_IN_CORE) THEN
           WRITE(NOUT,*) ' SETTING OMP THREADS: 2'
           CALL SETTHREADS(2)
  	ENDIF
#endif

@


1.48
log
@CROSRNG_E did not pass mirrored
@
text
@d4 1
a4 1
C    DSGR_P.F
d6 1
d94 3
d342 1
a342 1
     &         NIMALCG, CTYPE, XBUF,LUNDOC)
@


1.47
log
@CROSRNG_E SPEEDS UP
@
text
@d244 2
a245 1
     &	                  MAXRIN,NUMR, TOTMIN(IMI),ROTANGT(IMI), TT)
d279 2
a280 1
     &	                  MAXRIN,NUMR, TOTMIN(IMI),ROTANGT(IMI), TT)
@


1.46
log
@CKMIRROR logic bug
@
text
@d5 1
d16 6
d74 2
d179 5
a183 3
	  NIMALCG = 0
          IEND    = NIMA
          CCROTD  = -1.0D20
d185 1
a185 1
          IF (RANGE .LT. 1.0) THEN
d194 1
a194 1
                DT = ABS(EXPDIR(1) * REFDIR(1,IMI) + 
d197 1
d199 1
a199 1
	        IF (DT .GE. RANGE)  THEN
d203 1
d223 1
a223 1
	        IF (NIMALCG .GT. 0) IMI = (LCG(IMIL))
d226 15
a240 5
C                 CHECK MIRRORED POSITIONS ALSO AT THIS TIME
	          CALL CROSRNG_MS(BFC(1,IMI),CIROLD,LCIRC,NRING,
     &	             MAXRIN,NUMR, 
     &               TOTMIN(IMI),ROTANGT(IMI),
     &               TOTMIR(IMI),ROTANGM(IMI), TT)
d242 2
a243 1
	           CALL CROSRNG_DS(BFC(1,IMI),CIROLD,LCIRC,NRING,
d254 1
a254 1
	        IF (NIMALCG .GT. 0) IMI = (LCG(IMIL))
d259 12
a270 2
C                  CHECK BOTH NON-MIRRORED & MIRRORED POSITIONS
                   CALL CROSRNG_MS(CIRC,CIROLD,LCIRC,NRING,
d274 1
d276 3
a278 3
C                  DO NOT EVEN CHECK MIRRORED POSITION
                   CALL CROSRNG_DS(CIRC,CIROLD,LCIRC,NRING,
     &	                    MAXRIN,NUMR, TOTMIN(IMI),ROTANGT(IMI), TT)
d289 1
a289 1
	     IF (NIMALCG .GT. 0) IMI = (LCG(IMIL))
d291 11
a301 3
             IF (CKMIRROR) THEN
                IF (TOTMIR(IMI) .GE. CCROTD .AND.
     &              TOTMIR(IMI) .GT. TOTMIN(IMI)) THEN
d310 1
a310 8
             IF (TOTMIN(IMI) .GE. CCROTD) THEN
C               GOOD MATCH, NON-MIRRORED POSITION IS BETTER
                CCROTD    = TOTMIN(IMI)
                RANGNEW   = ROTANGT(IMI)
                MIRRORNEW = .FALSE.
                IREF      = IMI
	     ENDIF
          ENDDO   ! END OF: DO IMIL=1,IEND
@


1.45
log
@AP SH, AP REF major changes
@
text
@d235 1
d241 1
d265 3
a267 1
              ELSE
d269 6
a274 9
                IF (TOTMIN(IMI) .GE. CCROTD) THEN
                   CCROTD    = TOTMIN(IMI)
                   RANGNEW   = ROTANGT(IMI)
                   MIRRORNEW = .FALSE.
                   IREF      = IMI
	        ENDIF
             ENDIF
C         END OF: DO IMIL=1,IEND
          ENDDO
@


1.44
log
@rewrite
@
text
@a1 1

d6 8
a13 9
C **************************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
C *  COPYRIGHT (C)1981,1987, WADSWORTH CENTER FOR LABORATORIES AND         *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *  THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR       *
C *  LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR    *
C *  USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF     *
C *  THE CENTER FOR LABORATORIES AND RESEARCH   			   *
C **************************************************************************
d26 12
d43 2
a44 2
     &          MODE,REFANG,EXPANG,SCRFILE,
     &          REFPAT,EXPPAT,MIRROR,CTYPE)
d54 2
a55 1
        CHARACTER (LEN=*)                           :: REFANG,EXPANG
d58 1
d60 1
a60 4
        PARAMETER (NLIST=8)
	DOUBLE PRECISION                            :: EAV
	REAL, DIMENSION(NLIST)                      :: DLIST 
	DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:) :: TOTMIR
d63 4
a66 2
	LOGICAL                                     :: MIRROR
        CHARACTER (LEN=*)                           :: CTYPE 
d68 2
a69 3
C       ALLOCATED ARRAYS
	REAL, ALLOCATABLE, DIMENSION(:,:)           :: X 
	REAL, ALLOCATABLE, DIMENSION(:)             :: TMT 
d72 1
d74 2
a75 2
 	DOUBLE PRECISION, DIMENSION(NIMA)           :: TOTMIN 
 	REAL, DIMENSION(NIMA)                       :: TOT 
d77 5
a81 2
 	REAL, DIMENSION(3,NIMA)                     :: SA 
	REAL, DIMENSION(3)                          :: TA 
d84 1
a84 1
	PARAMETER (QUADPI = 3.141592653589793238462643383279502884197)
d87 1
a87 1
	DATA  INPIC/77/,INANG/78/,NDOC/55/,NSCF/50/
a90 3
C       ZERO DLIST ARRAY
	DLIST = 0.0

d92 1
d95 1
d99 3
a101 7
        IF (MIRROR) THEN
           ALLOCATE(X(NSAM,NROW), TOTMIR(NIMA),TMT(NIMA),STAT=IRTFLG)
           MWANT = NSAM * NROW + NIMA + NIMA
        ELSE
           ALLOCATE(X(NSAM,NROW), STAT=IRTFLG)
	   MWANT = NSAM * NROW
        ENDIF
d103 1
a103 1
           CALL  ERRT(46,'TOT,....',MWANT)
d114 5
a118 1
        CALL REG_GET_USED(NSEL_USED)
d120 2
a121 12
        LQ  = LROW/2+1
        LR1 = (NROW-1)/2
        LR2 = LQ+LR1
        LR1 = LQ-LR1
        LQ  = LSAM/2+1
        LS1 = (NSAM-1)/2
        LS2 = LQ+LS1
        LS1 = LQ-LS1

C       READ REF. ANGLES AND CONVERT TO SA (UNITARY DIRECTIONAL VECTORS.
        CALL AP_GETANG(ILIST,NIMA,0,REFANG,REFPAT,
     &                 INPIC,INANG,SA,IRTFLG)
d123 1
d133 13
a145 7
        DO ITI=1,NIDI
C         LOAD EXP. IMAGE DATA
	  CALL AP_GETDAT(ILIP,NIMA,LSAM,LROW,NSAM,NROW,
     &                     NUMTH,EXPPAT,INPIC, ITI,ITI,
     &                     LR1,LR2,LS1,LS2, X,
     &                     IRTFLG)
          IF (IRTFLG .NE. 0) GOTO 9999
d147 10
a156 3
c         READ EXP. ANGLE AND CONVERT TO TA (UNITARY DIRECTIONAL VECTOR
	  CALL AP_GETANG(ILIP,NIDI,ITI,EXPANG,EXPPAT,
     &                  -INPIC,INANG,TA,IRTFLG)
a157 1
          CLOSE(INPIC)
d160 1
a160 1
	  CALL NORMAS(X,-NSAM/2,NSAM/2,-NROW/2,NROW/2,
d163 2
a164 1
	  CALL ALRQ(X,NSAM,NROW,NUMR,CIROLD,LCIRC,NRING,MODE,ITI)
d166 1
d169 1
a169 1
C         DETERMINE WHICH ONES ARE TO BE COMPARED
d171 27
a197 58
          DO   IMI=1,NIMA
C             LOOP OVER ALL REF. IMAGES
C             ABS - DIRECTIONS AT 180 DEGREES ARE DIFFERENT 
C                   (- DO NOT CHECK MIRRORED)
              DT = ABS(TA(1)*SA(1,IMI)+TA(2)*SA(2,IMI)+TA(3)*SA(3,IMI))
	      IF (DT .GE. RANGE)  THEN
C                CHECK VS THIS IMAGE
	         NIMALCG      = NIMALCG + 1
	         LCG(NIMALCG) = IMI
	      ELSE
C                NO NEED TO CHECK VS THIS IMAGE
	         TOTMIN(IMI)  = -1.0D20
	         IF (MIRROR) TOTMIR(IMI) = -1.0D20
              ENDIF
	  ENDDO

          EAV = -1.0D20
	  IF (NIMALCG.GT.0) THEN
             IF (BFC_IN_CORE) THEN
C               USE BFC FOR REFERENCE RINGS
c$omp           parallel do private(imil,imi)
                DO IMIL=1,NIMALCG
	           IMI = LCG(IMIL)
                   IF (MIRROR) THEN
C                    CHECK MIRRORED POSITIONS ALSO AT THIS TIME
	             CALL CROSRNG_MS(BFC(1,IMI),CIROLD,LCIRC,NRING,
     &	               MAXRIN,NUMR,TOTMIN(IMI),TOT(IMI),TOTMIR(IMI),
     &                 TMT(IMI),TT)
                   ELSE
	              CALL CROSRNG_DS(BFC(1,IMI),CIROLD,LCIRC,NRING,
     &	                 MAXRIN,NUMR,TOTMIN(IMI),TOT(IMI),TT)
                   ENDIF
	        ENDDO
             ELSE
C               FILL CIRC FROM REFERENCE RINGS FILE
                REWIND(NSCF)
                DO IMI=1,NIMA
C                  ABS - DIRECTIONS AT 180 DEGREES ARE DIFFERENT
C                       (- DO NOT CHECK MIRRORED)
                  DT = ABS(TA(1)*SA(1,IMI)+TA(2)*SA(2,IMI)+
     &                     TA(3)*SA(3,IMI))
	           IF (DT .GE. RANGE)  THEN
                      READ(NSCF) CIRC
                      IF (MIRROR) THEN
                         CALL CROSRNG_MS(CIRC,CIROLD,LCIRC,NRING,
     &	                        MAXRIN,NUMR,TOTMIN(IMI),TOT(IMI),
     &                          TOTMIR(IMI), TMT(IMI),TT)
                      ELSE
                         CALL CROSRNG_DS(CIRC,CIROLD,LCIRC,NRING,
     &	                        MAXRIN,NUMR,TOTMIN(IMI),TOT(IMI),TT)
                      ENDIF
	           ELSE
C                     SKIP THIS COMPARISION
                      READ(NSCF)
	              TOTMIN(IMI) = -1.0D20
	              IF (MIRROR) TOTMIR(IMI) = -1.0D20
	           ENDIF
	        ENDDO
d200 39
a238 16
C            LOOP OVER ALL REF. IMAGES
             DO IMI=1,NIMA
                IF (MIRROR) THEN
                   IF (TOTMIN(IMI) .GE. EAV .AND. 
     &                 TOTMIN(IMI) .GT. TOTMIR(IMI)) THEN
                      EAV  = TOTMIN(IMI)
                      IDI  = ILIST(IMI)
                      RANG = TOT(IMI)
                      IMIT = IMI

                   ELSEIF (TOTMIR(IMI) .GE. EAV)  THEN
                      EAV  = TOTMIR(IMI)
                      IDI  = -ILIST(IMI)
                      RANG = TMT(IMI)
                      IMIT = IMI
                   ENDIF
d240 2
a241 6
                   IF (TOTMIN(IMI) .GE. EAV)  THEN
                      EAV  = TOTMIN(IMI)
                      IDI  = ILIST(IMI)
                      RANG = TOT(IMI)
                      IMIT = IMI
	           ENDIF
d244 30
a274 36
C            IDI IS NUMBER OF MOST SIMILAR REF. IMAGE (<0 IF MIRRORED)
             DLIST(2) = IDI
             DLIST(3) = EAV
             RANG     = (RANG-1) / MAXRIN * DIVAS
             DLIST(4) = RANG
C            DLIST 5&6  SET TO ZERO (KEEPS SAME FORMAT AS 'AP MQ')
             IDIT     = ABS(IDI)

C            DLIST(8) = ANGULAR CHANGE
             ANGT     = ABS(TA(1)*SA(1,IMIT) +
     &                      TA(2)*SA(2,IMIT) +
     &                      TA(3)*SA(3,IMIT))
             ANGT     = MIN(1.0,ANGT)
             DLIST(8) = ACOS(ANGT) / DGR_TO_RAD
	 ELSE
C            PROJECTION IS OUTSIDE OF RANGE OF ALL THE REF. PROJECTIONS	
             DLIST(2) =  0.0
             DLIST(3) = -1.0
             DLIST(4) =  0.0
             DLIST(8) = -1.0
	 ENDIF

         DLIST(1) = ITI
         DLIST(7) = ILIP(ITI)

         IF (NSEL_USED .GT. 0) THEN
C           OUTPUT TO REGISTER NOT TO DOC FILE
            CALL REG_SET_NSEL(1,5,DLIST(2),DLIST(3),DLIST(4),
     &                         DLIST(5),DLIST(6),IRTFLG)
            CALL REG_SET_NSEL(6,2,DLIST(7),DLIST(8),0.0,0.0,0.0,IRTFLG)
         ELSE
C           OUTPUT TO TO DOC FILE
            CALL LUNDOCWRTDAT(NDOC,ITI,DLIST(2),NLIST-1,IRTFLG)
      
         ENDIF
      ENDDO
d276 28
a303 2
9999  CLOSE(NDOC)
      CLOSE(INANG)
d306 1
a306 3
      IF (ALLOCATED(X))      DEALLOCATE(X)
      IF (ALLOCATED(TMT))    DEALLOCATE(TMT)
      IF (ALLOCATED(TOTMIR)) DEALLOCATE(TOTMIR)
d309 2
@


1.43
log
@new caller
@
text
@a0 245
 
C++************************************************************************
C
C    DSGR_PM.F
C
C **************************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
C *  COPYRIGHT (C)1981,1987, WADSWORTH CENTER FOR LABORATORIES AND         *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *  THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR       *
C *  LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR    *
C *  USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF     *
C *  THE CENTER FOR LABORATORIES AND RESEARCH   			   *
C **************************************************************************
C
C  ORDER OF PROCESSING:
C 1 - CALCULATE WEIGHTS FOR RINGS IN RINGWE, STORE IN WR
C 2 - CONVERT EACH REFERENCE IMAGE TO RINGS, DO THE FFTS
C     FOR ALL THE RINGS, APPLY WEIGHTS TO THE RINGS, STORE IT IN BFC.
C     IN ADDITION, HIGHEST FREQUENCY FOR ALL THE RINGS EXCEPT
C     MAXRING ARE DIVIDED BY 2.
C 3 - CONVERT EACH INPUT IMAGE TO RINGS, DO THE FFTS,
C     COMPARE EACH INPUT IMAGE WITH ALL THE REFERENCE IMAGES
C     USING CROSRNG_DS. 
C     SINCE Y WERE PRE-WEIGHTED THE RESULTS IS ALREADY CORRECT.
C
C--************************************************************************

        SUBROUTINE DSGR_PM(ILIST,NIMA,ILIP,NIDI,
     &             NSAM,NROW,LSAM,LROW,RANGE,
     &             NRING,LCIRC,NUMR,MODE,NUMTH,
     &             REFANG,EXPANG,OUTANG,SUCCESS,
     &             REFPAT,EXPPAT)

        INCLUDE 'CMLIMIT.INC'
        INCLUDE 'CMBLOCK.INC'

        PARAMETER (NLIST=8)
	PARAMETER (QUADPI = 3.141592653589793238462643383279502884197)
	PARAMETER (DGR_TO_RAD =   (QUADPI/180))
        INTEGER                   NUMR(3,NRING)
	DIMENSION                 ILIST(NIMA),ILIP(NIDI)

        CHARACTER(LEN=1)                    :: MODE
	CHARACTER (LEN=MAXNAM)              :: FILNAM
        CHARACTER (LEN=*)                   :: REFPAT,EXPPAT
        CHARACTER (LEN=*)                   :: REFANG,EXPANG
        CHARACTER (LEN=*)                   :: OUTANG
	REAL, ALLOCATABLE, DIMENSION(:,:,:) :: X
	REAL, ALLOCATABLE, DIMENSION(:,:)   :: BFC,DLIST,SA,TA
	DOUBLE PRECISION, ALLOCATABLE, DIMENSION(: ) :: TT

C       AUTOMATIC ARRAYS
        DIMENSION  BUFIN(LSAM)
	DIMENSION  WR(NRING)


	LOGICAL  SUCCESS

#ifndef SP_32
        INTEGER *8       IASK8,IOK
#else
        INTEGER *4       IASK8,IOK
#endif

	DATA  INPIC/77/,INANG/78/,NDOC/55/,NSCF/50/

        MAXRIN = NUMR(3,NRING)
	RANGE  = COS(RANGE*DGR_TO_RAD)

C       RINGWE RETURNS WR
        CALL  RINGWE(WR,NUMR,NRING,MAXRIN)
        IF (MODE .EQ. 'H')  THEN
            WR    = WR*0.5
            DIVAS = 180.0
        ELSE
            DIVAS = 360.0
        ENDIF

#ifdef SP_LIBFFT
	ALLOCATE(TT(MAXRIN+15),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
           CALL  ERRT(46,'TT',MAXRIN+15)
           RETURN
        ENDIF
	CALL  DZFFT1DUI(MAXRIN,TT)
#else
	ALLOCATE(TT(1),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
           CALL  ERRT(46,'TT',1)
           RETURN
        ENDIF
#endif

	ALLOCATE(X(NSAM,NROW,NUMTH),SA(3,NIMA),
     &          TA(3,NIDI),DLIST(NLIST,NUMTH),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
            MWANT = NSAM*NROW*NUMTH + 3*NIMA + 3*NIDI + NLIST*NUMTH
            CALL ERRT(46,'X...',MWANT)
            GOTO 9999
        ENDIF

C       ZERO DLIST ARRAY
	DLIST = 0.0

C       FLAG TO OPEN OUTPUT DOC FILE
        NRUN  = 0

	ALLOCATE(BFC(LCIRC,NIMA),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
C          ALLOCATION FAILED, RETURN & USE SLOW METHOD
           IF (ALLOCATED(BFC)) DEALLOCATE(BFC)
	   SUCCESS = .FALSE.
           WRITE(NOUT,90) LCIRC,NIMA
90         FORMAT ('--- CAN NOT ALLOCATE: BFC(',I8,' X ',I8,'), ',
     &             ' WILL TRY DSGR_P NOW ') 
           GOTO 9999
        ENDIF

        IASK8 = (LCIRC * NIMA + NIMA * 3 + NIDI * 3 + NSAM * NROW)*4
        CALL BIGALLOC(IASK8,IOK,.FALSE.,.FALSE.,IRTFLG)

        SUCCESS = .TRUE.
        WRITE(NOUT,92) LCIRC,NIMA
92      FORMAT ('--- ALLOCATED: BFC(',I8,' X ',I8,'),  IN DSGR_PM') 

        CALL REG_GET_USED(NSEL_USED)

        LQ   = LROW/2+1
        LR1  = (NROW-1)/2
        LR2  = LQ+LR1
        LR1  = LQ-LR1
        LQ   = LSAM/2+1
        LS1  = (NSAM-1)/2
        LS2  = LQ+LS1
        LS1  = LQ-LS1

        CALL FLUSHRESULTS()

C       READ REF. ANGLES AND CONVERT TO UNITARY DIRECTIONAL VECTORS.
        DO  IMI=1,NIMA
           CALL  UNSAV(REFANG,IMI-1,INANG,ILIST(IMI),BUFIN,3,IRTFLG,2)
	   IF (IRTFLG .NE. 0) THEN
              CLOSE(INANG)
	      CALL ERRT(102,'MISSING REFERENCE PROJECTION ANGLE',IMI)
              GOTO 9999
           ENDIF
           SA(1,IMI)=COS(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
           SA(2,IMI)=SIN(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
           SA(3,IMI)=COS(BUFIN(2)*DGR_TO_RAD)	
        ENDDO
        CLOSE(INANG)

C       READ THE ANGLES FOR ITI EXPERIMENTAL (SAMPLE) IMAGES
	DO  ITI=1,NIDI
	   CALL UNSAV(EXPANG,ITI-1,INANG,ILIP(ITI),BUFIN,3,IRTFLG,2)
	   IF (IRTFLG .NE. 0) THEN
              CLOSE(INANG)
	      CALL ERRT(102,'MISSING EXP. PROJECTION ANGLE',ITI)
              GOTO 9999
           ENDIF
           TA(1,ITI)=COS(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
           TA(2,ITI)=SIN(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
           TA(3,ITI)=COS(BUFIN(2)*DGR_TO_RAD)
	ENDDO
	CLOSE(INANG)

	DO ITIT=1,NIMA,NUMTH
	   DO K1=ITIT,MIN(NIMA,ITIT+NUMTH-1)
              NLET = 0
              CALL FILGET(REFPAT,FILNAM,NLET,ILIST(K1),INTFLAG)
	      MAXIM = 0
	      CALL OPFILEC(0,.FALSE.,FILNAM,INPIC,'O',IFORM,
     &               LSAM,LROW,NSLICE,MAXIM,' ',.FALSE.,IRTFLG)
              IF (IRTFLG .NE. 0)  GOTO 9999

	      DO K2=LR1,LR2
                 CALL  REDLIN(INPIC,BUFIN,LSAM,K2)
	         DO K3=LS1,LS2
                    X(K3-LS1+1,K2-LR1+1,K1-ITIT+1)=BUFIN(K3)
	         ENDDO
	      ENDDO
	      CLOSE(INPIC)
	  ENDDO

C         NORMALIZE UNDER THE MASK
c$omp     parallel do private(K1)
	  DO  K1=ITIT,MIN(NIMA,ITIT+NUMTH-1)
	    CALL NORMAS(X(1,1,K1-ITIT+1),-NSAM/2,NSAM/2,-NROW/2,NROW/2,
     &                 NUMR,NUMR(1,NRING))

	    CALL ALRQS(X(1,1,K1-ITIT+1),NSAM,NROW,NUMR,
     &		       BFC(1,K1),LCIRC,NRING,MODE)
	    CALL FRNGS(BFC(1,K1),LCIRC,NUMR,NRING)
	    CALL APPLYWS(BFC(1,K1),LCIRC,NUMR,WR,NRING,MAXRIN)
	  ENDDO
       ENDDO

       DO ITIT=1,NIDI,NUMTH
C         LOOP OVER ALL SETS OF EXPERIMENTAL (SAMPLE) IMAGES
	  DO ITI=ITIT,MIN(NIDI,ITIT+NUMTH-1)
             NLET = 0
             CALL FILGET(EXPPAT,FILNAM,NLET,ILIP(ITI),INTFLAG)
	     MAXIM = 0
	     CALL OPFILEC(0,.FALSE.,FILNAM,INPIC,'O',IFORM,
     &               LSAM,LROW,NSLICE,MAXIM,' ',.FALSE.,IRTFLG)
             IF (IRTFLG .NE. 0)  GOTO 9999

             DO K2=LR1,LR2
                CALL REDLIN(INPIC,BUFIN,LSAM,K2)
                   DO K3=LS1,LS2
                      X(K3-LS1+1,K2-LR1+1,ITI-ITIT+1) = BUFIN(K3)
	           ENDDO
    	     ENDDO
	     CLOSE(INPIC)
	  ENDDO

C         NORMALIZE UNDER THE MASK
c$omp     parallel do private(ITI)
	  DO ITI=ITIT,MIN(NIDI,ITIT+NUMTH-1)
	     CALL DSGR2D(X(1,1,ITI-ITIT+1),NSAM,NROW,NUMR,NRING,
     &             MODE,MAXRIN,BFC,LCIRC,NIMA,TT,SA,TA(1,ITI),RANGE,
     &	           DLIST(2,ITI-ITIT+1),DLIST(3,ITI-ITIT+1),
     &             DLIST(4,ITI-ITIT+1))
	  ENDDO

C         DLIST(2) = IDI
C         DLIST(3) = EAV
C         DLIST(4) = ANGMOR(RANG,MODE)
C         DLIST 5&6  PERMANENTLY SET TO ZERO (KEEP SAME FORMAT AS
C         AP MQ COMMAND)
          DO ITI=ITIT,MIN(NIDI,ITIT+NUMTH-1)
             DLIST(1,ITI-ITIT+1) = ITI
             IF (DLIST(2,ITI-ITIT+1) .GT. 0.0)  THEN
                 IDIT                = ILIST(INT(DLIST(2,ITI-ITIT+1)))
                 DLIST(2,ITI-ITIT+1) = IDIT
                 ANGT                = ABS(TA(1,ITI)*SA(1,IDIT)+
     &                                     TA(2,ITI)*SA(2,IDIT) +
     &                                     TA(3,ITI)*SA(3,IDIT))
                 ANGT                = MIN(1.0,ANGT)
                 DLIST(8,ITI-ITIT+1) = ACOS(ANGT) / DGR_TO_RAD
             ELSE
                 DLIST(8,ITI-ITIT+1) = -1.0
             ENDIF
             DLIST(7,ITI-ITIT+1) = ILIP(ITI)
a1 27
             IF (NSEL_USED .GT. 0) THEN
C               OUTPUT TO REGISTERS NOT TO DOC FILE
                IT = ITI-ITIT+1
                CALL REG_SET_NSEL(1,5,DLIST(2,IT),DLIST(3,IT),
     &              DLIST(4,IT),DLIST(5,IT),DLIST(6,IT),IRTFLG)
                CALL REG_SET_NSEL(6,2,DLIST(7,IT),
     &              DLIST(8,IT),0.0 ,0.0, 0.0,IRTFLG)
             ELSE
C               OUTPUT TO TO DOC FILE
                CALL SAVDN1(NDOC,OUTANG,DLIST(1,ITI-ITIT+1),NLIST,
     &                      NRUN,0)
                NRUN = 1
             ENDIF
          ENDDO
       ENDDO

       CALL  SAVDC
       CLOSE(NDOC)

9999   IF (ALLOCATED(BFC))   DEALLOCATE(BFC)
       IF (ALLOCATED(TA))    DEALLOCATE(TA)
       IF (ALLOCATED(SA))    DEALLOCATE(SA)
       IF (ALLOCATED(X))     DEALLOCATE(X)
       IF (ALLOCATED(DLIST)) DEALLOCATE(DLIST)
       IF (ALLOCATED(TT))    DEALLOCATE(TT)

       END
a2 2


d31 4
a34 4
     &          NSAM,NROW,LSAM,LROW,RANGE,
     &          NRING,LCIRC,NUMR,
     &          MODE,ASK,REFANG,EXPANG,OUTANG,SCRFILE,
     &          REFPAT,EXPPAT)
d39 9
a47 2
	PARAMETER (QUADPI = 3.141592653589793238462643383279502884197)
	PARAMETER (DGR_TO_RAD = (QUADPI/180))
d49 11
a59 6
        INTEGER                NUMR(3,NRING)
	DOUBLE PRECISION       EAV
	DIMENSION              ILIST(NIMA),ILIP(NIDI),DLIST(NLIST),TA(3)
	CHARACTER (LEN=MAXNAM) :: FILNAM
        CHARACTER (LEN=*) ::      REFPAT,EXPPAT,REFANG,EXPANG
        CHARACTER (LEN=*) ::      OUTANG,SCRFILE
d62 7
a68 2
        DIMENSION         BUFIN(LSAM)
	DIMENSION         WR(NRING)
d70 2
a71 13
	REAL, ALLOCATABLE, DIMENSION(:,:)  ::  X,BFC,SA
	REAL, ALLOCATABLE, DIMENSION(:)    ::  TOT,CIRC,CIROLD
	INTEGER, ALLOCATABLE, DIMENSION(:) ::  LCG
	DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:) :: TT,TOTMIN

#ifndef SP_32
        INTEGER *8       IASK8,IOK
#else
        INTEGER *4       IASK8,IOK
#endif

	CHARACTER(LEN=1) ::   MODE,ASK,NULL
	LOGICAL          ::   IN_CORE
a79 3
C       FLAG TO OPEN OUTPUT DOC FILE
        NRUN  = 0

d83 6
a88 5
C       RINGWE RETURNS WR
        CALL  RINGWE(WR,NUMR,NRING,MAXRIN)
        IF (MODE .EQ. 'H')  THEN
            WR    = WR*0.5
            DIVAS = 180.0
d90 2
a91 15
            DIVAS = 360.0
        ENDIF

#ifdef SP_LIBFFT
	ALLOCATE(TT(MAXRIN+15),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
           CALL  ERRT(46,'TT',MAXRIN+15)
           RETURN
        ENDIF
	CALL  DZFFT1DUI(MAXRIN,TT)
#else
	ALLOCATE(TT(1),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
           CALL  ERRT(46,'TT',1)
           RETURN
a92 4
#endif

        ALLOCATE(TOT(NIMA),TOTMIN(NIMA),X(NSAM,NROW),CIRC(LCIRC),
     &           CIROLD(LCIRC),SA(3,NIMA),LCG(NIMA),STAT=IRTFLG)
a93 1
           MWANT = 6 * NIMA + NSAM * NROW + 2 * LCIRC
a97 15
	IN_CORE = .TRUE.

	ALLOCATE(BFC(LCIRC,NIMA),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
C          GWP - I HAVE TO FIX THE ALLOCATION HERE FOR DEC UNIX
           IF (ALLOCATED(BFC)) DEALLOCATE(BFC)
	   ALLOCATE(BFC(LCIRC,1),STAT=IRTFLG)
	   IF (IRTFLG .NE. 0) THEN
	      CALL  ERRT(46,'AP RN, BFC',IER)
	      GOTO 9999
	   ENDIF
           IN_CORE = .FALSE.
           WRITE(NOUT,90) LCIRC,NIMA
90         FORMAT (' --- CAN NOT ALLOCATE: BFC(',I8,' X ',I8,'), ',
     &               ' USING TEMPORARY FILE INSTEAD') 
d99 1
d102 1
a103 1
        ELSE
a104 9
           IASK8 = (LCIRC * NIMA + NIMA * 6 + LCIRC * 2 + NSAM * NROW)*4
           CALL BIGALLOC(IASK8,IOK,.FALSE.,.FALSE.,IRTFLG)

           WRITE(NOUT,91) LCIRC,NIMA
91         FORMAT (' --- ALLOCATED: BFC(',I8,' X ',I8,'), IN DSGR_P ') 
  	ENDIF

        CALL FLUSHRESULTS()

d116 12
a127 72
C       READ  ANGLES AND CONVERT THEM TO UNITARY DIRECTIONAL VECTORS.
	DO  IMI=1,NIMA
	   CALL UNSAV(REFANG,IMI-1,INANG,ILIST(IMI),BUFIN,3,IRTFLG,2)
	   IF (IRTFLG .NE. 0) THEN
              CLOSE(INANG)
	      CALL ERRT(102,'MISSING REFERENCE PROJECTION ANGLE',IMI)
              GOTO 9999
           ENDIF
           SA(1,IMI)=COS(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
           SA(2,IMI)=SIN(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
           SA(3,IMI)=COS(BUFIN(2)*DGR_TO_RAD)	
	ENDDO
	CLOSE(INANG)

	IF (ASK .EQ. 'Y')  GOTO  7751

	IF (ASK.EQ.'W' .OR. .NOT.IN_CORE) THEN
C          OPEN(NSCF,FILE=SCRFILE,STATUS='UNKNOWN',FORM='UNFORMATTED')
           CALL OPAUXFILE(.FALSE.,SCRFILE,NULL,-NSCF,0,
     &                     'U',' ',.TRUE.,IRTFLG)
           IF (IRTFLG .NE. 0)  GOTO 9999
        ENDIF

	DO   K1=1,NIMA
C          OPEN REFERENCE PROJECTIONS
           NLET = 0
           CALL  FILGET(REFPAT,FILNAM,NLET,ILIST(K1),INTFLAG)
	   MAXIM = 0
	   CALL OPFILEC(0,.FALSE.,FILNAM,INPIC,'O',IFORM,
     &               LSAM,LROW,NSLICE,MAXIM,' ',.FALSE.,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9999

	   DO K2=LR1,LR2
              CALL  REDLIN(INPIC,BUFIN,LSAM,K2)
	      DO K3=LS1,LS2
                 X(K3-LS1+1,K2-LR1+1) = BUFIN(K3)
	      ENDDO
	   ENDDO
	   CLOSE(INPIC)

C          NORMALIZE UNDER THE MASK
           CALL NORMAS(X,-NSAM/2,NSAM/2,-NROW/2,NROW/2,
     &                NUMR,NUMR(1,NRING))

	   CALL ALRQ(X,NSAM,NROW,NUMR,CIRC,LCIRC,NRING,MODE,K1)
	   CALL FRNG(CIRC,LCIRC,NUMR,NRING)
	   CALL APPLYW(CIRC,LCIRC,NUMR,WR,NRING,MAXRIN)

	   IF (ASK.EQ.'W'.OR..NOT.IN_CORE)  WRITE(NSCF)  CIRC
           IF (IN_CORE) THEN
c$omp         parallel do private(i)
              DO I=1,LCIRC
                 BFC(I,K1) = CIRC(I)
              ENDDO
           ENDIF
	ENDDO

	IF (ASK.EQ.'W'.OR..NOT.IN_CORE) CLOSE(NSCF)
7751    CONTINUE
        IF (.NOT. IN_CORE .OR. ASK.EQ.'Y') THEN
C          OPEN(NSCF,FILE='scratch.file',STATUS='OLD',FORM='UNFORMATTED')
           CALL OPAUXFILE(.FALSE.,SCRFILE,NULL,-NSCF,0,
     &                     'O',' ',.TRUE.,IRTFLG)
           IF (IRTFLG .NE. 0)  GOTO 9999
        ENDIF

        IF (ASK .EQ. 'Y')  THEN
            DO  J=1,NIMA
               READ(NSCF) (BFC(I,J),I=1,LCIRC)
            ENDDO
            CLOSE(NSCF)
        ENDIF
d130 12
a141 26
C         OPEN EXPERIMENTAL (SAMPLE) IMAGES
          NLET = 0
          CALL FILGET(EXPPAT,FILNAM,NLET,ILIP(ITI),INTFLAG)
	  MAXIM = 0
	  CALL OPFILEC(0,.FALSE.,FILNAM,INPIC,'O',IFORM,
     &               LSAM,LROW,NSLICE,MAXIM,' ',.FALSE.,IRTFLG)
          IF (IRTFLG .NE. 0)  GOTO 9999

          DO K2=LR1,LR2
             CALL REDLIN(INPIC,BUFIN,LSAM,K2)
             DO K3=LS1,LS2
                X(K3-LS1+1,K2-LR1+1) = BUFIN(K3)
	     ENDDO
    	  ENDDO
	  CLOSE(INPIC)

C         READ THE ANGLES FOR THIS EXPERIMENTAL (SAMPLE) IMAGE
	  CALL  UNSAV(EXPANG,ITI-1,INANG,ILIP(ITI),BUFIN,3,IRTFLG,2)
	   IF (IRTFLG .NE. 0) THEN
              CLOSE(INANG)
	      CALL ERRT(102,'MISSING EXP. PROJECTION ANGLE',ITI)
              GOTO 9999
           ENDIF
          TA(1) = COS(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
          TA(2) = SIN(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
          TA(3) = COS(BUFIN(2)*DGR_TO_RAD)
d146 1
d148 1
d154 1
d157 1
a157 1
              DT = TA(1)*SA(1,IMI)+TA(2)*SA(2,IMI)+TA(3)*SA(3,IMI)
d159 2
a160 1
	         NIMALCG      = NIMALCG+1
d163 1
d165 2
a166 1
	      ENDIF
d168 1
d171 2
a172 1
             IF (IN_CORE) THEN
d176 7
a182 1
	           CALL CROSRNG_DS(BFC(1,IMI),CIROLD,LCIRC,NRING,
d184 1
d187 27
a213 1
             REWIND  NSCF
d215 22
a236 11
C               ABS - DIRECTIONS AT 180 DEGREES ARE DIFFERENT
C                    (- DO NOT CHECK MIRRORED)
                DT = TA(1)*SA(1,IMI)+TA(2)*SA(2,IMI)+TA(3)*SA(3,IMI)
	        IF (DT .GE. RANGE)  THEN
                   READ(NSCF)  CIRC
                   CALL CROSRNG_DS(CIRC,CIROLD,LCIRC,NRING,
     &	                     MAXRIN,NUMR,TOTMIN(IMI),TOT(IMI),TT)
	        ELSE
                   READ(NSCF)
	           TOTMIN(IMI) = -1.0D20
	        ENDIF
a237 9
          ENDIF

          DO IMI=1,NIMA
             IF (TOTMIN(IMI) .GE. EAV)  THEN
                EAV  = TOTMIN(IMI)
                IDI  = ILIST(IMI)
                RANG = TOT(IMI)
	     ENDIF
	  ENDDO
d239 14
a252 10
          DLIST(2) = IDI
          DLIST(3) = EAV
          RANG     = (RANG-1) / MAXRIN * DIVAS
          DLIST(4) = RANG
C         DLIST 5&6  SET TO ZERO (KEEPS SAME FORMAT AS 'AP MQ')
          IDIT     = ABS(IDI)
          ANGT     = ABS(TA(1)*SA(1,IDIT)+TA(2)*SA(2,IDIT) +
     &                   TA(3)*SA(3,IDIT))
          ANGT     = MIN(1.0,ANGT)
          DLIST(8) = ACOS(ANGT) / DGR_TO_RAD
d254 5
a258 5
C           PROJECTION IS OUTSIDE OF RANGE OF ALL THE REF. PROJECTIONS	
            DLIST(2) = 0.0
            DLIST(3) = -1.0
            DLIST(4) = 0.0
            DLIST(8) = -1.0
d267 1
a267 1
     &                  DLIST(5),DLIST(6),IRTFLG)
d271 2
a272 2
            CALL SAVDN1(NDOC,OUTANG,DLIST,NLIST, NRUN,0)
            NRUN = 1
d276 1
a276 2
      CALL  SAVDC
      CLOSE(NDOC)
d278 1
a278 176

9999  IF (.NOT.IN_CORE)  CLOSE(NSCF)
      DEALLOCATE(BFC)
      DEALLOCATE(LCG)
      DEALLOCATE(SA)
      DEALLOCATE(CIROLD)
      DEALLOCATE(CIRC)
      DEALLOCATE(X)
      DEALLOCATE(TOTMIN)
      DEALLOCATE(TOT)
      DEALLOCATE(TT)

      END



C++************************************************************************
C
C    DSGR_SA.F
C
C **********************************************************************
C * SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK       *
C * COPYRIGHT (C)1985, 2001. HEALTH RESEARCH INCORPORATED (HRI),       *
C * ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C * THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HRI AND ARE NOT   *
C * TO BE DISCLOSED TO OTHERS OR USED FOR PURPOSES OTHER THAN INTENDED *
C * WITHOUT WRITTEN APPROVAL OF HRI.                                   *
C *********************************************************************C **************************************************************************
C
C  ORDER OF PROCESSING:
C 1 - CALCULATE WEIGHTS FOR RINGS IN RINGWE, STORE IN WR
C 2 - CONVERT EACH REFERENCE IMAGE TO RINGS, DO THE FFTS
C     FOR ALL THE RINGS, APPLY WEIGHTS TO THE RINGS, STORE IT IN BFC.
C     IN ADDITION, HIGHEST FREQUENCY FOR ALL THE RINGS EXCEPT
C     MAXRING ARE DIVIDED BY 2.
C 3 - CONVERT EACH INPUT IMAGE TO RINGS, DO THE FFTS,
C     COMPARE EACH INPUT IMAGE WITH ALL THE REFERENCE IMAGES
C     USING CROSRNG_DS. 
C     SINCE Y WERE PRE-WEIGHTED THE RESULTS IS ALREADY CORRECT.
C
C--************************************************************************

         SUBROUTINE DSGR_SA(ILIST,NIMA,ILIP,NIDI,
     &          NSAM,NROW,LSAM,LROW,RANGE,
     &          NRING,LCIRC,NUMR,
     &          MODE,ASK,OUTANG,SCRFILE,
     &          REFPAT,EXPPAT)

        INCLUDE 'CMLIMIT.INC'
        INCLUDE 'CMBLOCK.INC'

	PARAMETER (QUADPI = 3.141592653589793238462643383279502884197)
	PARAMETER (DGR_TO_RAD = (QUADPI/180))
        PARAMETER (NLIST=8)

        INTEGER           NUMR(3,NRING)
	DOUBLE PRECISION  EAV
	DIMENSION         ILIST(NIMA),ILIP(NIDI),DLIST(NLIST),TA(3)

	CHARACTER (LEN=MAXNAM) :: FILNAM
        CHARACTER (LEN=*) ::      REFPAT,EXPPAT
        CHARACTER (LEN=*) ::      OUTANG,SCRFILE

C       AUTOMATIC ARRAYS
        DIMENSION         BUFIN(LSAM)
	DIMENSION         WR(NRING)

	REAL, ALLOCATABLE, DIMENSION(:,:)  ::  X,BFC,SA
	REAL, ALLOCATABLE, DIMENSION(:)    ::  TOT,CIRC,CIROLD
	INTEGER, ALLOCATABLE, DIMENSION(:) ::  LCG
	DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:) :: TOTMIN,TT

#ifndef SP_32
        INTEGER *8       IASK8,IOK
#else
        INTEGER *4       IASK8,IOK
#endif

	CHARACTER(LEN=1) ::   MODE,ASK,NULL
	LOGICAL          ::   IN_CORE

	DATA  INPIC/77/,NDOC/55/,NSCF/50/

        NULL  = CHAR(0)

C       ZERO DLIST ARRAY
	DLIST = 0.0

C       FLAG TO OPEN OUTPUT DOC FILE ON FIRST CALL
        NRUN   = 0

        MAXRIN = NUMR(3,NRING)
	RANGE  = COS(RANGE*DGR_TO_RAD)

C       RINGWE RETURNS WR
	CALL RINGWE(WR,NUMR,NRING,MAXRIN)
        IF (MODE .EQ. 'H')  THEN
           WR    = WR*0.5
           DIVAS = 180.0
        ELSE
           DIVAS = 360.0
        ENDIF

#ifdef SP_LIBFFT
	ALLOCATE(TT(MAXRIN+15),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
           CALL  ERRT(46,'TT',MAXRIN+15)
           RETURN
        ENDIF
	CALL  DZFFT1DUI(MAXRIN,TT)
#else
	ALLOCATE(TT(1),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
           CALL  ERRT(46,'TT',1)
           RETURN
        ENDIF
#endif

	ALLOCATE(TOT(NIMA),TOTMIN(NIMA),X(NSAM,NROW),CIRC(LCIRC),
     &           CIROLD(LCIRC),SA(3,NIMA),LCG(NIMA),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
            MWANT = NSAM*NROW + 6*NIMA + 3*NIDI + 2*LCIRC
            CALL ERRT(46,'X...',MWANT)
            GOTO 9999
        ENDIF

	IN_CORE = .TRUE.

	ALLOCATE(BFC(LCIRC,NIMA),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
C          GWP - I HAVE TO FIX THE ALLOCATION HERE FOR DEC UNIX
           IF (ALLOCATED(BFC)) DEALLOCATE(BFC)
	   ALLOCATE(BFC(LCIRC,1),STAT=IRTFLG)
	   IF (IRTFLG .NE. 0) THEN
	       CALL  ERRT(46,'BFC',LCIRC)
	       GOTO 9999
	   ENDIF
           IN_CORE = .FALSE.
           WRITE(NOUT,90) LCIRC,NIMA
90         FORMAT (' --- CAN NOT ALLOCATE: BFC(',I8,' X ',I8,'), ',
     &               ' USING TEMPORARY FILE INSTEAD') 
#ifdef SP_MP
           WRITE(NOUT,*) '  SETTING OMP THREADS: 2'
           CALL SETTHREADS(2)
#endif
        ELSE

           IASK8 = (LCIRC * NIMA + NIMA * 6 + LCIRC * 2 + NSAM * NROW)*4
           CALL BIGALLOC(IASK8,IOK,.FALSE.,.FALSE.,IRTFLG)

           WRITE(NOUT,91) LCIRC,NIMA
91         FORMAT (' --- ALLOCATED: BFC(',I8,' X ',I8,'), IN DSGR_P ') 
  	ENDIF

        CALL REG_GET_USED(NSEL_USED)

        LQ  = LROW/2+1
        LR1 = (NROW-1)/2
        LR2 = LQ+LR1
        LR1 = LQ-LR1
        LQ  = LSAM/2+1
        LS1 = (NSAM-1)/2
        LS2 = LQ+LS1
        LS1 = LQ-LS1


        CALL FLUSHRESULTS()

	IF (ASK .EQ. 'Y')  GOTO  7751

	IF (ASK.EQ.'W' .OR. .NOT.IN_CORE) THEN
C          OPEN(NSCF,FILE=SCRFILE,STATUS='UNKNOWN',FORM='UNFORMATTED')
           CALL OPAUXFILE(.FALSE.,SCRFILE,NULL,-NSCF,0,
     &                     'U',' ',.TRUE.,IRTFLG)
           IF (IRTFLG .NE. 0)  GOTO 9999
        ENDIF
d280 3
a282 28
	DO   K1=1,NIMA
C          READ REFERENCE IMAGES
           NLET = 0
           CALL FILGET(REFPAT,FILNAM,NLET,ILIST(K1),INTFLAG)
	   MAXIM = 0
	   CALL OPFILEC(0,.FALSE.,FILNAM,INPIC,'O',IFORM,
     &                 LSAM,LROW,NSLICE,MAXIM,' ',.FALSE.,IRTFLG)
           IF (IRTFLG .NE. 0)  GOTO 9999

	   DO K2=LR1,LR2
              CALL  REDLIN(INPIC,BUFIN,LSAM,K2)
	      DO K3=LS1,LS2
                 X(K3-LS1+1,K2-LR1+1) = BUFIN(K3)
	      ENDDO
	   ENDDO

C          READ ANGLES AND CONVERT TO UNITARY DIRECTIONAL VECTORS.
           ITLOC = IAPLOC + 1
           CALL LUNGETVALS(INPIC,ITLOC,4,BUFIN,IRTFLG)
           IF (IRTFLG .NE. 0)   GOTO 9999

           IF (BUFIN(4) .LE. 0) THEN
	      CALL ERRT(102,'NO ANGLES IN REF. PROJECTION',K1)
	       GOTO 9999
           ENDIF
           SA(1,K1)=COS(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
           SA(2,K1)=SIN(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
           SA(3,K1)=COS(BUFIN(2)*DGR_TO_RAD)	
a283 162
	   CLOSE(INPIC)

C          NORMALIZE UNDER THE MASK
           CALL NORMAS(X,-NSAM/2,NSAM/2,-NROW/2,NROW/2,
     &                NUMR,NUMR(1,NRING))

	   CALL ALRQ(X,NSAM,NROW,NUMR,CIRC,LCIRC,NRING,MODE,K1)
	   CALL FRNG(CIRC,LCIRC,NUMR,NRING)
	   CALL APPLYW(CIRC,LCIRC,NUMR,WR,NRING,MAXRIN)

	   IF (ASK.EQ.'W'.OR..NOT.IN_CORE) WRITE(NSCF) CIRC
           IF (IN_CORE)  THEN
c$omp         parallel do private(i)
              DO I=1,LCIRC
                 BFC(I,K1) = CIRC(I)
              ENDDO
           ENDIF
	ENDDO

	IF (ASK.EQ.'W'.OR..NOT.IN_CORE) CLOSE(NSCF)

7751    CONTINUE
        IF (.NOT. IN_CORE .OR. ASK.EQ.'Y') THEN
          CALL OPAUXFILE(.FALSE.,SCRFILE,NULL,-NSCF,0,
     &                     'O',' ',.TRUE.,IRTFLG)
           IF (IRTFLG .NE. 0)  GOTO 9999
        ENDIF

        IF (ASK .EQ. 'Y') THEN
            DO J=1,NIMA
               READ(NSCF) (BFC(I,J),I=1,LCIRC)
            ENDDO
            CLOSE(NSCF)
        ENDIF

        DO ITI=1,NIDI
C         READ EXPERIMENTAL IMAGES
          NLET = 0
          CALL FILGET(EXPPAT,FILNAM,NLET,ILIP(ITI),INTFLAG)
	  MAXIM = 0
	  CALL OPFILEC(0,.FALSE.,FILNAM,INPIC,'O',IFORM,
     &               LSAM,LROW,NSLICE,MAXIM,' ',.FALSE.,IRTFLG)
          IF (IRTFLG .NE. 0)   GOTO 9999

          DO K2=LR1,LR2
             CALL REDLIN(INPIC,BUFIN,LSAM,K2)
             DO K3=LS1,LS2
                X(K3-LS1+1,K2-LR1+1) = BUFIN(K3)
	     ENDDO
    	  ENDDO

C         READ THE ANGLES FOR ITI EXPERIMENTAL IMAGES
          CALL LUNGETVALS(INPIC,IAPLOC+1,4,BUFIN,IRTFLG)
          IF (IRTFLG .NE. 0)   GOTO 9999
	  CLOSE(INPIC)

          IF (BUFIN(4) .LE. 0) THEN
	     CALL ERRT(102,'NO ANGLES IN EXP. IMAGE',ITI)
	      GOTO 9999
          ENDIF

C         CONVERT TO UNITARY DIRECTIONAL VECTORS.
          TA(1) = COS(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
          TA(2) = SIN(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
          TA(3) = COS(BUFIN(2)*DGR_TO_RAD)

C         NORMALIZE UNDER THE MASK
	  CALL NORMAS(X,-NSAM/2,NSAM/2,-NROW/2,NROW/2,
     &                NUMR,NUMR(1,NRING))
	  CALL ALRQ(X,NSAM,NROW,NUMR,CIROLD,LCIRC,NRING,MODE,ITI)
	  CALL FRNG(CIROLD,LCIRC,NUMR,NRING)

C         DETERMINE WHICH ONES ARE TO BE COMPARED
	  NIMALCG = 0
          DO IMI=1,NIMA
C             ABS - DIRECTIONS AT 180 DEGREES ARE DIFFERENT 
C                   (- DO NOT CHECK MIRRORED)
              DT = TA(1)*SA(1,IMI)+TA(2)*SA(2,IMI)+TA(3)*SA(3,IMI)
	      IF (DT.GE.RANGE)  THEN
	         NIMALCG      = NIMALCG+1
	         LCG(NIMALCG) = IMI
	      ELSE
	         TOTMIN(IMI)  = -1.0D20
	      ENDIF
	  ENDDO
          EAV = -1.0D20
	  IF (NIMALCG.GT.0)  THEN
             IF (IN_CORE)  THEN
c$omp           parallel do private(imil,imi)
                DO IMIL=1,NIMALCG
	           IMI=LCG(IMIL)
	           CALL CROSRNG_DS(BFC(1,IMI),CIROLD,LCIRC,NRING,
     &	                 MAXRIN,NUMR,TOTMIN(IMI),TOT(IMI),TT)
	        ENDDO
             ELSE
             REWIND  NSCF
             DO IMI=1,NIMA
C               ABS - DIRECTIONS AT 180 DEGREES ARE DIFFERENT
C                    (- DO NOT CHECK MIRRORED)
                DT = TA(1)*SA(1,IMI)+TA(2)*SA(2,IMI)+TA(3)*SA(3,IMI)
	        IF (DT.GE.RANGE)  THEN
                   READ(NSCF)  CIRC
                   CALL CROSRNG_DS(CIRC,CIROLD,LCIRC,NRING,
     &	                  MAXRIN,NUMR,TOTMIN(IMI),TOT(IMI),TT)
	        ELSE
                   READ(NSCF)
	           TOTMIN(IMI) = -1.0D20
	        ENDIF
	     ENDDO
          ENDIF

          DO IMI=1,NIMA
             IF (TOTMIN(IMI) .GE. EAV)  THEN
                EAV  = TOTMIN(IMI)
                IDI  = ILIST(IMI)
                RANG = TOT(IMI)
	     ENDIF
	  ENDDO

          DLIST(2) = IDI
          DLIST(3) = EAV
          RANG     = (RANG-1)/MAXRIN*DIVAS
          DLIST(4) = RANG
C         DLIST 5&6 ARE PERMANENTLY SET TO ZERO (THIS KEEPS THE
C         SAME FORMAT AS 'AP MQ' OPERATION)
	 ELSE
C           PROJECTION IS OUTSIDE OF RANGE OF ALL THE REFERENCE PROJECTIONS	
            DLIST(2) = 0.0
            DLIST(3) = -1.0
            DLIST(4) = 0.0
	 ENDIF

         DLIST(1) = ITI
         DLIST(7) = ILIP(ITI)

         IF (NSEL_USED .GT. 0) THEN
C           OUTPUT TO REGISTER NOT TO DOC FILE
            CALL REG_SET_NSEL(1,5,DLIST(2),DLIST(3),DLIST(4),
     &                       DLIST(5),DLIST(6),IRTFLG)
            CALL REG_SET_NSEL(6,2,DLIST(7),DLIST(8),0.0,0.0,0.0,IRTFLG)

          ELSE
C           OUTPUT TO DOC FILE
            CALL SAVDN1(NDOC,OUTANG,DLIST,NLIST, NRUN,0)
            NRUN = 1
         ENDIF
      ENDDO
      CALL SAVDC
      CLOSE(NDOC)


      IF (.NOT.IN_CORE) CLOSE(NSCF)

9999  IF(ALLOCATED(BFC))    DEALLOCATE(BFC)
      IF(ALLOCATED(LCG))    DEALLOCATE(LCG)
      IF(ALLOCATED(SA))     DEALLOCATE(SA)
      IF(ALLOCATED(CIRC))   DEALLOCATE(CIRC)
      IF(ALLOCATED(X))      DEALLOCATE(X)
      IF(ALLOCATED(TOTMIN)) DEALLOCATE(TOTMIN)
      IF(ALLOCATED(TOT))    DEALLOCATE(TOT)
      IF(ALLOCATED(TT))     DEALLOCATE(TT)

a286 76
C++************************************************************************
C
C    DSGR2D.F
C
C **************************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
C *  COPYRIGHT (C)1981,1987, WADSWORTH CENTER FOR LABORATORIES AND         *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *  THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR       *
C *  LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR    *
C *  USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF     *
C *  THE CENTER FOR LABORATORIES AND RESEARCH   			   *
C **************************************************************************
C
C--************************************************************************

	SUBROUTINE  DSGR2D(X,NSAM,NROW,NUMR,NRING,MODE,MAXRIN,
     &		BFC,LCIRC,NIMA,TT,SA,TA,RANGE,
     &		DLIST2,DLIST3,RANG)

	CHARACTER*1      MODE
	DOUBLE PRECISION EAV,TOTMIN
        INTEGER          NUMR(3,NRING)
	DIMENSION X(NSAM,NROW),BFC(LCIRC,NIMA),SA(3,NIMA),TA(3)
	REAL, ALLOCATABLE, DIMENSION(:)    ::  CIROLD
	INTEGER, ALLOCATABLE, DIMENSION(:) ::  LCG

	ALLOCATE(CIROLD(LCIRC),LCG(NIMA),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) CALL ERRT(46,'AP RN, CIRCOLD,LCG',IER)

C       DETERMINE WHICH ONES ARE TO BE COMPARED
	NIMALCG = 0
        DO IMI=1,NIMA
C          ABS - DIRECTIONS AT 180 DEGREES ARE DIFFERENT 
C                (- DO NOT CHECK MIRRORED)
           DT = TA(1)*SA(1,IMI)+TA(2)*SA(2,IMI)+TA(3)*SA(3,IMI)
	   IF (DT .GE. RANGE)  THEN
	      NIMALCG      = NIMALCG+1
	      LCG(NIMALCG) = IMI
	   ENDIF
	ENDDO

	IF (NIMALCG.GT.0) THEN
	   CALL NORMAS(X,-NSAM/2,NSAM/2,-NROW/2,NROW/2,
     &                  NUMR,NUMR(1,NRING))
	   CALL ALRQS(X,NSAM,NROW,NUMR,CIROLD,LCIRC,NRING,MODE)
	   CALL FRNGS(CIROLD,LCIRC,NUMR,NRING)
           EAV = -1.0D20
           DO IMIL=1,NIMALCG
	      IMI = LCG(IMIL)
	      CALL  CROSRNG_DS(BFC(1,IMI),CIROLD,LCIRC,NRING,
     &	                       MAXRIN,NUMR,TOTMIN,TOT,TT)
              IF (TOTMIN .GE. EAV)  THEN
                 EAV  = TOTMIN
                 IDI  = IMI
                 RANG = TOT
	      ENDIF
	   ENDDO

	   IF (MODE.EQ.'F')  THEN
              RANG = (RANG-1.0)/MAXRIN*360.0
           ELSE
              RANG = (RANG-1.0)/MAXRIN*180.0
	   ENDIF
	   DLIST2 = IDI
	   DLIST3 = EAV
	ELSE
           RANG   = 0.0
	   DLIST2 = 0.0
	   DLIST3 = -1.0
	ENDIF

	DEALLOCATE(LCG)
	DEALLOCATE(CIROLD)

	END
@


1.42
log
@error msg for unfound angles wrong
@
text
@d1 1
a1 200

C++************************************************************************
C
C DSGR.F            'AP RN'
C                   CAN OUTPUT TO REGISTERS NOW   MAY 01 ARDEAN LEITH
C                   CAN GET ANGLES FROM HEADER    JUN 01 ARDEAN LEITH
C                   NORMASS -> NORMAS             OCT 01 ARDEAN LEITH
C                   SAVDN1 + SAVD BUG             JAN 02 ArDean Leith
C                   PROMPTS                       JAN 02 ARDEAN LEITH
C                   UNSAV LOOP IMPROVED           SEP 02 ARDEAN LEITH
C                   ADDED ANG. DIFFERENCE         OCT 02 ARDEAN LEITH
C                   OPFILEC                       FEB  03 ARDEAN LEITH
C
C **********************************************************************
C * SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK       *
C * COPYRIGHT (C)1985, 2002. HEALTH RESEARCH INCORPORATED (HRI),       *
C * ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C * THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HRI AND ARE NOT   *
C * TO BE DISCLOSED TO OTHERS OR USED FOR PURPOSES OTHER THAN INTENDED *
C * WITHOUT WRITTEN APPROVAL OF HRI.                                   *
C **********************************************************************
C
C    DSGR(MODE)                                 10/21/99
C
C    DISTANCES BETWEEN PROJECTIONS.
C    BUFFER ON THE DISK IN THE 'SCRATCH.FILE'
C    SWITCHES BETWEEN "IN CORE" AND "ON DISK" VERSION,
C    SCRATCH.FILE PRODUCED IN EITHER CASE ...
C    RESTRICTED ANGULAR SEARCH RANGE.
C    DO NOT CHECK MIRRORED ORIENTATIONS..
C
C--************************************************************************

         SUBROUTINE DSGR(MODE)

	 PARAMETER  (NILMAX=99998)

         INCLUDE 'CMLIMIT.INC'
         INCLUDE 'CMBLOCK.INC'

         CHARACTER*80      FIPROJ,FINPAT,FINPIC,REFANG,EXPANG
         COMMON  /F_SPEC/  FINPAT,FIPROJ,FINPIC,NLET,NLEP

	 INTEGER, ALLOCATABLE, DIMENSION(:,:) ::  NUMR
	 INTEGER, ALLOCATABLE, DIMENSION(:)   ::  ILIST,ILIP
         CHARACTER (LEN=MAXNAM) ::  ASK,SCRFILE,OUTANG
         CHARACTER(LEN=1)    ::     MODE,NULL
	 LOGICAL      ::            SUCCESS

         DATA  INPIC/77/

         NULL = CHAR(0)

	 ALLOCATE(ILIST(NILMAX),STAT=IRTFLG)
	 IF (IRTFLG .NE. 0) THEN
            CALL ERRT(46,'AP RN, ILIST',IER)
            RETURN
         ENDIF 

C       ASK FOR DATA FILE
	CALL FILELIST(.TRUE.,INPIC,FINPAT,NLET,ILIST,NILMAX,NIMA,
     &     'ENTER TEMPLATE FOR 2-D REFERENCE IMAGES',IRTFLG)
	IF (IRTFLG .NE. 0) GOTO 9999

C       NIMA - TOTAL NUMBER OF IMAGES
        IF (NIMA .GT. 0)  THEN
           WRITE(NOUT,2001) NIMA
2001       FORMAT('  Number of reference images: ',I7)
        ELSE
           CALL ERRT(101,'No reference images!',IDUM)
           GOTO 9999
        ENDIF

C       GET FIRST REFERENCE IMAGE TO DETERMINE DIMS
        CALL  FILGET(FINPAT,FINPIC,NLET,ILIST(1),INTFLG)
        MAXIM = 0
        CALL OPFILEC(0,.FALSE.,FINPIC,INPIC,'O',IFORM,NSAM,NROW,NSLICE,
     &               MAXIM,' ',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0)  GOTO 9999
        CLOSE(INPIC)

        CALL RDPRMI(MR,NR,NOT_USED,'FIRST AND LAST RING')

	IF(MR.LE.0.OR.NR.GE.MIN0(((NSAM-1)/2)*2+1,((NROW-1)/2)*2+1))THEN
	   CALL ERRT(31,'AP RN',NE)
	   GOTO 9999
	ENDIF

        CALL  RDPRMI(ISKIP,NDUMP,NOT_USED,'SKIP')
        ISKIP = MAX0(1,ISKIP)
        CALL  FILERD(REFANG,NREFA,NULL,
     &		'REFERENCE IMAGES ANGLES DOCUMENT',IRTFLG)
C        FILERD WILL RETURN IRTFLG=1 IF "*"

C        ACCEPT EXTENSION IF FILE IS NAMED
         IRTFLG = 9
         CALL FILERD(ASK,NA,NULL,
     &         'SCRATCH FILE EXISTS (Y/N/W/NAME)?~',IRTFLG)
         IF (IRTFLG .NE. 0)  THEN
             CALL ERRT(101,'FILE NAME NOT ENTERED',NE)
             GOTO 9999
         ENDIF

         SCRFILE = 'scratch.file'
         IF (NA .GT. 1) THEN
            SCRFILE = ASK
            ASK     = 'N'
         ENDIF

         NRING=0
         DO I=MR,NR,ISKIP
            NRING = NRING+1
	 ENDDO

	 ALLOCATE(NUMR(3,NRING),STAT=IRTFLG)
	 IF (IRTFLG .NE. 0) THEN
            CALL ERRT(46,'AP RN, NUMR',IER)
            GOTO 9999
         ENDIF

         NRING = 0
         DO I=MR,NR,ISKIP
            NRING = NRING+1
            NUMR(1,NRING) = I
	 ENDDO

C        CALCULATION OF ACTUAL DIMENSION OF AN IMAGE TO BE INTERPOLATED
C        2*(NO.OF RINGS)+(0'TH ELEMENT)+2*(MARGIN OF 1)

         NRA  = MIN0(((NSAM-1)/2)*2+1,((NROW-1)/2)*2+1,2*NR+3)
         LSAM = NSAM
         LROW = NROW
         NSAM = NRA
         NROW = NRA
         CALL ALPRBS(NUMR,NRING,LCIRC,MODE)
         MAXRIN = NUMR(3,NRING)

	 ALLOCATE(ILIP(NILMAX),STAT=IRTFLG)
	 IF (IRTFLG .NE. 0) THEN
            CALL ERRT(46,'AP RN, ILIP',IER)
            GOTO 9999
         ENDIF

C        IMAGES TO BE ALIGNED
	 CALL FILELIST(.TRUE.,INPIC,FIPROJ,NLEP,ILIP,NILMAX,NIDI,
     &     'ENTER TEMPLATE FOR IMAGE SERIES TO BE ALIGNED',IRTFLG)
	 IF (IRTFLG .NE. 0) GOTO 9999

         WRITE(NOUT,2002) NIDI
2002     FORMAT('  Number of experimental images: ',I6)

         CALL  FILERD(EXPANG,NEXPA,NULL,
     &		'EXPERIMENTAL IMAGES ANGLES DOCUMENT',IRTFLG)

	 CALL  RDPRM(RANGE,NOT_USED,'RANGE OF ANGULAR SEARCH')
C        NIDI - NUMBER OF EXPERIMENTAL IMAGES 

C        FIND NUMBER OF OMP THREADS
         CALL GETTHREADS(NUMTH)

         CALL REG_GET_USED(NSEL_USED)

         IF (NSEL_USED .LE. 0) THEN
            CALL  FILERD(OUTANG,NOUTANG,NULL,
     &		        'OUTPUT ANGLES DOCUMENT',IRTFLG)
         ENDIF

         IF (REFANG(1:1) .EQ. '*') THEN
C           'SMALLANGLE' MODIFICATIONS WITH INLINE ANGLES

            CALL DSGR_SA(ILIST,NIMA,ILIP,NIDI,
     &          NSAM,NROW,LSAM,LROW,RANGE,
     &          NRING,LCIRC,MAXRIN,NUMR,
     &          MODE,ASK,NUMTH,OUTANG,SCRFILE)
         ELSE

            SUCCESS = .FALSE.
	    IF (NUMTH.GT.1 .AND. NIDI.GT.NUMTH .AND. ASK.EQ.'N')  THEN
               CALL  DSGR_PM(ILIST,NIMA,ILIP,NIDI,
     &            NSAM,NROW,LSAM,LROW,RANGE,
     &            NRING,LCIRC,MAXRIN,NUMR,
     &            MODE,NUMTH,REFANG,EXPANG,OUTANG,SUCCESS)
	    ENDIF

	    IF (.NOT.SUCCESS) CALL DSGR_P(ILIST,NIMA,ILIP,NIDI,
     &         NSAM,NROW,LSAM,LROW,RANGE,
     &         NRING,LCIRC,MAXRIN,NUMR,
     &         MODE,ASK,NUMTH,REFANG,EXPANG,OUTANG,SCRFILE)
         ENDIF

9999     IF (ALLOCATED(ILIP))  DEALLOCATE(ILIP)
	 IF (ALLOCATED(NUMR))  DEALLOCATE(NUMR)
	 IF (ALLOCATED(ILIST)) DEALLOCATE(ILIST)

         WRITE (NOUT,2600)
2600     FORMAT (/ ' ',72('-')//,
     &             ' ','END OF COMPUTATION',//,
     &             ' ',72('-')/)
         END

d29 5
a33 4
        SUBROUTINE  DSGR_PM(ILIST,NIMA,ILIP,NIDI,
     &          NSAM,NROW,LSAM,LROW,RANGE,
     &          NRING,LCIRC,MAXRIN,NUMR,MODE,NUMTH,
     &          REFANG,EXPANG,OUTANG,SUCCESS)
d40 12
a51 7
	PARAMETER (DGR_TO_RAD = (QUADPI/180))
        INTEGER           NUMR(3,NRING)
	DIMENSION         ILIST(NIMA),ILIP(NIDI)
	COMMON  /F_SPEC/  FINPAT,FIPROJ,FINPIC,NLET,NLEP
	CHARACTER*80      FINPIC,FIPROJ,FINPAT,REFANG,EXPANG
        CHARACTER (LEN=MAXNAM) ::  OUTANG
        CHARACTER*1       MODE
a56 3
	REAL, ALLOCATABLE, DIMENSION(:,:,:) ::  X
	REAL, ALLOCATABLE, DIMENSION(:,:) ::   BFC,DLIST,SA,TA
	DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:) ::  TT
d59 7
d68 11
a78 3
	RANGE = COS(RANGE*DGR_TO_RAD)
	CALL  RINGWE(WR,NUMR,NRING,MAXRIN)
        IF (MODE.EQ.'H')  WR=WR*0.5
d82 4
a85 1
	IF (IRTFLG .NE. 0) CALL ERRT(46,'AP RN, TT',IER)
d89 4
a92 1
	IF (IRTFLG .NE. 0) CALL ERRT(46,'AP RN, TT',IER)
a93 2
	ALLOCATE(DLIST(NLIST,NUMTH),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) CALL ERRT(46,'AP RN, DLIST',IER)
d95 8
d105 1
a108 3
	ALLOCATE(X(NSAM,NROW,NUMTH),SA(3,NIMA),TA(3,NIDI),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) CALL ERRT(46,'AP MD, X',IER)

d116 1
a116 1
     &               ' WILL TRY DSGR_P NOW ') 
d138 3
a140 1
C       READ THE ANGLES AND CONVERT TO UNITARY DIRECTIONAL VECTORS.
d146 1
a146 1
              RETURN
d160 1
a160 1
              RETURN
d170 2
a171 2

              CALL FILGET(FINPAT,FINPIC,NLET,ILIST(K1),INTFLAG)
d173 1
a173 1
	      CALL OPFILEC(0,.FALSE.,FINPIC,INPIC,'O',IFORM,
d175 1
a175 1
              IF (IRTFLG .NE. 0)  RETURN
d202 2
a203 1
             CALL FILGET(FIPROJ,FINPIC,NLEP,ILIP(ITI),INTFLAG)
d205 1
a205 1
	     CALL OPFILEC(0,.FALSE.,FINPIC,INPIC,'O',IFORM,
d207 1
a207 1
             IF (IRTFLG .NE. 0)  RETURN
a264 1
       DEALLOCATE(BFC)
d266 6
a271 5
9999   DEALLOCATE(TA)
       DEALLOCATE(SA)
       DEALLOCATE(X)
       DEALLOCATE(DLIST)
       DEALLOCATE(TT)
d276 1
d306 3
a308 2
     &          NRING,LCIRC,MAXRIN,NUMR,
     &          MODE,ASK,NUMTH,REFANG,EXPANG,OUTANG,SCRFILE)
d316 6
a321 6
        INTEGER           NUMR(3,NRING)
	DOUBLE PRECISION  EAV
	DIMENSION         ILIST(NIMA),ILIP(NIDI),DLIST(NLIST),TA(3)
	CHARACTER*80      FINPIC,FIPROJ,FINPAT,REFANG,EXPANG,SCRFILE
	COMMON  /F_SPEC/  FINPAT,FIPROJ,FINPIC,NLET,NLEP
        CHARACTER (LEN=MAXNAM) ::  OUTANG
d331 1
d351 2
a352 1
	RANGE = COS(RANGE*DGR_TO_RAD)
d354 2
a355 1
	CALL RINGWE(WR,NUMR,NRING,MAXRIN)
d357 2
a358 2
           WR    = WR*0.5
           DIVAS = 180.0
d360 1
a360 1
           DIVAS = 360.0
d362 1
d366 1
a366 1
           CALL  ERRT(46,'AP RN, TT',IER)
d373 1
a373 1
           CALL  ERRT(46,'AP RN, TT',IER)
d377 2
a378 1
	ALLOCATE(TOT(NIMA),TOTMIN(NIMA),X(NSAM,NROW),CIRC(LCIRC),
d381 3
a383 2
           CALL  ERRT(46,'AP RN, TOT,....',IER)
           RETURN
d395 1
a395 1
	      RETURN
d401 4
d414 2
a426 3
#ifdef SP_MP
        IF (.NOT.IN_CORE) CALL SETTHREADS(2)
#endif
d433 1
a433 1
              RETURN
d447 1
a447 1
           IF (IRTFLG .NE. 0)  RETURN
d452 2
a453 1
           CALL  FILGET(FINPAT,FINPIC,NLET,ILIST(K1),INTFLAG)
d455 1
a455 1
	   CALL OPFILEC(0,.FALSE.,FINPIC,INPIC,'O',IFORM,
d457 1
a457 1
           IF (IRTFLG .NE. 0) RETURN
d490 1
a490 1
           IF (IRTFLG .NE. 0)  RETURN
d502 2
a503 1
          CALL FILGET(FIPROJ,FINPIC,NLEP,ILIP(ITI),INTFLAG)
d505 1
a505 1
	  CALL OPFILEC(0,.FALSE.,FINPIC,INPIC,'O',IFORM,
d507 1
a507 1
          IF (IRTFLG .NE. 0)  RETURN
d522 1
a522 1
              RETURN
d618 1
a618 5
#ifdef SP_MP
      IF (.NOT.IN_CORE) CALL SETTHREADS(NUMTH)
#endif

      IF (.NOT.IN_CORE)  CLOSE(NSCF)
d632 1
d661 3
a663 2
     &          NRING,LCIRC,MAXRIN,NUMR,
     &          MODE,ASK,NUMTH,OUTANG,SCRFILE)
d675 4
a678 3
	CHARACTER*80      FINPIC,FIPROJ,FINPAT,SCRFILE
	COMMON  /F_SPEC/  FINPAT,FIPROJ,FINPIC,NLET,NLEP
        CHARACTER (LEN=MAXNAM) ::  OUTANG
d687 2
a688 1
	DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:) :: TT,TOTMIN
d706 1
a706 1
        NRUN  = 0
d708 2
a709 1
	RANGE = COS(RANGE*DGR_TO_RAD)
d711 1
d723 1
a723 1
           CALL  ERRT(46,'AP RN, TT',IER)
d730 1
a730 1
           CALL  ERRT(46,'AP RN, TT',IER)
d734 1
d738 3
a740 2
           CALL  ERRT(46,'AP RN, TOT,....',IER)
           RETURN
d751 2
a752 2
	      CALL  ERRT(46,'AP RN, BFC',IER)
	      RETURN
d758 4
d782 2
a783 4
#ifdef SP_MP
        IF (.NOT.IN_CORE) WRITE(NOUT,*) ' SETTING OMP THREADS: 2'
        IF (.NOT.IN_CORE) CALL SETTHREADS(2)
#endif
d791 1
a791 1
           IF (IRTFLG .NE. 0) RETURN
d796 2
a797 1
           CALL FILGET(FINPAT,FINPIC,NLET,ILIST(K1),INTFLAG)
d799 1
a799 1
	   CALL OPFILEC(0,.FALSE.,FINPIC,INPIC,'O',IFORM,
d801 1
a801 1
           IF (IRTFLG .NE. 0) RETURN
d813 1
a813 1
           IF (IRTFLG .NE. 0)  RETURN
d817 1
a817 1
	      RETURN
d848 1
a848 1
           IF (IRTFLG .NE. 0) RETURN
d860 2
a861 1
          CALL FILGET(FIPROJ,FINPIC,NLEP,ILIP(ITI),INTFLAG)
d863 1
a863 1
	  CALL OPFILEC(0,.FALSE.,FINPIC,INPIC,'O',IFORM,
d865 1
a865 1
          IF (IRTFLG .NE. 0)  RETURN
d876 1
a876 1
          IF (IRTFLG .NE. 0)  RETURN
d881 1
a881 1
	     RETURN
a972 3
#ifdef SP_MP
      IF (.NOT.IN_CORE) CALL SETTHREADS(NUMTH)
#endif
d975 9
a983 9
      DEALLOCATE(BFC)
      DEALLOCATE(LCG)
      DEALLOCATE(SA)
      DEALLOCATE(CIROLD)
      DEALLOCATE(CIRC)
      DEALLOCATE(X)
      DEALLOCATE(TOTMIN)
      DEALLOCATE(TOT)
      DEALLOCATE(TT)
@


1.41
log
@opfilec
@
text
@d149 2
a150 2
        WRITE(NOUT,2002) NIDI
2002    FORMAT('  Number of experimental images: ',I6)
d308 1
d317 1
a317 1
          SA(1,IMI)=COS(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
d323 1
a323 1
C       READ THE ANGLES FOR ITI EXPERIMENTAL PROJECTION
d328 1
a328 1
	      CALL ERRT(102,'MISSING EXP. PROJECTION ANGLE',IMI)
d369 1
d471 1
a471 1
         SUBROUTINE  DSGR_P(ILIST,NIMA,ILIP,NIDI,
d608 1
d657 1
d672 1
a672 1
C         READ THE ANGLES FOR ITI EXPERIMENTAL PROJECTION
d676 1
a676 1
	      CALL ERRT(102,'MISSING EXP. PROJECTION ANGLE',IMI)
@


1.40
log
@register returns changed
@
text
@d12 1
d77 1
a77 1
        CALL OPFILE(.FALSE.,FINPIC,INPIC,'O',IFORM,NSAM,NROW,NSLICE,
d341 1
a341 1
	      CALL OPFILE(.FALSE.,FINPIC,INPIC,'O',IFORM,
d371 1
a371 1
	     CALL OPFILE(.FALSE.,FINPIC,INPIC,'O',IFORM,
d608 1
a608 1
	   CALL OPFILE(.FALSE.,FINPIC,INPIC,'O',IFORM,
d656 1
a656 1
	  CALL OPFILE(.FALSE.,FINPIC,INPIC,'O',IFORM,
d943 1
a943 1
	   CALL OPFILE(.FALSE.,FINPIC,INPIC,'O',IFORM,
d1006 1
a1006 1
	  CALL OPFILE(.FALSE.,FINPIC,INPIC,'O',IFORM,
@


1.39
log
@added angular change to output file
@
text
@d415 4
a418 4
                CALL REG_SET_NSEL(1,5,FLOAT(ILIP(ITI)),DLIST(2,IT),
     &              DLIST(3,IT),DLIST(4,IT),DLIST(5,IT),IRTFLG)
                CALL REG_SET_NSEL(6,3,DLIST(6,IT),
     &              DLIST(7,IT),DLIST(8,IT),0.0,0.0,IRTFLG)
d733 1
a733 1
          RANG     = (RANG-1)/MAXRIN*DIVAS
d754 3
a756 4
            CALL REG_SET_NSEL(1,5,FLOAT(ILIP(ITI)),DLIST(2),
     &                  DLIST(3),DLIST(4),DLIST(5),IRTFLG)
            CALL REG_SET_NSEL(6,3,DLIST(6),DLIST(7),DLIST(8),
     &                  0.0,0.0,IRTFLG)
d763 1
d1102 3
a1104 4
            CALL REG_SET_NSEL(1,5,FLOAT(ILIP(ITI)),DLIST(2),
     &          DLIST(3),DLIST(4),DLIST(5),IRTFLG)
            CALL REG_SET_NSEL(6,3,DLIST(6),DLIST(7),DLIST(8),
     &          0.0,0.0,IRTFLG)
@


1.38
log
@nloop,iloop_removed
@
text
@d4 1
a4 1
C DSGR.F
d10 2
d15 1
a15 1
C * COPYRIGHT (C)1985, 2001. HEALTH RESEARCH INCORPORATED (HRI),       *
d67 1
a67 1
2001       FORMAT(' Number of reference images: ',I6)
d149 1
a149 1
2002    FORMAT(' Number of experimental images: ',I6)
d235 1
a235 1
        PARAMETER (NLIST=7)
a307 2
        K2A  = 1
        LERR = -1
d309 5
a313 13
           CALL  UNSAV(REFANG,IMI-1,INANG,ILIST(IMI),BUFIN,3,LERR,K2A)
           IF (LERR .NE. 0) THEN
              LERR = -1
              K2A  = 0
              CALL UNSAV(REFANG,IMI-1,INANG,ILIST(IMI),BUFIN,
     &                      3,LERR,K2A)
              IF (LERR .NE. 0) THEN
                 CLOSE(INANG)
                 CALL ERRT(102,'REF. PROJECTION ANGLE NOT FOUND',
     &                      ILIST(IMI))
                 RETURN
              ENDIF
              K2A=1
d315 1
a315 1
           SA(1,IMI)=COS(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
a321 3
        K2A  = 1
        LERR = -1

d323 5
a327 12
	   CALL UNSAV(EXPANG,ITI-1,INANG,ILIP(ITI),BUFIN,3,LERR,K2A)
	   IF (LERR .NE. 0) THEN
              LERR = -1
              K2A  = 0
              CALL UNSAV(EXPANG,ITI-1,INANG,ILIP(ITI),BUFIN,3,LERR,K2A)
              IF (LERR .NE. 0) THEN
                 CLOSE(INANG)
                 CALL  ERRT(102,
     &                'EXPER. PROJECTION ANGLE NOT FOUND',ILIP(ITI))
                 RETURN
              ENDIF
              K2A=1
d398 12
a409 3
             DLIST(1,ITI-ITIT+1)=ITI
             IF (DLIST(2,ITI-ITIT+1).GT.0.0)  DLIST(2,ITI-ITIT+1)=
     &           ILIST(INT(DLIST(2,ITI-ITIT+1)))
d411 1
d417 2
a418 2
                CALL REG_SET_NSEL(6,2,DLIST(6,IT),
     &              DLIST(7,IT),0.0,0.0,0.0,IRTFLG)
d478 1
a478 1
        PARAMETER  (NLIST=7)
d509 1
a581 2
	K2A=1
        LERR = -1
d583 6
a588 14
	   CALL  UNSAV(REFANG,IMI-1,INANG,ILIST(IMI),BUFIN,3,LERR,K2A)
           IF (LERR .NE. 0) THEN
                LERR = -1
		K2A  = 0
                CALL  UNSAV(REFANG,IMI-1,INANG,ILIST(IMI),BUFIN,3,
     &                      LERR,K2A)
                IF (LERR .NE. 0) THEN
		   CLOSE(INANG)
	           CALL  ERRT(100,
     &             'ANGLE FOR REFERENCE PROJECTION NOT FOUND',NE)
		   RETURN
		ENDIF
		K2A = 1
            ENDIF
d628 1
a628 1
           IF (IN_CORE)  THEN
d647 1
a647 1
               READ(NSCF)  (BFC(I,J),I=1,LCIRC)
d668 6
a673 13
	  CALL  UNSAV(EXPANG,ITI-1,INANG,ILIP(ITI),BUFIN,3,LERR,K2A)
          IF (LERR .NE. 0) THEN
             LERR = -1
             K2A  = 0
             CALL  UNSAV(EXPANG,ITI-1,INANG,ILIP(ITI),BUFIN,3,LERR,K2A)
             IF (LERR .NE. 0) THEN
		CLOSE(INANG)
	        CALL  ERRT(100,
     &               'ANGLE FOR EXPERIMENTAL PROJECTION NOT FOUND',NE)
		RETURN
	     ENDIF
             K2A = 1
          ENDIF
d690 1
a690 1
	      IF (DT.GE.RANGE)  THEN
d697 4
a700 4
          EAV=-1.0D20
	  IF (NIMALCG.GT.0)  THEN
             IF (IN_CORE)  THEN
c$omp parallel do private(imil,imi)
d702 1
a702 1
	           IMI=LCG(IMIL)
d712 1
a712 1
	        IF (DT.GE.RANGE)  THEN
d715 1
a715 1
     &	                  MAXRIN,NUMR,TOTMIN(IMI),TOT(IMI),TT)
d735 6
a740 2
C         DLIST 5&6 ARE PERMANENTLY SET TO ZERO (THIS IS TO KEEP 
C         SAME FORMAT AS 'AP MQ' COMMAND)
d742 1
a742 1
C           PROJECTION IS OUTSIDE OF RANGE OF ALL THE REFERENCE PROJECTIONS	
d746 1
d755 3
a757 2
     &          DLIST(3),DLIST(4),DLIST(5),IRTFLG)
            CALL REG_SET_NSEL(6,2,DLIST(6),DLIST(7),0.0,0.0,0.0,IRTFLG)
d822 1
a822 1
        PARAMETER (NLIST=7)
d1104 2
a1105 1
            CALL REG_SET_NSEL(6,2,DLIST(6),DLIST(7),0.0,0.0,0.0,IRTFLG)
d1182 1
a1182 1
           DO   IMIL=1,NIMALCG
@


1.37
log
@prompts
@
text
@d79 1
a79 1
        CALL RDPRMI(MR,NR,NLOOP,ILOOP,'FIRST AND LAST RING')
d86 1
a86 1
        CALL  RDPRMI(ISKIP,NDUMP,NLOOP,ILOOP,'SKIP')
d152 1
a152 1
	 CALL  RDPRM(RANGE,NLOOP,ILOOP,'RANGE OF ANGULAR SEARCH')
@


1.36
log
@outang savd & savdn1 both used bug fixed
@
text
@d9 1
d89 1
a89 1
     &		'REFERENCE PROJECTIONS ANGLES DOCUMENT',IRTFLG)
d143 1
a143 1
     &      'ENTER TEMPLATE FOR 2-D EXPERIMENTAL PROJECTIONS',IRTFLG)
d147 1
a147 1
2002    FORMAT(' Number of experimental projections: ',I6)
d150 1
a150 1
     &		'EXPERIMENTAL PROJECTIONS ANGLES DOCUMENT',IRTFLG)
@


1.35
log
@bad refang on 2nd expang unsav fixed
@
text
@d8 1
a776 1
            CALL SAVD(NDOC,DLIST,NLIST,IRTFLG)
a1124 1
            CALL SAVD(NDOC,DLIST,NLIST,IRTFLG)
@


1.34
log
@normass --> normas
@
text
@d687 1
a687 1
             CALL  UNSAV(REFANG,ITI-1,INANG,ILIP(ITI),BUFIN,3,LERR,K2A)
@


1.33
log
@iaploc  usage changed
@
text
@d7 1
d57 1
a57 1
     &     'ENTER TEMPLATE FOR 2-D REFERENCE PROJECTIONS',IRTFLG)
d61 6
a66 3
        IF (NIMA .LE. 0)  THEN
            CALL ERRT(101,'NO IMAGES!',IDUM)
            GOTO 9999
d69 1
a69 3
        WRITE(NOUT,2001) NIMA
2001    FORMAT(' NUMBER OF IMAGES =',I6)

a74 1

d90 9
a98 2
       	 CALL RDPRMC(ASK,NA,.TRUE.,
     &               'SCRATCH FILE EXISTS (Y/N/W/NAME)?',NULL,IRT)
d141 1
a141 1
     &   'ENTER TEMPLATE FOR 2-D EXPERIMENTAL PROJECTIONS NAME',IRTFLG)
d144 3
d191 3
a193 1
2600     FORMAT (/,' ',27('-'),'END OF COMPUTATION',25('-')/)
d372 1
a372 1
	    CALL NORMASS(X(1,1,K1-ITIT+1),-NSAM/2,NSAM/2,-NROW/2,NROW/2,
d1194 1
a1194 1
	   CALL NORMASS(X,-NSAM/2,NSAM/2,-NROW/2,NROW/2,
@


1.32
log
@activated dsgr_sa inline header angle code
@
text
@d929 1
d958 2
a959 1
           CALL LUNGETVALS(INPIC,IAPLOC+1,3,BUFIN,IRTFLG)
@


1.31
log
@typo
@
text
@d87 1
d147 7
a153 6
         IF (NSEL_USED .GT. 0) THEN
C           'SMALLANGLE' MODIFICATIONS
	    CALL DSGR_P(ILIST,NIMA,ILIP,NIDI,
     &         NSAM,NROW,LSAM,LROW,RANGE,
     &         NRING,LCIRC,MAXRIN,NUMR,
     &         MODE,ASK,NUMTH,REFANG,EXPANG,OUTANG,SCRFILE)
d155 4
a159 3

            CALL  FILERD(OUTANG,NOUTANG,NULL,
     &		'OUTPUT ANGLES DOCUMENT',IRTFLG)
@


1.30
log
@angles in header in dsgr_sa routine added
@
text
@d15 1
a15 1
C *********************************************************************C **************************************************************************
@


1.29
log
@added register output (usefull for AP RN with smallangles)
@
text
@d6 1
d8 8
a15 9
C **************************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
C *  COPYRIGHT (C)1981,1987, WADSWORTH CENTER FOR LABORATORIES AND         *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *  THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR       *
C *  LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR    *
C *  USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF     *
C *  THE CENTER FOR LABORATORIES AND RESEARCH   			   *
C **************************************************************************
d40 1
a40 1
         CHARACTER (LEN=MAXNAM) ::  ASK,SCRFILE
d137 1
d139 1
a139 1
C        NIDI - NUMBER OF IMAGES TO CHECK DISTANCES
d143 22
a164 9
 
	 IF (NUMTH.GT.1 .AND. NIDI.GT.NUMTH .AND. ASK.EQ.'N')  THEN
            CALL  DSGR_PM(ILIST,NIMA,ILIP,NIDI,
     &          NSAM,NROW,LSAM,LROW,RANGE,
     &          NRING,LCIRC,MAXRIN,NUMR,
     &          MODE,NUMTH,NOUT,REFANG,EXPANG,SUCCESS)
	 ELSE
	    SUCCESS = .FALSE.
	 ENDIF
d166 1
a166 1
	 IF (.NOT.SUCCESS) CALL DSGR_P(ILIST,NIMA,ILIP,NIDI,
d169 2
a170 1
     &         MODE,ASK,NUMTH,NOUT,REFANG,EXPANG,SCRFILE)
d210 1
a210 1
     &          NOUT,REFANG,EXPANG,SUCCESS)
d212 3
d222 1
d227 2
a231 1
	DIMENSION  WR(NRING)
d253 2
d411 3
a413 1
                CALL SAVD(NDOC,DLIST(1,ITI-ITIT+1),NLIST,IRTFLG)
d461 4
a464 1
     &          MODE,ASK,NUMTH,NOUT,REFANG,EXPANG,SCRFILE)
d474 1
d496 2
d499 3
d553 1
a553 1
91         FORMAT (' --- ALLOCATED: BFC(',I8,' X ',I8,'), ') 
d761 2
d786 345
@


1.28
log
@SP_32 for NT
@
text
@d5 1
d162 1
a162 3
2600     FORMAT (/ ' ',72('-'),//,
     &             ' ', 'END OF COMPUTATION',//,
     &             ' ',72('-')/)
d255 2
d380 11
a390 1
             CALL SAVD(NDOC,DLIST(1,ITI-ITIT+1),NLIST,IRTFLG)
d523 2
d719 10
a728 1
         CALL  SAVD(NDOC,DLIST,NLIST,IRTFLG)
@


1.27
log
@allocation checks added
@
text
@d445 5
a449 1
	INTEGER * 8      :: IASK8,IOK
@


1.26
log
@typo '
@
text
@a4 1
C  needs improved error handling especially for deallocation on error!!
d31 1
d39 3
a41 3
         CHARACTER*80      ASK,SCRFILE
         CHARACTER*1       MODE,NULL
	 LOGICAL           SUCCESS
d129 2
a130 2
C       IMAGES TO BE ALIGNED
	CALL FILELIST(.TRUE.,INPIC,FIPROJ,NLEP,ILIP,NILMAX,NIDI,
d132 1
a132 1
	IF (IRTFLG .NE. 0) GOTO 9999
d141 3
a143 3

	IF (NUMTH.GT.1 .AND. NIDI.GT.NUMTH .AND. ASK.EQ.'N')  THEN
           CALL  DSGR_PM(ILIST,NIMA,ILIP,NIDI,
d147 3
a149 3
	ELSE
	   SUCCESS = .FALSE.
	ENDIF
d151 1
a151 1
	IF (.NOT.SUCCESS) CALL DSGR_P(ILIST,NIMA,ILIP,NIDI,
d249 3
d253 2
d297 1
a297 1
              CALL UNSAV(REFANG,ITI-1,INANG,ILIP(ITI),BUFIN,3,LERR,K2A)
d445 1
d447 2
a448 2
	CHARACTER*1  MODE,ASK,NULL
	LOGICAL      IN_CORE
d485 1
d500 4
@


1.25
log
@cosmetic & better msgs. about alloc progress
@
text
@d271 1
a271 1
                 CALL ERRT(102,REF. PROJECTION ANGLE NOT FOUND',
@


1.24
log
@named scratch file, and used opauxfile & cosmetic
@
text
@d60 1
a60 1
            CALL ERRT(101,'NO IMAGES !',IDUM)
d142 1
a142 1
	IF (NUMTH.GT.1.AND.NIDI.GT.NUMTH.AND.ASK.EQ.'N')  THEN
d151 1
a151 1
	IF (.NOT.SUCCESS) CALL  DSGR_P(ILIST,NIMA,ILIP,NIDI,
d161 1
a161 1
2600     FORMAT (/ ' ',80('-'),//,
d163 1
a163 1
     &             ' ',80('-')/)
d166 223
d390 1
d405 10
a414 10
C  order of processing:
C 1 - calculate weights for rings in RINGWE, store in WR
C 2 - convert each reference image to rings, do the FFTs
C     for all the rings, apply weights to the rings, store it in BFC.
C     In addition, highest frequency for all the rings except
C     maxring are divided by 2.
C 3 - convert each input image to rings, do the FFTs,
C     compare each input image with all the reference images
C     using CROSRNG_DS. 
C     Since Y were pre-weighted the results is already correct.
d426 1
a426 1
        INTEGER  NUMR(3,NRING)
d428 1
a428 1
	DIMENSION  ILIST(NIMA),ILIP(NIDI),DLIST(NLIST),TA(3)
d433 2
a434 2
        DIMENSION  BUFIN(LSAM)
	DIMENSION  WR(NRING)
d450 1
a450 1
	CALL  RINGWE(WR,NUMR,NRING,MAXRIN)
d481 1
a481 1
C          GWP - I HAVE TO FIX THE ALLOCATION HERE
d489 7
a495 1
	ENDIF
d516 1
a516 1
		K2A=0
d525 1
a525 1
		K2A=1
d561 3
a563 3
	   CALL  ALRQ(X,NSAM,NROW,NUMR,CIRC,LCIRC,NRING,MODE,K1)
	   CALL  FRNG(CIRC,LCIRC,NUMR,NRING)
	   CALL  APPLYW(CIRC,LCIRC,NUMR,WR,NRING,MAXRIN)
d567 1
a567 1
c$omp parallel do private(i)
d569 1
a569 1
                 BFC(I,K1)=CIRC(I)
d619 3
a621 3
          TA(1)=COS(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
          TA(2)=SIN(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
          TA(3)=COS(BUFIN(2)*DGR_TO_RAD)
d626 2
a627 2
	  CALL  ALRQ(X,NSAM,NROW,NUMR,CIROLD,LCIRC,NRING,MODE,ITI)
	  CALL  FRNG(CIROLD,LCIRC,NUMR,NRING)
d630 1
a630 1
	  NIMALCG=0
d634 1
a634 1
              DT=TA(1)*SA(1,IMI)+TA(2)*SA(2,IMI)+TA(3)*SA(3,IMI)
d636 2
a637 2
	         NIMALCG=NIMALCG+1
	         LCG(NIMALCG)=IMI
d639 1
a639 1
	         TOTMIN(IMI)=-1.0D20
d646 1
a646 1
                DO   IMIL=1,NIMALCG
d653 1
a653 1
             DO    IMI=1,NIMA
d668 1
a668 1
          DO   IMI=1,NIMA
d689 2
a690 2
         DLIST(1)=ITI
         DLIST(7)=ILIP(ITI)
a714 214
C++************************************************************************
C
C    DSGR_PM.F
C
C **************************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
C *  COPYRIGHT (C)1981,1987, WADSWORTH CENTER FOR LABORATORIES AND         *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *  THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR       *
C *  LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR    *
C *  USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF     *
C *  THE CENTER FOR LABORATORIES AND RESEARCH   			   *
C **************************************************************************
C
C--************************************************************************

        SUBROUTINE  DSGR_PM(ILIST,NIMA,ILIP,NIDI,
     &          NSAM,NROW,LSAM,LROW,RANGE,
     &          NRING,LCIRC,MAXRIN,NUMR,MODE,NUMTH,
     &          NOUT,REFANG,EXPANG,SUCCESS)

C  order of processing:
C 1 - calculate weights for rings in RINGWE, store in WR
C 2 - convert each reference image to rings, do the FFTs
C     for all the rings, apply weights to the rings, store it in BFC.
C     In addition, highest frequency for all the rings except
C     maxring are divided by 2.
C 3 - convert each input image to rings, do the FFTs,
C     compare each input image with all the reference images
C     using CROSRNG_DS. 
C     Since Y were pre-weighted the results is already correct.
C

        PARAMETER  (NLIST=7)
	PARAMETER (QUADPI = 3.141592653589793238462643383279502884197)
	PARAMETER (DGR_TO_RAD = (QUADPI/180))
        INTEGER  NUMR(3,NRING)
	DIMENSION  ILIST(NIMA),ILIP(NIDI)
	COMMON  /F_SPEC/  FINPAT,FIPROJ,FINPIC,NLET,NLEP
	CHARACTER*80  FINPIC,FIPROJ,FINPAT,REFANG,EXPANG
        CHARACTER*1  MODE
C       AUTOMATIC ARRAYS
        DIMENSION  BUFIN(LSAM)
	REAL, ALLOCATABLE, DIMENSION(:,:,:) ::  X
	REAL, ALLOCATABLE, DIMENSION(:,:) ::  BFC,DLIST,SA,TA
	DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:) ::  TT
	DIMENSION  WR(NRING)

	LOGICAL  SUCCESS
	DATA  INPIC/77/,INANG/78/,NDOC/55/,NSCF/50/

	RANGE=COS(RANGE*DGR_TO_RAD)
	CALL  RINGWE(WR,NUMR,NRING,MAXRIN)
        IF (MODE.EQ.'H')  WR=WR*0.5

#ifdef SP_LIBFFT
	ALLOCATE(TT(MAXRIN+15),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) CALL ERRT(46,'AP RN, TT',IER)
	CALL  DZFFT1DUI(MAXRIN,TT)
#else
	ALLOCATE(TT(1),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) CALL ERRT(46,'AP RN, TT',IER)
#endif
	ALLOCATE(DLIST(NLIST,NUMTH),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) CALL ERRT(46,'AP RN, DLIST',IER)

C       ZERO DLIST ARRAY
	DLIST = 0.0

	ALLOCATE(X(NSAM,NROW,NUMTH),SA(3,NIMA),TA(3,NIDI),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) CALL ERRT(46,'AP MD, X',IER)

	ALLOCATE(BFC(LCIRC,NIMA),STAT=IRTFLG)
	IF (IRTFLG.EQ.0) THEN
	   SUCCESS = .TRUE.

           LQ=LROW/2+1
           LR1=(NROW-1)/2
           LR2=LQ+LR1
           LR1=LQ-LR1
           LQ=LSAM/2+1
           LS1=(NSAM-1)/2
           LS2=LQ+LS1
           LS1=LQ-LS1
C          READ THE ANGLES AND CONVERT TO UNITARY DIRECTIONAL VECTORS.
	   K2A=1
           LERR = -1
	   DO  IMI=1,NIMA
	     CALL  UNSAV(REFANG,IMI-1,INANG,ILIST(IMI),BUFIN,3,LERR,K2A)
	     IF (LERR .NE. 0) THEN
                LERR = -1
		K2A  = 0
                CALL  UNSAV(REFANG,IMI-1,INANG,ILIST(IMI),BUFIN,
     &                      3,LERR,K2A)
                IF (LERR .NE. 0) THEN
		   CLOSE(INANG)
	           CALL ERRT(100,
     &                'ANGLE FOR REFERENCE PROJECTION NOT FOUND',NE)
		   RETURN
                ENDIF
                K2A=1
            ENDIF
            SA(1,IMI)=COS(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
            SA(2,IMI)=SIN(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
            SA(3,IMI)=COS(BUFIN(2)*DGR_TO_RAD)	
	ENDDO
	CLOSE(INANG)

C       READ THE ANGLES FOR ITI EXPERIMENTAL PROJECTION
	K2A  = 1
        LERR = -1
	DO  ITI=1,NIDI
	   CALL  UNSAV(EXPANG,ITI-1,INANG,ILIP(ITI),BUFIN,3,LERR,K2A)
	   IF (LERR .NE. 0) THEN
              LERR = -1
              K2A  = 0
              CALL UNSAV(REFANG,ITI-1,INANG,ILIP(ITI),BUFIN,3,LERR,K2A)
              IF (LERR .NE. 0) THEN
                 CLOSE(INANG)
                 CALL  ERRT(100,
     &                'ANGLE FOR EXPERIMENTAL PROJECTION NOT FOUND',NE)
                 RETURN
              ENDIF
              K2A=1
           ENDIF
           TA(1,ITI)=COS(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
           TA(2,ITI)=SIN(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
           TA(3,ITI)=COS(BUFIN(2)*DGR_TO_RAD)
	ENDDO
	CLOSE(INANG)

	DO ITIT=1,NIMA,NUMTH
	   DO K1=ITIT,MIN(NIMA,ITIT+NUMTH-1)

              CALL FILGET(FINPAT,FINPIC,NLET,ILIST(K1),INTFLAG)
	      MAXIM = 0
	      CALL OPFILE(.FALSE.,FINPIC,INPIC,'O',IFORM,
     &               LSAM,LROW,NSLICE,MAXIM,' ',.FALSE.,IRTFLG)
              IF (IRTFLG .NE. 0)  RETURN

	      DO K2=LR1,LR2
                 CALL  REDLIN(INPIC,BUFIN,LSAM,K2)
	         DO K3=LS1,LS2
                    X(K3-LS1+1,K2-LR1+1,K1-ITIT+1)=BUFIN(K3)
	         ENDDO
	      ENDDO
	      CLOSE(INPIC)
	  ENDDO

C         NORMALIZE UNDER THE MASK
c$omp parallel do private(K1)
	  DO  K1=ITIT,MIN(NIMA,ITIT+NUMTH-1)
	  CALL NORMASS(X(1,1,K1-ITIT+1),-NSAM/2,NSAM/2,-NROW/2,NROW/2,
     &                 NUMR,NUMR(1,NRING))

	  CALL ALRQS(X(1,1,K1-ITIT+1),NSAM,NROW,NUMR,
     &		BFC(1,K1),LCIRC,NRING,MODE)
	  CALL FRNGS(BFC(1,K1),LCIRC,NUMR,NRING)
	  CALL APPLYWS(BFC(1,K1),LCIRC,NUMR,WR,NRING,MAXRIN)
	  ENDDO
       ENDDO

       DO ITIT=1,NIDI,NUMTH
	  DO ITI=ITIT,MIN(NIDI,ITIT+NUMTH-1)
             CALL FILGET(FIPROJ,FINPIC,NLEP,ILIP(ITI),INTFLAG)
	     MAXIM = 0
	     CALL OPFILE(.FALSE.,FINPIC,INPIC,'O',IFORM,
     &               LSAM,LROW,NSLICE,MAXIM,' ',.FALSE.,IRTFLG)
             IF (IRTFLG .NE. 0)  RETURN

             DO K2=LR1,LR2
                CALL REDLIN(INPIC,BUFIN,LSAM,K2)
                   DO K3=LS1,LS2
                     X(K3-LS1+1,K2-LR1+1,ITI-ITIT+1) = BUFIN(K3)
	           ENDDO
    	        ENDDO
	        CLOSE(INPIC)
	     ENDDO

C            NORMALIZE UNDER THE MASK
c$omp parallel do private(ITI)
	     DO ITI=ITIT,MIN(NIDI,ITIT+NUMTH-1)
	        CALL DSGR2D(X(1,1,ITI-ITIT+1),NSAM,NROW,NUMR,NRING,
     &             MODE,MAXRIN,BFC,LCIRC,NIMA,TT,SA,TA(1,ITI),RANGE,
     &	           DLIST(2,ITI-ITIT+1),DLIST(3,ITI-ITIT+1),
     &             DLIST(4,ITI-ITIT+1))
	     ENDDO

C            DLIST(2) = IDI
C            DLIST(3) = EAV
C            DLIST(4) = ANGMOR(RANG,MODE)
C            DLIST 5&6  PERMANENTLY SET TO ZERO (KEEP SAME FORMAT AS
C            AP MQ COMMAND)
             DO  ITI=ITIT,MIN(NIDI,ITIT+NUMTH-1)
                DLIST(1,ITI-ITIT+1)=ITI
                IF (DLIST(2,ITI-ITIT+1).GT.0.0)  DLIST(2,ITI-ITIT+1)=
     &             ILIST(INT(DLIST(2,ITI-ITIT+1)))
                DLIST(7,ITI-ITIT+1) = ILIP(ITI)
                CALL SAVD(NDOC,DLIST(1,ITI-ITIT+1),NLIST,IRTFLG)
	     ENDDO
	  ENDDO
          CALL  SAVDC
          CLOSE(NDOC)
	  DEALLOCATE(BFC)
       ELSE
          SUCCESS=.FALSE.
       ENDIF

       DEALLOCATE(TA)
       DEALLOCATE(SA)
       DEALLOCATE(X)
       DEALLOCATE(DLIST)
       DEALLOCATE(TT)
       END
@


1.23
log
@error trapping on alloc & much cosmetic
@
text
@d38 4
a41 3
	 INTEGER, ALLOCATABLE, DIMENSION(:) ::  ILIST,ILIP
         CHARACTER*1  MODE,ASK,NULL
	 LOGICAL      SUCCESS
d55 1
a55 1
     &     'ENTER TEMPLATE FOR 2-D REFERENCE PROJECTIONS NAME',IRTFLG)
d87 7
a93 2
      	CALL RDPRMC(ASK,NA,.TRUE.,
     &	   'SCRATCH FILE EXISTS (Y/N/W)?',NULL,IRT)
d97 1
a97 1
            NRING=NRING+1
d106 1
a106 1
         NRING=0
d108 2
a109 2
            NRING=NRING+1
            NUMR(1,NRING)=I
d115 5
a119 5
         NRA=MIN0(((NSAM-1)/2)*2+1,((NROW-1)/2)*2+1,2*NR+3)
         LSAM=NSAM
         LROW=NROW
         NSAM=NRA
         NROW=NRA
d154 1
a154 1
     &         MODE,ASK,NUMTH,NOUT,REFANG,EXPANG)
d191 1
a191 1

d197 1
a197 1
     &          MODE,ASK,NUMTH,NOUT,REFANG,EXPANG)
d205 1
a205 1
	CHARACTER*80      FINPIC,FIPROJ,FINPAT,REFANG,EXPANG
d217 1
a217 1
	CHARACTER*1  MODE,ASK
d222 1
d228 2
a229 2
           WR=WR*0.5
           DIVAS=180.0
d231 1
a231 1
           DIVAS=360.0
d235 4
a238 1
	IF (IRTFLG .NE. 0) CALL  ERRT(46,'AP RN, TT',IER)
d242 4
a245 1
	IF (IRTFLG .NE. 0) CALL  ERRT(46,'AP RN, TT',IER)
d267 8
a274 8
        LQ=LROW/2+1
        LR1=(NROW-1)/2
        LR2=LQ+LR1
        LR1=LQ-LR1
        LQ=LSAM/2+1
        LS1=(NSAM-1)/2
        LS2=LQ+LS1
        LS1=LQ-LS1
d305 6
a310 2
	IF (ASK.EQ.'W'.OR..NOT.IN_CORE) OPEN(NSCF,FILE='scratch.file',
     &     STATUS='UNKNOWN',FORM='UNFORMATTED')
d317 1
a317 1
           IF (IRTFLG .NE. 0)  RETURN
d346 7
a352 3
        IF (.NOT.IN_CORE .OR. ASK.EQ.'Y')
     &         OPEN(NSCF,FILE='scratch.file',
     &             STATUS='OLD',FORM='UNFORMATTED')
d375 1
a375 1
C         Read the angles for ITI experimental projection
d424 2
a425 2
C               ABS - directions at 180 degrees are different
C                    (- do not check mirrored)
d429 1
a429 1
                   CALL CROSRNG_DS (CIRC,CIROLD,LCIRC,NRING,
d453 1
a453 1
C           Projection is outside of RANGE of all the reference projections	
d470 1
a470 1
C     CLOSE(NSCF,DISPOSE='DELETE')
@


1.22
log
@H
@
text
@d5 1
d17 2
a18 1
C    DSGR                                 10/21/99
d22 3
a24 15
C     SCRATCH.FILE PRODUCED IN EITHER CASE ...
C     RESTRICTED ANGULAR SEARCH RANGE.
C     DO NOT CHECK MIRRORED ORIENTATIONS..
C
C     SUBROUTINE DSGR(MAXMEM)
C     SUBROUTINE  DSGR_P(BUF,ILIST,NILMAX,ILIP,NIDI,NIDI,
C     SUBROUTINE  NORMAS(X,NS1,NS2,NR1,NR2,IR1,IR2)
C     SUBROUTINE  ALPRBS
C     SUBROUTINE  ALRQ
C     SUBROUTINE  CROSRNG_DS
C     SUBROUTINE  FRNG(CIRC,LCIRC,NUMR,NRING)
C     SUBROUTINE PRB1D(B,NPOINT,POS)
C     SUBROUTINE  FFTR_D(X,NV)
C     SUBROUTINE  FFTC_D(BR,BI,LN,KS)
C     FUNCTION  LOG2(N)
d31 1
d33 2
d36 1
a36 3
         CHARACTER*80  FINPIC,FIPROJ,FINPAT,REFANG,EXPANG
         INTEGER  MAXRIN
         CHARACTER*1  MODE,ASK,NULL
d39 3
a41 1
	 LOGICAL  SUCCESS
d43 2
a44 1
         NULL=CHAR(0)
d46 5
a50 1
	ALLOCATE(ILIST(NILMAX))
a52 1

d55 1
a55 1
	IF (IRTFLG .NE. 0) RETURN
d58 7
a64 7
         IF(NIMA.GT.0)  THEN
            WRITE(NOUT,2001) NIMA
2001        FORMAT('  NUMBER OF IMAGES =',I5)
         ELSE
            WRITE(NOUT,*)  '  NO IMAGES !'
            RETURN
         ENDIF
d66 3
a68 3
         CALL  FILGET(FINPAT,FINPIC,NLET,ILIST(1),INTFLG)
	 MAXIM = 0
	 CALL OPFILE(.FALSE.,FINPIC,INPIC,'O',IFORM,NSAM,NROW,NSLICE,
d70 1
a70 1
         IF(IRTFLG.NE.0)  RETURN
d72 1
a72 1
         CLOSE(INPIC)
d74 1
a74 1
         CALL  RDPRMI(MR,NR,NLOOP,ILOOP,'FIRST AND LAST RING')
d78 1
a78 1
	   RETURN
d81 4
a84 18

         CALL  RDPRMI(ISKIP,NDUMP,NLOOP,ILOOP,'SKIP')
         ISKIP=MAX0(1,ISKIP)
         CALL  FILERD(REFANG,NREFA,NULL,
     &		'Reference projections angles document',IRTFLG)
C
C     NA=1
C     CALL  RDPRMC(ASK,NA,.TRUE.,'(F)ULL OR (H)ALF CIRCLE',NULL,IRT)
C     IF(ASK.EQ.'F')  THEN
C         MODE='F'
C     ELSEIF(ASK.EQ.'H')  THEN
C        MODE='H'
C     ELSE
C        RETURN
C     ENDIF
C     CALL  RDPRMI(JACUP,NDUMP,NLOOP,ILOOP,
C     & 'Precision of peak location (0..100)$')
C     JACUP=MAX0(0,MIN0(100,JACUP))
d86 1
a86 1
      	CALL  RDPRMC(ASK,NA,.TRUE.,
d90 1
a90 1
         DO    I=MR,NR,ISKIP
d93 1
d95 5
a99 1
	 IF(IRTFLG.NE.0) CALL ERRT(46,'AP RN, NUMR',IER)
d101 3
a103 3
         DO    I=MR,NR,ISKIP
          NRING=NRING+1
          NUMR(1,NRING)=I
d105 4
a108 4
C
C Calculation of actual dimension of an image to be interpolated
C 2*(No.of rings)+(0'th element)+2*(margin of 1)
C
d114 2
a115 2
         CALL  ALPRBS(NUMR,NRING,LCIRC,MODE)
         MAXRIN=NUMR(3,NRING)
d117 5
a121 1
	 ALLOCATE(ILIP(NILMAX))
d126 1
a126 1
	IF (IRTFLG.NE.0) RETURN
d142 1
a142 1
	   SUCCESS=.FALSE.
d145 9
a153 9
	IF (.NOT.SUCCESS) 
     &   CALL  DSGR_P(ILIST,NIMA,ILIP,NIDI,
     &      NSAM,NROW,LSAM,LROW,RANGE,
     &      NRING,LCIRC,MAXRIN,NUMR,
     &      MODE,ASK,NUMTH,NOUT,REFANG,EXPANG)
C
	 DEALLOCATE(ILIP)
	 DEALLOCATE(NUMR)
	 DEALLOCATE(ILIST)
d175 11
d195 2
a196 3
         PARAMETER  (NLIST=7)
         INTEGER  MAXRIN
         INTEGER  NUMR(3,NRING)
d199 1
d201 2
a202 2
	CHARACTER*80  FINPIC,FIPROJ,FINPAT,REFANG,EXPANG
C Automatic arrays
d204 4
a207 2
	REAL, ALLOCATABLE, DIMENSION(:,:) ::  X,BFC,SA
	REAL, ALLOCATABLE, DIMENSION(:) ::  TOT,CIRC,CIROLD
d209 1
a209 2
	DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:) ::  TT,TOTMIN
	DIMENSION  WR(NRING)
d212 2
a213 1
	LOGICAL  IN_CORE
d216 3
a218 14
C  order of processing:
C 1 - calculate weights for rings in RINGWE, store in WR
C 2 - convert each reference image to rings, do the FFTs
C     for all the rings, apply weights to the rings, store it in BFC.
C     In addition, highest frequency for all the rings except
C     maxring are divided by 2.
C 3 - convert each input image to rings, do the FFTs,
C     compare each input image with all the reference images
C     using CROSRNG_DS. 
C     Since Y were pre-weighted the results is already correct.
C
	DLIST=0.0
	RANGE=COS(RANGE*DGR_TO_RAD)
C
d220 1
a220 1
        IF(MODE.EQ.'H')  THEN
d228 1
a228 1
	IF(IRTFLG.NE.0) CALL  ERRT(46,'AP RN, TT',IER)
d232 1
a232 1
	IF(IRTFLG.NE.0) CALL  ERRT(46,'AP RN, TT',IER)
d234 8
a241 14
	ALLOCATE(TOT(NIMA),STAT=IRTFLG)
	IF(IRTFLG.NE.0) CALL  ERRT(46,'AP RN, TOT',IER)
	ALLOCATE(TOTMIN(NIMA),STAT=IRTFLG)
	IF(IRTFLG.NE.0) CALL  ERRT(46,'AP RN, TOTMIN',IER)
	ALLOCATE(X(NSAM,NROW),STAT=IRTFLG)
	IF(IRTFLG.NE.0) CALL  ERRT(46,'AP RN, X',IER)
	ALLOCATE(CIRC(LCIRC),STAT=IRTFLG)
	IF(IRTFLG.NE.0) CALL  ERRT(46,'AP RN, CIRC',IER)
	ALLOCATE(CIROLD(LCIRC),STAT=IRTFLG)
	IF(IRTFLG.NE.0) CALL  ERRT(46,'AP RN, CIRCOLD',IER)
	ALLOCATE(SA(3,NIMA),STAT=IRTFLG)
	IF(IRTFLG.NE.0) CALL  ERRT(46,'AP RN, SA',IER)
	ALLOCATE(LCG(NIMA),STAT=IRTFLG)
	IF(IRTFLG.NE.0) CALL  ERRT(46,'AP RN, LCG',IER)
d243 9
a251 12
	IF (IRTFLG.NE.0) THEN
C         GWP - I HAVE TO FIX THE ALLOCATION HERE
          IF (ALLOCATED(BFC)) DEALLOCATE(BFC)
	  ALLOCATE(BFC(LCIRC,1),STAT=IRTFLG)
	  IF (IRTFLG.NE.0) THEN
	     CALL  ERRT(46,'AP RN, BFC',IER)
	     RETURN
	  ELSE
	     IN_CORE=.FALSE.
	  ENDIF
	ELSE
	  IN_CORE=.TRUE.
d254 8
a261 8
         LQ=LROW/2+1
         LR1=(NROW-1)/2
         LR2=LQ+LR1
         LR1=LQ-LR1
         LQ=LSAM/2+1
         LS1=(NSAM-1)/2
         LS2=LQ+LS1
         LS1=LQ-LS1
d266 1
a266 1
C  Read the angles and convert them to unitary directional vectors.
d270 2
a271 2
	CALL  UNSAV(REFANG,IMI-1,INANG,ILIST(IMI),BUFIN,3,LERR,K2A)
	    IF (LERR .NE. 0) THEN
d274 7
a280 5
           CALL  UNSAV(REFANG,IMI-1,INANG,ILIST(IMI),BUFIN,3,LERR,K2A)
                IF (LERR.NE.0) THEN
		CLOSE(INANG)
	CALL  ERRT(100,'Angle for reference projection not found',NE)
		RETURN
d284 3
a286 3
        SA(1,IMI)=COS(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
        SA(2,IMI)=SIN(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
        SA(3,IMI)=COS(BUFIN(2)*DGR_TO_RAD)	
d289 4
a292 4
C
	IF(ASK.EQ.'Y')  GOTO  7751
C
	IF(ASK.EQ.'W'.OR..NOT.IN_CORE) OPEN(NSCF,FILE='scratch.file',
d294 1
a294 1
C
d296 3
a298 3
         CALL  FILGET(FINPAT,FINPIC,NLET,ILIST(K1),INTFLAG)
	 MAXIM = 0
	 CALL OPFILE(.FALSE.,FINPIC,INPIC,'O',IFORM,
d300 20
a319 24
          IF(IRTFLG.NE.0)  THEN
           WRITE(NOUT,2032)  FINPIC
2032       FORMAT(' File not found ',A80,/,' Operation abandoned')
           RETURN
          ENDIF
	 DO    K2=LR1,LR2
          CALL  REDLIN(INPIC,BUFIN,LSAM,K2)
	  DO    K3=LS1,LS2
            X(K3-LS1+1,K2-LR1+1)=BUFIN(K3)
	  ENDDO
	 ENDDO
	 CLOSE(INPIC)
C
C  Normalize under the mask
C
	  CALL NORMAS(X,-NSAM/2,NSAM/2,-NROW/2,NROW/2,
     &       NUMR,NUMR(1,NRING))
C
	  CALL  ALRQ(X,NSAM,NROW,NUMR,CIRC,LCIRC,NRING,MODE,K1)
	  CALL  FRNG(CIRC,LCIRC,NUMR,NRING)
	  CALL  APPLYW(CIRC,LCIRC,NUMR,WR,NRING,MAXRIN)
C
	  IF(ASK.EQ.'W'.OR..NOT.IN_CORE)  WRITE(NSCF)  CIRC
          IF(IN_CORE)  THEN
d321 4
a324 4
           DO I=1,LCIRC
            BFC(I,K1)=CIRC(I)
           ENDDO
          ENDIF
d326 4
a329 3
	IF(ASK.EQ.'W'.OR..NOT.IN_CORE) CLOSE(NSCF)
7751     CONTINUE
         IF(.NOT.IN_CORE.OR.ASK.EQ.'Y')
d331 2
a332 2
     &        STATUS='OLD',FORM='UNFORMATTED')
         IF(ASK.EQ.'Y')  THEN
d334 1
a334 1
             READ(NSCF)  (BFC(I,J),I=1,LCIRC)
d336 5
a340 5
           CLOSE(NSCF)
         ENDIF
C
         DO  ITI=1,NIDI
          CALL  FILGET(FIPROJ,FINPIC,NLEP,ILIP(ITI),INTFLAG)
d344 7
a350 9
          IF(IRTFLG.NE.0)  THEN
           WRITE(NOUT,2032)  FIPROJ
           RETURN
          ENDIF
          DO    K2=LR1,LR2
           CALL  REDLIN(INPIC,BUFIN,LSAM,K2)
            DO    K3=LS1,LS2
             X(K3-LS1+1,K2-LR1+1)=BUFIN(K3)
	    ENDDO
d353 6
a358 6
C
C  Read the angles for ITI experimental projection
	 CALL  UNSAV(EXPANG,ITI-1,INANG,ILIP(ITI),BUFIN,3,LERR,K2A)
	    IF (LERR .NE. 0) THEN
                LERR = -1
		K2A=0
d360 1
a360 1
                IF (LERR.NE.0) THEN
d362 2
a363 2
	 CALL  ERRT(100,
     &         'Angle for experimental projection not found',NE)
d365 8
a372 7
		ENDIF
		K2A=1
            ENDIF
         TA(1)=COS(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
         TA(2)=SIN(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
         TA(3)=COS(BUFIN(2)*DGR_TO_RAD)
C  Normalize under the mask
d374 1
a374 1
     &      NUMR,NUMR(1,NRING))
d377 14
a390 12
C Determine which ones are to be compared
	   NIMALCG=0
           DO   IMI=1,NIMA
C ABS - directions at 180 degrees are different (- do not check mirrored)
         DT=TA(1)*SA(1,IMI)+TA(2)*SA(2,IMI)+TA(3)*SA(3,IMI)
	    IF(DT.GE.RANGE)  THEN
	     NIMALCG=NIMALCG+1
	     LCG(NIMALCG)=IMI
	    ELSE
	     TOTMIN(IMI)=-1.0D20
	    ENDIF
	   ENDDO
d392 2
a393 2
	 IF(NIMALCG.GT.0)  THEN
          IF(IN_CORE)  THEN
d395 20
a414 21
            DO   IMIL=1,NIMALCG
	     IMI=LCG(IMIL)
	     CALL  CROSRNG_DS
     &		(BFC(1,IMI),CIROLD,LCIRC,NRING,
     &	 MAXRIN,NUMR,TOTMIN(IMI),TOT(IMI),TT)
	    ENDDO
          ELSE
           REWIND  NSCF
           DO    IMI=1,NIMA
C ABS - directions at 180 degrees are different (- do not check mirrored)
        DT=TA(1)*SA(1,IMI)+TA(2)*SA(2,IMI)+TA(3)*SA(3,IMI)
	    IF(DT.GE.RANGE)  THEN
             READ(NSCF)  CIRC
             CALL  CROSRNG_DS
     &        (CIRC,CIROLD,LCIRC,NRING,
     &	MAXRIN,NUMR,TOTMIN(IMI),TOT(IMI),TT)
	    ELSE
             READ(NSCF)
	     TOTMIN(IMI)=-1.0D20
	    ENDIF
	   ENDDO
d416 1
a416 1
C
d418 4
a421 4
             IF(TOTMIN(IMI).GE.EAV)  THEN
                EAV=TOTMIN(IMI)
                IDI=ILIST(IMI)
                RANG=TOT(IMI)
d424 7
a430 7
C .....................................................................
          DLIST(2)=IDI
          DLIST(3)=EAV
          RANG=(RANG-1)/MAXRIN*DIVAS
          DLIST(4)=RANG
C DLIST 5&6 are permanently set to zero (this is to keep same format as
C  AP MQ command)
d432 4
a435 4
C Projection is outside of RANGE of all the reference projections	
          DLIST(2)=0.0
          DLIST(3)=-1.0
          DLIST(4)=0.0
d437 8
a444 7
          DLIST(1)=ITI
          DLIST(7)=ILIP(ITI)
          CALL  SAVD(NDOC,DLIST,NLIST,IRTFLG)
	 ENDDO
         CALL  SAVDC
         CLOSE(NDOC)
	 CLOSE(INANG)
d447 1
a447 1
	 IF (.NOT.IN_CORE) CALL SETTHREADS(NUMTH)
d449 30
a478 12
C        close(nscf,dispose='delete')
         IF(.NOT.IN_CORE)  CLOSE(NSCF)
	 DEALLOCATE(BFC)
	 DEALLOCATE(LCG)
	 DEALLOCATE(SA)
	 DEALLOCATE(CIROLD)
	 DEALLOCATE(CIRC)
	 DEALLOCATE(X)
	 DEALLOCATE(TOTMIN)
	 DEALLOCATE(TOT)
	 DEALLOCATE(TT)
         END
d484 13
d505 1
a505 1
C Automatic arrays
d514 1
a514 12
C
C  order of processing:
C 1 - calculate weights for rings in RINGWE, store in WR
C 2 - convert each reference image to rings, do the FFTs
C     for all the rings, apply weights to the rings, store it in BFC.
C     In addition, highest frequency for all the rings except
C     maxring are divided by 2.
C 3 - convert each input image to rings, do the FFTs,
C     compare each input image with all the reference images
C     using CROSRNG_DS. 
C     Since Y were pre-weighted the results is already correct.
C
d517 2
a518 1
        IF(MODE.EQ.'H')  WR=WR*0.5
d521 1
a521 1
	IF(IRTFLG.NE.0) CALL  ERRT(46,'AP RN, TT',IER)
d525 1
a525 1
	IF(IRTFLG.NE.0) CALL  ERRT(46,'AP RN, TT',IER)
d528 8
a535 9
	IF(IRTFLG.NE.0) CALL  ERRT(46,'AP RN, DLIST',IER)
	DLIST=0.0
C
	ALLOCATE(X(NSAM,NROW,NUMTH),STAT=IRTFLG)
	IF(IRTFLG.NE.0) CALL  ERRT(46,'AP MD, X',IER)
	ALLOCATE(SA(3,NIMA),STAT=IRTFLG)
	IF(IRTFLG.NE.0) CALL  ERRT(46,'AP RN, SA',IER)
	ALLOCATE(TA(3,NIDI),STAT=IRTFLG)
	IF(IRTFLG.NE.0) CALL  ERRT(46,'AP RN, TA',IER)
d537 17
a553 17
	IF(IRTFLG.EQ.0) THEN
	   SUCCESS=.TRUE.
C
         LQ=LROW/2+1
         LR1=(NROW-1)/2
         LR2=LQ+LR1
         LR1=LQ-LR1
         LQ=LSAM/2+1
         LS1=(NSAM-1)/2
         LS2=LQ+LS1
         LS1=LQ-LS1
C  Read the angles and convert them to unitary directional vectors.
	K2A=1
        LERR = -1
	DO  IMI=1,NIMA
	CALL  UNSAV(REFANG,IMI-1,INANG,ILIST(IMI),BUFIN,3,LERR,K2A)
	    IF (LERR .NE. 0) THEN
d555 10
a564 8
		K2A=0
           CALL  UNSAV(REFANG,IMI-1,INANG,ILIST(IMI),BUFIN,3,LERR,K2A)
                IF (LERR.NE.0) THEN
		CLOSE(INANG)
	CALL  ERRT(100,'Angle for reference projection not found',NE)
		RETURN
		ENDIF
		K2A=1
d566 3
a568 3
        SA(1,IMI)=COS(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
        SA(2,IMI)=SIN(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
        SA(3,IMI)=COS(BUFIN(2)*DGR_TO_RAD)	
d571 3
a573 3
C
C  Read the angles for ITI experimental projection
	K2A=1
d576 16
a591 15
	CALL  UNSAV(EXPANG,ITI-1,INANG,ILIP(ITI),BUFIN,3,LERR,K2A)
	    IF (LERR .NE. 0) THEN
                LERR = -1
		K2A=0
             CALL  UNSAV(REFANG,ITI-1,INANG,ILIP(ITI),BUFIN,3,LERR,K2A)
                IF (LERR.NE.0) THEN
		CLOSE(INANG)
	CALL  ERRT(100,'Angle for experimental projection not found',NE)
		RETURN
		ENDIF
		K2A=1
            ENDIF
        TA(1,ITI)=COS(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
        TA(2,ITI)=SIN(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
        TA(3,ITI)=COS(BUFIN(2)*DGR_TO_RAD)
d594 3
a596 3
C
	DO   ITIT=1,NIMA,NUMTH
	 DO  K1=ITIT,MIN(NIMA,ITIT+NUMTH-1)
d598 3
a600 3
         CALL  FILGET(FINPAT,FINPIC,NLET,ILIST(K1),INTFLAG)
	 MAXIM = 0
	 CALL OPFILE(.FALSE.,FINPIC,INPIC,'O',IFORM,
d602 9
a610 9
          IF(IRTFLG.NE.0)  THEN
           WRITE(NOUT,2032)  FINPIC
2032       FORMAT(' File not found ',A80,/,' Operation abandoned')
           RETURN
          ENDIF
	 DO    K2=LR1,LR2
          CALL  REDLIN(INPIC,BUFIN,LSAM,K2)
	  DO    K3=LS1,LS2
            X(K3-LS1+1,K2-LR1+1,K1-ITIT+1)=BUFIN(K3)
a611 5
	 ENDDO
	 CLOSE(INPIC)
	ENDDO

C  Normalize under the mask
d613 1
d615 1
a615 1
	 DO  K1=ITIT,MIN(NIMA,ITIT+NUMTH-1)
d617 3
a619 3
     &       NUMR,NUMR(1,NRING))
C
	  CALL  ALRQS(X(1,1,K1-ITIT+1),NSAM,NROW,NUMR,
d621 10
a630 11
	  CALL  FRNGS(BFC(1,K1),LCIRC,NUMR,NRING)
	  CALL  APPLYWS(BFC(1,K1),LCIRC,NUMR,WR,NRING,MAXRIN)
C
	ENDDO
	 ENDDO
C
         DO  ITIT=1,NIDI,NUMTH
	  DO  ITI=ITIT,MIN(NIDI,ITIT+NUMTH-1)
          CALL  FILGET(FIPROJ,FINPIC,NLEP,ILIP(ITI),INTFLAG)
	  MAXIM = 0
	  CALL OPFILE(.FALSE.,FINPIC,INPIC,'O',IFORM,
d632 12
a643 14
          IF(IRTFLG.NE.0)  THEN
           WRITE(NOUT,2032)  FINPIC
           RETURN
          ENDIF
          DO    K2=LR1,LR2
           CALL  REDLIN(INPIC,BUFIN,LSAM,K2)
            DO    K3=LS1,LS2
             X(K3-LS1+1,K2-LR1+1,ITI-ITIT+1)=BUFIN(K3)
	    ENDDO
    	  ENDDO
	  CLOSE(INPIC)
	 ENDDO
C
C  Normalize under the mask
d645 19
a663 4
	  DO  ITI=ITIT,MIN(NIDI,ITIT+NUMTH-1)
	CALL  DSGR2D(X(1,1,ITI-ITIT+1),NSAM,NROW,NUMR,NRING,MODE,MAXRIN,
     &    BFC,LCIRC,NIMA,TT,SA,TA(1,ITI),RANGE,
     &	  DLIST(2,ITI-ITIT+1),DLIST(3,ITI-ITIT+1),DLIST(4,ITI-ITIT+1))
d665 27
a691 26
C .....................................................................
C          DLIST(2)=IDI
C          DLIST(3)=EAV
C          DLIST(4)=ANGMOR(RANG,MODE)
C DLIST 5&6 are permanently set to zero (this is to keep same format as
C  AP MQ command)
 	  DO  ITI=ITIT,MIN(NIDI,ITIT+NUMTH-1)
           DLIST(1,ITI-ITIT+1)=ITI
	   IF(DLIST(2,ITI-ITIT+1).GT.0.0)  DLIST(2,ITI-ITIT+1)=
     &		ILIST(INT(DLIST(2,ITI-ITIT+1)))
           DLIST(7,ITI-ITIT+1)=ILIP(ITI)
           CALL  SAVD(NDOC,DLIST(1,ITI-ITIT+1),NLIST,IRTFLG)
	  ENDDO
	 ENDDO
         CALL  SAVDC
         CLOSE(NDOC)
	 DEALLOCATE(BFC)
	ELSE
	   SUCCESS=.FALSE.
	ENDIF
	 DEALLOCATE(TA)
	 DEALLOCATE(SA)
	 DEALLOCATE(X)
	 DEALLOCATE(DLIST)
	 DEALLOCATE(TT)
         END
d693 2
d698 2
a699 1
	CHARACTER*1  MODE
d701 1
a701 1
         INTEGER  NUMR(3,NRING)
d703 1
a703 1
	REAL, ALLOCATABLE, DIMENSION(:) ::  CIROLD
d705 14
a718 14
	ALLOCATE(CIROLD(LCIRC),STAT=IRTFLG)
	IF(IRTFLG.NE.0) CALL  ERRT(46,'AP RN, CIRCOLD',IER)
	ALLOCATE(LCG(NIMA),STAT=IRTFLG)
	IF(IRTFLG.NE.0) CALL  ERRT(46,'AP RN, LCG',IER)
C
C Determine which ones are to be compared
	NIMALCG=0
        DO   IMI=1,NIMA
C ABS - directions at 180 degrees are different (- do not check mirrored)
        DT=TA(1)*SA(1,IMI)+TA(2)*SA(2,IMI)+TA(3)*SA(3,IMI)
	 IF(DT.GE.RANGE)  THEN
	  NIMALCG=NIMALCG+1
	  LCG(NIMALCG)=IMI
	 ENDIF
d720 25
a744 25
	IF(NIMALCG.GT.0) THEN
	CALL NORMASS(X,-NSAM/2,NSAM/2,-NROW/2,NROW/2,
     &      NUMR,NUMR(1,NRING))
	CALL  ALRQS(X,NSAM,NROW,NUMR,CIROLD,LCIRC,NRING,MODE)
	CALL  FRNGS(CIROLD,LCIRC,NUMR,NRING)
        EAV=-1.0D20
        DO   IMIL=1,NIMALCG
	 IMI=LCG(IMIL)
	  CALL  CROSRNG_DS
     &		(BFC(1,IMI),CIROLD,LCIRC,NRING,
     &	   MAXRIN,NUMR,TOTMIN,TOT,TT)
          IF(TOTMIN.GE.EAV)  THEN
           EAV=TOTMIN
           IDI=IMI
           RANG=TOT
	  ENDIF
	ENDDO
C
	 IF(MODE.EQ.'F')  THEN
          RANG=(RANG-1.0)/MAXRIN*360.0
         ELSE
          RANG=(RANG-1.0)/MAXRIN*180.0
	 ENDIF
	 DLIST2=IDI
	 DLIST3=EAV
d746 3
a748 3
         RANG=0.0
	 DLIST2=0.0
	 DLIST3=-1.0
d750 1
d753 1
@


1.21
log
@*** empty log message ***
@
text
@d38 1
a38 1
         SUBROUTINE DSGR
d93 1
a93 1
         MODE='F'
d226 6
d443 1
a443 1
          RANG=(RANG-1)/MAXRIN*360.0
d512 1
d718 5
a722 1
         RANG=(RANG-1)/MAXRIN*360.0
@


1.20
log
@no message for small 1st ring
@
text
@d34 1
a34 1
C     FUNCTION  LOG2_P(N)
@


1.19
log
@used setthreads
@
text
@d84 1
a84 5
	IF(MR.LT.5)  WRITE(NOUT,7021)  MR
7021	FORMAT(' Small value of the first ring given (',I1,') may'
     &	' result in numerical errors',/,
     & ' Please verify the results or increase FIRST RING value to 5')
C
@


1.18
log
@associated --> allocated
@
text
@d275 1
a275 1
C
d277 1
a277 1
	IF(.NOT.IN_CORE) call  omp_set_num_threads(2)
d432 5
a436 5
           IF(TOTMIN(IMI).GE.EAV)  THEN
            EAV=TOTMIN(IMI)
            IDI=ILIST(IMI)
            RANG=TOT(IMI)
	   ENDIF
d458 1
d460 1
a460 1
	IF(.NOT.IN_CORE) call  omp_set_num_threads(NUMTH)
d462 1
a462 1
C     close(nscf,dispose='delete')
@


1.17
log
@added assciated to gwp changes
@
text
@d255 1
a255 1
          IF (ASSOCIATED(BFC)) DEALLOCATE(BFC)
@


1.16
log
@DEALLOCATE ADDED BY GWP
@
text
@d253 3
a255 3
	IF(IRTFLG.NE.0) THEN
C         GWP - I have to fix the allocation here
          DEALLOCATE(BFC)
d257 3
a259 3
	  IF(IRTFLG.NE.0) THEN
	   CALL  ERRT(46,'AP RN, BFC',IER)
	   RETURN
d261 1
a261 1
	   IN_CORE=.FALSE.
d264 1
a264 1
	 IN_CORE=.TRUE.
d266 1
a266 1
C
@


1.15
log
@Used getthreads & cosmetic
@
text
@d254 2
@


1.14
log
@ # continue char fails on NT f90
@
text
@d1 1
d16 1
a16 1
C   DSGR                                 10/21/99
d21 2
a22 2
C  Restricted angular search range.
C  Do not check mirrored orientations..
d51 1
a51 1
C
d53 3
a55 3
C
C  ASK FOR DATA FILE
C
d57 1
a57 1
     &   'ENTER TEMPLATE FOR 2-D REFERENCE PROJECTIONS NAME',IRTFLG)
d59 2
a60 1
C  NIMA - total number of images
d62 2
a63 2
          WRITE(NOUT,2001) NIMA
2001      FORMAT('  Number of images =',I5)
d65 2
a66 2
          WRITE(NOUT,*)  '  No images !'
          RETURN
d68 1
a68 1
C
d73 2
a74 4
         IF(IRTFLG.NE.0)  THEN
          CALL ERRT(4,'AP RN ',NE)
          RETURN
         ENDIF
d76 1
a76 1
C
d78 1
a78 1
C
d80 2
a81 2
	 CALL ERRT(31,'AP RN',NE)
	 RETURN
d83 1
d108 2
a109 2
     &	'SCRATCH FILE EXISTS (Y/N/W)?',NULL,IRT)
C
d112 1
a112 1
          NRING=NRING+1
d114 2
a115 2
	ALLOCATE(NUMR(3,NRING),STAT=IRTFLG)
	IF(IRTFLG.NE.0) CALL ERRT(46,'AP RN, NUMR',IER)
d132 1
a132 1
C
d134 2
a135 2
C
C  images to be aligned
d138 2
a139 1
	IF(IRTFLG.NE.0) RETURN
d141 9
a149 16
     &		'Experimental projections angles document',IRTFLG)
	 CALL  RDPRM(RANGE,NLOOP,ILOOP,'Range of angular search')
C  NIDI - number of images to check distances
C
#ifdef SP_MP
c$omp parallel private(np)
	np = OMP_GET_NUM_THREADS()
c$omp single
	NUMTH=np
c$omp end single
c$omp end parallel
#else
	NUMTH=1
#endif
	IF(NUMTH.GT.1.AND.NIDI.GT.NUMTH.AND.ASK.EQ.'N')  THEN
         CALL  DSGR_PM(ILIST,NIMA,ILIP,NIDI,
d154 1
a154 1
	 SUCCESS=.FALSE.
d156 2
a157 1
	IF(.NOT.SUCCESS) 
d167 3
a169 2
2600     FORMAT (/ ' ',80('-')//' ',
     &          'END OF COMPUTATION',//' ',80('-')/)
d171 2
d175 1
a175 1
C $$ DSGR_P.FOR
a186 3
C
C
C23456789012345678901234567890123456789012345678901234567890123456789012
d193 1
d210 1
a210 1
C
a211 1
	INTEGER  OMP_GET_NUM_THREADS
d214 1
a214 1
C
d490 1
a490 2
C
	INTEGER  OMP_GET_NUM_THREADS
d601 1
a601 1
C
d603 1
a603 1
C
@


1.13
log
@negative mirror
@
text
@d3 1
a3 1
C $$ DSGR.FOR
a14 5
C23456789012345678901234567890123456789012345678901234567890123456789012
C--************************************************************************

         SUBROUTINE DSGR

a22 1
C
d35 5
a39 1
	PARAMETER  (NILMAX=99998)
d122 1
a122 1
C 2*(# of rings)+(0'th element)+2*(margin of 1)
d172 1
a172 1
     #          'END OF COMPUTATION',//' ',80('-')/)
@


1.12
log
@*** empty log message ***
@
text
@d20 1
a20 1
C   DSGR                                 10/30/98
a27 7
C    WHEN IN THE OUTPUT DOCUMENT FILE N POINTS TO I+NIMA,
C    WHERE NIMA IS NUMBER OF REFERENCE PROJECTIONS,
C    THEN THE REFERENCE PROJECTION HAS TO BE MIRRORED
C    AND ITS EULERIAN ANGLES MODIFIED AS FOLLOWS:
C    I      :      THETA       PHI
C    I+NIMA :     180-THETA  180+PHI
C    AND PSI FROM THE OUTPUT DOCUMENT FILE  ->  180+PSI.
a282 2
c find max element on  ILIST
	MAXIMA=MAXVAL(ILIST)
d451 1
a451 1
          DLIST(2)=-1.0
a543 3

c find max element on  ILIST
	MAXIMA=MAXVAL(ILIST)
d647 1
a647 1
     &    BFC,LCIRC,NIMA,MAXIMA,TT,SA,TA(1,ITI),RANGE,
d676 1
a676 3



d678 1
a678 1
     &		BFC,LCIRC,NIMA,MAXIMA,TT,SA,TA,RANGE,
d724 1
a724 1
	 DLIST2=-1.0
@


1.11
log
@psi changed
@
text
@d353 1
a353 1
	 ENDDO
d384 1
a384 1
	CALL  UNSAV(EXPANG,ITI-1,INANG,ILIP(ITI),BUFIN,3,LERR,K2A)
d391 2
a392 1
	CALL  ERRT(100,'Angle for experimental projection not found',NE)
d397 3
a399 3
        TA(1)=COS(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
        TA(2)=SIN(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
        TA(3)=COS(BUFIN(2)*DGR_TO_RAD)
d409 1
a409 1
        DT=TA(1)*SA(1,IMI)+TA(2)*SA(2,IMI)+TA(3)*SA(3,IMI)
d425 1
a425 1
     &	MAXRIN,NUMR,TOTMIN(IMI),TOT(IMI),TT)
d447 1
a447 1
            IDI=IMI
d670 2
d733 3
a735 3
        RANG=(RANG-1)/MAXRIN*360.0
	DLIST2=IDI
	DLIST3=EAV
d737 3
a739 3
        RANG=0.0
	DLIST2=-1.0
	DLIST3=-1.0
@


1.10
log
@F90 version
@
text
@a453 1
          IF(RANG.GT.0.0)  RANG=360.0-RANG
a730 1
        IF(RANG.GT.0.0)  RANG=360.0-RANG
@


1.9
log
@*** empty log message ***
@
text
@d18 1
a18 1
         SUBROUTINE DSGR(MAXMEM)
d20 1
a20 1
C   DSFR                                 10/31/98
d25 1
a25 1
C  Restricted angular search range
d37 1
a37 1
C     SUBROUTINE  DSGR_S(BUF,ILIST,NILMAX,ILIP,NIPMAX,NIDI,
d41 1
a41 2
C     SUBROUTINE  CROSRNG
C     SUBROUTINE  CROSRMG
a45 1
C     FUNCTION  ANGMR(RKK,MODE)
d47 3
a49 16

	PARAMETER  (NILMAX=21000,NIPMAX=99998)
	PARAMETER  (MNUMR=480)
        INTEGER    NUMR(3,MNUMR)
	INCLUDE 'CMBLOCK.INC'
#ifdef SP_F90
        INCLUDE 'F90ALLOC.INC'
        REAL, DIMENSION(:), POINTER :: IPQ
        REAL, DIMENSION(:), POINTER :: BFC

#else
         DIMENSION BFC(1)
         POINTER   (IPQ,BFC) 
#endif
         LOGICAL         RUNTIME
         COMMON  DUMMY(80),BUF(1024),ILIST(NILMAX),ILIP(NIPMAX),Q(1)
d54 3
a56 2
         LOGICAL  IN_CORE
         EQUIVALENCE  (Q,NUMR)
d59 3
a61 1

d64 1
a64 2
         NMAX=NILMAX
         CALL  FILSEQP(FINPAT,NLET,ILIST,NMAX,NIMA,
d66 1
d68 8
a75 1

d77 6
a82 4
         CALL  OPENFB(BUF,FINPIC,INPIC,NSAM,NROW,'O',NF,NSL)
         IF (NF.NE.2)  THEN
            WRITE(NOUT,*)  ' FILE NOT FOUND'
            RETURN
d85 1
d89 2
a90 2
	CALL ERRT(31,'OR 2',NE)
	RETURN
d101 1
a114 1
         JACUP=0
d120 8
a127 2
         NRING=NRING+1
         NUMR(1,NRING)=I
d129 1
a129 1

d139 6
a144 2
         NMAX=NIPMAX
         CALL  FILSEQP(FIPROJ,NLEP,ILIP,NMAX,NIDI,
d146 1
a151 29
C
C   memory division
C     NUMR        1
C     CIRC        2
C A: X                 3
C    BUFIN             4
C    WORK              5
C          B:
C             CIROLD   4
C             TEMP     6
C             TOTMIN   61
C             TOT      63
C             TT       65
C             WR       66
C             K_SA
C             BFC      7
C
         MAXRIN=NUMR(3,NRING)
         K1=1
         K2=IPALIGN64(K1+3*NRING)
         K7=IPALIGN64(K2+LCIRC)
         K3A=K7
         K41A=IPALIGN64(K3A+NSAM*NROW)
         K4A=IPALIGN64(K41A+LSAM)
         K5A=K4A
         K3B=K5A
         K4B=K3B
         K5B=IPALIGN64(K4B+LCIRC)
         K6B=K5B
d153 6
a158 1
        K61=K6B
d160 1
a160 3
C  have to add 2 due to libfft
C  have to add 2 due to libfft
        K61=IPALIGN64(K6B+(MAXRIN+2)*4)
d162 39
d202 41
a242 4
         K62=IPALIGN64(K61+2*NIMA)
         K63=IPALIGN64(K62)
         K64=IPALIGN64(K63+NIMA)
         K65=IPALIGN64(K64)
d244 3
a246 1
         K66=IPALIGN64(K65+(LCIRC+15)*2)
d248 41
a288 1
         K66=K65
d290 183
a472 9
	K_SA=IPALIGN64(K66+NRING)
         K_LCG=IPALIGN64(K_SA+3*NIMA)
         K7B=IPALIGN64(K_LCG+NIMA)
        MEMTOT=NILMAX+1200+80+NIPMAX+MAX0(K5A,K7B)
	MEMBUF=LCIRC*NIMA
        CALL ALLOCIT(MEMBUF,RUNTIME,IPQ,'DSFS',IRTFLG)
	IF(MEMTOT.LE.MAXMEM.AND.RUNTIME)  THEN
#ifdef SP_F90
         BFC = >IPQ
d474 46
d521 9
a529 8
            WRITE (NOUT,2500)  MAXMEM , MEMTOT
2500        FORMAT (/,'  Alignment of projections, in-core version.',
     #              /,'  Memory: available ',I8,',  required ',I8,/)
            IN_CORE=.TRUE.
        ELSE
            IF(MEMTOT .LE. MAXMEM)  THEN
#ifdef SP_F90
            BFC = >IPQ
d531 40
a570 9
               WRITE (NOUT,2501)  MAXMEM , MEMTOT
2501           FORMAT (/,
     #'  Alignment of projections, on-disk version (scratch.file used).'
     #   ,/,'  Memory: available ',I8,',  required ',I8,/)
              IN_CORE=.FALSE.
            ELSE
               IF (RUNTIME) CALL ALLOCIT(0,RUNTIME,IPQ,'AP RN',IRTFLG)
               CALL  ERRT(45,'AP RN',NE)
               RETURN
d572 30
a601 1
        ENDIF
d603 82
a684 11
         CALL  DSGR_S(BUF,ILIST,NILMAX,ILIP,NIPMAX,NIDI,
     &      NSAM,NROW,LSAM,LROW,NIMA,
     &      NRING,LCIRC,MAXRIN,JACUP,NUMR,RANGE,
     &      Q(K2),Q(K3A),Q(K41A),Q(K4B),Q(K_SA),Q(K_LCG),
     &      Q(K6B),Q(K61),Q(K63),Q(K65),Q(K66),
     &          BFC(1),
     &   MODE,ASK,IN_CORE,NOUT,REFANG,EXPANG)
        IF(RUNTIME) CALL ALLOCIT(0,RUNTIME,IPQ,'AP RN',IRTFLG)
         WRITE (NOUT,2600)
2600     FORMAT (/ ' ',80('-')//' ',
     #          'END OF COMPUTATION',//' ',80('-')/)
d686 57
@


1.8
log
@*** empty log message ***
@
text
@d50 1
a50 1
         PARAMETER  (NILMAX=21000,NIPMAX=99998)
d53 1
a53 1
         INCLUDE 'CMBLOCK.INC'
d89 10
@


1.7
log
@*** empty log message ***
@
text
@d216 1
a216 1
     &          BFC,
@


1.6
log
@*** empty log message ***
@
text
@a53 1
#ifdef SP_ALLOC
a63 1
#endif
a71 1
CNO_SAVE
a181 1
#ifdef SP_ALLOC
a188 5
#else
        K8B=IPALIGN64(K7B+LCIRC*NIMA)
        MEMTOT=NILMAX+1200+80+NIPMAX+MAX0(K5A,K8B)
        IF (MEMTOT.LE.MAXMEM)  THEN
#endif
d194 2
a195 7
         ELSE
#ifdef SP_ALLOC
            K8B=K8B-LCIRC*NIMA
            MEMTOT=NILMAX+1200+80+NIPMAX+MAX0(K5A,K8B)
#endif
            IF (MEMTOT .LE. MAXMEM)  THEN
#ifdef SP_ALLOC
a198 1
#endif
d205 2
a206 4
#ifdef SP_ALLOC
               IF (RUNTIME) CALL ALLOCIT(0,RUNTIME,IPQ,'DSFS',IRTFLG)
#endif
               WRITE(NOUT,*)  '  Sorry, not enough memory !'
d208 2
a209 2
           ENDIF
         ENDIF
a215 1
#ifdef SP_ALLOC
a216 3
#else
     &          Q(K7B),
#endif
a217 1
#ifdef SP_ALLOC
a218 1
#endif
@


1.5
log
@ff
@
text
@d51 2
a69 1
         INTEGER  NUMR(3,480)
@


1.4
log
@99998
@
text
@d67 2
a68 2
         INTEGER*2  MAXRIN
         INTEGER*2  NUMR(3,480)
d154 1
a154 1
         K2=IPALIGN64(K1+(3*NRING+1)/2)
@


1.3
log
@buffer 99999
@
text
@d50 1
a50 1
         PARAMETER  (NILMAX=21000,NIPMAX=99999)
d185 1
a185 1
        MEMTOT=NILMAX+1200+MAX0(K5A,K7B)
d194 1
a194 1
        MEMTOT=NILMAX+1200+MAX0(K5A,K8B)
d205 1
a205 1
            MEMTOT=NILMAX+1200+MAX0(K5A,K8B)
@


1.2
log
@TEMP fixed
@
text
@d50 1
a50 1
         PARAMETER  (NILMAX=21000,NIPMAX=20000)
@


1.1
log
@Initial revision
@
text
@d167 3
a169 1
        K61=IPALIGN64(K6B+MAXRIN*4)
@
