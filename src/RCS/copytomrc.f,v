head	1.49;
access;
symbols
	pre_mrcs:1.42
	healthdept_2018:1.42
	pre_getangas:1.20
	GPL2010:1.20
	pre_GPL2010:1.19
	pre_var_equation:1.19
	pre_fftwrings:1.14
	pre_opfiles:1.14
	src:1.14
	best-code:1.14
	x-named-regs:1.13
	x:1.13
	v13-00:1.13
	pre_GPL:1.12
	prec_CA:1.12
	noindx:1.6;
locks; strict;
comment	@c @;


1.49
date	2025.11.10.22.33.58;	author dean;	state Exp;
branches;
next	1.48;

1.48
date	2025.10.25.15.34.03;	author dean;	state Exp;
branches;
next	1.47;

1.47
date	2025.10.20.13.51.27;	author dean;	state Exp;
branches;
next	1.46;

1.46
date	2020.01.09.17.59.57;	author leith;	state Exp;
branches;
next	1.45;

1.45
date	2019.12.31.20.02.02;	author leith;	state Exp;
branches;
next	1.44;

1.44
date	2019.11.14.18.49.29;	author leith;	state Exp;
branches;
next	1.43;

1.43
date	2019.11.04.17.35.58;	author leith;	state Exp;
branches;
next	1.42;

1.42
date	2018.10.03.14.34.03;	author leith;	state Exp;
branches;
next	1.41;

1.41
date	2018.01.26.17.06.42;	author leith;	state Exp;
branches;
next	1.40;

1.40
date	2018.01.25.14.42.26;	author leith;	state Exp;
branches;
next	1.39;

1.39
date	2018.01.25.14.40.57;	author leith;	state Exp;
branches;
next	1.38;

1.38
date	2016.09.21.18.01.37;	author leith;	state Exp;
branches;
next	1.37;

1.37
date	2016.09.14.17.54.50;	author leith;	state Exp;
branches;
next	1.36;

1.36
date	2016.09.13.18.31.43;	author leith;	state Exp;
branches;
next	1.35;

1.35
date	2016.07.25.17.22.43;	author leith;	state Exp;
branches;
next	1.34;

1.34
date	2016.06.13.15.46.53;	author leith;	state Exp;
branches;
next	1.33;

1.33
date	2016.01.22.14.52.57;	author leith;	state Exp;
branches;
next	1.32;

1.32
date	2015.07.15.14.41.08;	author leith;	state Exp;
branches;
next	1.31;

1.31
date	2015.07.15.14.12.01;	author leith;	state Exp;
branches;
next	1.30;

1.30
date	2015.01.21.16.38.32;	author leith;	state Exp;
branches;
next	1.29;

1.29
date	2014.09.15.15.37.33;	author leith;	state Exp;
branches;
next	1.28;

1.28
date	2013.08.01.12.33.42;	author leith;	state Exp;
branches;
next	1.27;

1.27
date	2013.08.01.12.30.25;	author leith;	state Exp;
branches;
next	1.26;

1.26
date	2013.07.31.18.07.54;	author leith;	state Exp;
branches;
next	1.25;

1.25
date	2013.03.21.17.44.03;	author leith;	state Exp;
branches;
next	1.24;

1.24
date	2013.03.12.12.49.53;	author leith;	state Exp;
branches;
next	1.23;

1.23
date	2013.03.05.18.46.23;	author leith;	state Exp;
branches;
next	1.22;

1.22
date	2012.05.21.16.38.59;	author leith;	state Exp;
branches;
next	1.21;

1.21
date	2012.05.17.14.48.30;	author leith;	state Exp;
branches;
next	1.20;

1.20
date	2010.06.24.13.25.18;	author leith;	state Exp;
branches;
next	1.19;

1.19
date	2009.01.22.13.29.07;	author leith;	state Exp;
branches;
next	1.18;

1.18
date	2009.01.05.16.28.04;	author leith;	state Exp;
branches;
next	1.17;

1.17
date	2008.12.19.15.19.39;	author leith;	state Exp;
branches;
next	1.16;

1.16
date	2008.09.26.12.33.05;	author leith;	state Exp;
branches;
next	1.15;

1.15
date	2008.09.26.12.29.08;	author leith;	state Exp;
branches;
next	1.14;

1.14
date	2006.01.09.16.14.10;	author leith;	state Exp;
branches;
next	1.13;

1.13
date	2005.10.17.20.59.58;	author leith;	state Exp;
branches;
next	1.12;

1.12
date	2003.09.22.18.38.02;	author leith;	state Exp;
branches;
next	1.11;

1.11
date	2003.04.11.16.15.14;	author leith;	state Exp;
branches;
next	1.10;

1.10
date	2003.03.04.16.05.07;	author leith;	state Exp;
branches;
next	1.9;

1.9
date	2003.03.04.15.47.53;	author leith;	state Exp;
branches;
next	1.8;

1.8
date	2003.03.03.16.57.36;	author leith;	state Exp;
branches;
next	1.7;

1.7
date	2003.02.20.21.41.09;	author leith;	state Exp;
branches;
next	1.6;

1.6
date	2002.07.18.13.49.18;	author leith;	state Exp;
branches;
next	1.5;

1.5
date	2002.07.15.20.32.51;	author leith;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.29.19.53.13;	author leith;	state Exp;
branches;
next	1.3;

1.3
date	2002.03.11.14.08.56;	author leith;	state Exp;
branches;
next	1.2;

1.2
date	2002.03.04.19.01.45;	author leith;	state Exp;
branches;
next	1.1;

1.1
date	2002.02.22.18.06.32;	author leith;	state Exp;
branches;
next	;


desc
@@


1.49
log
@*** empty log message ***
@
text
@
C ++********************************************************************
C
C COPYTOMRC    MODIFIED FROM COPYMRC               FEB 02 ArDean Leith  
C              ISSWAB ADDED                        JUL 02 ArDean Leith
C              FLIP QUESTION                       MAR 03 ArDean Leith
C              BAD IRECMRC4 & FLIP                 SEP 03 ArDean Leith
C              SCALING                             JAN 05 ArDean Leith
C              I*8                                 SEP 08 ArDean Leith
C              NPIX8                               DEC 08 ArDean Leith
C              BOTLEFT OPTION                      MAY 12 ArDean Leith
C              STREAM IO                           FEB 13 ArDean Leith
C              VOL BUG                             JUN 13 ArDean Leith
C              VOL BUG FIXED                       JUL 13 ArDean Leith
C              MODE 6 STACK SUPPORT                SEP 14 ArDean Leith
C              IPOSMRC INTEGER *8                  JAN 15 ArDean Leith
C              BOTLEFT DEFAULT                     JUL 15 ArDean Leith
C              2015 STACK SUPPORT                  JUL 15 ArDean Leith
C              COPYTOMRC_STK ADDED, STACK BUGGY    JUN 16 ArDean Leith
C              BOTLEFT OPTION REINTRODUCED         SEP 16 ArDean Leith
C              CREATES LITTLE ENDED FILES ONLY     JAN 18 ArDean Leith
C              GETLAB PARAMETERS                   NOV 19 ArDean Leith
C              REWRITE                             DEC 19 ArDean Leith
C              FIXED STACKS                        OCT 25 ArDean Leith
C
C **********************************************************************
C=*                                                                    *
C=* This file is part of:   SPIDER - Modular Image Processing System.  *
C=* SPIDER System Authors:  Joachim Frank & ArDean Leith               *
C=* Copyright 1985-2025  Health Research Inc.,                         *
C=* Riverview Center, 150 Broadway, Suite 560, Menands, NY 12204.      *
C=* Email:                                                             *
C=*                                                                    *
C=* SPIDER is free software; you can redistribute it and/or            *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* SPIDER is distributed in the hope that it will be useful,          *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* merchantability or fitness for a particular purpose.  See the GNU  *
C=* General Public License for more details.                           *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program. If not, see <http://www.gnu.org/licenses> *
C=*                                                                    *
C **********************************************************************
C 
C COPYTOMRC    (LUNSPI,LUNMRC,NX,NY,NZ)
C COPYTOMRC_STK(LUNSPI,LUNMRC,NX,NY,NZ)    !!! NEVER USED
C                                                                    
C PURPOSE: COPY FROM SPIDER TO MRC FILE FORMAT
C
C NOTES: DATA IN MRC FILE
C        MODE   TYPES OF PIXELS IN IMAGE
C               0 : INTEGER*1 (UNSIGNED BYTES) 
C               1 : INTEGER*2 (SIGNED) 
C               2 : REALS
C               6 : INTEGER*2 (UNSIGNED)
C
C  CALL TREE:
C  IF ('CP....')   
C     |
C  COPY1
C     |
C  IF ('CP TO MRC')    SPIDER FILE(S) TO MRC IMAGE(S) OR VOLUME(S)
C     |
C  COPYTOMRC
C     |
C     OPEN FIRST SPIDER INPUT FILE
C     OPFILES(0,LUNSPI,LUNDOC,LUNXM1,  
C     &       .TRUE.,FILNAM1,NLET1, 'E',
C     &       IFORM1,NX1,NY1,NZ1,NSTACK1,
C     &       'SPIDER INPUT FILE NAME OR TEMPLATE (e.g. SPI_STK@@*)~~9'
C     &       TRUE., ILIST1,NILMAX, 
C     &       NOT_USED,NGOT1,IMG1, IRTFLG) 
C     |
C     FILERD (FILNAM2,NLET2,NULL,  
C     &       'MRC OUTPUT FILE NAME OR TEMPLATE (e.g. MRC_STK@@*.mrc)~'
C     &       IRTFLG)
C     OPEN FIRST MRC OUTPUT FILE 
C     OPFILES(LUNSPI,LUNMRC,LUNDOC,LUNXM2, 
C     &       .FALSE.,FILNAM2,NLET2,DISP,
C     &       IFORM1,NX1,NY1,NZ1,NSTACK2,
C     &       FILNAM2,
C     &       .TRUE., ILIST2,NILMAX, 
C     &       NOT_USED,NGOT2,IMG2, IRTFLG) 
C       |
C     LOOP
C       REDLIN
C        |
C       WRTLIN
C        |
C       OPEN NEXT SPIDER INPUT & MRC OUTPUT FILES
C        |
C       NEXTFILES(NINDX1,NINDX2,  ILIST1,ILIST2,   
C               .FALSE., LUNXM1,LUNXM2,
C               NGOT1,NGOT2,    NSTACK1,NSTACK2,  
C               LUNSPI,LUNSPI,LUNMRC, FILNAM1,FILNAM2,
C               IMG1,IMG2, IRTFLG)
C        |
C     END LOOP
C23456789012345678901234567890123456789012345678901234567890123456789012
C***********************************************************************

      SUBROUTINE COPYTOMRC(LUNSPI,LUNMRC,
     &                     LUNDOC,LUNXM1,LUNXM2,IRTFLG)

      IMPLICIT NONE

      INCLUDE 'CMBLOCK.INC'
      INCLUDE 'CMLIMIT.INC'

      INTEGER                  :: IERR
      COMMON /IOERR/ IERR

      INTEGER                  :: BUF
      COMMON /IOBUF/ BUF(NBUFSIZ)

      INTEGER                  :: LUNSPI,LUNMRC,LUNDOC,LUNXM1,LUNXM2
      INTEGER                  :: IRTFLG

      INTEGER *2               :: I2MAX,I2VAL
      INTEGER *4               :: I4VAL
      INTEGER                  :: NC,MRCMODE,IGO,IEND,IDUM
      INTEGER                  :: NINDX1,NINDX2
      REAL                     :: FN,FNCON,FMINT,FMAXT,FAVT,FSIGT
      REAL                     :: SCALEX,SCALEY,SCALEZ

      INTEGER,ALLOCATABLE      :: ILIST1(:),ILIST2(:)

      CHARACTER (LEN=MAXNAM)   :: PROMPT 
      CHARACTER (LEN=MAXNAM)   :: FILNAM1,FILNAM2,MRCFILE
      CHARACTER (LEN=2*MAXNAM) :: COMMAN
      LOGICAL                  :: VERBOSE_SAVE,IS_MRC,IS_BARE
      CHARACTER (LEN=1)        :: NULL = CHAR(0)
      CHARACTER (LEN=1)        :: DISP
      CHARACTER (LEN=4)        :: CAXIS,CSTR
      INTEGER                  :: ICOMM,MYPID,MPIERR
      INTEGER                  :: IFORM1,NX1,NY1,NZ1,NSTACK1,NSTACK2
      INTEGER                  :: NGOT1,NGOT2,IMG1,IMG2,NILMAX,IVAL
      INTEGER                  :: MAXIM1,MAXIM2,NLET1,NLET2
      INTEGER                  :: LENT,NOT_USED,IRECIN

      INTEGER                  :: lnblnkn      ! FUNCTION
        
      CALL SET_MPI(ICOMM,MYPID,MPIERR) ! SETS ICOMM AND MYPID

      VERBOSE_SAVE = VERBOSE           ! SAVE CURRENT VERBOSITY

      NILMAX  = NIMAX             ! FROM CMLIMIT
      ALLOCATE(ILIST1(NIMAX),
     &         ILIST2(NIMAX),
     &         STAT=IRTFLG)
      IF (IRTFLG .NE. 0) THEN
         CALL ERRT(46,'COPYTOMRC; ILIST...',2*NIMAX)
         RETURN
      ENDIF

C     OPEN FIRST INPUT FILE, DISP = 'E' DOES NOT STOP ON ERROR
      MAXIM1 = 0
      IMG1   = 0
      PROMPT =
     &     'SPIDER INPUT FILE NAME OR TEMPLATE (e.g. SPI_STK@@*)~~9'
      CALL OPFILES(0,LUNSPI,LUNDOC,LUNXM1,  
     &               .TRUE.,FILNAM1,NLET1, 'O',
     &               IFORM1,NX1,NY1,NZ1,NSTACK1,
     &               PROMPT,
     &              .TRUE., ILIST1,NILMAX, 
     &               NOT_USED,NGOT1,IMG1, IRTFLG) 


#if defined(SP_DBUGIO)
      write(3,*)' ------- RETURNED TO: COPYTOMRC --------'
      write(3,*)' In copytomrc; nx1,ny1,nz1: ',nx1,ny1,nz1
      write(3,*)' '

#endif

      CALL LUNGETIS_MRC(LUNSPI,IS_MRC,IRTFLG)      
      CALL LUNGETISBARE(LUNSPI,IS_BARE,IRTFLG)

      IF (IS_MRC) THEN
         CALL ERRT(101,'OPERATION DOES NOT READ MRC FILES',IDUM)
         GOTO 999
      ENDIF

#if defined(SP_DBUGIO)
      !write(3,'(A,4i6)')' In nstack1; ngot1,img1:',nstack1,ngot1,img1
#endif


C     FIND HEADER VALUES FOR THE MRC FILE

      WRITE(NOUT,*) ' MRC DATA MODE 0:  8-BIT SIGNED INT, ',
     &              ' 1: 16-BIT SIGNED INT  '
      WRITE(NOUT,*)  '               2: 32-BIT REAL,       ',
     &              ' 6: 16-BIT UNSIGNED INT'

      MRCMODE = 2
      CALL RDPRI1S(MRCMODE,NOT_USED,'MRC MODE (0/1/2/6)',IRTFLG)
      IF (IRTFLG .NE. 0) GOTO 999

C     LEGACY INPUT TRAP
      IF (MRCMODE ==  8) MRCMODE = 0   !  8 BIT UNSIGNED INT
      IF (MRCMODE == 16) MRCMODE = 6   ! 16 BIT UNSIGNED INT
      IF (MRCMODE == 32) MRCMODE = 2   ! 32 BIT FLOATING POINT

       WRITE(NOUT,*) ' MRC DATA ORIGIN     UL: UPPER LEFT, ',
     &              ' LL: LOWER LEFT  '
      IF (NZ1 > 1) THEN
         WRITE(NOUT,*) ' MRC HANDEDNESS  L: LEFT, ','        R:  RIGHT '
      ENDIF

      CAXIS = 'UL  '        ! DEFAULT

      IF (NZ1 <= 1) THEN
         CALL RDPRMC(CSTR,NC,.TRUE.,'MRC DATA ORIGIN (UL/LL)',
     &               NULL,IRTFLG)
         IF (IRTFLG .NE. 0)  RETURN

         IF (CSTR(1:NC) == 'LL')  CAXIS(1:2) = 'LL'
 
      ELSE
C        VOLUME OUTPUT
         CALL RDPRMC(CSTR,NC,.TRUE.,  
     &          'DATA ORIGIN (UL/LL) & HANDEDNESS (L/R)',NULL,IRTFLG)
         IF (IRTFLG .NE. 0)  RETURN

C        GET FIRST TOKEN (CHAR. STRING DELIMITED BY A ", ( ) ] -")
         CALL GETNEXTTOKEN_N(CSTR,NC,1,IGO,IEND)
         IF (IGO <= 0) THEN
            CALL ERRT(101,'INVALID INPUT',IDUM)
            GOTO 999
         ENDIF

         IF (CSTR(IGO:IGO+1) == 'LL') CAXIS(1:2) = 'LL'

         IF (CAXIS(1:2) .NE. 'UL' .AND. CAXIS(1:2) .NE. 'LL')THEN
            CALL ERRT(101,'INVALID ORIGIN',IDUM)
            RETURN
         ENDIF

C        GET SECOND TOKEN (CHAR. STRING DELIMITED BY A ", ( ) ] -")
         CALL GETNEXTTOKEN_N(CSTR,NC,IEND+1,IGO,IEND)
         IF (IGO <= 0) THEN
            CALL ERRT(101,'INVALID INPUT',IDUM)
            GOTO 999
         ENDIF
         CAXIS(4:4) = 'L'

         IF     (CSTR(IGO:IGO) == '0') THEN
            CAXIS(4:4) = 'R' 
         ENDIF 
      
         IF (CAXIS(4:4) .NE. 'L' .AND. CAXIS(4:4) .NE. 'R')THEN
            CALL ERRT(101,'INVALID HANDEDNESS',IDUM)
            RETURN
         ENDIF
      ENDIF

C     FIND HEADER VALUES FOR THE MRC FILE

      IF (MRCMODE == 2 .AND. MAXIM1 < 0) THEN
C        32 BIT FLOATING POINT  IMAGE OR VOLUME (NOT WHOLE STACK)

C        NEED FMIN & FMAX (SIG IN COMMON: MASTER)
         IF (IMAMI .NE. 1) CALL NORM3(LUNSPI,NX1,NY1,NZ1,FMAX,FMIN,AV)

         FMINT = FMIN
         FMAXT = FMAX
         FAVT  = AV
         FSIGT = SIG
C        UNFININISHED HERE !!!!!!!!!!!!!!!!!!!

      ELSEIF (MRCMODE == 0  .AND. MAXIM1 < 0 ) THEN
C        8 BIT SIGNED INTEGER IMAGE OR VOLUME (NOT WHOLE STACK)

C        NEED FMIN & FMAX (SIG IN COMMON: MASTER)
         IF (IMAMI .NE. 1) CALL NORM3(LUNSPI,NX1,NY1,NZ1,FMAX,FMIN,AV)
         IF (FMIN < -128) THEN
            I4VAL = FMIN
            CALL ERRT(102,'POSSIBLE 8 BIT INTEGER UNDERFLOW',I4VAL)
            GOTO 999
         ELSEIF (FMAX > 127) THEN 
            I4VAL = FMAX
            CALL ERRT(102,'POSSIBLE 8 BIT INTEGER OVERFLOW',I4VAL)
            GOTO 999
         ENDIF

      ELSEIF (MRCMODE == 1  .AND. MAXIM1 < 0 ) THEN
C        16 BIT SIGNED INTEGER IMAGE OR VOLUME (NOT WHOLE STACK)

C        NEED FMIN & FMAX (SIG IN COMMON: MASTER)
         IF (IMAMI .NE. 1) CALL NORM3(LUNSPI,NX1,NY1,NZ1,FMAX,FMIN,AV)

         IF (FMIN < -HUGE(I2VAL)) THEN
            I4VAL = FMIN
            CALL ERRT(102,'POSSIBLE 16 BIT INTEGER UNDERFLOW',I4VAL)
            GOTO 999
         ELSEIF (FMAX > HUGE(I2VAL)) THEN 
            I4VAL = FMAX
            CALL ERRT(102,'POSSIBLE 16 BIT INTEGER OVERFLOW',I4VAL)
            GOTO 999
         ENDIF

      ELSEIF (MRCMODE == 6  .AND. MAXIM1 < 0 ) THEN
C        16 BIT UNSIGNED INTEGER (NOT WHOLE STACK)

C        NEED FMIN & FMAX (SIG IN COMMON: MASTER)
         IF (IMAMI .NE. 1) CALL NORM3(LUNSPI,NX1,NY1,NZ1,FMAX,FMIN,AV)

         IF (FMIN < -HUGE(I2VAL)) THEN
            I4VAL = FMIN
            CALL ERRT(102,'POSSIBLE 16 BIT INTEGER UNDERFLOW',I4VAL)
            GOTO 999

         ELSEIF (FMAX > HUGE(I2VAL)) THEN 
            I4VAL = FMAX
            CALL ERRT(102,'POSSIBLE 16 BIT INTEGER OVERFLOW',I4VAL)
            GOTO 999
         ENDIF
      ENDIF


C     TRY TO GET SPIDER IMAGE SCALE VALUE (USUALLY NOT SET)
      CALL GETLAB(LUNSPI,21,1,SCALEX,IRTFLG)

      IF (SCALEX > 0) THEN
           WRITE(NOUT,*) ' PIXEL SIZE (A) FOR ALL AXES IN ',
     &                   ' SPIDER HEADER(21): ',SCALEX
           SCALEY  = SCALEX
           SCALEZ  = SCALEX
      ELSE
C          NOTHING IN SPIDER HEADER?
           SCALEX = 1.0
           SCALEY = 1.0
           SCALEZ = 1.0
      ENDIF

        
      IF (NZ1 > 1) THEN
         CALL RDPRM3S(SCALEX,SCALEY,SCALEZ,NOT_USED,
     &              'PIXEL SIZE (A) FOR X, Y, & Z AXES',IRTFLG)
      ELSE
         CALL RDPRM2S(SCALEX,SCALEY,NOT_USED,
     &              'PIXEL SIZE (A) FOR X &  Y AXES',IRTFLG)
      ENDIF
      IF (IRTFLG .NE. 0) RETURN

      WRITE(NOUT,*) ' ' 
      NSTACK2 =  1   ! UNUSED, NOT SENT
      DISP    = 'N'  ! NEW OUTPUT FILE        

C     OPEN FIRST OUTPUT FILE 
      IMG2   = IMG1         ! DEFAULT
      PROMPT =
     &    'MRC OUTPUT FILE NAME OR TEMPLATE (e.g. *@@file_stk.mrc)~'

      CALL OPFILES(LUNSPI,LUNMRC,LUNDOC,LUNXM2, 
     &              .TRUE.,FILNAM2,NLET2,DISP,
     &              IFORM1,NX1,NY1,NZ1,NSTACK2,
     &              PROMPT,
     &              .FALSE., ILIST2,NILMAX, 
     &              NOT_USED,NGOT2,IMG2, IRTFLG) 

#if defined (SP_DBUGIO)
      write(3,*)' In copytomrc; nx1,ny1,nz1:    ', nx1,ny1,nz1
      write(3,*)' In copytomrc; nstack2,nilmax: ', nstack2,nilmax
      write(3,*)' In copytomrc; ngot2,img2:     ', ngot2,img2
      write(3,*)' '
#endif

      CALL LUNSETMODE_MRC(LUNMRC,MRCMODE,IRTFLG)

      CALL LUNSETHAND_MRC(LUNMRC,CAXIS,IRTFLG)

      CALL LUNSETPIXSIZES_MRC(LUNMRC,SCALEX,SCALEY,SCALEZ,IRTFLG)

      CALL LUNWRTHED_MRC(LUNMRC,IRTFLG)

      CALL LUNSETPOS_MRC(LUNMRC,IMG1,IRTFLG)

C     SETS LUNMRCNBYT(LUN) = NBYT    ! COMMENTED OUT??

C     DO NOT REPORT FILE INFO IF WHOLE STACK
      IF (NSTACK1 > 0 .AND. NSTACK2 >= 0) VERBOSE = .FALSE. 

      NINDX1 = 1
      NINDX2 = 1
      DO                ! LOOP OVER ALL IMAGES or IMAGE STACKS

C        COPY THE DESIRED NUMBER OF DATA RECORDS FROM EACH FILE
         DO IRECIN = 1,NY1*NZ1   ! NUMBER OF RECORDS COPIED

C           READ EACH ROW OF SPIDER INPUT FILE  (READS INPUT DATA)
            CALL REDLIN(LUNSPI,BUF,NX1,IRECIN)

C           WRITE EACH ROW OF SPIDER INPUT FILE 
            IF (MRCMODE == 2) THEN
C              32 BIT FLOATING POINT            (WRITES OUTPUT DATA)
               CALL WRTLIN_MRC(LUNMRC,BUF,NX1,IRECIN,MYPID,IERR)

            ELSEIF (MRCMODE == 0 ) THEN
C              8 BIT SIGNED INTEGER            (WRITES OUTPUT DATA)
               CALL WRTLIN_MRC(LUNMRC,BUF,NX1,IRECIN,MYPID,IERR)
 
            ELSEIF (MRCMODE == 1) THEN
C              16 BIT SIGNED INTEGER            (WRITES OUTPUT DATA)
               CALL WRTLIN_MRC(LUNMRC,BUF,NX1,IRECIN,MYPID,IERR)
 
            ELSEIF (MRCMODE == 6) THEN
C              16 BIT UNSIGNED INTEGER            (WRITES OUTPUT DATA)
               CALL WRTLIN_MRC(LUNMRC,BUF,NX1,IRECIN,MYPID,IERR)
 
            ENDIF

            IF (IERR .NE. 0) THEN
              LENT = lnblnkn(MRCFILE)
              WRITE(NOUT,99) IERR,IRECIN,NX1,LUNMRC,MRCFILE(:LENT)
99            FORMAT( '  *** ERROR(',I4,') WRITING RECORD: ',I12,
     &                ' LENGTH: ', I9,' UNIT: ',I3,' FILE: ',A)
              CALL ERRT(101,'ON MRC FILE OUTPUT',IERR)
              GOTO 999
            ENDIF

         ENDDO     ! END OF: DO IRECIN = 1,NY*NZ


C        OPEN NEXT SET OF I/O FILES, UPDATES NINDX1 & NINDX2

#if defined (SP_DBUGIO)
         write(3,*)' In copytomrc; calling nextfiles:',nindx1,nindx2
         write(3,*) ' ==================  next set ===================='
#endif
                    
         CALL NEXTFILES(NINDX1,NINDX2,  ILIST1,ILIST2, 
     &                  .FALSE., LUNXM1,LUNXM2,
     &                  NGOT1,NGOT2,    NSTACK1,NSTACK2,  
     &                  LUNSPI,LUNSPI,LUNMRC, FILNAM1,FILNAM2,
     &                  IMG1,IMG2, IRTFLG)

#if defined (SP_DBUGIO)
         write(3,*)' After nextfiles; ngot1,nstack1,img1: ',
     &                                ngot1,nstack1,img1
         write(3,*)' After nextfiles; ngot2,nstack2,img2: ',
     &                                ngot2,nstack2,img2
         write(3,*)' After nextfiles; irtflg:             ', irtflg
#endif

         IF (IRTFLG .NE. 0) EXIT      ! ERROR / END OF INPUT STACK
      ENDDO

      IRTFLG = 0
   
999   CLOSE(LUNSPI)
      CLOSE(LUNMRC)

      VERBOSE = VERBOSE_SAVE          ! RESTORE VERBOSITY 
      IF (ALLOCATED(ILIST1)) DEALLOCATE(ILIST1)
      IF (ALLOCATED(ILIST2)) DEALLOCATE(ILIST2)

      END

@


1.48
log
@fixed some stk bugs
defined(SP_DBUGIO)
@
text
@d49 1
a49 1
C COPYTOMRC_STK(LUNSPI,LUNMRC,NX,NY,NZ) 
d73 1
a73 1
C     &       'SPIDER INPUT FILE NAME OR TEMPLATE (e.g. SPI_STK@@**)~~9'
d78 1
a78 1
C     &       'MRC OUTPUT FILE NAME OR TEMPLATE (e.g. MRC_STK.mrc@@***)~'
d161 1
d163 1
a163 1
     &     'SPIDER INPUT FILE NAME OR TEMPLATE (e.g. SPI_STK@@**)~~9'
d173 4
a176 1
      !write(3,*)' ------- RETURNED TO: COPYTOMRC --------'
d214 1
a214 1
      CAXIS(1:2) = 'UL'        ! DEFAULT
d351 1
a351 1
      NSTACK2 =  1   ! UNUSED
d355 1
a355 1
      IMG2   = IMG1
d357 1
a357 1
     &    'MRC OUTPUT FILE NAME OR TEMPLATE (e.g.MRC_STK@@***.mrc)~'
d367 1
d369 2
a370 1
      write(3,*)' In copytomrc; ngot2,img2: ',     ngot2,img2
d374 1
d376 1
d378 1
a380 1
C     SETS LUNMRCNBYT(LUN) = NBYT
d383 2
d390 1
a390 1
      DO                ! LOOP OVER ALL IMAGES/STACKS
d393 1
a393 1
         DO IRECIN = 1,NY1*NZ1
d395 1
a395 1
C           READ EACH ROW OF SPIDER INPUT FILE 
d400 1
a400 1
C              32 BIT FLOATING POINT  
d404 1
a404 1
C              8 BIT SIGNED INTEGER
d408 1
a408 1
C              16 BIT SIGNED INTEGER
d412 1
a412 1
C              16 BIT UNSIGNED INTEGER
d429 2
a430 1
C        OPEN NEXT SET OF I/O FILES, UPDATES NINDX1 & NINDX2 
d432 2
a433 1
         write(3,*)' In copytomrc; calling nextfiles:',nindx1,nindx2 
d435 1
a435 1

d443 5
a447 4
         write(3,'(a,5i5)')'  After nextfiles; ngot1,nstack1,img1: ',
     &                                         ngot1,nstack1,img1
         write(3,'(a,5i5)')'  After nextfiles; ngot2,nstack2,img2: ',
     &                                         ngot2,nstack2,img2
a462 234





C **********************************************************************
C
C COPYTOMRC_STK  'CP TO MRC' STACKS               JUN 16 ArDean Leith
C
C **********************************************************************
C 
C COPYTOMRC_STK(LUNSPI,LUNMRC,SPIPAT,ILIST,NIMG, MAXIM,NX,NY,NZ)
C                                                                      
C PURPOSE: CONVERTS SPIDER IMAGE STACK TO MRC FORMAT, CRUDELY WRITTEN!!
C          CREATES NATIVE X386 BYTE ORDER MRC FILES 
C
C NOTES: DATA MODE IN MRC FILE : 2  (32 BIT FLOATING POINT)
C        ONLY CREATES 32 BIT REAL STACKS AS NORMALIZATION DIFFICULT FOR
C        LARGE MRC STACKS.
C
C       CREATE A NEW HEADER FOR THE MRC FILE 2014
C       DMAX < DMIN                         MAX & MIN UNDETERMINED
C       DMEAN < (SMALLER OF DMIN and DMAX)  DMEAN     UNDETERMINED
C       RMS < 0.0                           RMS       UNDETERMINED
C
C       TYPE           ISPG       MZ
C       IMAGE            0         1
C       IMAGE STACK      0      >= 1
C       VOLUME           1      = NZ
C       VOLUME STACK    401     = NZ / # OF SINGLE VOLUMES
C
C23456789012345678901234567890123456789012345678901234567890123456789012
C***********************************************************************

        SUBROUTINE COPYTOMRC_STK(LUNSPI,LUNMRC,SPIPAT,
     &                           ILIST,NIMG,MAXIM,IMGNUMOUT,
     &                           NX,NY,NZ)
 
C       COPY STACKS FROM SPIDER TO MRC FILE FORMAT 

        IMPLICIT NONE

        INCLUDE 'CMBLOCK.INC'
        INCLUDE 'CMLIMIT.INC'
 
        INTEGER                 :: IERR
        COMMON /IOERR/  IERR       ! LEGACY REDLIN ERROR FLAG

        REAL                    :: BUFIN
        COMMON /IOBUF/  BUFIN(NBUFSIZ)

        INTEGER LUNARA,LUNSTK,LUNARB,LUNFLIP
        COMMON /LUNARA/ LUNARA(100),LUNSTK(100),LUNARB(100),LUNFLIP(100)

        INTEGER                 :: LUNSPI,LUNMRC, NIMG,MAXIM,NX,NY,NZ
        CHARACTER(LEN=*)        :: SPIPAT
        INTEGER                 :: ILIST(*)
        INTEGER                 :: IMGNUMOUT

        REAL                    :: FIXLENBUF(256)
        REAL                    :: FLIPBUF(NX)

        CHARACTER(LEN=MAXNAM)   :: MRCFILE
        CHARACTER(LEN=4)        :: CSAXIS
        LOGICAL                 :: ISSWABT

        LOGICAL                 :: isswab,BOTLEFT
        INTEGER                 :: lnblnkn

        INTEGER *8              :: IPOSMRC
        INTEGER                 :: ISTARTX,ISTARTY,ISTARTZ
        REAL                    :: ORIGX,ORIGY,ORIGZ
        INTEGER                 :: IRTFLG,MODE,NX4
        INTEGER                 :: NSYMBT,MACHST,NE,IOFFSET 
        INTEGER                 :: NCHAR,LENT,ILEN,IBOTLEFT
        INTEGER                 :: NOT_USED
        INTEGER                 :: IRECIN,ILOCIN,IRECINT
        REAL                    :: RMS,FMINT,FMAXT,FAVT,FSIGT
        REAL                    :: UNUSED,SCALE,SCALEX,SCALEY,SCALEZ
        INTEGER                 :: NLET,IGO,MZ,IVERSION
        INTEGER                 :: NINDX,NGOT,IBITS,NSYMBYT,ISPG

        LOGICAL, PARAMETER      :: FOUROK = .FALSE.
        INTEGER, PARAMETER      :: LUNXM  = 0


C       OPEN NEW MRC STACK FILE FOR STREAM ACCESS, LITTLE ENDED
        CALL OPSTREAMFILE(.TRUE.,MRCFILE,DATEXC,LUNMRC,
     &                    'UNFORMATTED','NL',
     &                    'MRC OUTPUT',.TRUE.,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9999

        IVERSION = 20140
        IBOTLEFT = 1               
        CALL RDPRI2S(IVERSION,IBOTLEFT,NOT_USED,
     &    'MRC VERSION (0 or 20140), ORIGIN AT BOTTOM LEFT (YES==1)',
     &    IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9999

        BOTLEFT = (IBOTLEFT == 1)   ! USUAL MRC BOTTOM!!
        IF (IVERSION .NE. 20140 ) IVERSION = 0
  
C       MODE IS 32 BIT FLOATING POINT MRC IMAGE
        MODE    = 2                ! FLOATING POINT IMAGE

        ISTARTX = 0
        ISTARTY = 0
        ISTARTZ = 0

C       ORIGIN ON X,Y & Z AXIS  (MAKE THIS ALWAYS ZERO) 
        ORIGX   = 0.0
        ORIGY   = 0.0
        ORIGZ   = 0.0

C       TRY TO GET SPIDER IMAGE SCALE VALUE (MAY NOT BE SET?)
        CALL GETLAB(LUNSPI,21,1,SCALEX,IRTFLG)
        SCALEY  = SCALEX
        SCALEZ  = SCALEX

        IF (SCALEX > 0) THEN
           WRITE(NOUT,*) ' PIXEL SIZE (A) FOR ALL AXES (HEADER ',
     &                   ' LOCATION=21): ',SCALEX
        ELSEIF (NZ == 1) THEN

           SCALEX = 1.0
           SCALEY = 1.0
           SCALEZ = 1.0
           CALL RDPRM2S(SCALEX,SCALEY,NOT_USED,
     &              'PIXEL SIZE (A) FOR  X & Y AXES',IRTFLG)
        ELSE
           SCALEX = 1.0
           SCALEY = 1.0
           SCALEZ = 1.0
           CALL RDPRM3S(SCALEX,SCALEY,SCALEZ,NOT_USED,
     &              'PIXEL SIZE (A) FOR X, Y, & Z AXES',IRTFLG)
        ENDIF

C       SET UNDETERMINED IMAGE STATISTICS (FASTER)
        IF (IVERSION >= 20140) THEN
           FMINT =  0    
           FMAXT = -1
           FAVT  = -2
           FSIGT = -1
        ELSE
           FMINT =  0    ! UNDETERMINED SHUD BE: FMINT =  0 FOR MRC 2014
           FMAXT =  0    ! UNDETERMINED SHUD BE: FMAXT = -1
           FAVT  =  0    ! UNDETERMINED SHUD BE: FAVT  = -2
           FSIGT = -1    ! UNDETERMINED SHUD BE: FSIGT = -1
        ENDIF

 
        NSYMBYT = 0            ! NO ADDED HEADER LOCATIONS
        ISSWABT = .FALSE.

C       CREATE MRC HEADER. 
        CALL SETHEDCCP4_NEW(FIXLENBUF, NX,NY,NZ, NIMG, MODE,IVERSION,
     &                  ISTARTX,ISTARTY,ISTARTZ, 
     &                  ORIGX,ORIGY,ORIGZ, 
     &                  SCALEX,SCALEY,SCALEZ, 
     &                  FMINT,FMAXT,FAVT,FSIGT,
     &                  ISSWABT,NSYMBYT, IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9999

C       WRITE HEADER OF 1024 BYTES (256 FLOATS) TO MRC FILE
        IPOSMRC = 1  
        WRITE(LUNMRC, POS=IPOSMRC,IOSTAT=IERR) FIXLENBUF

        IF (IERR .NE. 0) THEN
           LENT = lnblnkn(MRCFILE)
           ILEN = 256
           WRITE(NOUT,99) IERR,IPOSMRC,ILEN,LUNMRC,MRCFILE(:LENT)
99         FORMAT( '  *** ERROR(',I4,') WRITING POSITION: ',I12,
     &              ' LENGTH: ', I9,' UNIT: ',I3,' FILE: ',A)
           GOTO 9999
        ENDIF

        IOFFSET = 1024
        NINDX   = IMGNUMOUT
        NGOT    = NIMG
        NX4     = NX * 4
          
C       LOOP OVER ALL IMAGES IN SPIDER STACK
        DO             ! LOOP OVER ALL IMAGES IN SPIDER STACK

C          SET STARTING POSITION FOR MRC DATA
           IPOSMRC = (IMGNUMOUT-1)  ! KLUDGE FOR INTEGER *8 PRESERVE
           IPOSMRC = IPOSMRC * NX * NY 
           IPOSMRC = IPOSMRC * 4
           IPOSMRC = IOFFSET + IPOSMRC + 1

c        write(6,'(2x,A,3i6,i12)') '  nindx,ilist,imgnumout,iposmrc:',
c     &                          nindx,ilist(nindx),imgnumout,iposmrc

           DO IRECIN = 1,NY*NZ

C             READ EACH ROW OF SPIDER INPUT FILE 


              IF (BOTLEFT) THEN
                 IRECINT = (NY * NZ) - IRECIN + 1    ! BOTTEM LEFT 
              ELSE
                 IRECINT = IRECIN
              ENDIF  
              CALL REDLIN(LUNSPI,BUFIN,NX,IRECINT)

C             PUT ROW OUT TO MRC FILE
              WRITE(LUNMRC, POS=IPOSMRC,IOSTAT=IERR) BUFIN(1:NX)

              IF (IERR .NE. 0) THEN
                LENT = lnblnkn(MRCFILE)
                WRITE(NOUT,99) IERR,IPOSMRC,NX,LUNMRC,MRCFILE(:LENT)
                GOTO 9999
              ENDIF
              IPOSMRC = IPOSMRC + NX4

           ENDDO     ! END OF: DO IRECIN = 1,NY*NZ

C          OPEN NEXT SPIDER INPUT FILE, UPDATES NINDX 
           CALL NEXTFILE(NINDX, ILIST, 
     &                  FOUROK, LUNXM,
     &                  NGOT,   MAXIM,   
     &                  LUNSPI, 0,
     &                  SPIPAT, 'O',
     &                  IMGNUMOUT, IRTFLG) 
         
           IF (NINDX > MAXIM) EXIT    ! FINISHED 
           IF (IRTFLG .NE. 0) EXIT    ! ERROR

        ENDDO
                      
9999    CLOSE(LUNSPI)
        CLOSE(LUNMRC)

        END
@


1.47
log
@cosmetic
@
text
@d24 1
d60 42
d140 1
a140 1
      INTEGER                  :: NDUM,NGOT1,NGOT2,IMG1,IMG2,NILMAX,IVAL
d164 1
a164 1
     &               .TRUE.,FILNAM1,NLET1, 'E',
d168 1
a168 1
     &               NDUM,NGOT1,IMG1, IRTFLG) 
d171 4
d179 1
a179 1
         CALL ERRT(101,'OPERATION DOES NOT READ MRC FILES',NDUM)
d183 3
a185 16
      !write(3,'(A,4i6)')' In nstack1,ngot1,img1:',nstack1,ngot1,img1

C     PROMPT: ~ IN LAST CHAR MEANS SKIP ADDING "FILE" AT END OF PROMPT


      CALL FILERD(FILNAM2,NLET2,NULL,
     &       'MRC OUTPUT FILE NAME OR TEMPLATE (e.g. MRC_STK.mrc@@***)~',
     &       IRTFLG)
      IF (IRTFLG .NE. 0) GOTO 999

      IF (INDEX(FILNAM2,'.mrc') <= 0 .AND.
     &    INDEX(FILNAM2,'.MRC') <= 0) THEN
         CALL ERRT(101,
     &     'OUTPUT FILE NAME MUST HAVE MRC/mrc EXTENSION',NDUM)
         GOTO 999
      ENDIF
d204 1
a204 2
      WRITE(NOUT,*) ' ' 
      WRITE(NOUT,*) ' MRC DATA ORIGIN     UL: UPPER LEFT, ',
d269 1
a269 1
C     UNFININISHED HERE !!!!!!!!!!!!!!!!!!!
d312 1
d346 1
d348 1
a348 1
      DISP    = 'U'  ! NEW OUTPUT FILE        
d351 4
a354 1
      IMG2 = IMG1
d356 1
a356 1
     &              .FALSE.,FILNAM2,NLET2,DISP,
d358 8
a365 10
     &              FILNAM2,
     &              .TRUE., ILIST2,NILMAX, 
     &              NDUM,NGOT2,IMG2, IRTFLG) 




      !write(3,'(A,4i6)')' In copytomrc nstack2,ngot2:',nstack2,ngot2
      !write(3,'(A,i6,A)')' In copytomrc img2:',img2
      !write(3,*)         ' In copytomrc caxis:',caxis
d420 3
a422 1
         !write(3,*)' In copytomrc, calling nextfiles:',nindx1,nindx2 
d429 8
d640 1
a640 1
c          write(6,'(2x,A,3i6,i12)') '  nindx,ilist,imgnumout,iposmrc:',
@


1.46
log
@renamed from copytomrc_new.f
@
text
@d4 1
a4 1
C COPYTOMRC    MODIFIED FROM COPYMRC               FEB 02 ArDean Leith         
d29 1
a29 1
C=* Copyright 1985-2019  Health Research Inc.,                         *
d31 1
a31 1
C=* Email: spider@@health.ny.gov                                        *
d138 3
d142 1
a142 1
     &       'MRC OUTPUT FILE NAME OR TEMPLATE (e.g. **@@MRC_STK.mrc)~',
d174 1
a174 2
         WRITE(NOUT,*) ' MRC HANDEDNESS  L: LEFT, ',
     &                 '        R:  RIGHT '
d323 3
@


1.45
log
@altered
@
text
@d62 2
a63 2
      SUBROUTINE COPYTOMRC_NEW(LUNSPI,LUNMRC,
     &                         LUNDOC,LUNXM1,LUNXM2,IRTFLG)
@


1.44
log
@getlab parameters
@
text
@d23 1
d62 2
a63 1
        SUBROUTINE COPYTOMRC(LUNSPI,LUNMRC,NX,NY,NZ)
d65 4
a68 1
        IMPLICIT NONE
d70 30
a99 4
        INCLUDE 'CMBLOCK.INC'
        INCLUDE 'CMLIMIT.INC'
 
        COMMON /IOERR/  IERR       ! LEGACY REDLIN ERROR FLAG
d101 3
a103 2
        REAL                    :: BUFIN
        COMMON /IOBUF/  BUFIN(NBUFSIZ)
d105 1
a105 1
        INTEGER                 :: LUNSPI,LUNMRC, NX,NY,NZ
d107 74
a180 138
        REAL,       ALLOCATABLE :: STREAMBUF(:)
        INTEGER *1, ALLOCATABLE :: I1STREAMBUF(:)
        INTEGER *2, ALLOCATABLE :: I2STREAMBUF(:)
        INTEGER,    ALLOCATABLE :: ILIST(:)
        REAL                    :: BUF(NBUFSIZ),FIXLENBUF(256)
        INTEGER *1              :: I1BUF(1024)
        COMMON                     BUF,FIXLENBUF,I1BUF

        CHARACTER(LEN=MAXNAM)   :: MRCFILE,FILPAT,FILOUT
        CHARACTER(LEN=8)        :: ANS
        CHARACTER(LEN=80)       :: PROMPT
        LOGICAL                 :: FLIP,ISSWABT,BOTLEFT
        INTEGER                 :: IVAL
        INTEGER *1              :: I1VAL
        INTEGER *2              :: I2VAL

        INTEGER *2              :: I2V
        INTEGER *1              :: I1V(2),I1TMP
        EQUIVALENCE                (I2V,I1V)

        INTEGER                 :: IERR,LENOPENB,LENOPENF,IRTFLG,MODE
        INTEGER                 :: NSYMBT,MACHST,NE,MAXIM,IOFFSET 
        INTEGER                 :: LENOPEN,NCHAR,IRECMRC
        INTEGER                 :: IBOTLEFT,NOT_USED,ILOCOUT
        INTEGER                 :: IRECIN,ILOCIN,IRECINT,NSYMBYT
        REAL                    :: RMS,FMINT,FMAXT,FAVT,FSIGT,FN,FNCON
        REAL                    :: UNUSED,SCALE,SCALEX,SCALEY,SCALEZ
        INTEGER                 :: IX,IY,IZ,NLET
        INTEGER                 :: I,NSTACKT,ITYPE,NUNUSED,NSTACKOUT
        INTEGER                 :: IMGNUMOUT,NSTACK,IGO
        INTEGER                 :: NIMG,MZ

        LOGICAL                 :: FOUROK

        IERR = 0

C       OPEN NEW MRC FILE FOR DIRECT ACCESS, RECORD LENGTH 1024 BYTES
C       FORCE IT TO LITTLE ENDED OUTPUT, OVERRULES COMPILER  'UL'
        LENOPENB = 1024
        LENOPENF = LENOPENB / 4
        CALL OPAUXFILE(.TRUE.,MRCFILE,DATEXC,LUNMRC,LENOPENB,'UL',
     &                 'MRC OUTPUT',.TRUE.,IRTFLG)

        IVAL     = 8
        IBOTLEFT = 1
        CALL RDPRI2S(IVAL,IBOTLEFT,NOT_USED,
     &   'MRC DATA LENGTH (8/32 BITS), ORIGIN AT BOTTOM LEFT (YES==1)',
     &   IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9999

        MODE = 2
        IF (IVAL == 8) MODE = 0

        BOTLEFT = (IBOTLEFT == 1)   ! USUAL MRC BOTTOM!!

C       CREATE A NEW HEADER FOR THE MRC FILE
        FMINT = FMIN
        FMAXT = FMAX
        FAVT  = AV
        FSIGT = SIG

        IF (MODE == 0) THEN
           FN    = (255.0 - 0.0) / (FMAXT - FMINT)
           FNCON = 0.0 - FN * FMINT

           FMINT = 0.0
           FMAXT = 255.0
           I2VAL = FMINT * FN + FNCON
           FAVT  = I2VAL
C          FSIGT IS NOT RIGHT!!!!
           FSIGT = -1.0
        ENDIF

C       TRY TO GET SCALE VALUE (MAY NOT BE USED)
        CALL GETLAB(LUNSPI,21,1,SCALE,IRTFLG)
        SCALEX  = SCALE
        SCALEY  = SCALE
        SCALEZ  = SCALE

C       CREATE HEADER. (NOTE: FMIN, FMAX, AV ARE SAME AS SPIDER IMAGE)
        NIMG    = 1
        MZ      = NZ
        NSYMBYT = 0
        ISSWABT = .FALSE.

        CALL SETHEDCCP4(FIXLENBUF, NX, NY, NZ,
     &            FMINT,FMAXT,FAVT,FSIGT,
     &            SCALEX,SCALEY,SCALEZ,MODE,
     &            ISSWABT,NSYMBYT, NIMG,MZ,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9999

C       WRITE HEADER OF 1024 BYTES (256 FLOATS) TO MRC FILE
        CALL WRTLIN(LUNMRC,FIXLENBUF,LENOPENF,1) 

C       SET STARTING RECORD FOR MRC DATA
        IRECMRC = 1   !SKIPS ONE HEADER RECORD
        ILOCOUT = 0

        IF (MODE == 2) THEN
C          FLOATING POINT OUTPUT

           DO  IRECIN = 1,NY * NZ

C             READ EACH ROW OF SPIDER INPUT FILE 
              IF (BOTLEFT) THEN
                 IRECINT = (NY * NZ) - IRECIN + 1  
              ELSE
                 IRECINT = IRECIN  
              ENDIF
              CALL REDLIN(LUNSPI,BUFIN,NX,IRECINT)

C             PUT ROW OUT TO MRC FILE
              DO ILOCIN=1,NX
                ILOCOUT            = ILOCOUT + 1
                FIXLENBUF(ILOCOUT) = BUFIN(ILOCIN)

                IF (ILOCOUT >= LENOPENF) THEN
C                  PUT OUT COMPLETED RECORD

                   IRECMRC = IRECMRC + 1

                   CALL WRTLIN(LUNMRC,FIXLENBUF,LENOPENF,IRECMRC)
                   !write(6,*) '  Rec: ',irecint,'-->',irecmrc

                   ILOCOUT = 0
                ENDIF
              ENDDO
           ENDDO

           IF (ILOCOUT > 0) THEN
C             PUT OUT ANY REMAINING MRC RECORD
              IRECMRC = IRECMRC + 1
              CALL WRTLIN(LUNMRC,FIXLENBUF,ILOCOUT,IRECMRC)
              !write(6,*) '  Rec: ',irecint,'-->',irecmrc
           ENDIF
        
        ELSEIF (MODE == 0) THEN
C          COPY FROM SPIDER TO MRC 8 BIT FILE FORMAT 
d182 117
a298 44
           DO IRECIN = 1,NY * NZ
C             READ EACH ROW OF SPIDER INPUT FILE 
              IF (BOTLEFT) THEN
                 IRECINT = (NY * NZ) - IRECIN + 1  
                 CALL REDLIN(LUNSPI,BUFIN,NX,IRECINT)
              ELSE
                 CALL REDLIN(LUNSPI,BUFIN,NX,IRECIN)
              ENDIF

C             PUT ROW OUT TO MRC FILE
              DO ILOCIN=1,NX
                ILOCOUT        = ILOCOUT + 1
                I2VAL          = BUFIN(ILOCIN) * FN + FNCON
                I1BUF(ILOCOUT) = I2VAL

                IF (ILOCOUT >= LENOPENB) THEN
C                  PUT OUT COMPLETED RECORD
                   IRECMRC = IRECMRC + 1

                   CALL WRTLIN8(LUNMRC,I1BUF,LENOPENB,IRECMRC)
                   IF (IERR .NE. 0) THEN
                      CALL ERRT(102,'WRITING RECORD',IRECMRC)
                      GOTO 9999
                   ENDIF
                   ILOCOUT = 0
                ENDIF
              ENDDO
           ENDDO

           IF (ILOCOUT > 0) THEN
C             PUT OUT REMAINING RECORD
              IRECMRC = IRECMRC + 1
              CALL WRTLIN8(LUNMRC,I1BUF,ILOCOUT,IRECMRC)
          ENDIF

        ELSE
           CALL ERRT(102,'CAN NOT CREATE MRC MODE',MODE)
           GOTO 9999
        ENDIF

        IF (IERR .NE. 0) THEN
           CALL ERRT(102,'WRITING RECORD',IRECIN)
           GOTO 9999
        ENDIF
d301 64
a364 5
9999    CLOSE(LUNSPI)
        CLOSE(LUNMRC)
        IF(ALLOCATED(STREAMBUF)) DEALLOCATE(STREAMBUF)

        END
d366 31
d398 1
d462 2
a463 1
        LOGICAL                 :: ISSWABT, BOTLEFT
d465 1
a465 1
        LOGICAL                 :: isswab
@


1.43
log
@mrc_support
@
text
@d22 1
d149 1
a149 1
        CALL GETLAB(LUNSPI,NX,UNUSED,21,1,SCALE,IRTFLG)
d381 1
a381 1
        CALL GETLAB(LUNSPI,NX,UNUSED,21,1,SCALEX,IRTFLG)
@


1.42
log
@email_health_dept
@
text
@d27 1
a27 1
C=* Copyright 1985-2018  Health Research Inc.,                         *
d45 1
a45 1
C COPYTOMRC(LUNSPI,LUNMRC,NX,NY,NZ)
a85 1
        LOGICAL                 :: isswab
a92 4

        REAL    *4              :: R4VALIN,R4VALOUT
        INTEGER *1              :: I1VALIN(4),I1VALOUT(4)
        EQUIVALENCE                (R4VALIN,I1VALIN),(R4VALOUT,I1VALOUT)
@


1.41
log
@machine stamp fixed,  convert=little-ended rewrite
@
text
@d29 1
a29 1
C=* Email: spider@@wadsworth.org                                        *
@


1.40
log
@*** empty log message ***
@
text
@d4 18
a21 17
C COPYTOMRC   MODIFIED FROM COPYMRC               FEB 02 ArDean Leith         
C             ISSWAB ADDED                        JUL 02 ArDean Leith
C             FLIP QUESTION                       MAR 03 ArDean Leith
C             BAD IRECMRC4 & FLIP                 SEP 03 ArDean Leith
C             SCALING                             JAN 05 ArDean Leith
C             I*8                                 SEP 08 ArDean Leith
C             NPIX8                               DEC 08 ArDean Leith
C             BOTLEFT OPTION                      MAY 12 ArDean Leith
C             STREAM IO                           FEB 13 ArDean Leith
C             VOL BUG                             JUN 13 ArDean Leith
C             VOL BUG FIXED                       JUL 13 ArDean Leith
C             MODE 6 STACK SUPPORT                SEP 14 ArDean Leith
C             IPOSMRC INTEGER *8                  JAN 15 ArDean Leith
C             BOTLEFT DEFAULT                     JUL 15 ArDean Leith
C             2015 STACK SUPPORT                  JUL 15 ArDean Leith
C             COPYTOMRC_STK ADDED, STACK BUGGY    JUN 16 ArDean Leith
C             BOTLEFT OPTION REINTRODUCED         SEP 16 ArDean Leith
d48 1
a48 1
C PURPOSE: COPY SPIDER FORMAT FILE TO MRC FILE FORMAT
d116 1
d119 1
a119 1
        CALL OPAUXFILE(.TRUE.,MRCFILE,DATEXC,LUNMRC,LENOPENB,'U',
a157 10
C       FIND IF CURRENTLY SWAPPING BYTES DURING FILE OUTPUT
C       THIS MAY BE DONE BY COMPILER, SO HAVE TO ACTUALLY TEST OUTPUT
        ISSWABT = ISSWAB(99)

C       FLIP BYTES DURING MRC FILE OUTPUT
        IF (ISSWABT) THEN
           CALL LUNSETFLIP(LUNMRC,1,IRTFLG)
           ISSWABT = .FALSE.
        ENDIF

d162 2
d271 5
d334 1
a334 1
        LOGICAL                 :: ISSWABT, SWABT, BOTLEFT
d356 1
a356 1
C       OPEN NEW MRC STACK FILE FOR STREAM ACCESS
d358 1
a358 1
     &                    'UNFORMATTED','N',
a361 7
C       FIND IF CURRENTLY SWAPPING BYTES DURING FILE OUTPUT
C       THIS MAY BE DONE IN COMPILATION, HAVE TO ACTUALLY TEST OUTPUT
        ISSWABT = ISSWAB(99)
        
c       write(6,*) '  isswabt,lunflip:', isswabt,lunflip(lunmrc)
        swabt = .false.    

d422 1
d476 1
a476 7
              IF (SWABT) THEN
C                FLIP BYTE ORDERING IN BUFIN
                 CALL FLIPBYTES(BUFIN,FLIPBUF,NX,IRTFLG)
                 WRITE(LUNMRC, POS=IPOSMRC,IOSTAT=IERR) FLIPBUF(1:NX)
              ELSE
                 WRITE(LUNMRC, POS=IPOSMRC,IOSTAT=IERR) BUFIN(1:NX)
              ENDIF
@


1.39
log
@COPYTOCCP4 renamed COPYTOMRC
@
text
@d5 16
a20 16
C              ISSWAB ADDED                        JUL 02 ArDean Leith
C              FLIP QUESTION                       MAR 03 ArDean Leith
C              BAD IRECMRC4 & FLIP                 SEP 03 ArDean Leith
C              SCALING                             JAN 05 ArDean Leith
C              I*8                                 SEP 08 ArDean Leith
C              NPIX8                               DEC 08 ArDean Leith
C              BOTLEFT OPTION                      MAY 12 ArDean Leith
C              STREAM IO                           FEB 13 ArDean Leith
C              VOL BUG                             JUN 13 ArDean Leith
C              VOL BUG FIXED                       JUL 13 ArDean Leith
C              MODE 6 STACK SUPPORT                SEP 14 ArDean Leith
C              IPOSMRC INTEGER *8                  JAN 15 ArDean Leith
C              BOTLEFT DEFAULT                     JUL 15 ArDean Leith
C              2015 STACK SUPPORT                  JUL 15 ArDean Leith
C              COPYTOMRC_STK ADDED, STACK BUGGY   JUN 16 ArDean Leith
C              BOTLEFT OPTION REINTRODUCED         SEP 16 ArDean Leith
d47 1
a47 1
C PURPOSE: COPY FROM SPIDER TO MRC FILE FORMAT
@


1.38
log
@restored botleft option
@
text
@d4 1
a4 1
C COPYTOCCP4   MODIFIED FROM COPYMRC               FEB 02 ArDean Leith         
d19 1
a19 1
C              COPYTOCCP4_STK ADDED, STACK BUGGY   JUN 16 ArDean Leith
d26 1
a26 1
C=* Copyright 1985-2016  Health Research Inc.,                         *
d44 2
a45 2
C COPYTOCCP4(LUNSPI,LUNMRC,NX,NY,NZ)
C COPYTOCCP4_STK(LUNSPI,LUNMRC,NX,NY,NZ) 
d59 1
a59 1
        SUBROUTINE COPYTOCCP4(LUNSPI,LUNMRC,NX,NY,NZ)
d132 1
a132 1
C       CREATE A NEW HEADER FOR THE CCP4 (MRC) FILE
d279 1
a279 1
C COPYTOCCP4_STK  'CP TO MRC' STACKS               JUN 16 ArDean Leith
d283 1
a283 1
C COPYTOCCP4_STK(LUNSPI,LUNMRC,SPIPAT,ILIST,NIMG, MAXIM,NX,NY,NZ)
d306 1
a306 1
        SUBROUTINE COPYTOCCP4_STK(LUNSPI,LUNMRC,SPIPAT,
@


1.37
log
@comments
@
text
@d20 1
d101 1
a101 1
        INTEGER                 :: IBOTLEF,NOT_USED,ILOCOUT
d120 5
a124 4
        IVAL    = 8
        IBOTLEF = 1
        CALL RDPRI2S(IVAL,IBOTLEF,NOT_USED,
     &               'MRC DATA LENGTH (8/32 BITS)',IRTFLG)
d130 1
a130 1
        BOTLEFT = (IBOTLEF > 0)   ! USUAL MRC BOTTOM!!
a190 1
                 CALL REDLIN(LUNSPI,BUFIN,NX,IRECINT)
d192 1
a192 1
                 CALL REDLIN(LUNSPI,BUFIN,NX,IRECIN)
d194 1
d207 2
d215 1
a215 1
C             PUT OUT REMAINING RECORD
d218 1
d335 2
a336 1
        LOGICAL                 :: ISSWABT, SWABT
d345 1
a345 1
        INTEGER                 :: NCHAR,LENT,ILEN
d371 4
a374 3
        IBITS    = 32               ! FOR FUTURE
        CALL RDPRI2S(IVERSION,IBITS,NOT_USED,
     &               'MRC VERSION (<CR> = 20140)', IRTFLG)
d377 1
d473 7
a479 1
              IRECINT = (NY * NZ) - IRECIN + 1     ! BOTTEM LEFT 
@


1.36
log
@copies stacks with missing images
no byte swap
@
text
@d281 1
d362 1
a362 1
        swabt = .false.
d470 1
@


1.35
log
@undedefined ngot bug
@
text
@d20 1
a20 1

d109 1
a109 1
        LOGICAL                 :: ASKNAM,FOUROK,WANTSTACK,FOLD
d301 1
a301 1
     &                           ILIST,NIMG,MAXIM,
d317 3
d323 1
d326 1
d329 1
a329 1
        LOGICAL                 :: ISSWABT
d331 1
d333 1
d336 1
a336 1
        INTEGER                 :: LENOPENB,LENOPENF,IRTFLG,MODE
d338 4
a341 4
        INTEGER                 :: LENOPEN,NCHAR,IRECMRC
        INTEGER                 :: NOT_USED,ILOCOUT
        INTEGER                 :: IRECIN,ILOCIN,IRECINT,NZMRC
        REAL                    :: RMS,FMINT,FMAXT,FAVT,FSIGT,FN,FNCON
d343 2
a344 2
        INTEGER                 :: NLET,IMGNUMOUT,IGO,MZ,IVERSION
        INTEGER                 :: NINDX1,NGOT,IBITS,NSYMBYT,ISPG
a345 1
        LOGICAL                 :: ASKNAM,WANTSTACK,FOLD
d347 1
a347 1
        INTEGER, PARAMETER      :: LUNXM = 0
d349 6
a354 5
C       OPEN NEW MRC FILE FOR DIRECT ACCESS, RECORD LENGTH 1024 BYTES
        LENOPENB = 1024
        LENOPENF = LENOPENB / 4
        CALL OPAUXFILE(.TRUE.,MRCFILE,DATEXC,LUNMRC,LENOPENB,'U',
     &                 'MRC OUTPUT',.TRUE.,IRTFLG)
d359 3
a361 6

        IF (ISSWABT) THEN
C          FLIP BYTES DURING MRC FILE OUTPUT
           CALL LUNSETFLIP(LUNMRC,1,IRTFLG)
           ISSWABT = .FALSE.
        ENDIF
d432 14
a445 7
        CALL WRTLIN(LUNMRC,FIXLENBUF,LENOPENF,1)
 
C       SET STARTING RECORD FOR MRC DATA
        IRECMRC = 1   ! SKIPS ONE HEADER RECORD
        ILOCOUT = 0
        IERR    = 0
        NINDX1  = 1
d447 10
d458 2
a459 1
        DO             ! LOOP OVER ALL IMAGES IN SPIDER STACK
d468 6
a473 10
              DO ILOCIN=1,NX
                 ILOCOUT            = ILOCOUT + 1
                 FIXLENBUF(ILOCOUT) = BUFIN(ILOCIN)

                 IF (ILOCOUT >= LENOPENF) THEN
C                   PUT OUT COMPLETED RECORD

                    IRECMRC = IRECMRC + 1
                    CALL WRTLIN(LUNMRC,FIXLENBUF,LENOPENF,IRECMRC)
                    ILOCOUT = 0
d475 6
a481 2
                 ENDIF
              ENDDO
d484 2
a485 3

C          OPEN NEXT SPIDER INPUT FILE, UPDATES NINDX1 
           CALL NEXTFILE(NINDX1, ILIST, 
d491 3
a493 4
           !write(6,*) '  maxim,nindx1,irtflg:',maxim,nindx1,irtflg

           IF (NINDX1 > MAXIM) EXIT    ! FINISHED 
           IF (IRTFLG .NE. 0)  EXIT    ! ERROR
d496 1
a496 11
       
        IF (ILOCOUT > 0) THEN
C          PUT OUT REMAINING RECORD IN THIS IMAGE
           IRECMRC = IRECMRC + 1
           CALL WRTLIN(LUNMRC,FIXLENBUF,ILOCOUT,IRECMRC)
        ENDIF
        !IF (IERR .NE. 0) THEN
        !   CALL ERRT(102,'WRITING RECORD',IRECIN)
        !   GOTO 9999
        !ENDIF
                
a500 1

@


1.34
log
@bad stack bug fixed
@
text
@d435 1
d470 1
a470 1
           !write(6,*) '  nindx1,irtflg:',nindx1,irtflg
@


1.33
log
@CALL LUNSETFLIP was before ISSWABT was initialized bug
@
text
@d4 17
a20 16
C COPYTOCCP4               MODIFIED FROM COPYMRC   FEB 02 ArDean Leith         
C                          ISSWAB ADDED            JUL 02 ArDean Leith
C                          FLIP QUESTION           MAR 03 ArDean Leith
C                          BAD IRECMRC4 & FLIP     SEP 03 ArDean Leith
C                          SCALING                 JAN 05 ArDean Leith
C                          I*8                     SEP 08 ArDean Leith
C                          NPIX8                   DEC 08 ArDean Leith
C                          BOTLEFT OPTION          MAY 12 ArDean Leith
C                          STREAM IO               FEB 13 ArDean Leith
C                          VOL BUG                 JUN 13 ArDean Leith
C                          VOL BUG FIXED           JUL 13 ArDean Leith
C                          MODE 6 STACK SUPPORT    SEP 14 ArDean Leith
C                          IPOSMRC INTEGER *8      JAN 15 ArDean Leith
C                          BOTLEFT DEFAULT         JUL 15 ArDean Leith
C                          2015 STACK SUPPORT      JUL 15 ArDean Leith
C
d25 1
a25 1
C=* Copyright 1985-2015  Health Research Inc.,                         *
d44 2
a45 1
C                                                                      
d272 1
a272 1
C ++********************************************************************
d274 1
a274 1
C COPYTOCCP4_STK  'CP TO MRC' STACKS               JUN 15 ArDean Leith
d286 10
a295 3
C        DMAX < DMIN                         MAX & MIN UNDETERMINED
C        DMEAN < (SMALLER OF DMIN and DMAX)  DMEAN     UNDETERMINED
C        RMS < 0.0                           RMS       UNDETERMINED
d301 2
a302 2
     &                          ILIST,NIMG,MAXIM,
     &                          NX,NY,NZ)
d327 2
d336 1
a336 1
        INTEGER                 :: NLET,IMGNUMOUT,IGO,MZ
a348 7
        IGO   = 1
        IBITS = 32               ! FOR FUTURE
        CALL RDPRI2S(IGO,IBITS,NOT_USED,
     &               'INITIAL MRC IMAGE NUMBER', IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9999
        MODE  = 2                ! FLOATING POINT IMAGE

d359 19
a377 12
C       CREATE A NEW HEADER FOR THE MRC FILE
C       DMAX < DMIN                         MAX & MIN UNDETERMINED
C       DMEAN < (SMALLER OF DMIN and DMAX)  DMEAN     UNDETERMINED
C       RMS < 0.0                           RMS       UNDETERMINED
C       ISPG   == 0                IMAGE OR IMAGE STACK
C       ISPG   == 1                VOLUMES
C       ISPG   == 401              STACK OF EM VOLUMES

        FMINT =  0    ! UNDETERMINED
        FMAXT =  0    ! UNDETERMINED
        FAVT  = -1    ! UNDETERMINED
        FSIGT = -1    ! UNDETERMINED
d384 32
d419 6
a424 3
        CALL SETHEDCCP4(FIXLENBUF, NX,NY,NZ, FMINT,FMAXT,FAVT,FSIGT,
     &                  SCALEX,SCALEY,SCALEZ, MODE,
     &                  ISSWABT,NSYMBYT,NIMG,MZ,IRTFLG)
d428 2
a429 2
        CALL WRTLIN(LUNMRC,FIXLENBUF,LENOPENF,1) 

d431 1
a431 1
        IRECMRC = IGO + 1   ! SKIPS ONE HEADER RECORD
a433 1

d436 1
a436 1
        DO      ! LOOP OVER ALL IMAGES IN SPIDER STACK
d438 1
a438 1
           DO IRECIN = 1,NY * NZ
d441 1
a441 1
              IRECINT = (NY * NZ) - IRECIN + 1  
a452 1

d455 2
d459 1
a459 1
           ENDDO
a460 10
           IF (ILOCOUT > 0) THEN
C             PUT OUT REMAINING RECORD IN THIS IMAGE
              IRECMRC = IRECMRC + 1
              CALL WRTLIN(LUNMRC,FIXLENBUF,ILOCOUT,IRECMRC)
           ENDIF
        
           IF (IERR .NE. 0) THEN
              CALL ERRT(102,'WRITING RECORD',IRECIN)
              GOTO 9999
           ENDIF
d469 1
d474 1
a474 1
       ENDDO
d476 12
a487 5
9999   CLOSE(LUNSPI)
       CLOSE(LUNMRC)

       END

d489 1
@


1.32
log
@*** empty log message ***
@
text
@d81 2
a82 1
        LOGICAL                 :: FLIP,ISSWABT,ISSWAB,BOTLEFT
a116 6
C       FLIP BYTES DURING MRC FILE OUTPUT
        IF (ISSWABT) THEN
           CALL LUNSETFLIP(LUNMRC,1,IRTFLG)
           ISSWABT = .FALSE.
        ENDIF

d156 6
d315 2
a316 1
        LOGICAL                 :: ISSWABT,ISSWAB
@


1.31
log
@stack support
@
text
@d18 1
@


1.30
log
@IPOSMRC  to INTEGER * 8
@
text
@d4 1
a4 1
C COPYCCP4                 MODIFIED FROM COPYMRC   FEB 02 ArDean Leith         
d17 2
d41 1
a41 1
C COPYCCP4(LUNSPI,LUNMRC,NX,NY,NZ)
d43 1
a43 2
C PURPOSE: CONVERTS SPIDER IMAGES TO OR FROM CCP4 FORMAT
C          CRUDELY WRITTEN!!!
d46 1
a46 1
C	 MODE   TYPES OF PIXEL IN IMAGE
d55 1
a55 1
        SUBROUTINE COPYCCP4(LUNSPI,LUNMRC,NX,NY,NZ)
d78 2
a79 2
	CHARACTER(LEN=8)        :: ANS
	CHARACTER(LEN=80)       :: PROMPT
a92 1
	CHARACTER(LEN=1)        :: NULL = CHAR(0)
d95 3
a97 3
        INTEGER                 :: LENOPEN,NCHAR,IRECMRC,IRECSPI
        INTEGER                 :: IBOTLEF,NOT_USED,IRECINC,ILOCOUT
        INTEGER                 :: IRECIN,ILOCIN,IRECINT
d99 2
a100 2
        REAL                    :: UNUSED,SCALE
        INTEGER                 :: IX,IY,IZ,NLET,LOCAT,LOCAST
d102 2
a103 3
        INTEGER                 :: IMGNUMOUT,NSTACK,IGO,ISTACK,IRECSTK

        INTEGER *8              :: IPOSMRC
a105 7
        INTEGER, PARAMETER      :: LUNDOCSEL = 0
        INTEGER, PARAMETER      :: LUNXM     = 0

        integer   :: imax   = -1000000, iymax  = 0, imax2  = 0
        integer   :: ixmax2 = 0, iymax2 = 0
        integer   :: imin   = 100000000, ixmin = 0,iymin = 0, imin2 = 0
        integer   :: ixmin2 = 0, iymin2 = 0
d109 1
a109 340
C       FIND IF CURRENTLY SWAPPING BYTES
        ISSWABT = ISSWAB(99)

        IF (FCHAR(4:5)  == 'TO')      GOTO 1000


C       COPY FROM MRC TO SPIDER FILE FORMAT --------------- FROM MRC

C       OPEN MRC FILE AS DIRECT ACCESS, UNFORMATTED, RECL=1024 BYTES
        LENOPENB = 1024
        LENOPENF = 1024 / 4
        CALL OPAUXFILE(.TRUE.,MRCFILE,DATEXC,LUNMRC,LENOPENB,'O',
     &                       'MRC (CCP4) INPUT',.TRUE.,IRTFLG)
        IF (IRTFLG .NE. 0) RETURN

C       READ MRC HEADER 
        CALL REDLIN(LUNMRC,FIXLENBUF,LENOPENF,1)
 
C	PARSE MRC HEADER	
	CALL GETHEDCCP4(FIXLENBUF,NX,NY,NZ,MODE,FMIN,FMAX,
     &                   AV,RMS,NSYMBT,ISSWABT,FLIP,MACHST,IRTFLG)
        IF (IRTFLG == 2) THEN
            CALL ERRT(101,'NOT CURRENT MRC FORMAT, MAY BE PRE 1999 MRC',
     &                NE)
           GOTO 9999
        ENDIF
C       CLOSE MRC FILE
        CLOSE(LUNMRC)

        WANTSTACK = .FALSE. 
        NSTACK    = 0

        IF (NZ > 1) THEN
C          MRC FILE MAY BE VOLUME OR STACK (STUPID FILE FORMAT FOR STACK)
           PROMPT = 
     &      'OUTPUT VOLUME OR TEMPLATE FOR IMAGE STACK (E.G. STK@@*)~'

           CALL FILERD(FILPAT,NLET,NULL,PROMPT,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9999

           LOCAT     = INDEX(FILPAT(1:NLET),'@@')   
           LOCAST    = INDEX(FILPAT(1:NLET),'*')
           WANTSTACK = (LOCAST > LOCAT ) 
           ASKNAM    = .FALSE.    ! ALREADY ASKED OUTPUT FILENAME

           IF (WANTSTACK) THEN
C             OPEN FIRST SPIDER OUTPUT FILE	

              IGO = 1
              CALL RDPRI1S(IGO,NOT_USED,
     &                    'FIRST IMAGE NUMBER IN STACK',IRTFLG)
              IF (IRTFLG .NE. 0) GOTO 9999

              NSTACK = NZ
              ALLOCATE(ILIST(NSTACK),STAT=IRTFLG)
              IF (IRTFLG > 0) THEN
                 CALL ERRT(46,'COPYCCP4; ILIST',NSTACK)
                 GOTO 9999
              ENDIF

C             MAKE LIST OF STACKED FILE NUMBERS
              DO I = IGO,NSTACK
                 ILIST(I) = I
              ENDDO

              NSTACKT = -NSTACK    ! USE ILIST FOR STACKED IMG NUMBERS
              FOUROK  = .FALSE.    ! NOT FOURIER
              NZ      = 1          ! NOT A VOLUME
              ITYPE   = 1

C             OPEN SPIDER STACK OUTPUT FILE	
              CALL OPFILES(0,LUNSPI,LUNDOCSEL,LUNXM,
     &            ASKNAM,FILOUT,NLET, 'U',
     &            ITYPE,NX,NY,NZ,MAXIM,
     &            FILPAT,
     &            FOUROK, ILIST,NSTACKT, 
     &            NUNUSED,NSTACKOUT, IMGNUMOUT, IRTFLG)
              !write(6,*) 'nstackout, imgnumout:', nstackout, imgnumout 

           ELSE
C             OPEN SPIDER VOLUME OUTPUT FILE	
              ITYPE  = 3
              MAXIM  = 0
              CALL OPFILEC(0,ASKNAM,FILPAT,LUNSPI,'U',ITYPE,NX,NY,NZ,
     &                 MAXIM,' ',.FALSE.,IRTFLG)
              IF (IRTFLG .NE. 0) GOTO 9999
           ENDIF
        ELSE
C          OPEN SPIDER IMAGE OUTPUT FILE	
           ITYPE  = 1
           MAXIM  = 0
           CALL OPFILEC(0,.TRUE.,FILPAT,LUNSPI,'U',ITYPE,NX,NY,NZ,
     &                 MAXIM,'SPIDER IMAGE OUTPUT',.FALSE.,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9999
        ENDIF


C       EXTRACT DATA FROM MRC FILE AFTER HEADER & PUT IN SPIDER FILE
        IOFFSET = 1024 + NSYMBT

        IF (MODE == 0) THEN
           ALLOCATE(I1STREAMBUF(NX), STREAMBUF(NX),STAT=IRTFLG)

        ELSEIF (MODE == 1 .OR. MODE == 6)  THEN
           ALLOCATE(I2STREAMBUF(NX), STREAMBUF(NX),STAT=IRTFLG)

        ELSEIF (MODE == 2 )  THEN
           ALLOCATE(STREAMBUF(NX),STAT=IRTFLG)

        ELSE 
           CALL ERRT(102,'UNSUPPORTED MRC MODE',MODE)
        ENDIF 

        IF (IRTFLG .NE. 0) THEN
           CALL ERRT(46,'COPYCCP4; **STREAMBUF',NX)
           GOTO 9999
        ENDIF

C       OPEN MRC FILE FOR STREAM ACCESS
        CALL OPSTREAMFILE(.FALSE.,MRCFILE,NULL,LUNMRC,
     &                    'UNFORMATTED','O',' ',.TRUE.,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9999

        CALL RDPRMC(ANS,NCHAR,.TRUE.,
     &           'FLIP BYTE ORDERING? (Y/N), INVERT TOP/BOTTOM? (Y/N)',
     &            NULL,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9999

        IF (ANS(1:1) == 'Y') FLIP = .NOT. FLIP

        ! BOTLEFT IS USUAL MRC BOTTOM IN CURRENT FORMAT !!
        BOTLEFT = (NCHAR > 2 .AND. (INDEX(ANS(3:NCHAR),'Y')) > 0) 

        ISTACK  = 1

        DO  ! POSSIBLE LOOP OVER MRC STACK -------------------------
         IRECSPI = 0
         IRECINC = 1
         IRECSTK = (ISTACK-1) * NY

         IF (BOTLEFT) THEN
C           INVERT TOP & BOT OF EACH IMAGE OR EACH IMAGE WITHIN VOLUME
            IRECSPI = NY*NZ + 1    ! NZ HAS BEEN SET = 1 IF STACK
            IRECINC = -1
         ENDIF

         IF (MODE == 0) THEN
C          SIGNED 8 BIT INTEGER CCP4 (MRC) INPUT FILE

           DO IZ = 1,NZ
             DO IY = 1,NY
                IREC    = IRECSTK + (IZ  -1) * NY + IY

C               IPOSMRC = IOFFSET + (IREC-1) * NX + 1

                IPOSMRC = (IREC-1)    ! KLUDGE FOR INTEGER *8 PRESERVE
                IPOSMRC = IPOSMRC * NX
                IPOSMRC = IOFFSET + IPOSMRC + 1

                READ(LUNMRC, POS=IPOSMRC,IOSTAT=IERR) I1STREAMBUF

                DO IX = 1,NX
                   IVAL = I1STREAMBUF(IX)
                   IF (IVAL < 0) IVAL = 256 + IVAL
                   STREAMBUF(IX) = IVAL
                ENDDO
  
                !if (irec == 1) then
                !   write(6,*)' ',iposmrc,i1streambuf(1),streambuf(1)
                !endif

                IRECSPI = IRECSPI + IRECINC
                !write(6,*) ' irecspi:',irecspi
                CALL WRTLIN(LUNSPI,STREAMBUF,NX,IRECSPI)

              ENDDO ! END OF: IY = 1,NY
           ENDDO    ! END OF: IZ = 1,NZ

        ELSEIF (MODE == 1 .OR. MODE == 6) THEN
C         16 BIT INTEGER CCP4 (MRC) INPUT FILE

          FOLD = (MODE == 1)
          !write(6,*) 'Flip & fold:',flip,fold

          DO IZ = 1,NZ
             DO IY = 1,NY
                IREC    = IRECSTK + (IZ  -1) * NY + IY

c               IPOSMRC = IOFFSET + (IREC-1) * NX * 2 + 1

                IPOSMRC = (IREC-1)    ! KLUDGE FOR INTEGER *8 PRESERVE
                IPOSMRC = IPOSMRC * NX
                IPOSMRC = IPOSMRC * 2
                IPOSMRC = IOFFSET + IPOSMRC + 1

                READ(LUNMRC, POS=IPOSMRC,IOSTAT=IERR) I2STREAMBUF

                IF (FLIP .AND. FOLD) THEN
C                  INVERT BYTE ORDER & CONVERT SIGNED INTEGER TO UNSIGNED
                   DO IX = 1,NX
                      I2V           = I2STREAMBUF(IX)
                      I1TMP         = I1V(1)
                      I1V(1)        = I1V(2)
                      I1V(2)        = I1TMP

C                     FOLD CONVERTS SIGNED INTEGER TO UNSIGNED
                      IF (I2V < 0) I2V = 65536 + I2V

                      STREAMBUF(IX) = I2V
                   ENDDO

                ELSEIF (FOLD) THEN
C                  CONVERT SIGNED INTEGER TO UNSIGNED
                   DO IX = 1,NX
                      I2V = I2STREAMBUF(IX)
                      IF (I2V < 0) I2V = 65536 + I2V
                      STREAMBUF(IX) = I2V
                   ENDDO

                ELSEIF (FLIP) THEN
C                  INVERT BYTE ORDER
                   DO IX = 1,NX
                      I2V           = I2STREAMBUF(IX)
                      I1TMP         = I1V(1)
                      I1V(1)        = I1V(2)
                      I1V(2)        = I1TMP
                      STREAMBUF(IX) = I2V
                   ENDDO

                ELSE
C                  NO CONVERSION
                   STREAMBUF = I2STREAMBUF
                ENDIF

#ifdef NEVER
                do ix = 1,nx
                   if (streambuf(ix) < imin) then
                      imin2  = imin
                      ixmin2 = ixmin
                      iymin2 = iymin
                      imin   = streambuf(ix)
                      ixmin  = ix
                      iymin  = iy
                   endif
                   if (streambuf(ix) > imax) then
                      imax2  = imax
                      ixmax2 = ixmax
                      iymax2 = iymax
                      imax   = streambuf(ix)
                      ixmax  = ix
                      iymax  = iy
                   endif
                enddo
#endif

C               PUT OUT COMPLETED RECORD
                IRECSPI = IRECSPI + IRECINC
                CALL WRTLIN(LUNSPI,STREAMBUF,NX,IRECSPI)

              ENDDO
           ENDDO

#ifdef NEVER
           write(6,*) 'maxs: ',ixmax,iymax,imax
           write(6,*) 'maxs2:',ixmax2,iymax2,imax2
           write(6,*) 'mins: ',ixmin,iymin,imin
           write(6,*) 'mins2:',ixmin2,iymin2,imin2
#endif

        ELSEIF (MODE == 2) THEN
C          32 BIT FOATING POINT CCP4 MRC INPUT FILE

           DO IZ = 1,NZ
             DO IY = 1,NY
                IREC    = IRECSTK + (IZ  -1) * NY + IY
c               IPOSMRC = IOFFSET + (IREC-1) * NX * 4 + 1
                      
                IPOSMRC = (IREC-1)    ! KLUDGE FOR INTEGER *8 PRESERVE
                IPOSMRC = IPOSMRC * NX
                IPOSMRC = IPOSMRC * 4
                IPOSMRC = IOFFSET + IPOSMRC + 1

                READ(LUNMRC, POS=IPOSMRC,IOSTAT=IERR) STREAMBUF
                !if (irec ==1) write(6,*) ' Val:',iposmrc, streambuf(1)
                !write(6,*) ' irec,iposmrc:',irec,iposmrc

                IF (FLIP) THEN
C                  INVERT BYTE ORDER
                   DO IX = 1,NX
                      R4VALIN       = STREAMBUF(IX)
                      I1VALOUT(1)   = I1VALIN(4)
                      I1VALOUT(2)   = I1VALIN(3)
                      I1VALOUT(3)   = I1VALIN(2)
                      I1VALOUT(4)   = I1VALIN(1)
                      STREAMBUF(IX) = R4VALOUT
                   ENDDO
                ENDIF

C               PUT OUT COMPLETED RECORD
                IRECSPI = IRECSPI + IRECINC
                CALL WRTLIN(LUNSPI,STREAMBUF,NX,IRECSPI)

              ENDDO
           ENDDO

        ELSE
           CALL ERRT(102,'CAN NOT COPY MRC MODE',MODE)
        ENDIF

        IF (.NOT. WANTSTACK) EXIT    ! FINISHED IF NOT A MRC STACK

C       OPEN NEXT STACKED OUTPUT FILE 
        CALL NEXTFILE(ISTACK, ILIST, 
     &                FOUROK,LUNXM,
     &                NSTACK,MAXIM,   
     &                LUNSPI,0,
     &                FILPAT,'N',
     &                IMGNUMOUT, IRTFLG) 

        IF (ISTACK > NSTACK) EXIT    ! FINISHED 
        IF (IRTFLG == -99) THEN
           CALL ERRT(102,'INSUFFICIENT OUTPUT FILE NAMES',NSTACK)
           EXIT         
        ELSEIF (IRTFLG .NE. 0) THEN
           EXIT                      ! ERROR
        ENDIF

       ENDDO   ! END OF STACK LOOP --------------------------

       GOTO 9999

	



C      COPY FROM SPIDER TO MRC FILE FORMAT ----------------- TO MRC

1000   CONTINUE

C	OPEN NEW MRC FILE FOR DIRECT ACCESS, RECORD LENGTH 1024 BYTES
d115 6
d122 1
a122 1
        IBOTLEF = 0
d124 1
a124 2
     &       'MRC DATA LENGTH (8/32 BITS), FLIP TOP/BOTTOM =1 (0/1)',
     &        IRTFLG)
d126 1
d129 1
d132 1
a132 1
C	CREATE A NEW HEADER FOR THE CCP4 FILE
d152 7
d160 4
a163 1
C	CREATE HEADER. (NOTE: FMIN, FMAX, AV ARE SAME AS SPIDER IMAGE)
d165 3
a167 1
     &            FMINT,FMAXT,FAVT,FSIGT,SCALE,MODE,ISSWABT,IRTFLG)
d170 1
a170 1
C	WRITE HEADER OF 1024 BYTES (256 FLOATS) TO MRC FILE
d211 1
a211 1
 	
d224 1
a224 1
C             PUT ROW OUT TO CCP4 FILE
d260 1
a260 1
	
d268 26
a293 1
C       -------------- ISSWAB ----------------------------------------
d295 1
a295 1
        LOGICAL FUNCTION ISSWAB(LUN)
d300 2
a301 3
        INTEGER,DIMENSION(3) ::  IVAL
        CHARACTER(LEN=12) ::     CVAL,CVALIN
        EQUIVALENCE(IVAL,CVAL)
d303 2
a304 2
        CHARACTER(LEN=MAXNAM) :: FILNAM
        LOGICAL ::               VERBOSE_SAVE
d306 22
a327 1
        CHARACTER(LEN=1) ::      NULL = CHAR(0)
d329 5
a333 3
C       DO NOT ECHO FILE OPENING
        VERBOSE_SAVE = VERBOSE
        VERBOSE      = .FALSE.
d335 6
a340 2
        FILNAM = 'TMP_JNK_SCRATCH'
        CALL OPAUXFILE(.FALSE.,FILNAM,NULL,LUN,12,'U',' ',.TRUE.,IRTFLG)
d342 3
a344 12
        CVAL(1:1)   = CHAR(0)
        CVAL(2:2)   = CHAR(0)
        CVAL(3:3)   = CHAR(0)
        CVAL(4:4)   = CHAR(4)
        CVAL(5:5)   = CHAR(48)
        CVAL(6:6)   = CHAR(48)
        CVAL(7:7)   = CHAR(49)
        CVAL(8:8)   = CHAR(50)
        CVAL(9:9)   = CHAR(0)
        CVAL(10:10) = CHAR(0)
        CVAL(11:11) = CHAR(0)
        CVAL(12:12) = CHAR(4)
d346 31
a376 2
        CALL WRTLIN(LUN,IVAL,3,1)
        CLOSE(LUN)
d378 2
a379 1
        CALL OPAUXFILE(.FALSE.,FILNAM,NULL,LUN,0,'O',' ',.TRUE.,IRTFLG)
d381 4
a384 1
        READ(LUN,*) CVALIN
d386 1
a386 1
        CLOSE(LUN,STATUS='DELETE')
d388 1
a388 3
c       WRITE(NOUT,*) 'CVALIN: ',CVALIN,' == ',CVAL
 
        ISSWAB   = (CVALIN(8:8) .NE. CVAL(8:8))
d390 1
a390 5
c        IF (ISSWAB) THEN
c           WRITE(NOUT,*) 'NON-NATIVE BYTE ORDER '
c        ELSE
c           WRITE(NOUT,*) 'NATIVE BYTE ORDER'
c        ENDIF
d392 3
a394 1
        VERBOSE = VERBOSE_SAVE
d396 4
a399 1
        END
d401 2
a402 1
C       --------------  OPSTREAMFILE ------------------------------
d404 1
a404 3
         SUBROUTINE OPSTREAMFILE(ASKNAME,FILNAM,EXTENT,LUNT,
     &                           FORMVAR, DISP, 
     &                           PROMPTT,CALLERRT,IRTFLG)
d406 5
d412 4
a415 80
        IMPLICIT NONE

        INCLUDE 'CMBLOCK.INC'

        
        LOGICAL           :: ASKNAME
        CHARACTER(LEN=*)  :: FILNAM,EXTENT
        INTEGER           :: LUNT
        CHARACTER(LEN=11) :: FORMVAR
        CHARACTER(LEN=*)  :: DISP,PROMPTT
        LOGICAL           :: CALLERRT
        INTEGER           :: IRTFLG

        LOGICAL           :: EX
        CHARACTER(LEN=96) :: PROMPT
        CHARACTER(LEN=80) :: EXTEN
        CHARACTER(LEN=7)  :: STATVAR

        INTEGER           :: ICOMM,MYPID,MPIERR,LENP,NCHAR
        INTEGER           :: LNBLNKN
        INTEGER           :: LENE,IRTFLGT,LUN,IDUM,LENOPEN,LENOPENFILE
        INTEGER           :: LENOPN,LENREC

        CALL SET_MPI(ICOMM,MYPID,MPIERR) ! SETS ICOMM AND MYPID  #ifdef USE_MPI

C       SET DEFAULT ERROR RETURN
        IRTFLG = 1

C       DO NOT WANT TO RETURN EXTEN
        EXTEN = EXTENT

C       INPUT FILE NAME (IF EXTEN EXISTS IT IS ADDED)

        IF (ASKNAME) THEN
C          SET PROMPT TO ALLOW FILE EXTENSION ON INPUT
           LENP   = LEN(PROMPTT)
           LENP   = MIN(LENP,93)
           PROMPT = PROMPTT(1:LENP) // '~9' 

           CALL FILERD(FILNAM,NCHAR,EXTEN,PROMPT(1:LENP+2),IRTFLG)
           IF (IRTFLG .NE. 0) RETURN
        ELSE
C          MAY WANT TO ADD EXTENT TO FILNAM
           NCHAR = LNBLNKN(FILNAM)
           LENE  = LNBLNKN(EXTENT)
           IF (LENE > 0) THEN
C             ADD THE EXTENSION THAT IS SENT TO FILNAM
              CALL FILNAMANDEXT(FILNAM,EXTEN,FILNAM,NCHAR,
     &                          .TRUE.,IRTFLGT)
           ENDIF
        ENDIF

        LUN = ABS(LUNT)
        IF ((LUN <= 0 .OR. LUN > 100) .AND.
     &     (LUN .NE. 103)) THEN
C          LUN=103 USED IN  SYMPARTEXT 
           CALL ERRT(102,'IN SOURCE CODE, LUN MUST BE 1...100',LUN)
           RETURN
        ENDIF

        IF (LUN > 0 .AND. LUN <= 100) THEN
C          ZERO THE FLAGS USED IN REDLIN/WRTLIN
           CALL LUNSETLUNS(LUN,0,0,LUN,0,IRTFLGT)
 
C          MAKE SURE THIS IS NOT TREATED AS INLINE FILE
           CALL CLOSEINLN(LUN,IRTFLGT)
        ENDIF

C       SET STATUS FOR OPEN
        STATVAR = 'NEW'

        IF (DISP(1:1) == 'N' .OR. DISP(1:1) == 'U') 
     &     STATVAR = 'REPLACE'

        IF (DISP(1:1) == 'S') STATVAR = 'SCRATCH'

        IF (DISP(1:1) == 'O') THEN
C          CHECK FOR FILE EXISTENCE 
           IF (MYPID <= 0) THEN
              INQUIRE (FILE=FILNAM(1:NCHAR),EXIST=EX,IOSTAT=IRTFLGT) 
a416 10

#ifdef USE_MPI
           CALL BCAST_MPI('OPSTREAMFILE','EX',           EX,1,'L',ICOMM)
           CALL BCAST_MPI('OPSTREAMFILE','IRTFLGT', IRTFLGT,1,'I',ICOMM)
#endif

           IF (IRTFLGT .NE. 0) THEN
              WRITE(NOUT,*) '*** INQUIRY ERROR'
              IF (CALLERRT)  CALL ERRT(4,'OPSTREAMFILE',IDUM)
              RETURN
d418 3
a420 23
           ELSEIF (.NOT. EX) THEN
              WRITE(NOUT,*) '*** FILE DOES NOT EXIST: ',FILNAM(1:NCHAR)
              IF (CALLERRT)  CALL ERRT(100,'OPSTREAMFILE',IDUM)
              RETURN

           ENDIF
           STATVAR = 'OLD'
        ENDIF

C       OPEN FILE FOR STREAM ACCESS

C       COMPUTE RECL UNITS (DIFFERS WITH OS &A COMPILER FLAGS)
        LENOPN = LENOPENFILE(LENREC)

        IF (MYPID <= 0) THEN
           IF (STATVAR == 'SCRATCH') THEN
	      OPEN(UNIT=LUN,STATUS=STATVAR,
     &             FORM=FORMVAR, ACCESS='STREAM',
     &             IOSTAT=IRTFLGT)
           ELSE
	      OPEN(UNIT=LUN,FILE=FILNAM(1:NCHAR),STATUS=STATVAR,
     &             FORM=FORMVAR, ACCESS='STREAM', 
     &             IOSTAT=IRTFLGT)
a421 1
        ENDIF
d423 15
a437 3
#ifdef USE_MPI
        CALL BCAST_MPI('OPSTREAMFILE','IRTFLGT', IRTFLGT,1, 'I',ICOMM)
#endif
d439 1
a440 6
        IF (IRTFLGT .NE. 0) THEN
           WRITE(NOUT,90) FORMVAR(1:1), FILNAM(:NCHAR)
 90        FORMAT(' ERROR OPENING (',A1,'): ',A)
           IF (CALLERRT) CALL ERRT(102,'OPSTREAMFILE',IRTFLGT)
           RETURN
        ENDIF
a441 8
        IF (VERBOSE .AND. MYPID <= 0) THEN
           WRITE(NOUT,91) FORMVAR(1:1), FILNAM(:NCHAR)
 91        FORMAT('  OPENED (',A1,'): ',A)
        ENDIF

        IRTFLG = 0

        END
@


1.29
log
@==,  stack support, speed bug fixed, ..
@
text
@d16 1
d21 1
a21 1
C=* Copyright 1985-2014  Health Research Inc.,                         *
d100 1
a100 1
        INTEGER                 :: IPOSMRC,IX,IY,IZ,NLET,LOCAT,LOCAST
d104 2
d269 6
a274 1
                IPOSMRC = IOFFSET + (IREC-1) * NX + 1
d304 7
a310 1
                IPOSMRC = IOFFSET + (IREC-1) * NX * 2 + 1
d392 6
a397 1
                IPOSMRC = IOFFSET + (IREC-1) * NX * 4 + 1
@


1.28
log
@*** empty log message ***
@
text
@d4 12
a15 11
C COPYCCP4                 MODIFIED FROM COPYMRC FEB 02 ArDean Leith         
C                          ISSWAB ADDED          JUL 02 ArDean Leith
C                          FLIP QUESTION         MAR 03 ArDean Leith
C                          BAD IRECMRC4 & FLIP   SEP 03 ArDean Leith
C                          SCALING               JAN 05 ArDean Leith
C                          I*8                   SEP 08 ArDean Leith
C                          NPIX8                 DEC 08 ArDean Leith
C                          BOTLEFT OPTION        MAY 12 ArDean Leith
C                          STREAM IO             FEB 13 ArDean Leith
C                          VOL BUG               JUN 13 ArDean Leith
C                          VOL BUG FIXED         JUL 13 ArDean Leith
d20 1
a20 1
C=* Copyright 1985-2013  Health Research Inc.,                         *
d43 6
a48 4
C NOTES: DATA IN MRC FILE:
C	 MODE   0 : IMAGE STORED AS INTEGER*1  
C               1 : IMAGE STORED AS INTEGER*2
C               2 : IMAGE STORED AS REALS
d60 1
a60 1
        COMMON /IOERR/  IERR
d65 1
a65 1
        INTEGER                 :: LUNSPI,LUNMRC,NX,NY,NZ
d67 1
a67 1
        REAL, ALLOCATABLE       :: STREAMBUF(:)
d70 1
d75 3
a77 4
        INTEGER *8              :: NPIX8,NEED8,IGOT8,NT8

        CHARACTER(LEN=MAXNAM)   :: FILNAM,MRCFILE
	CHARACTER(LEN=80)       :: ANS
d87 1
a87 1
        REAL *4                 :: R4VALIN,R4VALOUT
d93 1
a93 1
        INTEGER                 :: NSYMBT,MACHST,NE,MAXIM,IOFFSET,MODEA 
d95 1
a95 2
        INTEGER                 :: ILOCCCCP,NVAL,IBOTLEF,NOT_USED 
        INTEGER                 :: ILOCSPI,ILOCMRC,IRECINC,ILOCOUT
d99 13
a111 2
        INTEGER                 :: IPOSMRC,IX,IY,IZ
    
d143 67
a209 7
C       OPEN SPIDER OUTPUT FILE	
        IFORM  = 1
        IF (NZ > 1) IFORM = 3
        MAXIM  = 0
        CALL OPFILEC(0,.TRUE.,FILNAM,LUNSPI,'U',IFORM,NX,NY,NZ,
     &             MAXIM,'SPIDER OUTPUT',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9999
d214 2
a215 3
C       NPIX8 = TOTAL NUMBER OF PIXELS IN MRC FILE
        NPIX8 = NX * NY     ! DO NOT SIMPLIFY, COMPILER WRONG
        NPIX8 = NPIX8 * NZ
d217 2
a218 2
C       CHANGE MODE: 0,1,2 TO MODEA: 8,16,32
        MODEA = (2**(MODE + 1)) * 4
d220 1
a220 5
        IF (MODEA == 8) THEN
           ALLOCATE(I1STREAMBUF(NX), STREAMBUF(NX),STAT=IRTFLG)
        ELSEIF (MODEA == 16) THEN
           ALLOCATE(I2STREAMBUF(NX), STREAMBUF(NX),STAT=IRTFLG)
        ELSE
d222 3
d226 1
d234 1
a234 2
     &                    'UNFORMATTED','O', ' ',.TRUE.,IRTFLG)

d238 1
a238 1
     &           'FLIP BYTE ORDERING? (Y/N), INVERT TOP/BOTTEM? (Y/N)',
d244 1
a244 1
        ! USUAL MRC BOTTEM!!
d247 1
a247 2
c        write(6,*)' modea,lenop,NPIX8:',
c     &              modea,lenopen,NPIX8,NX,NY,NZ
d249 1
d252 1
d256 1
a256 1
            IRECSPI = NY*NZ + 1
d260 2
a261 2
        IF (MODEA == 8) THEN
C          8 BIT INTEGER CCP4 (MRC) INPUT FILE
d265 1
a265 1
                IREC    = (IZ -1) * NY + IY
d273 1
a273 1
                   STREAMBUF = IVAL
d284 5
a288 2
              ENDDO
           ENDDO
d290 2
a291 2
        ELSEIF (MODEA == 16) THEN
C          16 BIT INTEGER CCP4 (MRC) INPUT FILE
d295 1
a295 1
                IREC    = (IZ -1) * NY + IY
a298 2
                !if (irec ==1) write(6,*)' Val:',iposmrc,i2streambuf(1)
                !write(6,*) ' irec,iposmrc:',irec,iposmrc
d300 23
a322 1
                IF (FLIP) THEN
d330 5
a334 1
                    ENDDO
d337 20
a356 5
                DO IX = 1,NX
                   IVAL = I2STREAMBUF(IX)
                   IF (IVAL < 0) IVAL = 256 + IVAL
                   STREAMBUF = IVAL
                ENDDO
d365 8
a372 1
        ELSEIF (MODEA == 32) THEN
d375 1
a375 1
          DO IZ = 1,NZ
d377 1
a377 1
                IREC    = (IZ -1) * NY + IY
d407 21
a427 1
        GOTO 9999
d433 1
a433 1
C       COPY FROM SPIDER TO MRC FILE FORMAT ----------------- TO MRC
d435 1
a435 1
1000    CONTINUE
d446 1
a446 1
     &       'MRC DATA LENGTH (8/32 BITS), FLIP TOP/BOTTEM =1 (0/1)',
d451 1
a451 1
        BOTLEFT = (IBOTLEF > 0)   ! USUAL MRC BOTTEM!!
a665 4
#ifdef USE_MPI
        INCLUDE 'mpif.h'
#endif

d726 2
a727 10
           CALL MPI_BCAST(EX, 1, MPI_LOGICAL, 0, ICOMM, MPIERR)
           IF (MPIERR .NE. 0) THEN
              WRITE(0,*) 'OPSTREAMFILE: FAILED TO BCAST EX'
              STOP
           ENDIF 
           CALL MPI_BCAST(IRTFLGT, 1, MPI_INTEGER, 0, ICOMM, MPIERR)
           IF (MPIERR .NE. 0) THEN
              WRITE(0,*) 'OPSTREAMFILE: FAILED TO BCAST IRTFLGT'
              STOP
           ENDIF 
d762 1
a762 5
        CALL MPI_BCAST(IRTFLGT, 1, MPI_INTEGER, 0, ICOMM, MPIERR)
        IF (MPIERR .NE. 0) THEN
           WRITE(0,*) 'OPSTREAMFILE: FAILED TO BCAST IRTFLGT'
           STOP
        ENDIF 
d764 1
@


1.27
log
@*** empty log message ***
@
text
@d167 2
a168 2
     &             'FLIP BYTE ORDERING? (Y/N), FLIP TOP/BOTTEM? (Y/N)',
     &              NULL,IRTFLG)
@


1.26
log
@invert bug fixed for all known cases
@
text
@d167 1
a167 1
     &             'FLIP BYTE ORDERING? (Y/N), FLIP TOP/BOTTEM (Y/N)',
@


1.25
log
@IPOSMRC = IOFFSET + (IREC-1)*NX*4 + 1
@
text
@d13 2
d40 1
d42 1
a42 1
C NOTES: DATA IN CCP4 FILE:
d59 1
a59 1
        REAL                  :: BUFIN
d62 1
a62 1
        INTEGER               :: LUNSPI,LUNMRC,NX,NY,NZ
d64 34
a97 26
        REAL, ALLOCATABLE     :: STREAMBUF(:)
        REAL                  :: BUF(NBUFSIZ),FIXLENBUF(256)
        INTEGER * 1           :: I1BUF(1024)
        COMMON                   BUF,FIXLENBUF,I1BUF

        INTEGER * 8           :: NPIX8,NEED8,IGOT8,NT8

        CHARACTER(LEN=MAXNAM) :: FILNAM,MRCFILE
	CHARACTER(LEN=80)     :: ANS
        LOGICAL               :: FLIP,ISSWABT,ISSWAB,BOTLEFT
        INTEGER * 2           :: I2VAL

        REAL *4               :: R4VALIN,R4VALOUT
        INTEGER *1            :: I1VALIN(4),I1VALOUT(4)
        EQUIVALENCE              (R4VALIN,I1VALIN),(R4VALOUT,I1VALOUT)
 
	CHARACTER(LEN=1)      :: NULL = CHAR(0)
        INTEGER               :: IERR,LENOPENB,LENOPENF,IRTFLG,MODE
        INTEGER               :: NSYMBT,MACHST,NE,MAXIM,IOFFSET,MODEA 
        INTEGER               :: LENOPEN,NCHAR,IRECMRC,IRECSPI
        INTEGER               :: ILOCCCCP,NVAL,IVAL,IBOTLEF,NOT_USED 
        INTEGER               :: ILOCSPI,ILOCMRC,IRECINC,ILOCOUT
        INTEGER               :: IRECIN,ILOCIN,IRECINT
        REAL                  :: RMS,FMINT,FMAXT,FAVT,FSIGT,FN,FNCON
        REAL                  :: UNUSED,SCALE
        INTEGER               :: IPOSMRC,IX
d107 1
a107 1
C       COPY FROM MRC TO SPIDER FILE FORMAT --------------- FROM CCP4
d127 2
d148 4
a151 8
C       CLOSE MRC FILE
        CLOSE(LUNMRC)

        IF (MODEA == 8 .OR. MODEA == 16) THEN
C          REOPEN MRC FILE AS NX*MODEA/8 BYTE, DIRECT ACCESS, UNFORMATTED
           LENOPEN = NX * (MODEA / 8)
           CALL OPAUXFILE(.FALSE.,MRCFILE,NULL,LUNMRC,LENOPEN,'O',
     &                   ' ',.TRUE.,IRTFLG)
d154 5
a158 4
           IF (IRTFLG .NE. 0) THEN
              CALL ERRT(46,'COPYCCP4; STREAMBUF',NX)
              GOTO 9999
           ENDIF
d160 3
a162 4
C          OPEN FOR STREAM ACCESS
           CALL OPSTREAMFILE(.FALSE.,MRCFILE,NULL,LUNMRC,
     &                       'UNFORMATTED','O', ' ',.TRUE.,IRTFLG)
        ENDIF
d166 1
a166 1
        CALL  RDPRMC(ANS,NCHAR,.TRUE.,
d179 9
d189 1
a189 3
C          8 BIT INTEGER CCP4 INPUT FILE
           CALL RAW8TOSPI(LUNMRC,LUNSPI,NX,NPIX8,IOFFSET,.TRUE.,
     &                   LENOPEN,BUF,IRTFLG)
d191 4
a194 2
        ELSEIF (MODEA == 16) THEN
C          16 BIT INTEGER MRC FILE (HEADER LENGTH DIVISABLE BY TWO)
d196 1
a196 4
           IF (IRTFLG .NE. 0) GOTO 9999
           FLIP = .NOT. FLIP
           CALL RAW16TOSPI(LUNMRC,LUNSPI,NX,NPIX8,IOFFSET,FLIP,
     &                   .FALSE.,LENOPEN,BUF,IRTFLG)
d198 13
a210 2
        ELSEIF (MODEA == 32) THEN
C          32 BIT FOATING POINT MRC INPUT FILE
d212 2
a213 6
          IRECSPI = 0
          IRECINC = 1
          IF (BOTLEFT) THEN
             IRECSPI = NY + 1
             IRECINC = -1
          ENDIF
d215 2
a216 2
          DO IREC = 1,NY*NZ
             IPOSMRC = IOFFSET + (IREC-1)*NX*4 + 1
d218 19
a236 1
            !write(6,*) ' irec,iposmrc:',irec,iposmrc
a237 5
             READ(LUNMRC, POS=IPOSMRC,IOSTAT=IERR) STREAMBUF
             !if (irec ==1) write(6,*) ' Val:',iposmrc, streambuf(1)

             IF (FLIP) THEN
C               INVERT BYTE ORDER
d239 3
a241 6
                   R4VALIN       = STREAMBUF(IX)
                   I1VALOUT(1)   = I1VALIN(4)
                   I1VALOUT(2)   = I1VALIN(3)
                   I1VALOUT(3)   = I1VALIN(2)
                   I1VALOUT(4)   = I1VALIN(1)
                   STREAMBUF(IX) = R4VALOUT
a242 1
             ENDIF
d244 3
a246 7
C            PUT OUT COMPLETED RECORD
             IRECSPI = IRECSPI + IRECINC
             CALL WRTLIN(LUNSPI,STREAMBUF,NX,IRECSPI)

c            itmp = mod(irecspi,NY)
c            if (itmp == 0) write(6,999) irecspi,buf(NX)
999          format(i10,' ; ',1pg13.7)
d248 33
a280 2
          ENDDO
          !write(6,*) ' irec,iposmrc:',irec,iposmrc
d381 1
a381 1
C          COPY FROM SPIDER TO MRC  8 BIT FILE FORMAT 
d383 1
a383 1
           DO  IRECIN = 1,NY * NZ
d653 1
a653 1
        RETURN
a654 1

@


1.24
log
@mpi header needed
@
text
@d194 1
a194 1
             IPOSMRC = IOFFSET + (IREC-1)*NX*4 + 0
@


1.23
log
@OPSTREAMFILE used for 32 bit mrc --> spider conversion
@
text
@d467 4
@


1.22
log
@bot left option added
@
text
@d12 1
d17 1
a17 1
C=* Copyright 1985-2012  Health Research Inc.,                         *
d61 1
d86 1
a86 1

d93 1
a93 1
        IF (FCHAR(4:5)  .EQ. 'TO')      GOTO 1000
d138 17
a154 4
C       REOPEN MRC FILE AS NX*MODEA/8 BYTE, DIRECT ACCESS, UNFORMATTED
        LENOPEN = NX * (MODEA / 8)
        CALL OPAUXFILE(.FALSE.,MRCFILE,NULL,LUNMRC,LENOPEN,'O',
     &                ' ',.TRUE.,IRTFLG)
a185 6
          IOFFSET = IOFFSET / 4
          IRECMRC = 0
          ILOCSPI = 0
          ILOCMRC = NX + 1
          IGOT8   = 0

a191 6
    
C         NEED8 IS TOTAL NUMBER OF BYTES TO BE READ INCLUDING HEADER
          NEED8 = NPIX8 + IOFFSET

          DO WHILE (IGOT8 < NEED8)
             ILOCMRC = ILOCMRC + 1
d193 2
a194 7
             IF (ILOCMRC > NX) THEN
C               NEED TO READ NEW RECORD FROM INPUT
                NVAL = NX
                NT8  = NEED8 - IGOT8
                IF (NT8 .LT. NX) NVAL = NT8
                IRECMRC = IRECMRC + 1
                CALL REDLIN(LUNMRC,FIXLENBUF,NVAL,IRECMRC)
d196 1
a196 2
c               if(IRECMRC .le. 10)write(6,998)IRECMRC,nval,FIXLENBUF(nval)
998             format(' irec,nval,: ',2i10,' ; ',1pg13.7)
d198 2
a199 5
                ILOCMRC = 1
             ENDIF

C            IGOT8 POINTS TO CURRENT WORD IN INPUT FILE
             IGOT8 = IGOT8 + 1
d201 10
a210 15
             IF (IGOT8 > IOFFSET) THEN
C               WANT THIS VALUE FOR AN OUTPUT PIXEL
                ILOCSPI = ILOCSPI + 1
                IF (FLIP) THEN
C                  INVERT BYTE ORDER
                   R4VALIN      = FIXLENBUF(ILOCMRC)
                   I1VALOUT(1)  = I1VALIN(4)
                   I1VALOUT(2)  = I1VALIN(3)
                   I1VALOUT(3)  = I1VALIN(2)
                   I1VALOUT(4)  = I1VALIN(1)
                   BUF(ILOCSPI) = R4VALOUT
                ELSE
C                  NO FLIP
                   BUF(ILOCSPI) = FIXLENBUF(ILOCMRC)
                ENDIF
d213 7
a219 9
             IF (ILOCSPI >= NX) THEN
C               PUT OUT COMPLETED RECORD
                IRECSPI = IRECSPI + IRECINC
                CALL WRTLIN(LUNSPI,BUF,NX,IRECSPI)
                ILOCSPI = 0

c          itmp = mod(irecspi,NY)
c          if (itmp .eq. 0) write(6,999) irecspi,buf(NX)
999       format(i10,' ; ',1pg13.7)
a220 1
             ENDIF
d222 1
d373 1
d437 66
d504 3
d508 86
@


1.21
log
@nx, mrc not ccp4 labels,  prompts updated
@
text
@d7 1
a7 1
C                          BAD IRECCCP4 & FLIP   SEP 03 ArDean Leith
d11 1
d16 1
a16 1
C=* Copyright 1985-2010  Health Research Inc.,                         *
d34 1
a34 1
C COPYCCP4(LUNSPI,LUNCCP4,NX,NY,NZ)
d46 3
a48 1
        SUBROUTINE COPYCCP4(LUNSPI,LUNCCP4,NX,NY,NZ)
d54 2
d58 6
a64 2
        INTEGER * 1           :: I1BUF
        COMMON                BUF(NBUFSIZ),FIXLENBUF(256),I1BUF(1024)
d66 3
a68 3
        CHARACTER(LEN=MAXNAM) :: FILNAM,CCP4FILE
	CHARACTER(LEN=1)      :: NULL,ANS
        LOGICAL               :: FLIP,ISSWABT,ISSWAB
d75 11
a85 1
        NULL = CHAR(0)
d94 1
a94 1
C       COPY FROM CCP4 TO SPIDER FILE FORMAT --------------- FROM CCP4
d96 1
a96 1
C       OPEN CCP4 FILE AS DIRECT ACCESS, UNFORMATTED, RECL=1024 BYTES
d99 1
a99 1
        CALL OPAUXFILE(.TRUE.,CCP4FILE,DATEXC,LUNCCP4,LENOPENB,'O',
d104 1
a104 1
        CALL REDLIN(LUNCCP4,FIXLENBUF,LENOPENF,1)
d110 1
a110 2
C           NOT CURRENT CCP4 FORMAT
            CALL ERRT(101,'NOT CURRENT MRC FORMAT, TRY OLD MRC FORMAT',
d117 1
a117 1
        IF (NZ .GT. 1) IFORM = 3
d134 1
a134 1
        CLOSE(LUNCCP4)
d138 1
a138 1
        CALL OPAUXFILE(.FALSE.,CCP4FILE,NULL,LUNCCP4,LENOPEN,'O',
d142 9
a150 3
        CALL  RDPRMC(ANS,NCHAR,.TRUE.,'FLIP BYTE ORDERING? (Y/N)',
     &               NULL,IRT)
        IF (ANS .EQ. 'Y') FLIP = .NOT. FLIP
d157 1
a157 1
           CALL RAW8TOSPI(LUNCCP4,LUNSPI,NX,NPIX8,IOFFSET,.TRUE.,
d161 1
a161 1
C          16 BIT INTEGER CCP4 FILE (HEADER LENGTH DIVISABLE BY TWO)
d165 1
a165 1
           CALL RAW16TOSPI(LUNCCP4,LUNSPI,NX,NPIX8,IOFFSET,FLIP,
d169 1
a169 1
C          32 BIT FOATING POINT CCP4 INPUT FILE
d172 5
a176 1
          IRECCCP = 0
d178 6
a183 4
          ILOCSPI = 0
          ILOCCCP = NX + 1
          IGOT8    = 0
          
d188 3
a190 2
             ILOCCCP = ILOCCCP + 1
             IF (ILOCCCP .GT. NX) THEN
d195 2
a196 2
                IRECCCP = IRECCCP + 1
                CALL REDLIN(LUNCCP4,FIXLENBUF,NVAL,IRECCCP)
d198 1
a198 1
c            if(IRECCCP .le. 10)write(6,998)IRECCCP,nval,FIXLENBUF(nval)
d201 1
a201 1
                ILOCCCP = 1
d207 1
a207 1
             IF (IGOT8 .GT. IOFFSET) THEN
d212 1
a212 1
                   R4VALIN      = FIXLENBUF(ILOCCCP)
d220 1
a220 1
                   BUF(ILOCSPI) = FIXLENBUF(ILOCCCP)
d224 1
a224 1
             IF (ILOCSPI .GE. NX) THEN
d226 1
a226 1
                IRECSPI = IRECSPI + 1
d238 1
a238 1
           CALL ERRT(102,'CAN NOT COPY CCP4 MODE',MODE)
d245 2
d254 1
a254 1
        CALL OPAUXFILE(.TRUE.,CCP4FILE,DATEXC,LUNCCP4,LENOPENB,'U',
d257 5
a261 3
        IVAL = 8
        CALL RDPRI1S(IVAL,NOT_USED,
     &       'ENTER DATA LENGTH FOR MRC FILE (8 OR 32 BITS)',IRTFLG)
d264 2
a265 1
        IF (IVAL .EQ. 8) MODE = 0
d273 1
a273 1
        IF (MODE .EQ. 0) THEN
d293 2
a294 2
C	WRITE HEADER OF 1024 BYTES (256 FLOATS) TO CCP4 FILE
        CALL WRTLIN(LUNCCP4,FIXLENBUF,LENOPENF,1) 
d297 5
a301 2
        IRECOUT         = 1
        ILOCOUT         = 0
a302 1
        IF (MODE .EQ. 2) THEN
a303 2
C             READ EACH ROW OF SPIDER INPUT FILE   
              CALL REDLIN(LUNSPI,BUFIN,NX,IRECIN)
d305 9
a313 1
C             PUT ROW OUT TO CCP4 FILE
d318 1
a318 1
                IF (ILOCOUT .GE. LENOPENF) THEN
d320 4
a323 2
                   IRECOUT = IRECOUT + 1
                   CALL WRTLIN(LUNCCP4,FIXLENBUF,LENOPENF,IRECOUT)
d329 1
a329 1
           IF (ILOCOUT .GT. 0) THEN
d331 2
a332 2
              IRECOUT = IRECOUT + 1
              CALL WRTLIN(LUNCCP4,FIXLENBUF,ILOCOUT,IRECOUT)
d335 2
a336 2
        ELSEIF (MODE .EQ. 0) THEN
C          COPY FROM SPIDER TO CCP4  8 BIT FILE FORMAT 
d339 7
a345 2
C             READ EACH ROW OF SPIDER INPUT FILE   
              CALL REDLIN(LUNSPI,BUFIN,NX,IRECIN)
d353 1
a353 1
                IF (ILOCOUT .GE. LENOPENB) THEN
d355 3
a357 2
                   IRECOUT = IRECOUT + 1
                   CALL WRTLIN8(LUNCCP4,I1BUF,LENOPENB,IRECOUT)
d359 1
a359 1
                      CALL ERRT(102,'WRITING RECORD',IRECIN)
d367 1
a367 1
           IF (ILOCOUT .GT. 0) THEN
d369 2
a370 2
              IRECOUT = IRECOUT + 1
              CALL WRTLIN8(LUNCCP4,I1BUF,ILOCOUT,IRECOUT)
d374 1
a374 1
           CALL ERRT(102,'CAN NOT CREATE CCP4 MODE',MODE)
d382 1
a382 1
 
d385 1
a385 1
        CLOSE(LUNCCP4)
a386 1
        RETURN
a400 1
        CHARACTER(LEN=1) ::      NULL
d404 1
a404 1
        NULL = CHAR(0)
d408 1
a408 1
        VERBOSE = .FALSE.
@


1.20
log
@GPL_2010
@
text
@d33 1
a33 1
C COPYCCP4(LUNSPI,LUNCCP4,NSAM,NROW,NSLICE)
d45 1
a45 1
        SUBROUTINE COPYCCP4(LUNSPI,LUNCCP4,NSAM,NROW,NSLICE)
d81 1
a81 1
     &                       'CCP4 INPUT',.TRUE.,IRTFLG)
d84 1
a84 1
C       READ CCP4 HEADER 
d87 2
a88 2
C	PARSE CCP4 HEADER	
	CALL GETHEDCCP4(FIXLENBUF,NSAM,NROW,NSLICE,MODE,FMIN,FMAX,
d90 1
a90 1
        IF (IRTFLG .EQ. 2) THEN
d92 2
a93 1
            CALL ERRT(101,'NOT CCP4 FORMAT, TRY OLD MRC FORMAT',NE)
d99 1
a99 1
        IF (NSLICE .GT. 1) IFORM = 3
d101 1
a101 1
        CALL OPFILEC(0,.TRUE.,FILNAM,LUNSPI,'U',IFORM,NSAM,NROW,NSLICE,
d105 1
a105 1
C       EXTRACT DATA FROM CCP4 FILE AFTER HEADER & PUT IN SPIDER FILE
d108 3
a110 3
C       NPIX8 = TOTAL NUMBER OF PIXELS IN CCP4 FILE
        NPIX8 = NSAM * NROW     ! DO NOT SIMPLIFY, COMPILER WRONG
        NPIX8 = NPIX8 * NSLICE
d115 1
a115 1
C       CLOSE CCP4 FILE
d118 2
a119 2
C       REOPEN CCP4 FILE AS NSAM*MODEA/8 BYTE, DIRECT ACCESS, UNFORMATTED
        LENOPEN = NSAM * (MODEA / 8)
d129 1
a129 1
c     &              modea,lenopen,NPIX8,nsam,nrow,nslice
d131 1
a131 1
        IF (MODEA .EQ. 8) THEN
d133 1
a133 1
           CALL RAW8TOSPI(LUNCCP4,LUNSPI,NSAM,NPIX8,IOFFSET,.TRUE.,
d136 1
a136 1
        ELSEIF (MODEA .EQ. 16) THEN
d141 1
a141 1
           CALL RAW16TOSPI(LUNCCP4,LUNSPI,NSAM,NPIX8,IOFFSET,FLIP,
d144 1
a144 1
        ELSEIF (MODEA .EQ. 32) THEN
d151 1
a151 1
          ILOCCCP = NSAM + 1
d157 1
a157 1
          DO WHILE (IGOT8 .LT. NEED8)
d159 1
a159 1
             IF (ILOCCCP .GT. NSAM) THEN
d161 1
a161 1
                NVAL = NSAM
d163 1
a163 1
                IF (NT8 .LT. NSAM) NVAL = NT8
d193 1
a193 1
             IF (ILOCSPI .GE. NSAM) THEN
d196 1
a196 1
                CALL WRTLIN(LUNSPI,BUF,NSAM,IRECSPI)
d199 2
a200 2
c          itmp = mod(irecspi,nrow)
c          if (itmp .eq. 0) write(6,999) irecspi,buf(nsam)
d214 1
a214 1
C       COPY FROM SPIDER TO CCP4 FILE FORMAT ----------------- TO CCP4
d218 1
a218 1
C	OPEN NEW CCP4 FILE FOR DIRECT ACCESS, RECORD LENGTH 1024 BYTES
d222 1
a222 1
     &                 'CCP4 OUTPUT',.TRUE.,IRTFLG)
d226 1
a226 1
     &       'ENTER DATA LENGTH FOR CCP4 FILE (8 OR 32 BITS)',IRTFLG)
d250 1
a250 1
        CALL GETLAB(LUNSPI,NSAM,UNUSED,21,1,SCALE,IRTFLG)
d253 1
a253 1
        CALL SETHEDCCP4(FIXLENBUF, NSAM, NROW, NSLICE,
d260 1
a260 1
C       SET STARTING RECORD FOR CCP4 DATA
d265 1
a265 1
           DO  IRECIN = 1,NROW * NSLICE
d267 1
a267 1
              CALL REDLIN(LUNSPI,BUFIN,NSAM,IRECIN)
d270 1
a270 1
              DO ILOCIN=1,NSAM
d292 1
a292 1
           DO  IRECIN = 1,NROW * NSLICE
d294 1
a294 1
              CALL REDLIN(LUNSPI,BUFIN,NSAM,IRECIN)
d297 1
a297 1
              DO ILOCIN=1,NSAM
@


1.19
log
@integer 8
@
text
@a11 2
C=* FROM: SPIDER - MODULAR IMAGE PROCESSING SYSTEM.   AUTHOR: J.FRANK  *
C=* Copyright (C) 1985-2008  Health Research Inc.                       *
d13 5
a17 2
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *   
C=* ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
d19 1
a19 3
C=* Email:  spider@@wadsworth.org                                       *
C=*                                                                    *
C=* This program is free software; you can redistribute it and/or      *
d24 1
a24 1
C=* This program is distributed in the hope that it will be useful,    *
d26 1
a26 1
C=* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
a27 1
C=*                                                                    *
d29 1
a29 3
C=* along with this program; if not, write to the                      *
C=* Free Software Foundation, Inc.,                                    *
C=* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.      *
@


1.18
log
@ngot8 in 32 bit bug
@
text
@d57 1
a57 1
        INTEGER * 8           :: NPIX8,NEED8,IGOT8
d131 2
a132 1
c       write(6,*)' modea,lenopen,NPIX8,nsam:',modea,lenopen,NPIX8,nsam,nrow,nslice
d163 4
a166 2
C               NEED8 TO READ NEW RECORD FROM INPUT
                NVAL    = MIN(NSAM,NEED8-IGOT8)
d169 4
d201 5
@


1.17
log
@npix8 on calls
@
text
@d157 1
a157 3
C         NPIX8 = TOTAL NUMBER OF PIXELS IN CCP4 FILE
          NPIX8 = NSAM * NROW * NSLICE
          NEED8 = NPIX + IOFFSET
@


1.16
log
@npix8 & need8
@
text
@d10 1
a10 1
C
d13 1
a13 1
C=* Copyright (C) 1985-208  Health Research Inc.                       *
d57 1
a57 1
        INTEGER * 8           :: NPIX8,NEED8
d111 3
a113 2
C       NPIX = TOTAL NUMBER OF PIXELS IN CCP4 FILE
        NPIX = NSAM * NROW * NSLICE
d131 2
d135 1
a135 1
           CALL RAW8TOSPI(LUNCCP4,LUNSPI,NSAM,NPIX,IOFFSET,.TRUE.,
d143 1
a143 1
           CALL RAW16TOSPI(LUNCCP4,LUNSPI,NSAM,NPIX,IOFFSET,FLIP,
d154 1
a154 1
          IGOT    = 0
d161 1
a161 1
          DO WHILE (IGOT .LT. NEED8)
d165 1
a165 1
                NVAL    = MIN(NSAM,NEED8-IGOT)
d171 2
a172 2
C            IGOT POINTS TO CURRENT WORD IN INPUT FILE
             IGOT = IGOT + 1
d174 1
a174 1
             IF (IGOT .GT. IOFFSET) THEN
a395 2


@


1.15
log
@npix8 & need8
@
text
@d57 3
a59 3
        INTEGER * 8     :: NPIX8,NEED8
        INTEGER * 1     :: I1BUF
        COMMON          :: BUF(NBUFSIZ),FIXLENBUF(256),I1BUF(1024)
d68 1
a68 1
        EQUIVALENCE           :: (R4VALIN,I1VALIN),(R4VALOUT,I1VALOUT)
@


1.14
log
@scale
@
text
@d9 1
d13 1
a13 1
C=* Copyright (C) 1985-2005  Health Research Inc.                      *
d57 3
a59 2
        INTEGER * 1     I1BUF
        COMMON          BUF(NBUFSIZ),FIXLENBUF(256),I1BUF(1024)
d62 7
a68 7
	CHARACTER(LEN=1) ::      NULL,ANS
        LOGICAL  ::              FLIP,ISSWABT,ISSWAB
        INTEGER * 2              I2VAL

        REAL *4                  R4VALIN,R4VALOUT
        INTEGER *1               I1VALIN(4),I1VALOUT(4)
        EQUIVALENCE              (R4VALIN,I1VALIN),(R4VALOUT,I1VALOUT)
d81 1
a81 1
C       OPEN CCP4 FILE AS DIRECT ACCESS, UNFORMATTED, RECL= 1024 BYTES
d153 4
a156 2
C         NEED IS TOTAL NUMBER OF BYTES TO BE READ INCLUDING HEADER
          NEED = NPIX + IOFFSET
d158 1
a158 1
          DO WHILE (IGOT .LT. NEED)
d161 2
a162 2
C               NEED TO READ NEW RECORD FROM INPUT
                NVAL    = MIN(NSAM,NEED-IGOT)
d329 1
@


1.13
log
@GPL License fixed
@
text
@d8 1
d235 3
d240 1
a240 1
     &            FMINT,FMAXT,FAVT,FSIGT,MODE,ISSWABT,IRTFLG)
@


1.12
log
@flip & offset bugs
@
text
@d10 23
a32 6
C * SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK       *
C * COPYRIGHT (C)1985, 2002. HEALTH RESEARCH INCORPORATED (HRI),       *
C * ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C * THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HRI AND ARE NOT   *
C * TO BE DISCLOSED TO OTHERS OR USED FOR PURPOSES OTHER THAN INTENDED *
C * WITHOUT WRITTEN APPROVAL OF HRI.                                   *
@


1.11
log
@fixed flip
@
text
@d7 1
d126 2
a127 1
          IRECCCP = 1
d132 1
a132 1

d157 1
a157 1
                   I1VALOUT(3)  = I1VALIN(1)
@


1.10
log
@flip question
@
text
@d153 4
a156 4
                   I1VALOUT(4)  = I1VALIN(3)
                   I1VALOUT(3)  = I1VALIN(4)
                   I1VALOUT(2)  = I1VALIN(1)
                   I1VALOUT(1)  = I1VALIN(2)
@


1.9
log
@lunsetluns in opauxfile now
@
text
@a78 4
        CALL  RDPRMC(ANS,NCHAR,.TRUE.,'FLIP BYTE ORDERING? (Y/N)',
     &               NULL,IRT)
        IF (ANS .EQ. 'Y') FLIP = .NOT. FLIP

d104 4
@


1.8
log
@flip on 16
@
text
@d6 2
a7 1
C             
a33 1
        COMMON /LUNARA/ LUNARA(100),LUNSTK(100),LUNARB(100)
a54 2
        LUNARB(LUNCCP4) = LUNCCP4
        LUNSTK(LUNCCP4) = 0
d57 1
d79 4
a307 2
        COMMON /LUNARA/ LUNARA(100),LUNSTK(100),LUNARB(100)

a323 1
        LUNARB(LUN) = LUN
@


1.7
log
@opfilec
@
text
@d115 1
@


1.6
log
@*** empty log message ***
@
text
@d84 1
a84 1
        CALL OPFILE(.TRUE.,FILNAM,LUNSPI,'U',IFORM,NSAM,NROW,NSLICE,
@


1.5
log
@*** empty log message ***
@
text
@d42 1
a42 1
        LOGICAL  ::              FLIP,ISSWABT,ISSWAB,REVERSE
d55 2
a58 1

d62 3
a64 2
        LENREC = 1024
        CALL OPAUXFILE(.TRUE.,CCP4FILE,DATEXC,LUNCCP4,LENREC,'O',
a66 2
 
        READ(LUNCCP4,REC=1,IOSTAT=IERR) FIXLENBUF
d68 2
a69 5
        IF (IERR .NE. 0) THEN
           WRITE(NOUT,*) '*** ERROR: (',IERR,') READING CCP4 HEADER'
           CALL ERRT(100,'COPYCCP4',NE)
           GOTO 9999
        ENDIF
d71 1
a71 1
C	PARSE THE CCP4 HEADER	
d94 3
a99 3
C       CHANGE MODE: 0,1,2 TO MODEA: 8,16,32
        MODEA = (2**(MODE + 1)) * 4

d113 2
d119 40
a158 5
C          32 BIT FOATING POINT IMAGE
           NFLIP = 0
           IF (FLIP) NFLIP = 2
           CALL RAW32TOSPI(LUNCCP4,LUNSPI,NSAM,NPIX,
     &                     IOFFSET,NFLIP,LENOPEN,BUF,IRTFLG)
d160 8
d180 4
a183 3
C	OPEN A NEW FILE FOR THE CCP4 FORMAT USING DIRECT ACCESS
C       RECORD LENGTH IS 4 BYTES  
        CALL OPAUXFILE(.TRUE.,CCP4FILE,DATEXC,LUNCCP4,4,'N',
d185 1
a185 1
	
d211 2
a212 2
C	WRITE HEADER. (NOTE: FMIN, FMAX, AV ARE SAME AS SPIDER IMAGE)
        CALL SETHEDCCP4(BUF, NSAM, NROW, NSLICE,
d216 2
a217 21
        IF (ISSWABT) THEN
           WRITE(NOUT,*)'      Flipping file data byte order'
        ENDIF


C	WRITE HEADER OF 1024 BYTES (256 FLOATS) FLOAT BY FLOAT
	DO IRECT=1, 256
	   WRITE(LUNCCP4,REC=IRECT,IOSTAT=IERR) BUF(IRECT)
           IF (IERR .NE. 0) THEN
              CALL ERRT(102,'WRITING CCCP HEADER POSITION',IRECT)
              GOTO 9999
           ENDIF
 	ENDDO

C	REOPEN CCP4 FILE FOR DIRECT ACCESS, RECORD LENGTH 1024 BYTES
        CLOSE(LUNCCP4)  
        LENREC = 1024
        CALL OPAUXFILE(.FALSE.,CCP4FILE,NULL,LUNCCP4,LENREC,'O',
     &                 ' ',.TRUE.,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9999

d220 2
a221 3
        IRECOUT        = 1
        ILOCOUT        = 0
        LUNARB(LUNCCP4) = LUNCCP4
d230 2
a231 13
                ILOCOUT = ILOCOUT + 1

                IF (ISSWABT) THEN
C                  FLIP BYTE ORDER
                   R4VALIN      = BUFIN(ILOCIN)
                   I1VALOUT(4)  = I1VALIN(3)
                   I1VALOUT(3)  = I1VALIN(4)
                   I1VALOUT(2)  = I1VALIN(1)
                   I1VALOUT(1)  = I1VALIN(2)
                   BUF(ILOCOUT) = R4VALOUT
                ELSE
                   BUF(ILOCOUT) = BUFIN(ILOCIN)
                ENDIF
d233 1
a233 1
                IF (ILOCOUT .GE. 256) THEN
d236 1
a236 5
                   CALL WRTLIN(LUNCCP4,BUF,256,IRECOUT)
                   IF (IERR .NE. 0) THEN
                      CALL ERRT(102,'WRITING RECORD',IRECIN)
                      GOTO 9999
                   ENDIF
d245 1
a245 1
              CALL WRTLIN(LUNCCP4,BUF,ILOCOUT,IRECOUT)
d261 1
a261 1
                IF (ILOCOUT .GE. LENREC) THEN
d264 1
a264 1
                   CALL WRTLIN8(LUNCCP4,I1BUF,LENREC,IRECOUT)
@


1.4
log
@*** empty log message ***
@
text
@d5 2
a6 1
C                                         
d9 1
a9 1
C * COPYRIGHT (C)1985, 2001. HEALTH RESEARCH INCORPORATED (HRI),       *
d16 1
a16 1
C COPYCCP4(LUNSPI,LUNNEW)
d41 2
a42 2
	CHARACTER(LEN=1) ::      NULL
        LOGICAL  ::              FLIP
d45 4
d52 3
d76 1
a76 1
     &                   AV,RMS,NSYMBT,FLIP,MACHST,IRTFLG)
d170 1
a170 1
     &                FMINT,FMAXT,FAVT,FSIGT,MODE,IRTFLG)
d173 5
d208 12
a219 1
                BUF(ILOCOUT) = BUFIN(ILOCIN)
d288 66
@


1.3
log
@nloop,iloop_removed
@
text
@d71 1
a71 1
            CALL ERRT(101,'NOT CCP4 FORMAT, TRY MRC FORMAT?',NE)
d108 1
a108 4

           MSB = 1
           IF (FLIP) MSB = 2
           CALL RAW16TOSPI(LUNCCP4,LUNSPI,NSAM,NPIX,IOFFSET,MSB,
@


1.2
log
@*** empty log message ***
@
text
@d139 1
a139 1
        CALL RDPRI1S(IVAL,NLOOP,ILOOP,
@


1.1
log
@Initial revision
@
text
@d40 2
a41 2
	CHARACTER * 1            NULL
        LOGICAL                  FLIP
d92 2
a93 3
        IF (MODE .EQ. 0) THEN
C          8 BIT INTEGER CCP4 INPUT FILE
           INMODE  = 8
d95 5
a99 5
C          REOPEN CCP4 FILE WITH LENREC = 1 BYTE, DIRECT, FORMATTED
           LENOPEN = NSAM
           CALL OPAUXFILE(.FALSE.,CCP4FILE,NULL,LUNCCP4,LENOPEN,'O',
     &                   ' ',.TRUE.,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9999
d101 2
d106 1
a106 1
        ELSEIF (MODE .EQ. 1) THEN
a108 6
C          REOPEN CCP4 FILE AS NSAM*2 BYTE, DIRECT ACCESS, UNFORMATTED
           LENOPEN = NSAM * 2
           CALL OPAUXFILE(.FALSE.,CCP4FILE,NULL,LUNCCP4,LENOPEN,'O',
     &                   ' ',.TRUE.,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9999

d114 1
a114 1
        ELSEIF (MODE .EQ. 2) THEN
d116 2
a117 9

C          REOPEN CCP4 FILE AS NSAM*4 BYTE, DIRECT ACCESS, UNFORMATTED
           LENOPEN = NSAM * 4
           CALL OPAUXFILE(.FALSE.,CCP4FILE,NULL,LUNCCP4,LENOPEN,'O',
     &                    ' ',.TRUE.,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9999

           IMODE = 32
           IF (FLIP) IMODE = -33
d119 1
a119 1
     &                     IOFFSET,IMODE,LENOPEN,BUF,IRTFLG)
d122 1
a122 3
 	   WRITE(NOUT,*)'CCP4 MODE: ',MODE,
     &                  '  CAN NOT BE COPIED TO SPIDER' 
           CALL ERRT(100,'COPYCCP4',NE)
@
