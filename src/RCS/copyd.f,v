head	1.53;
access;
symbols
	pre_mrcs:1.48
	healthdept_2018:1.48
	pre_getangas:1.44
	GPL2010:1.37
	pre_GPL2010:1.36
	pre_var_equation:1.36
	pre_fftwrings:1.36
	pre_opfiles:1.36
	src:1.36
	best-code:1.36
	x-named-regs:1.36
	x:1.36
	v13-00:1.36
	pre_GPL:1.34
	prec_CA:1.30
	noindx:1.23
	Bproc:1.21
	oct21:1.20
	last77:1.17;
locks; strict;
comment	@c @;


1.53
date	2025.11.10.22.33.58;	author dean;	state Exp;
branches;
next	1.52;

1.52
date	2025.10.16.19.37.11;	author dean;	state Exp;
branches;
next	1.51;

1.51
date	2025.09.21.15.27.16;	author dean;	state Exp;
branches;
next	1.50;

1.50
date	2019.12.20.15.23.39;	author leith;	state Exp;
branches;
next	1.49;

1.49
date	2019.11.04.17.35.47;	author leith;	state Exp;
branches;
next	1.48;

1.48
date	2018.10.03.14.34.03;	author leith;	state Exp;
branches;
next	1.47;

1.47
date	2014.06.02.13.24.59;	author leith;	state Exp;
branches;
next	1.46;

1.46
date	2014.06.02.11.58.30;	author leith;	state Exp;
branches;
next	1.45;

1.45
date	2013.11.14.17.51.23;	author leith;	state Exp;
branches;
next	1.44;

1.44
date	2011.02.09.17.04.21;	author leith;	state Exp;
branches;
next	1.43;

1.43
date	2011.01.31.13.13.37;	author leith;	state Exp;
branches;
next	1.42;

1.42
date	2011.01.12.18.32.08;	author leith;	state Exp;
branches;
next	1.41;

1.41
date	2011.01.10.14.04.35;	author leith;	state Exp;
branches;
next	1.40;

1.40
date	2011.01.03.16.37.59;	author leith;	state Exp;
branches;
next	1.39;

1.39
date	2010.10.22.16.51.01;	author leith;	state Exp;
branches;
next	1.38;

1.38
date	2010.10.21.17.42.27;	author leith;	state Exp;
branches;
next	1.37;

1.37
date	2010.06.24.13.25.18;	author leith;	state Exp;
branches;
next	1.36;

1.36
date	2005.10.17.19.57.07;	author leith;	state Exp;
branches;
next	1.35;

1.35
date	2005.10.17.17.53.36;	author leith;	state Exp;
branches;
next	1.34;

1.34
date	2004.11.19.17.21.20;	author cyang;	state Exp;
branches;
next	1.33;

1.33
date	2004.07.20.20.05.01;	author leith;	state Exp;
branches;
next	1.32;

1.32
date	2004.02.05.14.17.41;	author leith;	state Exp;
branches;
next	1.31;

1.31
date	2003.12.19.14.05.34;	author leith;	state Exp;
branches;
next	1.30;

1.30
date	2003.03.13.18.46.00;	author leith;	state Exp;
branches;
next	1.29;

1.29
date	2003.03.13.16.25.32;	author leith;	state Exp;
branches;
next	1.28;

1.28
date	2003.02.28.21.15.46;	author leith;	state Exp;
branches;
next	1.27;

1.27
date	2003.02.28.19.23.08;	author leith;	state Exp;
branches;
next	1.26;

1.26
date	2003.02.24.15.53.39;	author leith;	state Exp;
branches;
next	1.25;

1.25
date	2003.02.18.21.49.43;	author leith;	state Exp;
branches;
next	1.24;

1.24
date	2003.01.23.15.51.41;	author leith;	state Exp;
branches;
next	1.23;

1.23
date	2002.12.17.16.07.36;	author leith;	state Exp;
branches;
next	1.22;

1.22
date	2001.04.18.18.14.47;	author leith;	state Exp;
branches;
next	1.21;

1.21
date	2000.08.07.13.24.50;	author leith;	state Exp;
branches;
next	1.20;

1.20
date	99.09.08.17.00.20;	author leith;	state Exp;
branches;
next	1.19;

1.19
date	99.04.12.15.24.09;	author leith;	state Exp;
branches;
next	1.18;

1.18
date	99.04.06.17.21.52;	author leith;	state Exp;
branches;
next	1.17;

1.17
date	98.01.21.14.30.35;	author leith;	state Exp;
branches;
next	1.16;

1.16
date	98.01.20.18.22.48;	author leith;	state Exp;
branches;
next	1.15;

1.15
date	98.01.20.14.15.09;	author leith;	state Exp;
branches;
next	1.14;

1.14
date	98.01.15.16.41.20;	author leith;	state Exp;
branches;
next	1.13;

1.13
date	98.01.12.20.29.11;	author leith;	state Exp;
branches;
next	1.12;

1.12
date	97.12.19.19.32.31;	author leith;	state Exp;
branches;
next	1.11;

1.11
date	97.12.17.15.04.43;	author leith;	state Exp;
branches;
next	1.10;

1.10
date	97.12.12.18.02.47;	author leith;	state Exp;
branches;
next	1.9;

1.9
date	97.12.10.21.19.35;	author leith;	state Exp;
branches;
next	1.8;

1.8
date	97.12.01.21.41.45;	author liy;	state Exp;
branches;
next	1.7;

1.7
date	97.11.20.20.02.46;	author liy;	state Exp;
branches;
next	1.6;

1.6
date	97.04.21.12.56.22;	author leith;	state Exp;
branches;
next	1.5;

1.5
date	96.08.21.19.19.56;	author leith;	state Exp;
branches
	1.5.1.1;
next	1.4;

1.4
date	95.04.17.13.30.46;	author leith;	state Exp;
branches;
next	1.3;

1.3
date	94.08.15.14.23.00;	author leith;	state Exp;
branches;
next	1.2;

1.2
date	94.05.13.14.03.29;	author leith;	state Exp;
branches;
next	1.1;

1.1
date	94.05.13.12.47.50;	author leith;	state Exp;
branches;
next	;

1.5.1.1
date	96.12.17.18.42.42;	author liy;	state Exp;
branches;
next	;


desc
@unix specific source code with preprocessor lines
@


1.53
log
@*** empty log message ***
@
text
@
C++*********************************************************************
C
C COPYD.F      CREATED                        23 DEC 87 ARDEAN LEITH
C              USED GETOLDSTACK, GETNEWSTACK  APRIL 99  ARDEAN LEITH
C              GETNEWSTACK PARAM.             FEB 03    ARDEAN LEITH
C              FLIPEND                        FEB 03    ARDEAN LEITH
C              MPI                            FEB 04    Chao Yang
C              OPFILES                        DEC 10    ARDEAN LEITH
C              INDEXED STACK BUG              JAN 11    ARDEAN LEITH
C              INDEXED STACK BUG              FEB 11    ARDEAN LEITH
C              NON SPIDER IMAGE COPY          MAY 14    ARDEAN LEITH
C              DEBUG OUTPUT ADDED             SEP 20    ArDean Leith
C
C **********************************************************************
C=*                                                                    *
C=* This file is part of:   SPIDER - Modular Image Processing System.  *
C=* SPIDER System Authors:  Joachim Frank & ArDean Leith               *
C=* Copyright 1985-2025  Health Research Inc.,                         *
C=* Riverview Center, 150 Broadway, Suite 560, Menands, NY 12204.      *
C=* Email:                                                             *
C=*                                                                    *
C=* SPIDER is free software; you can redistribute it and/or            *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* SPIDER is distributed in the hope that it will be useful,          *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* merchantability or fitness for a particular purpose.  See the GNU  *
C=* General Public License for more details.                           *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program. If not, see <http://www.gnu.org/licenses> *
C=*                                                                    *
C **********************************************************************
C
C  COPYD(LUN1,LUN2,LUNDOC,LUNXM1,LUNXM2,INDXD,FLIPOUT)
C
C  PURPOSE:  COPY SPIDER IMAGE/VOL TO ANOTHER FILE INCLUDING MRC FIL
C 
C  PARAMETERS: LUN1,LUN2      READ & WRITE UNIT                 (SENT)
C              LUNDOC         READ & WRITE UNIT                 (SENT)
C              LUNXM1,LUNXM2  READ & WRITE UNIT                 (SENT)
C              INDXD          CREATE INDXD STACK                (SENT)
C              FLIPOUT        CHANGE BYTE ORDER                 (SENT)
C
C23456789 123456789 123456789 123456789 123456789 123456789 123456789 12
C--*********************************************************************

        SUBROUTINE COPYD(LUN1,LUN2,LUNDOC,LUNXM1,LUNXM2,INDXD,FLIPOUT)

        INCLUDE 'CMBLOCK.INC'
        INCLUDE 'CMLIMIT.INC'

        COMMON /IOERR/  IERR
        COMMON /IOBUF/  BUF(NBUFSIZ)

        common /lunara/ lunara(100),lunstk(100),lunarb(100),lunflip(100)
        INTEGER                  :: LUN1,LUN2,LUNDOC,LUNXM1,LUNXM2
        LOGICAL                  :: INDXD,FLIPOUT

        INTEGER                  :: IFLIPOUT
        CHARACTER (LEN=MAXNAM)   :: PROMPT 
        CHARACTER (LEN=MAXNAM)   :: FILNAM1,FILNAM2
        CHARACTER (LEN=2*MAXNAM) :: COMMAN
        LOGICAL                  :: VERBOSE_SAVE,IFLIP
        INTEGER,ALLOCATABLE      :: ILIST1(:),ILIST2(:)
        CHARACTER (LEN=1)        :: NULL = CHAR(0)
        CHARACTER (LEN=1)        :: DISP

        CALL SET_MPI(ICOMM,MYPID,MPIERR) ! SETS ICOMM AND MYPID

        VERBOSE_SAVE = VERBOSE           ! SAVE CURRENT VERBOSITY

        NILMAX       = NIMAX             ! FROM CMLIMIT
        ALLOCATE(ILIST1(NIMAX),
     &           ILIST2(NIMAX),
     &           STAT=IRTFLG)
        IF (IRTFLG .NE. 0) THEN
           CALL ERRT(46,'COPYD; ILIST....',2*NIMAX)
           RETURN
        ENDIF

        !write(3,*)' In copyd 0: lun1,iflipin: ',lun1,iflipin 
        !write(3,*)' In copyd 0 calling opfiles: lun1: ',lun1 

C       OPEN FIRST INPUT FILE, DISP = 'E' DOES NOT STOP ON ERROR
        MAXIM1 = 0
        PROMPT = 'INPUT FILE NAME OR TEMPLATE (E.G. STK@@*)~~9'
        CALL OPFILES(0,LUN1,LUNDOC,LUNXM1,  
     &               .TRUE.,FILNAM1,NLET1, 'E',
     &               IFORM1,NX1,NY1,NZ1,NSTACK1,
     &               PROMPT,
     &              .TRUE., ILIST1,NILMAX, 
     &               NDUM,NGOT1,IMG1, IRTFLG) 

	
        !write(3,*)' Back in copyd   ------------ 1 ----------' 
        !write(3,*)' In copyd 1: lun1,iflipin:  ', lun1,iflipin 
        !write(3,*)' In copyd 1: lunflip(lun1): ', lunflip(lun1) 
        !write(3,*)' In copyd 1, lun1,flipout:',   lun1,flipout
        !write(3,*)' In copyd 1: irtflg,filnam1: ',irtflg,filnam1 


        IF (IRTFLG == 5) THEN
C          NOT A VALID SPIDER OR MRC INPUT DATA FILE

           CALL FILERD(FILNAM2,NLET2,NULL,'OUTPUT FILE NAME',IRTFLG)
           IF (IRTFLG .NE. 0) RETURN 

           !write(3,*) ' In copyd: Non spider input: ', filnam1(1:nlet1)
           !write(3,*) ' In copyd: Non spider output: ',filnam2(1:nlet2)

           LOCDOT1 = ( INDEX(FILNAM1(1:NLET1),'.',BACK=.TRUE.) )
           LOCDOT2 = ( INDEX(FILNAM2(1:NLET2),'.',BACK=.TRUE.) )

           IF ( LOCDOT2 <= 0 ) THEN 
C             APPEND EXTENSION TO FILNAM2
              FILNAM2 = FILNAM2(1:NLET2) // '.' // FILNAM1(LOCDOT1+1:)
              NLET2   = lnblnkn(FILNAM2)
           ENDIF

C          USE SYSTEM COPY
           COMMAN = 'cp ' // FILNAM1(1:NLET1) //' '// FILNAM2(1:NLET2)

           WRITE(NOUT,'(2X,2A,2X,A)')
     &           'cp ',FILNAM1(:NLET1),FILNAM2(:NLET2)
           IRET = system(COMMAN)
           GOTO 999
	   
	ENDIF
	
        IF (IRTFLG .NE. 0) GOTO 999

        !write(3,'(a,8i5)')' In copyd; nstack1,ngot1,img1:', 
        !&                             nstack1,ngot1,img1

C       FIND NATIVE-ENDDEDNESS OF SPIDER INPUT     
        CALL LUNGETFLIP(LUN1,IFLIPIN,IRTFLG)

        NSTACK2 =  1 ! UNUSED
        DISP    = 'U'          
        IF (NSTACK1 .GT. 0 .AND. INDXD) THEN
C          INPUT IS A WHOLE STACK AND WANT INDEXED OUTPUT STACK
           DISP    = 'I'
           NSTACK2 = NSTACK1  ! MAX SIZE
        ENDIF
	
        !write(3,*)' In copyd --------------- 0 --------'
        !write(3,'(A,L5)') ' In copyd 0, flipout:',   flipout
        !write(3,'(A,4i6)')' In copyd 0: iflipin,: ', iflipin 
        !write(3,'(A,4i6)')' In copyd 0: lunflip(lun1): ',lunflip(lun1) 
        !write(3,*)' --------------- END OF 0 --------' 

C       FIND NATIVE-ENDDEDNESS OF INPUT     
        CALL LUNGETFLIP(LUN1,IFLIPIN,IRTFLG)

C       FIND NATIVE-ENDDEDNESS OF INPUT     
        IFLIPOUT = 0    ; 
        IF     (IFLIPIN .EQ. 0 .AND.       FLIPOUT) THEN
	   IFILPOUT = 1
        ELSEIF (IFLIPIN .EQ. 0 .AND. .NOT. FLIPOUT) THEN
           IFLIPOUT = 0
        ELSEIF (IFLIPIN .EQ. 1 .AND.       FLIPOUT) THEN
           IFLIPOUT = 0
        ELSEIF (IFLIPIN .EQ. 1 .AND. .NOT. FLIPOUT) THEN
           IFLIPOUT = 1
	ENDIF
	
        CALL LUNSETFLIP(LUN2,IFLIPOUT,IRTFLG)
		
        !write(3,*)'  '
        !write(3,*)' In copyd --------------- 0 --------'
        !write(3,'(A,4i6)')'  In copyd: iflipin,iflipout: ',
        !&                              iflipin,iflipout 
        !write(3,'(A,4i6)')'  In copyd: lunflip(lun1),lunflip(lun2): ',
        !&                              lunflip(lun1),lunflip(lun2) 
        !write(3,*)' -------------- END OF 0 CALLING OPFILES -------' 
      	    	
C	OPEN FIRST OUTPUT FILE
        IMG2 = IMG1
        CALL OPFILES(LUN1,LUN2,LUNDOC,LUNXM2, 
     &             .TRUE.,FILNAM2,NLET2,DISP,
     &             IFORM1,NX1,NY1,NZ1,NSTACK2,
     &             NULL,
     &             .TRUE., ILIST2,NILMAX, 
     &             NDUM,NGOT2,IMG2, IRTFLG) 

        !write(3,*)'  '
        !write(3,*)' In copyd --------------- 1 --------'
        !write(3,'(A,4i6)')'  In copyd: nstack2,ngot2,img2:',
        !&                              nstack2,ngot2,img2
        !write(3,'(A,4i6)')'  In copyd: iflipin,iflipout: ',
        !&                              iflipin,iflipout 
        !write(3,'(A,4i6)')'  In copyd: lun1,lun2: ',
        !&                              lun1,lun2 
        !write(3,'(A,4i6)')'  In copyd: lunflip(lun1),lunflip(lun2): ',
        !&                              lunflip(lun1),lunflip(lun2) 
        !write(3,*)' --------------- END OF 1 --------' 
    
       IF (IFLIPOUT == 1) THEN
C          TELL WRTLIN TO FLIP CONTENTS DURING I/O
           CALL LUNSETFLIP(LUN2,IFLIPOUT,IRTFLG)

C          REPLACE HEADER WITH BYTE-FLIPPED HEADER
           CALL LUNWRTHED(LUN2,NX1,0,IRTFLG)
        ENDIF
	
        !write(3,*)'  '
        !write(3,*)' In copyd --------------- 2 --------'
        !call lungetstat(lun2,imamit,fmint,fmaxt,avt,sigt,irtflg)
        !write(3,*)' In copyd, stats3:',imamit,fmint,fmaxt,avt,sigt 
        !write(3,*)' --------------- END OF 2 --------' 

        NINDX1 = 1
        NINDX2 = 1

        DO       ! LOOP OVER ALL IMAGES/STACKS

C          DO NOT REPORT FILE INFO IF WHOLE STACK (VERBOSE IN COMMON)
	   IF (NSTACK1 > 0 .AND. NSTACK2 >= 0) VERBOSE = .FALSE. 

C          COPY THE DESIRED NUMBER OF DATA RECORDS
           DO IREC = 1,NY1 * NZ1
              CALL REDLIN(LUN1,BUF,NX1,IREC)
              CALL WRTLIN(LUN2,BUF,NX1,IREC)
           ENDDO

C          OPEN NEXT SET OF I/O FILES, UPDATES NINDX1 & NINDX2 
           !write(3,*)' In copyd, Calling nextfiles:',nindx1,nindx2 

           CALL NEXTFILES(NINDX1,NINDX2,  ILIST1,ILIST2, 
     &                    .FALSE., LUNXM1,LUNXM2,
     &                    NGOT1,NGOT2,    NSTACK1,NSTACK2,  
     &                    LUN1,LUN1,LUN2, FILNAM1,FILNAM2,
     &                    IMG1,IMG2, IRTFLG)

           !write(3,*) ' In copyd, After nextfiles, irtflg',irtflg
           !if (irtflg .ne. 0) then
           !write(3,'(A,4i6)') 
           !&        ' Nextfiles img1,img2,irtflg:',img1,img2,irtflg
           !write(3,'(A,4i6)') 
           !&        ' Nextfiles nindx1,nindx2:',nindx1,nindx2
           !endif

           IF (IRTFLG .NE. 0) EXIT      ! ERROR / END OF INPUT STACK
       ENDDO

       IRTFLG = 0
   
999    CLOSE(LUN1)
       CLOSE(LUN2)

       VERBOSE = VERBOSE_SAVE          ! RESTORE VERBOSITY 
       IF (ALLOCATED(ILIST1)) DEALLOCATE(ILIST1)
       IF (ALLOCATED(ILIST2)) DEALLOCATE(ILIST2)

       END

@


1.52
log
@debug output altered
@
text
@d21 1
a21 1
C=* Email: spider@@health.ny.gov                                        *
d89 1
a89 1
        PROMPT = 'INPUT FILE NAME OR TEMPLATE (E.G. STK@@****)~~9'
@


1.51
log
@flip logic changes needed
gfort compiler changes needed
@
text
@d13 1
d135 2
a136 1
        !write(3,'(a,8i5)')' In  nstack1,ngot1,img1:',nstack1,ngot1,img1
d175 3
a177 3
        !&                                 iflipin,iflipout 
        ! write(3,'(A,4i6)')'  In copyd: lunflip(lun1),lunflip(lun2): ',
        !&                                 lunflip(lun1),lunflip(lun2) 
d192 1
a192 1
        !&                                 nstack2,ngot2,img2
d194 1
a194 1
        !&                                 iflipin,iflipout 
d196 1
a196 1
        !&                                 lun1,lun2 
d198 1
a198 1
        !&                                 lunflip(lun1),lunflip(lun2) 
d204 1
d206 1
a206 1
           CALL LUNWRTHED (LUN2,NX1,0,IRTFLG)
d217 2
a218 1
        DO                ! LOOP OVER ALL IMAGES/STACKS
d230 2
a231 1
           !write(3,*)' In copyd, calling nextfiles:',nindx1,nindx2 
d238 1
a238 1
           !write(3,*) ' In copyd, after nextfiles, irtflg',irtflg
d241 1
a241 1
           !     &        ' Nextfiles img1,img2,irtflg:',img1,img2,irtflg
d243 1
a243 1
           !     &        ' Nextfiles nindx1,nindx2:',nindx1,nindx2
@


1.50
log
@comments
@
text
@d18 1
a18 1
C=* Copyright 1985-2014  Health Research Inc.,                         *
d57 1
d83 3
d96 8
d110 2
a111 2
           !write(6,*) ' Non spider input: ', filnam1(1:nlet1)
           !write(6,*) ' Non spider output: ',filnam2(1:nlet2)
d116 1
a116 1
           IF ( LOCDOT2 <= 0 ) THEN
d125 1
a125 1
           WRITE(NOUT,'(2X,2A,2X,A)'),
d129 4
a132 1
        ENDIF
d134 1
a134 1
        IF (IRTFLG .NE. 0) RETURN
d136 2
a137 1
        !write(6,'(a,8i5)')' In  nstack1,ngot1,img1:',nstack1,ngot1,img1
d146 32
a177 8

        IF (FLIPOUT) THEN
C          STANDARD COPY WITH FLIPPED ENDEDNESS
           CALL LUNGETFLIP(LUN1,IFLIPIN,IRTFLG)
           IF (IFLIPIN .NE. 1) IFLIPOUT = 1
        ENDIF
        IF (IFLIPOUT == 1) CALL LUNSETFLIP(LUN2,IFLIPOUT,IRTFLG)

d187 12
a198 10
        !write(6,'(A,4i6)')' Out nstack2,ngot2,img2:',nstack2,ngot2,img2

        IFLIPOUT = 0
        IF (FLIPOUT) THEN
C          STANDARD COPY WITH FLIPPED ENDEDNESS
           CALL LUNGETFLIP(LUN1,IFLIPIN,IRTFLG)
           IF (IFLIPIN .NE. 1) IFLIPOUT = 1
        ENDIF
        !write(6,'(A,4i6)')' IFLIPIN, IFLIPOUT:',IFLIPIN, IFLIPOUT 

d200 1
a200 1
C          TELL WRITLIN TO FLIP CONTENTS DURING I/O
d205 6
a210 2
       !call lungetstat(lun2,imamit,fmint,fmaxt,avt,sigt,irtflg)
       !write(3,*)' In copyd, stats3:',imamit,fmint,fmaxt,avt,sigt 
d235 4
a238 4
           !write(6,'(A,4i6)') 
!     &        ' Nextfiles img1,img2,irtflg:',img1,img2,irtflg
           !write(6,'(A,4i6)') 
!     &        ' Nextfiles nindx1,nindx2:',nindx1,nindx2
@


1.49
log
@debug_msg
@
text
@d38 1
a38 1
C  PURPOSE:  COPY A SPIDER IMAGE FILE TO ANOTHER FILE
d93 1
d170 1
a170 1
C          DO NOT REPORT FILE INFO IF WHOLE STACK
@


1.48
log
@email_health_dept
@
text
@d163 1
a163 1
       !write(6,*)' stats3:',imamit,fmint,fmaxt,avt,sigt 
d178 2
a179 2
C          OPEN NEXT SET OF I/O FILES, UPDATES NINDX* 
           !write(6,*)  ' CALLING nextfiles'
d185 2
a186 2
 
           !write(6,*) ' After nextfiles, irtflg',irtflg
@


1.47
log
@appended extension to non-spider copy
@
text
@d20 1
a20 1
C=* Email: spider@@wadsworth.org                                        *
@


1.46
log
@            COMMAN = 'echo cp '//FILNAM1(1:NLET1)//' '// FILNAM2(1:NLET2)
<
for non spider files
@
text
@d12 1
d18 1
a18 1
C=* Copyright 1985-2011  Health Research Inc.,                         *
d93 1
a93 2
           write(6,*) ' Non spider image: ',filnam1(1:nlet1)
       
d97 12
d110 1
a110 1
           COMMAN = 'echo cp '//FILNAM1(1:NLET1)//' '// FILNAM2(1:NLET2)
d112 2
@


1.45
log
@nsam, REPLACE HEADER WITH BYTE-FLIPPED HEADER
@
text
@d56 2
a57 2
        INTEGER                :: LUN1,LUN2,LUNDOC,LUNXM1,LUNXM2
        LOGICAL                :: INDXD,FLIPOUT
d59 8
a66 6
        INTEGER                :: IFLIPOUT
        CHARACTER (LEN=MAXNAM) :: FILNAM1,FILNAM2
        LOGICAL                :: VERBOSE_SAVE,IFLIP
        INTEGER,ALLOCATABLE    :: ILIST1(:),ILIST2(:)
        CHARACTER (LEN=1)      :: NULL = CHAR(0)
        CHARACTER (LEN=1)      :: DISP
d81 3
a83 2
C       OPEN FIRST INPUT FILE
        MAXIM1  = 0
d85 1
a85 1
     &               .TRUE.,FILNAM1,NLET1, 'O',
d87 1
a87 1
     &               NULL,
d90 14
d105 1
@


1.44
log
@NSTACK2 = NSTACK1
@
text
@d83 1
a83 1
     &               IFORM1,NSAM1,NROW1,NSLICE1,NSTACK1,
d98 7
d109 1
a109 1
     &             IFORM1,NSAM1,NROW1,NSLICE1,NSTACK2,
d122 10
a131 1
        IF (IFLIPOUT .EQ. 1) CALL LUNSETFLIP(LUN2,IFLIPOUT,IRTFLG)
d141 3
a143 3
           DO IREC = 1,NROW1 * NSLICE1
              CALL REDLIN(LUN1,BUF,NSAM1,IREC)
              CALL WRTLIN(LUN2,BUF,NSAM1,IREC)
@


1.43
log
@INDEXED STACK BUG
@
text
@d11 1
d95 1
a95 1
           NSTACK2 = -NSTACK1  ! MAX SIZE
d131 1
d138 3
a140 2
!          if (irtflg .ne. 0) then
!          write(6,'(A,4i6)') 
d142 1
a142 1
!          write(6,'(A,4i6)') 
d144 1
a144 1
!          endif
@


1.42
log
@img2 = img1
@
text
@d10 1
d16 1
a16 1
C=* Copyright 1985-2010  Health Research Inc.,                         *
d63 1
d74 1
a74 1
           CALL ERRT(46,'INTERPS; ILIST....',2*NIMAX)
d89 8
d100 1
a100 1
     &             .TRUE.,FILNAM2,NLET2,'U',
@


1.41
log
@nimax allocate.
@
text
@d88 1
@


1.40
log
@opfiles supported
@
text
@d60 1
a60 1
        INTEGER                :: ILIST1(NIMAX),ILIST2(NIMAX)
d68 7
d141 2
@


1.39
log
@CALL GETNEWSTACK(LUNIN,LUNOUT,COPYSTAT
@
text
@d9 1
d33 1
a33 1
C  COPYD(LUNIN,LUNOUT,INDXD, NSAM,NROW,NSLICE,NSTACKIN,ITYPE,IFLIP)
d37 5
a41 4
C  PARAMETERS: LUNIN       READ UNIT                       (SENT)
C              LUNOUT      WRITE UNIT                      (SENT)
C
C  NOTES:   NEEDS TO SET BUF(26) IN STACK
d46 1
a46 2
        SUBROUTINE COPYD(LUNIN,LUNOUT,INDXD,
     &                   NSAM,NROW,NSLICE,NSTACKIN,ITYPE,IFLIP)
a50 2
        CHARACTER (LEN=MAXNAM) :: FILNAM

d54 2
a55 5
        LOGICAL            :: VERBOSE_SAVE,INDXD

        LOGICAL, PARAMETER :: COPYSTAT = .TRUE.

        CALL SET_MPI(ICOMM,MYPID,MPIERR)
d57 38
a94 7
        VERBOSE_SAVE = VERBOSE

C	OPEN OUTPUT FILE, KEEP INPUT FILE DATE, TIME AND TITLE
        NSTACKOUT =  1           
        IF (NSTACKIN .GT. 0) THEN
C          INPUT IS A WHOLE STACK CHECK IF WANT INDEXED STACK
           IF (INDXD) NSTACKOUT = -NSTACKIN
d96 1
d98 11
a108 48
        CALL OPFILEC(LUNIN,.TRUE.,FILNAM,LUNOUT,'U',ITYPE,
     &               NSAM,NROW,NSLICE,NSTACKOUT,'OUTPUT',.TRUE.,IRTFLG) 
	IF (IRTFLG .NE. 0) RETURN
        IF (IFLIP .EQ. 1) CALL LUNSETFLIP(LUNOUT,IFLIP,IRTFLG)

	IF (NSTACKIN .GT. 0 .AND. NSTACKOUT .GE. 0) THEN
C	   DUPLICATE WHOLE STACK FILE RECORD BY RECORD INCLUDING HEADER

C          FIGURE OUT NUMBER OF DATA RECORDS TO BE COPIED
	   CALL TOTREC(NSAM,NROW,NSLICE,IEND)

C          DO NOT REPORT FILE INFO
           VERBOSE = .FALSE.

C          KEEP TRACK OF NUMBER OF IMAGES DONE
           IMDONE = 0

           IMGNUM = 1
           DO WHILE (IMGNUM .LE. NSTACKIN)

C            GET INPUT IMAGE FROM INPUT STACK (CAN INCREASE IMGNUM)            
             CALL GETOLDSTACK(LUNIN,NSAM,IMGNUM,
     &                       .TRUE.,.FALSE.,.TRUE.,IRTFLG)

             IF (IRTFLG .EQ. 0) THEN
C               CREATE OUTPUT IMAGE IN OUTPUT STACK
                CALL GETNEWSTACK(LUNIN,LUNOUT,COPYSTAT,NSAM,
     &                           IMGNUM,IRTFLG)

                DO IREC = 1,IEND
                   CALL REDLIN(LUNIN,BUF,NSAM,IREC)
	           IF (IERR .NE. 0) THEN
                      WRITE(NOUT,*) 
     &                    '*** I/O ERROR:(',IERR,') READING RECORD: ',
     &                    IREC
                      CALL ERRT(101,'COPYD',IDUM)
                      GOTO 999
                   ENDIF

                   CALL WRTLIN(LUNOUT,BUF,NSAM,IREC)
	           IF (IERR .NE. 0) THEN
                      CALL ERRT(101,'COPYD',IDUM)
                      GOTO 999
                   ENDIF
                END DO
                IMGNUM = IMGNUM + 1
                IMDONE = IMDONE + 1
             ENDIF
d111 16
a126 35
           IF (MYPID .LE. 0) WRITE(NOUT,90) IMDONE
90         FORMAT('  IMAGES COPIED: ',I6)
   
        ELSEIF (NSTACKIN .GE. 0 .AND. NSTACKOUT .LT. 0) THEN
           CALL ERRT(101,'CAN NOT COPY A WHOLE STACK TO AN IMAGE',NE)
           GOTO 999

	ELSE
C	  IMAGE TO STACKED IMAGE OR STACKED IMAGE TO IMAGE

C         ALTER NECESSARY HEADER VALUES SUCH AS: BUF=24 & 27

C         ISTACK (BUF=25)IS  -1 JUST FOR OLD WEB COMPATIBILITY
          IV25 = 0
          IF (NSTACKOUT .GT. -2) IV25 = -1

          CALL LUNSET25(LUNOUT,IV25,IRTFLG)

C         SET IMGNUM  (BUF=27)
          CALL LUNGETINUSE(LUNOUT,IMGNUM,IRTFLG)
          IF (NSTACKOUT .EQ. -2) IMGNUM = 0
          CALL LUNSETINUSE(LUNOUT,IMGNUM,IRTFLG)

C         PLACE ALTERED HEADER INTO NEW IMAGE FILE
	  CALL LUNWRTHED(LUNOUT,NSAM,IMGNUM,IRTFLG)
          IF (IRTFLG .NE. 0) GOTO 999
    
C         FIGURE OUT NUMBER OF DATA RECORDS TO BE COPIED
	  CALL TOTREC(NSAM,NROW,NSLICE,IEND)

C         COPY THE DESIRED NUMBER OF DATA RECORDS
          DO  I = 1,IEND
             CALL REDLIN(LUNIN,BUF,NSAM,I)
             CALL WRTLIN(LUNOUT,BUF,NSAM,I)
          ENDDO
a127 1
       ENDIF
d129 3
d133 1
a133 3
999    CLOSE(LUNIN)
       CLOSE(LUNOUT)
       VERBOSE = VERBOSE_SAVE  
a134 1
       RETURN
@


1.38
log
@SET_MPI, /COMMUN/ removed
@
text
@d55 3
a57 1
        LOGICAL :: VERBOSE_SAVE,INDXD
d96 2
a97 1
                CALL GETNEWSTACK(LUNIN,LUNOUT,NSAM,IMGNUM,IRTFLG)
@


1.37
log
@GPL_2010
@
text
@d32 1
a32 1
C  COPYD(IRTFLG)
d36 2
a37 1
C  PARAMETERS:       IRTFLG       ERROR FLAG                      (RET.)
a50 1
        COMMON /COMMUN/ FILNAM
d56 2
a57 11
#ifdef USE_MPI
        include 'mpif.h'
        INTEGER  MYPID, COMM, MPIERR, NLETI
        CHARACTER(LEN=1) :: NULL
        COMM = MPI_COMM_WORLD
        MPIERR = 0 
        CALL MPI_COMM_RANK(COMM, MYPID, MPIERR)
        NULL = CHAR(0)
#else
        MYPID = -1
#endif
@


1.36
log
@GPL License fixed
@
text
@a10 2
C=* FROM: SPIDER - MODULAR IMAGE PROCESSING SYSTEM.   AUTHOR: J.FRANK  *
C=* Copyright (C) 1985-2005  Health Research Inc.                      *
d12 5
a16 2
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *   
C=* ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
d18 1
a18 3
C=* Email:  spider@@wadsworth.org                                       *
C=*                                                                    *
C=* This program is free software; you can redistribute it and/or      *
d23 1
a23 1
C=* This program is distributed in the hope that it will be useful,    *
d25 1
a25 1
C=* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
a26 1
C=*                                                                    *
d28 1
a28 3
C=* along with this program; if not, write to the                      *
C=* Free Software Foundation, Inc.,                                    *
C=* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.      *
@


1.35
log
@HRI GPL License used
@
text
@a10 1
C * SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK       *
d14 1
a14 1
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *  
a33 6

C * COPYRIGHT (C)1985, 2002. HEALTH RESEARCH INCORPORATED (HRI),       *
C * ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C * THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HRI AND ARE NOT   *
C * TO BE DISCLOSED TO OTHERS OR USED FOR PURPOSES OTHER THAN INTENDED *
C * WITHOUT WRITTEN APPROVAL OF HRI.                                   *
@


1.34
log
@Removed MPI I/O sync because they are taken care of at lower level I/O routines
@
text
@d12 24
@


1.33
log
@overlentth line *** I/O ERROR:(',IERR,') READING RECORD: ',IREC
@
text
@d45 1
a45 1
        INTEGER  MYPID, COMM, IERR, NLETI
d48 2
a49 1
        CALL MPI_COMM_RANK(COMM, MYPID, IERR)
a62 83
#ifdef USE_MPI
C       CHECK THE FILENAME TO SEE IF THE OUTPUT IS INLINE
        CALL FILERD(FILNAM,NLETI,NULL,'OUTPUT',IRTFLG)
        IF (MYPID .EQ. 0 .or. FILNAM(1:1) .EQ. '_') THEN
           CALL OPFILEC(LUNIN,.FALSE.,FILNAM,LUNOUT,'U',ITYPE,
     &                  NSAM,NROW,NSLICE,NSTACKOUT,'OUTPUT',
     &                  .TRUE.,IRTFLG)
        ENDIF 
        CALL MPI_BCAST(IRTFLG, 1, MPI_INTEGER, 0, COMM, IERR)
        CALL MPI_BCAST(IBCNT , 1, MPI_INTEGER, 0, COMM, IERR)
        IF (IRTFLG .NE. 0) RETURN

        IF (MYPID .EQ. 0 .OR. FILNAM(1:1) .EQ. '_') THEN
           IF (IFLIP .EQ. 1) CALL LUNSETFLIP(LUNOUT,IFLIP,IRTFLG)

	   IF (NSTACKIN .GT. 0 .AND. NSTACKOUT .GE. 0) THEN
C	      DUPLICATE WHOLE STACK FILE RECORD BY RECORD INCLUDING HEADER

C             FIGURE OUT NUMBER OF DATA RECORDS TO BE COPIED
	      CALL TOTREC(NSAM,NROW,NSLICE,IEND)

C             DO NOT REPORT FILE INFO
              VERBOSE = .FALSE.

C             KEEP TRACK OF NUMBER OF IMAGES DONE
              IMDONE = 0

              IMGNUM = 1
              DO WHILE (IMGNUM .LE. NSTACKIN)

C               GET INPUT IMAGE FROM INPUT STACK (CAN INCREASE IMGNUM)            
                CALL GETOLDSTACK(LUNIN,NSAM,IMGNUM,
     &                          .TRUE.,.FALSE.,.TRUE.,IRTFLG)

                IF (IRTFLG .EQ. 0) THEN
C                  CREATE OUTPUT IMAGE IN OUTPUT STACK
                   CALL GETNEWSTACK(LUNIN,LUNOUT,NSAM,IMGNUM,IRTFLG)

                   DO IREC = 1,IEND
                      CALL REDLIN(LUNIN,BUF,NSAM,IREC)
	              IF (IERR .NE. 0) THEN
                         WRITE(NOUT,*) 
     &                   '*** I/O ERROR:(',IERR,') READING RECORD: ',
     &                   IREC
                         CALL ERRT(101,'COPYD',IDUM)
                         GOTO 999
                      ENDIF

                      CALL WRTLIN(LUNOUT,BUF,NSAM,IREC)
	              IF (IERR .NE. 0) THEN
                         CALL ERRT(101,'COPYD',IDUM)
                         GOTO 999
                      ENDIF
                   END DO
                   IMGNUM = IMGNUM + 1
                   IMDONE = IMDONE + 1
                ENDIF
              ENDDO

              IF (MYPID .EQ. 0) THEN
                 WRITE(NOUT,90) IMDONE
              ENDIF
90            FORMAT('  IMAGES COPIED: ',I6)
   
           ELSEIF (NSTACKIN .GE. 0 .AND. NSTACKOUT .LT. 0) THEN
              CALL ERRT(101,'CAN NOT COPY A WHOLE STACK TO AN IMAGE',NE)
              GOTO 999

	   ELSE
C	      IMAGE TO STACKED IMAGE OR STACKED IMAGE TO IMAGE

C             ALTER NECESSARY HEADER VALUES SUCH AS: BUF=24 & 27

C             ISTACK (BUF=25)IS  -1 JUST FOR OLD WEB COMPATIBILITY
              IV25 = 0
              IF (NSTACKOUT .GT. -2) IV25 = -1

              CALL LUNSET25(LUNOUT,IV25,IRTFLG)

C             SET IMGNUM  (BUF=27)
              CALL LUNGETINUSE(LUNOUT,IMGNUM,IRTFLG)
              IF (NSTACKOUT .EQ. -2) IMGNUM = 0
              CALL LUNSETINUSE(LUNOUT,IMGNUM,IRTFLG)
a63 17
C             PLACE ALTERED HEADER INTO NEW IMAGE FILE
	      CALL LUNWRTHED(LUNOUT,NSAM,IMGNUM,IRTFLG)
              IF (IRTFLG .NE. 0) GOTO 999
    
C             FIGURE OUT NUMBER OF DATA RECORDS TO BE COPIED
	      CALL TOTREC(NSAM,NROW,NSLICE,IEND)

C             COPY THE DESIRED NUMBER OF DATA RECORDS
              DO  I = 1,IEND
                 CALL REDLIN(LUNIN,BUF,NSAM,I)
                 CALL WRTLIN(LUNOUT,BUF,NSAM,I)
              ENDDO

           ENDIF
           IRTFLG = 0
        ENDIF
#else
d113 1
a113 1
           WRITE(NOUT,90) IMDONE
a150 1
#endif
@


1.32
log
@mpi
@
text
@d195 2
a196 1
     &                    '*** I/O ERROR:(',IERR,') READING RECORD: ',IREC
@


1.31
log
@cosmetic output
@
text
@d8 1
d43 10
d62 83
d146 17
d249 1
d257 1
@


1.30
log
@lunsetflip needed
@
text
@d101 1
a101 1
90         FORMAT(' IMAGES COPIED: ',I6)
@


1.29
log
@buf 24 set
@
text
@d30 1
a30 1
     &                   NSAM,NROW,NSLICE,NSTACKIN,ITYPE,IRTFLG)
d55 1
@


1.28
log
@*** empty log message ***
@
text
@d83 1
a83 1
     &                    '*** ERROR (',IERR,') READING RECORD: ',IREC
d110 6
a115 3
          IV24 = 0
          IF (NSTACKOUT .GT. -2) IV24 = NSTACKOUT
          CALL LUNSETISTACK(LUNOUT,IV24,IRTFLG)
@


1.27
log
@endedness
@
text
@d112 1
a112 1
          CALL LUNSETISTACK(LUN,IV24,IRTFLG)
d117 1
a117 1
          CALL LUNSETINUSE(LUN,IMGNUM,IRTFLG)
@


1.26
log
@getnewstack paramaters changed
@
text
@d7 1
d29 2
a30 1
        SUBROUTINE COPYD(INDXD,IRTFLG)
a42 2
	LUNIN        = 14
	LUNOUT       = 15
a44 6
C	GET NAME OF EXISTING INPUT FILE, CAN BE A BARE STACK
10      NSTACKIN = 1
        CALL OPFILEC(0,.TRUE.,FILNAM,LUNIN,'O',IFORM,NSAM,NROW,NSLICE,
     &             NSTACKIN,'INPUT',.TRUE.,IRTFLG) 
	IF (IRTFLG .NE. 0) RETURN

a45 1
        IRTFLG    = -9 
d52 1
a52 1
        CALL OPFILEC(LUNIN,.TRUE.,FILNAM,LUNOUT,'U',IFORM,
a53 1
	IF (IRTFLG .EQ. -1) GOTO 10
a108 4
C         RETRIEVE CURRENT IMAGE HEADER VARIABLES FROM OLD FILE
	  CALL REDHED(LUNIN,BUF,NBUFSIZ,NSAM,0,IRTFLG)
          IF (IRTFLG .NE. 0) GOTO 999

d110 3
a112 2
          BUF(24) = 0.0
          IF (NSTACKOUT .GT. -2) BUF(24) = NSTACKOUT
d116 2
a117 2
	  BUF(27) = IMGNUM
          IF (NSTACKOUT .EQ. -2) BUF(27) = 0
d120 1
a120 1
	  CALL WRTHED(LUNOUT,BUF,NSAM,IRTFLG)
@


1.25
log
@opfilec
@
text
@d4 3
a6 2
C COPYD.FOR -- CREATED 23 DEC 87 ARDEAN LEITH
C              USED GETOLDSTACK, GETNEWSTACK  APRIL 99 ARDEAN LEITH
d85 1
a85 1
                CALL GETNEWSTACK(LUNOUT,NSAM,IMGNUM,IRTFLG)
@


1.24
log
@indexed stacks
@
text
@d46 1
a46 1
        CALL OPFIL(.TRUE.,FILNAM,LUNIN,'OLD',NSAM,NROW,NSLICE,
d58 2
a59 2
        CALL OPFIL(.TRUE.,FILNAM,LUNOUT,'UNK',NSAM,NROW,NSLICE,
     &             NSTACKOUT,'OUTPUT',.TRUE.,IRTFLG) 
@


1.23
log
@imgnum not placed in copied stack image
@
text
@d8 6
a13 7
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
C *  COPYRIGHT (C)1981,1987, WADSWORTH CENTER FOR LABORATORIES AND         *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *    THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR     *
C *    LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR  *
C *    USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF   *
C *    THE CENTER FOR LABORATORIES AND RESEARCH 			   *
d27 1
a27 1
        SUBROUTINE COPYD(IRTFLG)
d32 1
a32 1
        CHARACTER *81   FILNAM
d34 1
a35 1

d38 1
a38 1
        LOGICAL :: VERBOSE_SAVE
d44 2
a45 2
C	GET NAME OF INPUT FILE
10      NSTACKIN = -1
d52 6
a57 2
        NSTACKOUT = -1           
        IF (NSTACKIN .GT. 0) NSTACKOUT = NSTACKIN
d63 1
a63 1
	IF (NSTACKIN .GE. 0 .AND. NSTACKOUT .GE. 0) THEN
d116 1
a116 1
C         RETRIEVE HEADER VARIABLES FROM OLD FILE
d120 2
a121 2
C         ALTER NECESSARY HEADER VALUES SUCH AS: (BUF=24,25,&27)
	  BUF(24) = 0.0
a123 3
C         SET IMUSED  (BUF=25)
	  BUF(25) = 1.0

d125 1
a125 2
          CALL LUNGETIMGNUM(LUNIN,IMGNUM,IRTFLG)
          IF (IRTFLG .NE. 0) GOTO 999
d127 1
@


1.22
log
@N_VERBOSE --> VERBOSE
@
text
@d117 1
a117 1
C         ALTER NECESSARY HEADER VALUES SUCH AS: (BUF=24)
d120 1
d123 5
@


1.21
log
@i --> irec
@
text
@d39 1
a39 3
	LUNIN          = 14
	LUNOUT         = 15
        N_VERBOSE_SAVE = N_VERBOSE
d41 4
d67 1
a67 1
           N_VERBOSE = 0
d141 1
a141 1
       N_VERBOSE = N_VERBOSE_SAVE  
@


1.20
log
@CMLIMIT.INC
@
text
@d85 1
a85 1
     &                    '*** ERROR (',IERR,') READING RECORD: ',I
@


1.19
log
@TURNED OFF VERBOSITY, REOPORTED NUMBER OF IMAGES COPIED
@
text
@d31 1
a36 1
        PARAMETER       (NBUFSIZ = 17008)
@


1.18
log
@fixed inline stack copy
@
text
@d39 3
a41 2
	LUNIN  = 14
	LUNOUT = 15
d64 6
d73 1
a73 1
C            GET INPUT IMAGE FROM INPUT STACK            
d97 1
d100 3
d139 1
@


1.17
log
@*** empty log message ***
@
text
@d4 2
a5 1
C COPYD.FOR -- CREATED 23 DEC 87 al
d21 1
a21 1
C  PARAMETERS:       IRTFLG       ERROR FLAG
a24 1
C        0         2         3         4         5         6         7     
a30 1
CNO_SAVE
a33 1
        COMMON /LUNARA/ LUNARA(100),LUNSTK(100)
a34 1
        COMMON          VALUES(256),BUF(256)
d36 2
a37 1
        DATA NBUFSIZ/17000/
a58 15
           WRITE(NOUT,*)
     &           ' PLEASE IGNORE ANY ARRAY OVERFLOW ERROR MESSAGE'
           LUNARA(LUNIN)  = 0
           LUNSTK(LUNIN)  = 0
           LUNARA(LUNOUT) = 0
           LUNSTK(LUNOUT) = 0
           IREC           = 0
           IERR           = 0
           DO WHILE (IERR .EQ. 0)
              IREC = IREC + 1
              CALL REDLIN(LUNIN,BUF,NSAM,IREC)
	      IF (IERR .EQ. 0) THEN
                 CALL WRTLIN(LUNOUT,BUF,NSAM,IREC)
              ENDIF
	   END DO
d60 33
@


1.16
log
@changed IGORE msg.
@
text
@d45 1
a45 1
10      NSTACKIN = 1
@


1.15
log
@changed nstackout input
@
text
@d61 2
a62 2
           IF (FILNAM(1:1) .EQ. '_')
     &        WRITE(NOUT,*) '*** IGNORE ARRAY OVERFLOW ERROR MESSAGE'
@


1.14
log
@needed stack aware indicator
@
text
@d52 2
a53 1
        NSTACKOUT = 1           
@


1.13
log
@for nstack retrieval of max img. number
@
text
@d45 2
a46 1
10      CALL OPFIL(.TRUE.,FILNAM,LUNIN,'OLD',NSAM,NROW,NSLICE,
d51 2
a52 1
        IRTFLG = -9            
d59 16
a74 15
C	  DUPLICATE WHOLE STACK FILE RECORD BY RECORD INCLUDING HEADER
          WRITE(NOUT,*) '*** IGNORE ANY ARRAY OVERFLOW ERROR MESSAGE'
          LUNARA(LUNIN)  = 0
          LUNSTK(LUNIN)  = 0
          LUNARA(LUNOUT) = 0
          LUNSTK(LUNOUT) = 0
          IREC           = 0
          IERR           = 0
          DO WHILE (IERR .EQ. 0)
             IREC = IREC + 1
             CALL REDLIN(LUNIN,BUF,NSAM,IREC)
	     IF (IERR .EQ. 0) THEN
                CALL WRTLIN(LUNOUT,BUF,NSAM,IREC)
             ENDIF
	  END DO
d102 2
a103 2
            CALL REDLIN(LUNIN,BUF,NSAM,I)
            CALL WRTLIN(LUNOUT,BUF,NSAM,I)
@


1.12
log
@new error msg added
@
text
@d22 2
d37 1
a38 1
        COMMON       VALUES(256),BUF(256)
d41 2
a42 2
	LUNIN   = 14
	LUNOUT   = 15
d53 2
a54 1
	IF (IRTFLG .NE. 0) GOTO 10
d56 1
a56 1
	IF (NSTACKIN .LT. 0 .AND. NSTACKOUT .LT. 0) THEN
d73 1
a73 1
        ELSEIF (NSTACKIN .LT. 0 .AND. NSTACKOUT .GE. 0) THEN
d84 1
a84 1
C         ALTER NECESSARY HEADER VALUES SUCH AS NSTACK (BUF=24)
d86 1
a86 1
          IF (NSTACKOUT .GT. 0) BUF(24) = NSTACKOUT
@


1.11
log
@wrong parameter list on redhed call
@
text
@d55 1
@


1.10
log
@fixed number of records copied if a stack to stack
@
text
@d77 1
a77 1
	  CALL REDHED(LUNIN,BUF,NBUFSIZ,NSAM,IRTFLG)
@


1.9
log
@rewritten
@
text
@d55 2
a56 1
          IREC           = 0
d59 1
@


1.8
log
@correct the stack structure
@
text
@d31 1
a31 2
        CHARACTER *81 FILNAM
	INTEGER       LABREC
d36 1
a36 1
        COMMON VALUES(256),BUF(256)
d39 2
a40 2
	LUN1   = 14
	LUN2   = 15
d43 2
a44 2
10      CALL OPFIL(.TRUE.,FILNAM,LUN1,'OLD',NSAM,NROW,NSLICE,
     &             IDUM,'INPUT',.TRUE.,IRTFLG) 
a45 5
	NSTACKIN = INDEX(FILNAM, '@@')
        CALL REDHED(LUN1,BUF,NBUFSIZ,NSAM,IRTFLG)
	NSTK = BUF(24)
	IRECF = BUF(3)
	LABREC = BUF(13)
d48 3
a50 3
        IRTFLG = -1            
        CALL OPFIL(.TRUE.,FILNAM,LUN2,'UNK',NSAM,NROW,NSLICE,
     &             IDUM,'OUTPUT',.TRUE.,IRTFLG) 
a51 1
	NSTACKOUT = INDEX(FILNAM, '@@')
d53 17
a69 23
	NIMAGE = 0
	IF (NSTACKIN.EQ.0.AND.NSTACKOUT.EQ.0.AND.NSTK.NE.0) THEN
C	  COPY STOCK FILE TO STOCK FILE

C	  RESET THE LABEL
	  CALL GETLAB(LUN1,NSAM,BUF,6,210,VALUES,IRTFLG)
	  BUF(24) = NSTK
	  NOPRNT  = -1
	  CALL SETLAB(LUN2,NSAM,BUF,6,210,VALUES,'U',NOPRNT)

100	  IERR = 0
	  LUNSTK(LUN1) = NIMAGE *IRECF
          CALL REDLIN(LUN1,BUF,NSAM,1)

C	  FILE EXISTS AND NOT A BLACK IMAGE
	  IF (IERR.EQ.0) THEN 
	    NIMAGE = NIMAGE + 1
	    GOTO 100
	  ENDIF

	  IEND = IRECF * NIMAGE
	  LUNSTK(LUN1) = 0
	  LUNSTK(LUN2) = 0
d72 10
a81 4
C	  OTHER CASES
C         COPY HEADER VARIABLES
	  IERR = 0
	  CALL GETLAB(LUN1,NSAM,BUF,6,210,VALUES,IRTFLG)
d83 4
a86 2
	  NOPRNT  = -1
	  CALL SETLAB(LUN2,NSAM,BUF,6,210,VALUES,'U',NOPRNT)
d88 1
a88 1
C         FIGURE OUT NUMBER OF RECORDS TO BE COPIED
d90 6
a95 1
	ENDIF
d97 2
a98 5
C       COPY THE DESIRED NUMBER OF RECORDS
        DO  I = 1,IEND
          CALL REDLIN(LUN1,BUF,NSAM,I)
          CALL WRTLIN(LUN2,BUF,NSAM,I)
        ENDDO
d100 2
a101 2
999   CLOSE(LUN1)
      CLOSE(LUN2)
d103 2
a104 2
      RETURN
      END
@


1.7
log
@added copy from stack to stack
@
text
@d32 1
a46 2

C	CHECK FILE NAME AND FILE FORM 
d51 1
d63 7
d87 6
a92 5
          CALL GETLAB(LUN1,NSAM,BUF,6,210,VALUES,IRTFLG)
          BUF(25) = 1.0
          NOPRNT  = -1
          CALL SETLAB(LUN2,NSAM,BUF,6,210,VALUES,'U',NOPRNT)

d94 1
a94 1
          CALL TOTREC(NSAM,NROW,NSLICE,IEND)
d103 1
a103 1
      CLOSE(LUN1)
@


1.6
log
@added buf(25) setting
@
text
@d33 2
d36 2
a37 1
        COMMON VALUES(256),BUF(1)
d47 6
d58 1
a58 7

C       COPY HEADER VARIABLES
        IERR = 0
        CALL GETLAB(LUN1,NSAM,BUF,6,210,VALUES,IRTFLG)
        BUF(25) = 1.0
        NOPRNT  = -1
        CALL SETLAB(LUN2,NSAM,BUF,6,210,VALUES,'U',NOPRNT)
d60 28
a87 2
C       FIGURE OUT NUMBER OF RECORDS TO BE COPIED
        CALL TOTREC(NSAM,NROW,NSLICE,IEND)
@


1.5
log
@removed short label stuff
@
text
@d53 2
a54 1
        NOPRNT = -1
@


1.5.1.1
log
@*** empty log message ***
@
text
@d26 1
a26 1
        SUBROUTINE COPYD(LUN1,LUN2,NSAM,NROW,NSLIC1,IRTFLG)
d36 8
d45 1
a45 1
10      IRTFLG = -1            
@


1.4
log
@nlabel changed to nhistrec
nlabel changed to nhistrec
@
text
@a18 2
C            WILL CONVERT OLD SHORT LABEL FILES TO PRESENT LONG 
C            LABEL FILES ALSO.
d26 1
a26 1
      SUBROUTINE COPYD(IRTFLG)
d28 2
a29 5
#ifdef SP_UNIX
      INCLUDE 'CMBLOCK.INC'
#else
      INCLUDE 'COMMON1:CMBLOCK.INC'
#endif
d31 2
a32 4
      COMMON /COMMUN/ FILNAM
      COMMON /LUNARA/ LUNARA(100),LASLAB
      COMMON BDUM(32000),VALUES(256),BUF(32000),ANGLES(10)
C     BDUM IS FOR OPENF USE
d34 1
a34 1
      PARAMETER (MAXDIM=32000)
d36 2
a37 2
      CHARACTER *81 FILNAM
      CHARACTER *1  NULL
a38 6
        NULL   = CHAR(0)

	LUN1   = 8
	LUN2   = 10
        IRTFLG = 1

d40 2
a41 1
10      CALL FILERD(FILNAM,NLET,NULL,'INPUT',IRTFLG)
a42 51
	CALL OPENF(FILNAM,LUN1,NSAM,NROW,'OLD',NF,NSLIC1) 
	IF (NF .NE. 2) RETURN
	IF (NSAM .GT. MAXDIM) THEN
           IERR = 9
           CALL ERRT(IERR,'COPYD',NE)
           CLOSE(LUN1)
           RETURN
        ENDIF
        LASLB1 = LASLAB
        IREC1  = IREC

        IF (FCHAR(4:4) .EQ. 'F') THEN
C         A SPECIAL FILE FORMAT OUTPUT TO FOR010.DAT
          DO I=1,NROW
            CALL REDLIN(LUN1,BUF,NSAM,I)
            WRITE(10,201) (BUF(K),K=1,NSAM)
201         FORMAT(20F6.3)
          ENDDO
	  WRITE(NOUT,*)' FORMATTED FILE OUTPUT TO FOR010.DAT'
          CLOSE(LUN1)
          IRTFLG = 0
          RETURN
        ENDIF

        VALUES(1) = IMAMI
        VALUES(2) = FMAX
        VALUES(3) = FMIN
        VALUES(4) = AV
        VALUES(5) = SIG
        VALUES(6) = IHIST

        IF (LASLB1 .LE. 0) THEN
C          SOURCE FILE IS SHORT LABEL
           CALL GETANG(LUN1,NSAM,BUF,IDUM,NANGLE,ANGLES(2),IRTFLG)

           IF (IRTFLG .EQ. 0) THEN
C             TILT ANGLES RETRIEVED FROM TITLE FOR LABEL POSITIONS
              ANGLES(1) = 1.0
              IF (NANGLE .LE. 0) NANGLE = 3
              IF (NANGLE .GT. 9) NANGLE = 10
           ELSE
              ANGLES(1) = 0.0
           ENDIF
        ENDIF

C       NEGATIVE NSLICE IS FLAG FOR OLD FORMAT FILE LABEL 
        NSLIC2 = NSLIC1
	IF (FCHAR(4:4) .EQ. 'S') NSLIC2 = -(ABS(NSLIC1))
	NF = -1            
C       KEEPS INPUT FILE DATE, TIME AND TITLE

d44 4
a47 2
C	GET OUTPUT FILE NAME
15      CALL FILERD(FILNAM,NLET,NULL,'OUTPUT',IRTFLG)
a48 2
        CALL OPENF(FILNAM,LUN2,NSAM,NROW,'UNKNOWN',NF,NSLIC2)
	IF (NF .NE. 2) GOTO 15
d50 5
a54 31
        IERR =0
        IF (FCHAR(4:4) .EQ. 'S') THEN
C         COPY INFO INTO SHORT LABEL FORMAT FILE
          NOPRNT = -1
          CALL SETLAB(LUN2,NSAM,BUF,6,6,VALUES,'U',NOPRNT)

        ELSE
C         COPY INTO LONG LABEL OUTPUT FILE (STANDARD COPY)

          IF (LASLB1 .GT. 0) THEN
C            LONG LABEL INPUT FILE
             CALL GETLAB(LUN1,NSAM,BUF,6,210,VALUES,IRTFLG)
             NOPRNT = -1
             CALL SETLAB(LUN2,NSAM,BUF,6,210,VALUES,'U',NOPRNT)
          ELSE
C            SHORT LABEL INPUT FILE
             NOPRNT = -1
             CALL SETLAB(LUN2,NSAM,BUF,6,6,VALUES,'U',NOPRNT)
             IF (ANGLES(1) .EQ. 1.0) THEN
C               USE TILT ANGLES FROM OLD TITLE
                NOPRNT = -1
                CALL SETLAB(LUN2,NSAM,BUF,14,NANGLE,ANGLES,'U',NOPRNT)
             ENDIF

             LENBYT = NSAM * 4
             LABREC = 1024 / LENBYT
             IF (MOD(1024,LENBYT) .NE. 0) LABREC = LABREC + 1
             VALUES(1) = NSAM * 4 * LABREC
             VALUES(2) = NSAM * 4
             CALL SETLAB(LUN2,NSAM,BUF,22,2,VALUES,'U',NOPRNT)
          ENDIF
a55 2
        ENDIF        

d57 1
a57 23
        IF ((IFORM .EQ. 1 .OR. IFORM .EQ. 3).AND. IHIST .EQ. 0) THEN
C          2D OR 3D IMAGE WITHOUT HISTOGRAM
           IEND = NROW * NSLIC1

        ELSEIF ((IFORM .EQ. 1 .OR. IFORM .EQ. 3).AND. IHIST .NE. 0) THEN
C          2D OR 3D IMAGE WITH STORED HISTOGRAM
           IEND = NROW * NSLIC1 + NHISTREC

        ELSEIF (IFORM .EQ. -1) THEN
C          2D FOURIER FILE
           IEND = (NSAM + 2) * NROW
           IEND = IEND / NSAM
           IF (MOD(IEND,NSAM) .NE. 0) IEND = IEND + 1

        ELSEIF (IFORM .EQ. -7 .OR. IFORM .EQ. -9) THEN
C          3D FOURIER (MICHAELS FORMAT)
           IEND = NROW * NSLIC1

        ELSE
C          OTHER ODD FILE TYPE, JUST COPY IMAGE RECORDS
           IEND = NROW * NSLIC1
        ENDIF

d60 1
a60 1
        DO 100 I = 1,IEND
d63 1
a63 1
100     CONTINUE
d67 2
@


1.3
log
@added code to set loc 22 & 23 on short to long label copy
@
text
@d154 1
a154 1
           IEND = NROW * NSLIC1 + NLABEL
@


1.2
log
@cpp_lines_added
@
text
@d2 1
a2 1
C++*************************************************************************
d4 1
a4 1
C $$ COPYD.FOR -- CREATED 23 DEC 87 al
d6 1
a6 1
C **************************************************************************
d14 1
a14 1
C **************************************************************************
d16 5
a20 1
C $$ COPYD(IRTFLG)
d22 1
a22 1
C      PARAMETERS:       IRTFLG       ERROR FLAG
d46 1
a46 1
        NULL=CHAR(0)
d68 1
a68 1
          DO 250 I=1,NROW
d72 1
a72 1
250	  CONTINUE
d121 1
d136 7
@


1.1
log
@Initial revision
@
text
@d26 3
d30 1
@
