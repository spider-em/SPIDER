head	1.36;
access;
symbols
	pre_getangas:1.36
	GPL2010:1.36
	pre_GPL2010:1.35
	pre_var_equation:1.35
	pre_fftwrings:1.35
	pre_opfiles:1.34
	src:1.34
	best-code:1.34
	x-named-regs:1.34
	x:1.34
	v13-00:1.34
	pre_GPL:1.32
	prec_CA:1.28
	noindx:1.28;
locks; strict;
comment	@c @;


1.36
date	2010.06.24.13.25.38;	author leith;	state Exp;
branches;
next	1.35;

1.35
date	2007.10.04.13.48.14;	author leith;	state Exp;
branches;
next	1.34;

1.34
date	2005.10.17.20.26.31;	author leith;	state Exp;
branches;
next	1.33;

1.33
date	2005.10.17.18.18.16;	author leith;	state Exp;
branches;
next	1.32;

1.32
date	2004.09.30.18.30.25;	author leith;	state Exp;
branches;
next	1.31;

1.31
date	2004.05.14.13.58.35;	author leith;	state Exp;
branches;
next	1.30;

1.30
date	2004.04.06.16.00.35;	author leith;	state Exp;
branches;
next	1.29;

1.29
date	2004.03.26.14.55.14;	author leith;	state Exp;
branches;
next	1.28;

1.28
date	2002.10.18.15.13.50;	author leith;	state Exp;
branches;
next	1.27;

1.27
date	2002.10.15.19.49.05;	author leith;	state Exp;
branches;
next	1.26;

1.26
date	2002.10.07.19.04.39;	author leith;	state Exp;
branches;
next	1.25;

1.25
date	2002.10.07.19.01.11;	author leith;	state Exp;
branches;
next	1.24;

1.24
date	2002.05.03.17.57.41;	author leith;	state Exp;
branches;
next	1.23;

1.23
date	2002.05.01.20.31.52;	author leith;	state Exp;
branches;
next	1.22;

1.22
date	2002.04.09.15.51.40;	author leith;	state Exp;
branches;
next	1.21;

1.21
date	2002.04.08.17.32.59;	author leith;	state Exp;
branches;
next	1.20;

1.20
date	2002.04.03.19.29.02;	author leith;	state Exp;
branches;
next	1.19;

1.19
date	2002.04.01.20.57.16;	author leith;	state Exp;
branches;
next	1.18;

1.18
date	2002.03.11.14.08.13;	author leith;	state Exp;
branches;
next	1.17;

1.17
date	2001.09.14.17.40.14;	author leith;	state Exp;
branches;
next	1.16;

1.16
date	2001.06.22.16.00.26;	author leith;	state Exp;
branches;
next	1.15;

1.15
date	2001.06.20.17.31.50;	author leith;	state Exp;
branches;
next	1.14;

1.14
date	2001.06.19.19.13.03;	author leith;	state Exp;
branches;
next	1.13;

1.13
date	2001.05.25.15.01.16;	author leith;	state Exp;
branches;
next	1.12;

1.12
date	2001.05.09.14.24.20;	author leith;	state Exp;
branches;
next	1.11;

1.11
date	2001.05.08.14.01.00;	author leith;	state Exp;
branches;
next	1.10;

1.10
date	2001.05.07.20.00.14;	author leith;	state Exp;
branches;
next	1.9;

1.9
date	2001.05.04.19.25.05;	author leith;	state Exp;
branches;
next	1.8;

1.8
date	2001.05.03.19.11.32;	author leith;	state Exp;
branches;
next	1.7;

1.7
date	2001.05.03.18.49.03;	author leith;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.03.17.56.14;	author leith;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.03.16.16.30;	author leith;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.03.13.39.15;	author leith;	state Exp;
branches;
next	1.3;

1.3
date	2001.05.02.17.53.51;	author leith;	state Exp;
branches;
next	1.2;

1.2
date	2001.04.30.20.16.50;	author leith;	state Exp;
branches;
next	1.1;

1.1
date	2001.04.30.19.28.00;	author leith;	state Exp;
branches;
next	;


desc
@@


1.36
log
@GPL_2010
@
text
@C ++********************************************************************
C                                                                      *
C FILTER                  CREATED             MAR 2001 ARDEAN LEITH    * 
C                         ADDED OPERATIONS    MAY 2001 ARDEAN LEITH    *
C                         3D FIXED           JUNE 2001 ARDEAN LEITH    *
C                         TOP HAT NEIGH FIXED APR 2002 ArDean Leith    *
C                         PRE & SOBEL 3D BUG  APR 2002 ArDean Leith    *
C                         LAHE                APR 2002 ArDean Leith    *
C                         VAR BUG FIXED       OCT 2002 ArDean Leith
C                         SOME STACKS SUPPORT OCT 2002 ArDean Leith    *
C                         VS PIXEL REGISTER   OCT 2004 ArDean Leith    *
C                                                                      *
C **********************************************************************
C=*                                                                    *
C=* This file is part of:   SPIDER - Modular Image Processing System.  *
C=* SPIDER System Authors:  Joachim Frank & ArDean Leith               *
C=* Copyright 1985-2010  Health Research Inc.,                         *
C=* Riverview Center, 150 Broadway, Suite 560, Menands, NY 12204.      *
C=* Email: spider@@wadsworth.org                                        *
C=*                                                                    *
C=* SPIDER is free software; you can redistribute it and/or            *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* SPIDER is distributed in the hope that it will be useful,          *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* merchantability or fitness for a particular purpose.  See the GNU  *
C=* General Public License for more details.                           *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program. If not, see <http://www.gnu.org/licenses> *
C=*                                                                    *
C **********************************************************************
C
C  FILTER(LUN1,LUN2,NSAM,NROW,NSLICE,MODE)
C
C  PARAMETERS: LUN1,LUN2   IO UNITS                             (INPUT)
C              NSAM        X DIMENSIONS                         (INPUT)
C              NROW        Y DIMENSIONS                         (INPUT)
C              NSLICE      Z DIMENSIONS                         (INPUT)
C              MODE        TYPE SPECIFIER                       (INPUT)
C              FMINT       INPUT IMAGE MINIMUM                  (INPUT)
C                          F:  FREI-CHEN - 3x3 NEIGHBORHOOD
C                          G : GRADIENT  - 3x3 NEIGHBORHOOD
C                          LA: LAPLACIAN - RECTILINEAR NEIGHBORHOOD
C                          LH: LOCAL AREA HISTOGRAM EQUALIZATION
C                          MA: MAXIMUM   - RECTILINEAR NEIGHBORHOOD
C                          MI: MINIMUM   - RECTILINEAR NEIGHBORHOOD
C                          p:  PREWITT   - 3x3 NEIGHBORHOOD
C                          R:  RANGE     - RECTILINEAR NEIGHBORHOOD
C                          RI: RIDGE FOLLOWING
C                          S:  SOBEL     - 3x3 NEIGHBORHOOD
C                          T:  TOPHAT    - CIRCULAR NEIGHBORHOOD
C                          V:  VARIANCE  - RECTILINEAR NEIGHBORHOOD
C                          VS: VARIANCE SMOOTHING  - RECTILINEAR NEIGH.
C
C  PURPOSE: ALTER CONTRAST IN AN IMAGE OR VOLUME USING CONVOLUTION OR 
C           OTHER LOCAL IMAGE SPACE METHODS
C                                                                      *
C **********************************************************************

	SUBROUTINE FILTER(LUN1,LUN2,NSAM,NROW,NSLICE,MAXIM,
     &                    MODE,FMINT,FMAXT,SIGT)

	INCLUDE 'CMBLOCK.INC'
        INCLUDE 'CMLIMIT.INC'

	REAL, ALLOCATABLE, DIMENSION(:)  ::  VIN,VKERNAL

	REAL, DIMENSION(9)  ::  GRAD2,GRAD2X,GRAD2Y,LAPL2
	REAL, DIMENSION(9)  ::  SOBX,SOBY,PREX,PREY
	REAL, DIMENSION(27) ::  GRAD3,GRAD3X,GRAD3Y,GRAD3Z,LAPL3
	REAL, DIMENSION(27) ::  SOBX3,SOBY3,SOBZ3,PREX3,PREY3,PREZ3

	CHARACTER(LEN=2) ::   MODE 
        LOGICAL          ::   THREED,LOADIT

        REAL, PARAMETER :: sq2 = 0.7071
        REAL, PARAMETER :: sq3 = 0.57735


C       SIMPLE 3X3 LAPLACIAN (DYNAMIC BELOW)
        DATA LAPL2 / -1.0,-1.0,-1.0,
     &               -1.0, 8.0,-1.0,  
     &               -1.0,-1.0,-1.0/

        DATA LAPL3 / -1.0,-1.0,-1.0,  -1.0,-1.0,-1.0,  -1.0,-1.0,-1.0,
     &               -1.0,-1.0,-1.0,  -1.0,26.0,-1.0,  -1.0,-1.0,-1.0,
     &               -1.0,-1.0,-1.0,  -1.0,-1.0,-1.0,  -1.0,-1.0,-1.0/

C       GRADIENT MAGNITUDE
        DATA GRAD2 /0.7071,  1.0, 0.7071,   
     &              1.0000, -1.0, 1.000,  
     &              0.7071,  1.0, 0.7071/

C       GRADIENT X COMPONENT
        DATA GRAD2X/ -.7071, 0.0, 0.7071,  
     &              -1.000,  0.0, 1.000,  
     &               -.7071, 0.0, 0.7071/

C       GRADIENT Y COMPONENT
        DATA GRAD2Y/0.7071, 1.0, 0.7071,  
     &              0.000,  0.0, 0.000,  
     &              -.7071,-1.0, -.7071/

C       GRADIENT MAGNITUDE
        DATA GRAD3/
     &      .57735,.7071,.57735, .7071,1.0,.7071, .57735,.7071,.57735,
     &      .7071,  1.0,  .7071,   1.0, 1.0, 1.0,   .7071, 1.0,  .7071,
     &      .57735,.7071,.57735, .7071,1.0,.7071, .57735,.7071,.57735/

C       GRADIENT X COMPONENT
        DATA GRAD3X/
     &        -.57735,0.0,.57735, -.7071,0.0,.7071, -.57735,0.0,.57735,
     &        -.7071, 0.0,.7071,  -1.0,  0.0, 1.0,  -.7071, 0.0, .7071,
     &        -.57735,0.0,.57735, -.7071,0.0,.7071, -.57735,0.0,.57735/

C       GRADIENT Y COMPONENT
        DATA GRAD3Y/
     &        .57735,.7071,.57735, 0.0,0.0,0.0, -.57735,-.7071,-.57735,
     &        .7071, 1.0,  .7071,  0.0,0.0,0.0, -.7071,  -1.0, -.7071,
     &        .57735,.7071,.57735, 0.0,0.0,0.0, -.57735,-.7071,-.57735/
        
C       GRADIENT Z COMPONENT
        DATA GRAD3Z/
     &          -.57735,-.7071,-.57735,  -.7071,-1.0,-.7071,
     &          -.57735,-.7071,-.57735,
     &          0.0, 0.0, 0.0,   0.0, 0.0,0.0,    0.0, 0.0, 0.0,
     &           .57735, .7071, .57735,   .7071, 1.0,.7071,    
     &           .57735, .7071, .57735/

C       SOBEL X MASK
        DATA SOBX/
     &       -1, 0, 1,
     &       -2, 0, 2,
     &       -1, 0, 1/

C       SOBEL Y MASK
        DATA SOBY/
     &        1, 2, 1,
     &        0, 0, 0,
     &       -1,-2,-1/

C       SOBEL 3D X MASK
        DATA  SOBX3/
     &       -1, 0, 1,
     &       -2, 0, 2,
     &       -1, 0, 1,
     &       -1, 0, 1,
     &       -2, 0, 2,
     &       -1, 0, 1,
     &       -1, 0, 1,
     &       -2, 0, 2,
     &       -1, 0, 1/

C       SOBEL 3D Y MASK
        DATA SOBY3/
     &        1, 2, 1,
     &        0, 0, 0,
     &       -1,-2,-1,

     &        1, 2, 1,
     &        0, 0, 0,
     &       -1,-2,-1,

     &        1, 2, 1,
     &        0, 0, 0,
     &       -1,-2,-1/

C       SOBEL 3D Z MASK
         DATA SOBZ3/
     &        1, 1, 1, 
     &        2, 2, 2, 
     &        1, 1, 1,

     &        0, 0, 0,
     &        0, 0, 0,
     &        0, 0, 0,

     &       -1,-1,-1, 
     &       -2,-2,-2, 
     &       -1,-1,-1/

C       PREWITT X MASK
        DATA PREX/
     &        1, 0,-1,
     &        1, 0,-1,
     &        1, 0,-1/

C       PREWITT Y MASK
        DATA PREY/
     &       -1,-1,-1,
     &        0, 0, 0,
     &        1, 1, 1/

C       PREWITT 3D X MASK
        DATA PREX3/
     &        1, 0,-1,
     &        1, 0,-1,
     &        1, 0,-1,
     &        1, 0,-1,
     &        1, 0,-1,
     &        1, 0,-1,
     &        1, 0,-1,
     &        1, 0,-1,
     &        1, 0,-1/

C       PREWITT 3D Y MASK
        DATA PREY3/
     &       -1,-1,-1,
     &        0, 0, 0,
     &        1, 1, 1,
     &       -1,-1,-1,
     &        0, 0, 0,
     &        1, 1, 1,
     &       -1,-1,-1,
     &        0, 0, 0,
     &        1, 1, 1/
 
C       PREWITT 3D Z MASK
         DATA PREZ3/
     &        1, 1, 1, 
     &        1, 1, 1, 
     &        1, 1, 1,
     &        0, 0, 0,
     &        0, 0, 0,
     &        0, 0, 0,
     &       -1,-1,-1, 
     &       -1,-1,-1, 
     &       -1,-1,-1/

        THREED = (NSLICE .GT. 1)

C       SET DEFAULT NEIGHBORS
        LX = 3
        LY = 3
        LZ = 1
        IF (THREED) LZ = 3
        NEIGH = LX * LY * LZ

C       CATEGORIES ONLY USED BY HURST
        ICAT = 1

C       SOME FILTERS NEED >1 KERNAL
        NK  = 1
        IF (MODE(1:1) .EQ. 'S' .OR. MODE(1:1) .EQ. 'P' .OR.
     &      MODE(1:1) .EQ. 'H') NK = 2
        IF ((MODE(1:1) .EQ. 'S' .OR. MODE(1:1) .EQ. 'P' ) .AND. 
     &       NSLICE .GT. 1) NK = 3
        IF (MODE(1:1) .EQ. 'F') NK = 9

        IF (MODE(1:1) .EQ. 'T') THEN
C          TOP-HAT OVER SPECIFIED NEIGHBORHOOD

11         CALL RDPRIS(IDIN,IDOUT,NOT_USED,
     &                 'INNER & OUTER DIAMETERS',IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9999

           IF ((IDIN  .LT. 1 .OR. MOD(IDIN,2)  .EQ. 0) .OR.
     &         (IDOUT .LT. 1 .OR. MOD(IDOUT,2) .EQ. 0)) THEN
              CALL ERRT(101,'DIAMETERS MUST BE ODD  AND > 0',IDUM) 
              GOTO 11
           ENDIF

           RADIN  = IDIN  / 2.0 
           RADOUT = IDOUT / 2.0 
           LX     = IDOUT
           LY     = LX
           NEIGH  = LX * LY
           LZ     = 0
           IF (THREED) THEN
              LZ    = LX
              NEIGH = NEIGH * LZ
           ENDIF

        ELSEIF (MODE(1:1) .EQ. 'H') THEN
C          HURST OVER SPECIFIED DIAMETER

12         CALL RDPRI1S(IDOUT,NOT_USED,'DIAMETER',IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9999

           IF (IDOUT .LT. 1 .OR. MOD(IDOUT,2) .EQ. 0) THEN
              CALL ERRT(101,'DIAMETER MUST BE ODD  AND > 0',IDUM) 
              GOTO 12
           ENDIF
           LX      = IDOUT 
           LY      = IDOUT
           NEIGH   = LX * LY
           LZ      = 1
           IF (THREED) THEN
              WRITE(NOUT,*) ' THIS FILTER IS NOT IMPLEMENTED IN 3D!' 
              WRITE(NOUT,*) ' VOLUME WILL BE PROCESSED SLICE-BY-SLICE' 
              THREED = .FALSE.
           ENDIF

        ELSEIF (MODE(1:2) .EQ. 'RA' .OR. MODE(1:1) .EQ. 'M' .OR.
     &          MODE(1:1) .EQ. 'L'  .OR. MODE(1:1) .EQ. 'V' .OR.
     &          MODE(1:1) .EQ. '-'  .OR. MODE(1:1) .EQ. '-' .OR.
     &          MODE(1:2) .EQ. 'VS' .OR. MODE(1:2) .EQ. 'LH') THEN
C          RANGE, MAX, MIN, LAPLACIAN, VARIANCE, LOCAL HISTOGRAM
C          VARIANCE SMOOTHING, FILTER OVER SPECIFIED NEIGHBORHOOD

10         IF (THREED) THEN
              CALL RDPRI3S(LX,LY,LZ,NOT_USED,
     &                    'NEIGHBORHOOD X, Y, & Z',IRTFLG)
           ELSE
              CALL RDPRIS(LX,LY,NOT_USED,'NEIGHBORHOOD X & Y',IRTFLG)
              LZ = 1
           ENDIF
           IF (IRTFLG .NE. 0) GOTO 9999

           IF (LX .LT. 3 .OR. MOD(LX,2) .EQ. 0 .OR. 
     &         LY .LT. 3 .OR. MOD(LY,2) .EQ. 0 .OR. (THREED .AND.
     &         LZ .LT. 3 .OR. MOD(LZ,2) .EQ. 0)) THEN
              CALL ERRT(101,'DIMENSIONS MUST BE ODD  AND > 2',IDUM) 
              GOTO 10
           ENDIF

           NEIGH = LX * LY * LZ

	   IF (MODE(1:2) .EQ. 'LH') THEN
C             LAHE
              NBINS = 64
              CALL RDPRI1S(NBINS,NOT_USED,'NUMBER OF BINS',IRTFLG)
              IF (IRTFLG .NE. 0) GOTO 9999
              GOTO 1000

           ENDIF
        ELSEIF (MODE(1:1) .EQ. 'F') THEN
C          FREI-CHEN FILTER OVER 3x3 NEIGHBORHOOD
           IF (THREED) THEN
              WRITE(NOUT,*) ' THIS FILTER IS NOT IMPLEMENTED IN 3D!' 
              WRITE(NOUT,*) ' VOLUME WILL BE PROCESSED SLICE-BY-SLICE' 
              THREED = .FALSE.
              LZ     = 1
              NEIGH  = LX * LY 
           ENDIF
        ENDIF

C       ALLOCATE SPACE FOR KERNAL(S)
 	ALLOCATE(VKERNAL(NEIGH*NK),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
            CALL ERRT(46,'CE, VKERNAL',IER)
            RETURN
        ENDIF

        IF (MODE(1:2) .EQ. 'GX') THEN
C          X GRADIENT OVER A 3X3 NEIGHBORHOOD
           IF (THREED) THEN
              VKERNAL = GRAD3X 
           ELSE
              VKERNAL = GRAD2X
           ENDIF

        ELSEIF (MODE(1:2) .EQ. 'GY') THEN
C          Y GRADIENT OVER A 3X3 NEIGHBORHOOD
           IF (THREED) THEN
              VKERNAL = GRAD3Y 
           ELSE
              VKERNAL = GRAD2Y
           ENDIF

        ELSEIF (MODE(1:2) .EQ. 'GZ') THEN
C          Z GRADIENT OVER A 3X3 NEIGHBORHOOD
           VKERNAL = GRAD3Z 

        ELSEIF (MODE(1:1) .EQ. 'G') THEN
C          GRADIENT OVER A 3X3 NEIGHBORHOOD
           IF (THREED) THEN 
              VKERNAL = GRAD3
           ELSE
              VKERNAL = GRAD2
           ENDIF
           VKERNAL(NEIGH/2 + 1) = - (NEIGH - 1)

        ELSEIF (MODE(1:1) .EQ. 'V') THEN
C          VARIANCE, VARIANCE SMOOTHING  OVER A RECTILINEAR NEIGHBORHOOD
           CONTINUE

        ELSEIF (MODE(1:1) .EQ. 'R' .OR.
     &          MODE(1:2) .EQ. 'MA' .OR. MODE(1:2) .EQ. 'MI') THEN
C          RANGE, RIDGE, MAX. OR MIN. OVER A RECTILINEAR NEIGHBORHOOD
           DO I = 1, NEIGH
              VKERNAL(I) = 1.0
           ENDDO
           VKERNAL(NEIGH/2 + 1) = 0.0

        ELSEIF (MODE(1:1) .EQ. 'L') THEN
C          LAPLACIAN  OVER A RECTILINEAR NEIGHBORHOOD
           DO I = 1, NEIGH
              VKERNAL(I) = -1.0
           ENDDO
           VKERNAL(NEIGH/2 + 1)   =  NEIGH - 1

        ELSEIF (MODE(1:1) .EQ. 'S') THEN
C          SOBEL OVER A 3X3 NEIGHBORHOOD
           IF (.NOT. THREED) THEN
              DO I = 1, NEIGH
                 VKERNAL(I)         = SOBX(I)
                 VKERNAL(I+NEIGH)   = SOBY(I)
              ENDDO
           ELSE
              DO I = 1, NEIGH
                 VKERNAL(I)         = SOBX3(I)
                 VKERNAL(I+NEIGH)   = SOBY3(I)
                 VKERNAL(I+2*NEIGH) = SOBZ3(I)
              ENDDO
           ENDIF

         ELSEIF (MODE(1:1) .EQ. 'P') THEN
C          PREWITT OVER A 3X3 NEIGHBORHOOD
           IF (.NOT. THREED) THEN
              DO I = 1, NEIGH
                 VKERNAL(I)         = PREX(I)
                 VKERNAL(I+NEIGH)   = PREY(I)
              ENDDO
           ELSE
              DO I = 1, NEIGH
                 VKERNAL(I)         = PREX3(I)
                 VKERNAL(I+NEIGH)   = PREY3(I)
                 VKERNAL(I+2*NEIGH) = PREZ3(I)
              ENDDO
           ENDIF

        ELSEIF (MODE(1:1) .EQ. 'T') THEN
C          TOP-HAT
           LXD2 = LX / 2
           LZD2 = LZ / 2
	   CALL FILTER_HAT(RADIN,RADOUT,LXD2,LZD2,NEIGH,
     &                     VKERNAL,THREED)

        ELSEIF (MODE(1:1) .EQ. 'H') THEN
C          HURST
           LXD2 = LX / 2
	   CALL FILTER_HURST(LXD2,THREED,NEIGH,ICAT,
     &             VKERNAL,VKERNAL(NEIGH+1))

        ELSEIF (MODE(1:1) .EQ. 'F') THEN
C          FREI-CHEN
	   CALL FILTER_FREI(NEIGH,VKERNAL)
        ENDIF

1000    CONTINUE
        ALLOCATE(VIN(NSAM*NROW*NSLICE),STAT=IRTFLG)
        IF (IRTFLG .NE. 0) THEN
           CALL ERRT(46,'CE, VIN',IER)
           GOTO 9999
        ENDIF

        IF (MAXIM .LE. 0) THEN
C          NOT A WHOLE STACK, LOAD INPUT VOLUME
           CALL REDVOL(LUN1,NSAM,NROW,1,NSLICE,VIN,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9999
        ENDIF

        LXD2  = LX / 2
        LYD2  = LY / 2
        LZD2  = LZ / 2

        WRITE(NOUT,90) NEIGH
90      FORMAT('  NEIGHBORHOOD: ',I4)

        IF (MODE(1:2) .EQ. 'LH') THEN
C          LAHE
           CALL FILTER_LAHE(VIN,NSAM,NROW,NSLICE,LXD2,LYD2,LZD2,
     &                     NEIGH,MODE,LUN2,FMINT,FMAXT,NBINS)

        ELSEIF ((NK .GT. 1) .AND. THREED) THEN
C          USES MULTIPLE KERNALS ON A WHOLE VOLUME
           CALL FILTER3M(VIN,NSAM,NROW,NSLICE,VKERNAL,LXD2,LYD2,LZD2,
     &                  NEIGH,MODE,NK,LUN2,ICAT)

        ELSEIF (NK .GT. 1) THEN
C          USES MULTIPLE KERNALS ON 2D IMAGE
           DO ISLICE=1,NSLICE
              ILOC = (ISLICE - 1) * NROW * NSAM + 1
              CALL FILTER2M(VIN(ILOC),NSAM,NROW,NSLICE,VKERNAL,
     &                      LXD2,LYD2,1,NEIGH,MODE,NK,LUN2,ICAT,ISLICE)
           ENDDO

        ELSEIF (THREED) THEN
C          OPERATION WORKS ON A WHOLE VOLUME
           CALL FILTER3(VIN,NSAM,NROW,NSLICE,VKERNAL,LXD2,LYD2,LZD2,
     &                  NEIGH,MODE,LUN2,FMINT,SIGT)

        ELSE
C          OPERATION WORKS ON 2D IMAGE OR SLICE-BY-SLICE THRU A VOLUME
C          INCLUDING STACKS
           LOADIT = (MAXIM .GT. 0)
           IMGNUM = -3
           DO WHILE (IMGNUM .LT. MAXIM) 
              CALL GETSTACK(LUN1,LUN2,IMGNUM,MAXIM,VERBOSE,
     &                      LOADIT,VIN,.TRUE.,IRTFLG)
              IF (IRTFLG .NE. 0) GOTO 9999

              DO ISLICE=1,NSLICE
                 ILOC = (ISLICE - 1) * NROW * NSAM + 1
                 CALL FILTER2(VIN(ILOC),NSAM,NROW,NSLICE,VKERNAL,
     &                      LXD2,LYD2,NEIGH,MODE,LUN2,FMIN,ISLICE,SIGT)
              ENDDO
           ENDDO
        ENDIF

9999    IF (ALLOCATED(VIN))     DEALLOCATE(VIN)
        IF (ALLOCATED(VKERNAL)) DEALLOCATE(VKERNAL)

        END


C       ------------------------- FILTER2M ----------------------------

	SUBROUTINE FILTER2M(VIN,NSAM,NROW,NSLICE,VKERNAL,LXD2,LYD2,LZD2,
     &                     NEIGH,MODE,NKT,LUN2,ICAT,IZ)

	REAL, DIMENSION(NSAM,NROW) :: VIN
	REAL, DIMENSION(-LXD2:LXD2,-LYD2:LYD2,NKT) :: VKERNAL

C       AUTOMATIC ARRAY
	REAL, DIMENSION(NSAM) :: VOUT
	REAL, DIMENSION(ICAT) :: VALSMIN,VALSMAX

	CHARACTER(LEN=2) ::      MODE

        NK = NKT 
        IF (MODE(1:1) .EQ. 'H') NK = 1

        DO IY=1,NROW  
                    
           DO IX=1,NSAM
              VALT  = 0.0
              IF (MODE(1:1) .EQ. 'R' .OR. MODE(1:1) .EQ. 'M' .OR.
     &            MODE(1:1) .EQ. 'S' .OR. MODE(1:1) .EQ. 'P') THEN
C                RANGE, ETC, USE MIN OR MAX OR BOTH
                 VALMIN = HUGE(VALMIN)
                 VALMAX = -VALMIN

              ELSEIF (MODE(1:1) .EQ. 'H') THEN
C                HURST,  ZERO DIFFERENCE ARRAYS
                 VALSMIN =  HUGE(VALMIN) 
                 VALSMAX = -VALSMIN 
 
              ELSEIF (MODE(1:1) .EQ. 'F') THEN
C                FREI CHEN NEEDS TWO SUMS
                 VAL1 = 0.0
                 VAL2 = 0.0
              ENDIF

C             APPLY  MULTIPLE KERNALS
              DO KER = 1,NK
                 IF (MODE .EQ. 'F') VALT = 0.0
                 DO MY=-LYD2,LYD2
                    IYT = MOD(IY+MY+NROW-1,NROW)+1

                    DO MX=-LXD2,LXD2
C                      VALUE FOR PIXEL UNDER CURRENT KERNAL ELEMENT
                       VOK = VIN(MOD(IX+MX+NSAM-1,NSAM)+1,IYT)

                       IF (MODE(1:1) .EQ. 'H') THEN
C                         HURST
                          IVOK = VKERNAL(MX,MY,1)
                          IF (IVOK .GT. 0) THEN
                             VALSMIN(IVOK) = MIN(VALSMIN(IVOK),VOK) 
                             VALSMAX(IVOK) = MAX(VALSMAX(IVOK),VOK) 
                          ENDIF
                       ELSE
                          VALT = VALT + VOK * VKERNAL(MX,MY,KER)
                       ENDIF

                    ENDDO
C                   END LOOP: MX=-LXD2,LXD2 

                 ENDDO
C                END LOOP: DO MY=-LYD2,LYD2 

                 IF (MODE(1:1) .EQ. 'S' .OR. MODE(1:1) .EQ. 'P') THEN
C                   SOBEL OR PREWITT
                    VALMAX = MAX(VALMAX,VALT)

                 ELSEIF (MODE(1:1) .EQ. 'F') THEN
C                   FREI-CHEN
                    IF (KER .GE. 2 .AND. KER .LE. 3) THEN
                       VAL1 = VAL1 + VALT**2
                    ELSE
                       VAL2 = VAL2 + VALT**2
                    ENDIF
                 ENDIF

              ENDDO
C             END LOOP:  DO KER = 1,NK

              IF (MODE(1:1) .EQ. 'S' .OR. MODE(1:1) .EQ. 'P') THEN
C                SOBEL OR PREWITT
                 VOUT(IX) = VALMAX

              ELSEIF (MODE(1:1) .EQ. 'H') THEN
C                HURST
	         CALL FILTER_HURST_DO(VKERNAL(-LXD2,-LYD2,2),ICAT,
     &               VALSMIN,VALSMAX,VOUT(IX))

               ELSEIF (MODE(1:1) .EQ. 'F') THEN
C                FREI-CHEN
                 IF (VAL2 .NE. 0.0) THEN
                    VOUT(IX) = COS(SQRT(VAL1/VAL2))
                 ELSE
C                   I DO NOT KNOW IF THIS IS OK??? al
                    VOUT(IX) = 0.0
                 ENDIF
             ENDIF

           ENDDO
C          END LOOP:  DO IX=1,NSAM
 
C          OUTPUT IMAGE
           IREC = (IZ - 1) * NROW + IY
           CALL WRTLIN(LUN2,VOUT,NSAM,IREC)
         ENDDO

         END	

C       ------------------------- FILTER3M ----------------------------

	SUBROUTINE FILTER3M(VIN,NSAM,NROW,NSLICE,VKERNAL,LXD2,LYD2,LZD2,
     &                     NEIGH,MODE,NKT,LUN2,ICAT)

	REAL, DIMENSION(NSAM,NROW,NSLICE) :: VIN
	REAL, DIMENSION(-LXD2:LXD2,-LYD2:LYD2,-LZD2:LZD2,NKT) :: VKERNAL

C       AUTOMATIC ARRAY
	REAL, DIMENSION(NSAM)      :: VOUT

	CHARACTER(LEN=2) ::           MODE 

        NK = NKT 
        IF (MODE(1:1) .EQ. 'H') NK = 1

        DO IZ=1,NSLICE

        DO IY=1,NROW  
                    
           DO IX=1,NSAM
              VALT = 0.0
              IF (MODE(1:1) .EQ. 'R' .OR. MODE(1:1) .EQ. 'M' .OR.
     &            MODE(1:1) .EQ. 'S' .OR. MODE(1:1) .EQ. 'P') THEN
C                RANGE, ETC, USE MIN OR MAX OR BOTH
                 VALMIN = HUGE(VALMIN)
                 VALMAX = -VALMIN
              ENDIF

C             APPLY  MULTIPLE KERNALS
              DO KER = 1,NK
                 DO MZ=-LZD2,LZD2
                    IZT = MOD(IZ+MZ+NSLICE-1,NSLICE)+1 
 
                    DO MY=-LYD2,LYD2
                       IYT = MOD(IY+MY+NROW-1,NROW)+1

                      DO MX=-LXD2,LXD2
C                         VALUE FOR PIXEL UNDER CURRENT KERNAL ELEMENT
                          VOK = VIN(MOD(IX+MX+NSAM-1,NSAM)+1,IYT,IZT)

                          VALT = VALT + VOK * VKERNAL(MX,MY,MZ,KER)
                       ENDDO
C                      END LOOP: MX=-LXD2,LXD2 
                    ENDDO
C                   END LOOP: DO MY=-LYD2,LYD2 
                 ENDDO

                 IF (MODE(1:1) .EQ. 'S' .OR. MODE(1:1) .EQ. 'P') THEN
C                   SOBEL OR PREWITT
                    VALMAX = MAX(VALMAX,VALT)
                 ENDIF

              ENDDO
C             END LOOP:  DO KER = 1,NK

              IF (MODE(1:1) .EQ. 'S' .OR. MODE(1:1) .EQ. 'P') THEN
C                SOBEL OR PREWITT
                 VOUT(IX) = VALMAX
              ENDIF

           ENDDO
C          END LOOP:  DO IX=1,NSAM
 
C          OUTPUT IMAGE
           IREC = (IZ - 1) * NROW + IY
           CALL WRTLIN(LUN2,VOUT,NSAM,IREC)
         ENDDO
         ENDDO

         END	

C       ------------------------- FILTER3 -----------------------------

	SUBROUTINE FILTER3(VIN,NSAM,NROW,NSLICE,VKERNAL,LXD2,LYD2,LZD2,
     &                     NEIGH,MODE,LUN2,FMINT,SIGT)

	INCLUDE 'CMBLOCK.INC'

	REAL, DIMENSION(NSAM,NROW,NSLICE)                 :: VIN
	REAL, DIMENSION(-LXD2:LXD2,-LYD2:LYD2,-LZD2:LZD2) :: VKERNAL

C       AUTOMATIC ARRAY
        REAL, DIMENSION(NEIGH) :: FMED
	REAL, DIMENSION(NSAM)  :: VOUT

	CHARACTER(LEN=2)       :: MODE 

        IF (MODE(1:1) .EQ. 'V') THEN
C          VARIANCE OR VARIANCE SMOOTHING
           CONAVG  = 1.0 / FLOAT(NEIGH)
           CONVAR  = 1.0 / FLOAT(NEIGH -1)
           SIGTSQ  = SIGT**2
           KMED    = NEIGH / 2 + 1
           NREPL   = 0
        ENDIF

        DO IZ=1,NSLICE
        DO IY=1,NROW  
                    
           DO IX=1,NSAM
              VALT = 0.0

              IF (MODE(1:1) .EQ. 'V') THEN
C                VARIANCE
                 VALAVG  = 0
                 VOC     = VIN(IX,IY,IZ)    
                 LMED    = 0

              ELSEIF (MODE(1:1) .EQ. 'R' .OR. MODE(1:1) .EQ. 'M' .OR.
     &                MODE(1:1) .EQ. 'T') THEN
C                RANGE, RIDGE, MIN, MAX, OR TOP-HAT
                 VALMIN  = HUGE(VALMIN)
                 VALMAX  = -VALMIN
                 VALMAX2 = -VALMIN
                 VOC     = VIN(IX,IY,IZ)    
              ENDIF

C             APPLY KERNAL
              DO MZ=-LZD2,LZD2
              IZT = MOD(IZ+MZ+NSLICE-1,NSLICE)+1 
 
              DO MY=-LYD2,LYD2
                 IYT = MOD(IY+MY+NROW-1,NROW)+1

                 DO MX=-LXD2,LXD2
C                   VALUE FOR IMAGE UNDER CURRENT KERNAL ELEMENT
                    VOK = VIN(MOD(IX+MX+NSAM-1,NSAM)+1,IYT,IZT)

                    IF (MODE(1:1) .EQ. 'V') THEN
C                      USE SQ. FOR VARIANCE
                       VALT   = VALT   + VOK ** 2
                       VALAVG = VALAVG + VOK 

                       IF (MODE(2:2) .EQ. 'S') THEN
C                          NEED TO GET MEDIAN FOR VARIANCE SMOOTHING
                           LMED       = LMED + 1
                           FMED(LMED) = VOK
                       ENDIF
 
                    ELSEIF (MODE(1:1) .EQ. 'R' .OR. 
     &                      MODE(1:1) .EQ. 'M') THEN
C                      RANGE, RIDGE, MIN., OR MAX.
                       VALMIN = MIN(VALMIN,VOK)
                       VALMAX = MAX(VALMAX,VOK)

                    ELSEIF (MODE(1:1) .EQ. 'T') THEN
C                      TOP-HAT
                       IF (VKERNAL(MX,MY,MZ) .EQ. 1) THEN
                          VALMAX = MAX(VALMAX,VOK)
                       ELSEIF (VKERNAL(MX,MY,MZ) .EQ. 2) THEN
                          VALMAX2 = MAX(VALMAX2,VOK)
                       ENDIF

                    ELSE
C                      USE SUM OF KERNAL PRODUCTS
                       VALT = VALT + VOK * VKERNAL(MX,MY,MZ)
                    ENDIF
                 ENDDO
              ENDDO
              ENDDO

              IF (MODE(1:2) .EQ. 'RA') THEN
C                RANGE
                 VOUT(IX) = VALMAX - VALMIN

              ELSEIF (MODE(1:1) .EQ. 'R') THEN
C                RIDGE
                 IF (VOC .LT. VALMIN .OR. VALMAX .GT. VOC) THEN
                     VOUT(IX) = FMINT
                 ELSE
                     VOUT(IX) = VOC
                 ENDIF
              ELSEIF (MODE(1:2) .EQ. 'MA') THEN
C                MAX
                 VOUT(IX) = VALMAX 

              ELSEIF (MODE(1:2) .EQ. 'MI') THEN
C                MIN
                 VOUT(IX) = VALMIN 

              ELSEIF (MODE(1:1) .EQ. 'T') THEN
C                TOP-HAT
                 VOUT(IX) = VALMAX2 - VALMAX 

              ELSEIF (MODE(1:2) .EQ. 'VS') THEN
C                VARIANCE SMOOTHING
                 SLOC = ABS(CONVAR * 
     &                  (VALT - CONAVG *(VALAVG * VALAVG)))

                 IF (((VOC - VALAVG)**2) .GT. SLOC .AND. 
     &                SLOC .GT. SIGTSQ) THEN
C                    USE MEDIAN FROM NEIGHBORING VALUES
                     CALL FSORT(FMED,LMED)
                     VOUT(IX) = FMED(KMED)
                     NREPL    = NREPL + 1
                 ELSE
C                    KEEP SAME VALUE
                     VOUT(IX) = VOC
                 ENDIF

              ELSEIF (MODE(1:1) .EQ. 'V') THEN
C                VARIANCE
                 VOUT(IX) =  CONVAR * (VALT - CONAVG *(VALAVG * VALAVG)) 
              ELSE
                 VOUT(IX) = VALT
              ENDIF
 
          ENDDO

C          OUTPUT VOLUME LINE
           IREC = (IZ - 1) * NROW + IY
           CALL WRTLIN(LUN2,VOUT,NSAM,IREC)
         ENDDO
         ENDDO

         IF (MODE(1:2) .EQ. 'VS') THEN
C           VARIANCE SMOOTHING

            FREPL = FLOAT(NREPL)
            CALL REG_SET_NSEL(1,1, FNREPL,0.0, 0.0, 0.0, 0.0,IRTFLG)

            WRITE(NOUT,*) ' VOXELS REPLACED: ',NREPL
         ENDIF

         END	


C       ------------------------- FILTER2 -----------------------------

	SUBROUTINE FILTER2(VIN,NSAM,NROW,NSLICE,VKERNAL,LXD2,LYD2,NEIGH,
     &                      MODE,LUN2,FMINT,IZ,SIGT)

	INCLUDE 'CMBLOCK.INC'

	REAL, DIMENSION(NSAM,NROW)             :: VIN
	REAL, DIMENSION(-LXD2:LXD2,-LYD2:LYD2) :: VKERNAL

C       AUTOMATIC ARRAYS
	REAL, DIMENSION(NSAM)                  :: VOUT
        REAL, DIMENSION(NEIGH )                :: FMED

	CHARACTER(LEN=2)                       :: MODE 

        IF (MODE(1:1) .EQ. 'V') THEN
C          VARIANCE
           CONAVG   = 1.0 / FLOAT(NEIGH)
           CONVAR   = 1.0 / FLOAT(NEIGH - 1)
           SIGTSQ   = SIGT**2
           KMED     = NEIGH / 2 + 1
           NREPL    = 0
        ENDIF

        DO IY=1,NROW  
                    
           DO IX=1,NSAM
              VALT = 0.0

              IF (MODE(1:1) .EQ. 'V') THEN
C                VARIANCE
                 VALAVG  = 0
                 VOC     = VIN(IX,IY)    
                 LMED    = 0

             ELSEIF (MODE(1:1) .EQ. 'R' .OR. MODE(1:1) .EQ. 'M' .OR.
     &                MODE(1:1) .EQ. 'T') THEN
C                RANGE, RIDGE, MIN, MAX, OR TOP-HAT
                 VALMIN  = HUGE(VALMIN)
                 VALMAX  = -VALMIN
                 VALMAX2 = -VALMIN
                 VOC     = VIN(IX,IY)    
              ENDIF

C             APPLY KERNAL 
              DO MY=-LYD2,LYD2
                 IYT = MOD(IY+MY+NROW-1,NROW)+1

                 DO MX=-LXD2,LXD2
C                   VALUE FOR IMAGE UNDER CURRENT KERNAL ELEMENT
                    VOK = VIN(MOD(IX+MX+NSAM-1,NSAM)+1,IYT)

                    IF (MODE(1:1) .EQ. 'V') THEN
C                      USE SQ. FOR VARIANCE
                       VALT   = VALT   + VOK ** 2
                       VALAVG = VALAVG + VOK 

                       IF (MODE(2:2) .EQ. 'S') THEN
C                          NEED TO GET MEDIAN FOR VARIANCE SMOOTHING
                           LMED       = LMED + 1
                           FMED(LMED) = VOK
                       ENDIF
 
                    ELSEIF (MODE(1:1) .EQ. 'R' .OR. 
     &                      MODE(1:1) .EQ. 'M') THEN
C                      RANGE, RIDGE, MIN., OR MAX.
                       VALMIN = MIN(VALMIN,VOK)
                       VALMAX = MAX(VALMAX,VOK)

                    ELSEIF (MODE(1:1) .EQ. 'T') THEN
C                      TOP-HAT
                       IF (VKERNAL(MX,MY) .EQ. 1) THEN
C                         OUTER RING
                          VALMAX = MAX(VALMAX,VOK)

                       ELSEIF (VKERNAL(MX,MY) .EQ. 2) THEN
C                         INNER RING
                          VALMAX2 = MAX(VALMAX2,VOK)
                       ENDIF

                    ELSE
C                      USE SUM OF KERNAL * IMAGE PRODUCTS
                       VALT = VALT + VOK * VKERNAL(MX,MY)
                    ENDIF
                 ENDDO
              ENDDO

              IF (MODE(1:2) .EQ. 'RA') THEN
C                RANGE
                 VOUT(IX) = VALMAX - VALMIN

              ELSEIF (MODE(1:1) .EQ. 'R') THEN
C                RIDGE
                 IF (VOC .LT. VALMIN .OR. VALMAX .GT. VOC) THEN
                     VOUT(IX) = FMINT
                 ELSE
                     VOUT(IX) = VOC
                 ENDIF
              ELSEIF (MODE(1:2) .EQ. 'MA') THEN
C                MAX
                 VOUT(IX) = VALMAX 

              ELSEIF (MODE(1:2) .EQ. 'MI') THEN
C                MIN
                 VOUT(IX) = VALMIN 

              ELSEIF (MODE(1:1) .EQ. 'T') THEN
C                TOP-HAT
                 VOUT(IX) = VALMAX2 - VALMAX 

              ELSEIF (MODE(1:2) .EQ. 'VS') THEN
C                VARIANCE SMOOTHING
C                 VALT   = VALT   - VOC ** 2
C                 VALAVG = VALAVG - VOC 

                 SLOC = ABS(CONVAR * 
     &                  (VALT - CONAVG *(VALAVG * VALAVG)))
                 VT   = VALAVG * CONAVG

                 IF (((VOC - VT)**2) .GT. SLOC .AND. 
     &                SLOC .GT. SIGTSQ) THEN

C                    USE MEDIAN FROM NEIGHBORING VALUES
                     CALL FSORT(FMED,LMED)
                     VOUT(IX) = FMED(KMED)
C                    VOUT(IX) = (VALAVG - VOC) * CONVAR

CCC                  WRITE(NOUT,*) ' REPLACED(',IX,',',IY,'): ',VOC,
CCC  &                         '  WITH: ',VOUT(IX)

                     NREPL    = NREPL + 1
                 ELSE
C                    KEEP SAME VALUE
                     VOUT(IX) = VOC
                 ENDIF

              ELSEIF (MODE(1:1) .EQ. 'V') THEN
C                VARIANCE
                 VOUT(IX) =  CONVAR * (VALT - CONAVG*(VALAVG * VALAVG)) 

              ELSE
                 VOUT(IX) = VALT
              ENDIF
           ENDDO

C          OUTPUT IMAGE LINE
           IREC = (IZ - 1) * NROW + IY
           CALL WRTLIN(LUN2,VOUT,NSAM,IREC)
         ENDDO

         IF (MODE(1:2) .EQ. 'VS') THEN
C           VARIANCE SMOOTHING

            FNREPL = FLOAT(NREPL)
            CALL REG_SET_NSEL(1,1, FNREPL,0.0, 0.0, 0.0, 0.0,IRTFLG)

            WRITE(NOUT,*) ' PIXELS REPLACED: ',NREPL
         ENDIF
         END	



C       ------------------------- FILTER_HAT ----------------------------

	SUBROUTINE FILTER_HAT(RADIN,RADOUT,LXD2,LZD2,NEIGH,
     &                        VKERNAL,THREED)

	REAL, DIMENSION(NEIGH) :: VKERNAL

        LOGICAL :: THREED

        EPS = EPSILON(EPS)

        ILOC = 0

        DO MZ=-LZD2,LZD2
           DO MY=-LXD2,LXD2
              DO MX=-LXD2,LXD2
                 DIST = SQRT(FLOAT(MX)**2 + FLOAT(MY)**2 + FLOAT(MZ)**2)
                 ILOC = ILOC + 1

                 IF (DIST  .LT. RADIN) THEN
C                   INNER REGION
                    VKERNAL(ILOC) = 2

                 ELSEIF (DIST  .LT. RADOUT) THEN
C                   OUTER REGION
                    VKERNAL(ILOC) = 1

                 ELSE
C                   BORDER REGION
                    VKERNAL(ILOC) = 0
                 ENDIF
              ENDDO
           ENDDO
        ENDDO

        END


C       ------------------------- FILTER_FREI ----------------------------

	SUBROUTINE FILTER_FREI(NEIGH,VKERNAL)

	REAL, DIMENSION(NEIGH*8) :: VKERNAL

        REAL, DIMENSION(9) :: FC0,FC1,FC2,FC3,FC4,FC5,FC6,FC7,FC8

        DATA FC0/
     &        1, 1, 1,
     &        1, 1, 1,
     &        1, 1, 1/

        DATA FC1/
     &       -1,-1.414,-1,
     &        0,   0,   0,
     &        1, 1.414, 1/

        DATA FC2/
     &      -1,     0, -1,
     &      -1.414, 0, -1.414,
     &      -1,     0,  1/

        DATA FC3/
     &       0,     -1, -1.414,
     &       1,      0, -1 ,
     &      -1.4141, 1,  0/

        DATA FC4/
     &      -1.414, -1,  0,
     &      -1,      0, -1 ,
     &      0 ,      1, -1.414/
        DATA FC5/
     &        0, 1, 0,
     &       -1, 1, 1,
     &        0,-1, 0/

        DATA FC6/
     &       -1, 0, 1,
     &        0, 0, 0,
     &        1, 0,-1/

        DATA FC7/
     &        1,-2, 1,
     &       -2, 4,-2,
     &        1,-2, 1/

        DATA FC8/
     &       -2, 1,-2,
     &        1, 4, 1,
     &       -2, 1,-2/
 
        DO I = 1, NEIGH
           VKERNAL(I+NEIGH*0) = FC0(I)
           VKERNAL(I+NEIGH*1) = FC1(I)
           VKERNAL(I+NEIGH*2) = FC2(I)
           VKERNAL(I+NEIGH*3) = FC3(I)
           VKERNAL(I+NEIGH*4) = FC4(I)
           VKERNAL(I+NEIGH*5) = FC5(I)
           VKERNAL(I+NEIGH*6) = FC6(I)
           VKERNAL(I+NEIGH*7) = FC7(I)
           VKERNAL(I+NEIGH*8) = FC8(I)
        ENDDO

        END

C       ------------------------- FILTER_HURST ----------------------------

	SUBROUTINE FILTER_HURST(LXD2,THREED,NEIGH,ICAT,VKERNAL,VLOGDIST)

C       SURE, THIS IS SLOW, BUT IT IS NOT IMPORTANT!

	REAL, DIMENSION(NEIGH) :: VKERNAL,VLOGDIST

C       AUTOMATIC ARRAYS
        INTEGER, DIMENSION((LXD2+1)**2) :: IUNIQ,IUNIQSORT

C       THREED NOT IMPLEMENTED!!!
        LOGICAL :: THREED,NEWDIST

        LEND  = (2*LXD2+1)**2

C       FIND UNIQUE DISTANCES**2 TO ANY KERNAL ELEMENT
        ICAT = 0
        ILOC = 0
        DO MY=0,LXD2
           DO MX=0,MY
              IVAL     = MX**2 + MY**2
              ILOC     = ILOC + 1 
              NEWDIST  = .TRUE.
              IF (ICAT .GT. 0) THEN
                 DO I = 1,ICAT
                    IF (IUNIQ(I) .EQ. IVAL) THEN
                       NEWDIST = .FALSE.
                       EXIT
                    ENDIF
                 ENDDO
              ENDIF
              IF (NEWDIST .AND. IVAL .GT. 0) THEN
                 ICAT        = ICAT + 1
                 IUNIQ(ICAT) = IVAL
              ENDIF
           ENDDO
        ENDDO

C       SET KERNAL ELEMENTS TO CATEGORIES
        VKERNAL = 0
        ILOC    = 0
        DO MY=-LXD2,LXD2
           DO MX=-LXD2,LXD2
              ILOC = ILOC + 1
              IVAL = MX**2 + MY**2
              DO I=1,ICAT
                 IF (IVAL .EQ. IUNIQ(I)) THEN
                    VKERNAL(ILOC) = I
                    VLOGDIST(I)   = LOG(SQRT(FLOAT(IVAL)))
                    EXIT
                 ENDIF
              ENDDO
           ENDDO
        ENDDO

        END

C       ------------------------- FILTER_HURST_DO -----------------------

	SUBROUTINE FILTER_HURST_DO(VLOGDIST,ICAT,VALSMIN,VALSMAX,VAL)

C       SURE, THIS IS SLOW, BUT IT IS NOT IMPORTANT!

	REAL, DIMENSION(ICAT) :: VALSMIN,VALSMAX,VLOGDIST
	REAL, DIMENSION(2)    :: COEF

        EPS = EPSILON(EPS)

C       FIND RANGE FOR ALL CATEGORIES
        DO I = 1,ICAT
          IF ((VALSMAX(I) - VALSMIN(I)) .LE. EPS) THEN
              VAL = 0.0
              RETURN
           ENDIF
           VALSMAX(I) = LOG(VALSMAX(I) - VALSMIN(I))
        ENDDO

C       SUBROUTINE POLFIT(X,Y,NORD,N,C)
C       PURPOSE:  MAKES LEAST SQUARES FIT OF EXPERIMENTAL DATA IN
C                 X(N),Y(N) USING A POLYNOMIAL OF ARBITRARY ORDER>1
C       X     A REAL ARRAY DIMENSIONED N CONTAINING THE ABSCISSAE
C       Y     A REAL ARRAY DIMENSIONED N CONTAINING THE FUNCTION VALUES
C       NORD  ORDER OF POLYNOMIAL. NORD<N.
C       C     A REAL ARRAY CONTAINING THE NORD+1 COEFFICIENTS OF THE
C               POLYNOMIAL IN INCREASING ORDER

        CALL POLFIT(VLOGDIST,VALSMAX,1,ICAT,COEF)

C       RETURN SLOPE
        VAL = COEF(1)
        END
        

C       ------------------------- FILTER_LAHE -------------------------

	SUBROUTINE FILTER_LAHE(VIN,NSAM,NROW,NSLICE,LXD2,LYD2,LZD2,
     &                     NEIGH,MODE,LUN2,FMINT,FMAXT,NBINS)

	REAL, DIMENSION(NSAM,NROW,NSLICE) :: VIN

C       AUTOMATIC ARRAYS
	REAL, DIMENSION(NSAM)     :: VOUT
	INTEGER, DIMENSION(NBINS) :: HIST

	CHARACTER(LEN=2)          :: MODE 

C       HISTOGRAM BIN SIZE
        BINSPVAL = (NBINS - 1) / (FMAXT - FMINT)
        VALPPIX  = (FMAXT - FMINT) / NEIGH

        DO IZ=1,NSLICE
           DO IY=1,NROW  
              DO IX=1,NSAM

C                ZERO THE HIST ARRAY
                 HIST = 0

C                APPLY KERNAL
                 DO MZ=-LZD2,LZD2
                    IZT = MOD(IZ+MZ+NSLICE-1,NSLICE)+1 
 
                    DO MY=-LYD2,LYD2
                       IYT = MOD(IY+MY+NROW-1,NROW)+1

                       DO MX=-LXD2,LXD2
C                         VALUE FOR IMAGE UNDER CURRENT KERNAL ELEMENT
                          VOK = VIN(MOD(IX+MX+NSAM-1,NSAM)+1,IYT,IZT)
                          IBIN       = (VOK - FMINT) * BINSPVAL + 1.5
                          HIST(IBIN) = HIST(IBIN) + 1
                       ENDDO
                    ENDDO
                 ENDDO

C                NUMBER OF BINNED VALUES NEEDED TO GET CURRENT VALUE
C                ITARG=(VIN(IX,IY,IZ)-FMINT)*(NBINS-1)/(FMAXT-FMINT)+1.5
                 ITARG = (VIN(IX,IY,IZ) - FMINT) * BINSPVAL + 1.5
                 IGOT  = 0

                 DO I = 1,ITARG
                    IGOT = IGOT + HIST(I)
                 ENDDO

C                HISTOGRAM EQUALIZED OUTPUT VALUE
C                VOUT(IX) = (IGOT - 1) * ((FMAXT-FMINT)/NEIGH) + FMINT
                 VOUT(IX) = (IGOT - 1) * VALPPIX + FMINT
              ENDDO

C             OUTPUT IMAGE LINE
              IREC = (IZ - 1) * NROW + IY
              CALL WRTLIN(LUN2,VOUT,NSAM,IREC)
            ENDDO
         ENDDO

         END	
@


1.35
log
@abs in CE VS calc.
@
text
@a13 2
C=* FROM: SPIDER - MODULAR IMAGE PROCESSING SYSTEM.   AUTHOR: J.FRANK  *
C=* Copyright (C) 1985-2005  Health Research Inc.                      *
d15 5
a19 2
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *   
C=* ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
d21 1
a21 3
C=* Email:  spider@@wadsworth.org                                       *
C=*                                                                    *
C=* This program is free software; you can redistribute it and/or      *
d26 1
a26 1
C=* This program is distributed in the hope that it will be useful,    *
d28 1
a28 1
C=* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
a29 1
C=*                                                                    *
d31 1
a31 3
C=* along with this program; if not, write to the                      *
C=* Free Software Foundation, Inc.,                                    *
C=* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.      *
@


1.34
log
@GPL License fixed
@
text
@d811 1
a811 1
                 SLOC = (CONVAR * 
d968 1
a968 1
                 SLOC = (CONVAR * 
@


1.33
log
@HRI GPL License used
@
text
@a13 1
C * SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK       *
d17 1
a17 1
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *  
a36 6

C * COPYRIGHT (C)1985, 2002. HEALTH RESEARCH INCORPORATED (HRI),       *
C * ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C * THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HRI AND ARE NOT   *
C * TO BE DISCLOSED TO OTHERS OR USED FOR PURPOSES OTHER THAN INTENDED *
C * WITHOUT WRITTEN APPROVAL OF HRI.                                   *
@


1.32
log
@'CE VS' can return aregister of pixles replaced
@
text
@d15 24
@


1.31
log
@ce vs uses median filter now
@
text
@d11 1
d278 2
a279 2
              WRITE(NOUT,*) 'THIS FILTER IS NOT IMPLEMENTED IN 3D!' 
              WRITE(NOUT,*) 'VOLUME WILL BE PROCESSED SLICE-BY-SLICE' 
d319 2
a320 2
              WRITE(NOUT,*) 'THIS FILTER IS NOT IMPLEMENTED IN 3D!' 
              WRITE(NOUT,*) 'VOLUME WILL BE PROCESSED SLICE-BY-SLICE' 
d448 1
a448 1
90      FORMAT(' NEIGHBORHOOD: ',I4)
d701 1
d802 1
d823 9
d857 1
d962 5
a966 2
                     WRITE(NOUT,*) ' REPLACED(',IX,',',IY,'): ',VOC,
     &                         '  WITH: ',VOUT(IX)
d986 8
@


1.30
log
@ce vs
@
text
@d683 3
a685 1
	REAL, DIMENSION(NSAM,NROW,NSLICE) :: VIN
d689 2
a690 1
	REAL, DIMENSION(NSAM) :: VOUT
d692 1
a692 1
	CHARACTER(LEN=2)      :: MODE 
d695 1
a695 1
C          VARIANCE
d699 1
d712 1
d739 6
d797 3
a799 1
                     VOUT(IX) = VALAVG * CONAVG
d801 1
d828 3
a830 1
	REAL, DIMENSION(NSAM,NROW) ::             VIN
d833 3
a835 2
C       AUTOMATIC ARRAY
	REAL, DIMENSION(NSAM)      :: VOUT
d837 1
a837 1
	CHARACTER(LEN=2) ::           MODE 
d844 1
d856 1
d880 6
d897 1
d941 1
d945 6
a950 5
                     VOUT(IX) = (VALAVG - VOC) * CONVAR

                    write(6,*) 'replaced(',ix,',',iy,'): ',voc,
     &                         '  with: ',VOUT(IX)

d952 1
@


1.29
log
@ce vs
@
text
@d695 1
d781 2
a782 1
                 SLOC = CONVAR * (VALT - CONAVG *(VALAVG * VALAVG))
d784 3
a786 3
                 IF ((ABS(VOC) - SLOC) .GT. SLOC .AND. 
     &                SLOC .GT. SIGT) THEN
                     VOUT(IX) = VALAVG
d824 3
a826 3
           CONAVG  = 1.0 / FLOAT(NEIGH)
           CONVAR  = 1.0 / FLOAT(NEIGH - 1)

d909 10
a918 1
                 SLOC = CONVAR * (VALT - CONAVG *(VALAVG * VALAVG))
d920 3
a922 3
                 IF ((ABS(VOC) - SLOC) .GT. SLOC .AND. 
     &                SLOC .GT. SIGT) THEN
                     VOUT(IX) = VALAVG
d926 1
@


1.28
log
@stacks for some
@
text
@d41 1
d49 1
a49 1
     &                    MODE,FMINT,FMAXT)
d285 1
a285 1
     &          MODE(1:2) .EQ. 'LH') THEN
d287 1
a287 1
C          FILTER OVER SPECIFIED NEIGHBORHOOD
d363 1
a363 1
C          VARIANCE OVER A RECTILINEAR NEIGHBORHOOD
d470 1
a470 1
     &                  NEIGH,MODE,LUN2,FMINT)
d485 1
a485 1
     &                        LXD2,LYD2,NEIGH,MODE,LUN2,FMIN,ISLICE)
d681 1
a681 1
     &                     NEIGH,MODE,LUN2,FMINT)
d706 1
d778 11
a791 1

d810 1
a810 1
     &                      MODE,LUN2,FMINT,IZ)
d824 1
d835 1
d905 11
a915 1
                ELSEIF (MODE(1:1) .EQ. 'V') THEN
@


1.27
log
@stacks
@
text
@d61 1
a61 1
        LOGICAL          ::   THREED
d435 5
a439 3
C       LOAD INPUT VOLUME
        CALL REDVOL(LUN1,NSAM,NROW,1,NSLICE,VIN,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9999
d473 2
a474 1

d477 2
a478 1
              CALL GETSTACK(LUN1,LUN2,NSAM,IMGNUM,MAXIM,VERBOSE,IRTFLG)
d484 1
a484 1
     &                        LXD2,LYD2,NEIGH,MODE,LUN2,FMINT,ISLICE)
@


1.26
log
@subscript error on 'top hat'
@
text
@d10 1
d47 2
a48 1
	SUBROUTINE FILTER(LUN1,LUN2,NSAM,NROW,NSLICE,MODE,FMINT,FMAXT)
d452 1
a452 1
C          USES MULTIPLE KERNALS ON VOLUME
d465 1
a465 1
C          3D VOLUME
d470 12
a481 5
C          2D IMAGE OR SLICE BY SLICE
           DO ISLICE=1,NSLICE
              ILOC = (ISLICE - 1) * NROW * NSAM + 1
              CALL FILTER2(VIN(ILOC),NSAM,NROW,NSLICE,VKERNAL,LXD2,LYD2,
     &                  NEIGH,MODE,LUN2,FMINT,ISLICE)
@


1.25
log
@bad bug in 'CE VAR'

.\
@
text
@d699 1
a699 1
                 VOC     = VIN(IX,IY)    
@


1.24
log
@redvol parameters changed
@
text
@d6 1
a6 1
C                         TOP HAD NEIGH FIXED APR 2002 ArDean Leith    *
d9 1
d53 1
a53 1
	REAL, DIMENSION(9)  ::  GRAD2,GRAD2X,GRAD2Y,VARA2,LAPL2
d55 1
a55 1
	REAL, DIMENSION(27) ::  GRAD3,GRAD3X,GRAD3Y,GRAD3Z,VARA3,LAPL3
a63 5
c        DATA VARA2/ va2,1.0,va2,  1.0,-1.0,1.0,  va2,1.0,va2/
c
c        DATA VARA3/ va3,va2,va3,  va2,1.0,va2,   va3,va2,va3,
c     &              va2,1.0,va2,  1.0,1.0,1.0,   va2,1.0,va2,
c     &              va3,va2,va3,  va2,1.0,va2,   va3,va2,va3/
d361 1
a361 4
           DO I = 1, NEIGH
              VKERNAL(I) = 1.0
           ENDDO
           VKERNAL(NEIGH/2 + 1)   = - (NEIGH - 1)
d363 1
a363 1
        ELSEIF (MODE(1:1) .EQ. 'V'  .OR. MODE(1:1) .EQ. 'R' .OR.
d463 1
a463 1
C          VOLUME
d468 1
a468 1
C          2D IMAGE
d677 6
d688 8
a695 3
              IF (MODE(1:1) .EQ. 'R' .OR. MODE(1:1) .EQ. 'M' .or.
     &            MODE(1:1) .EQ. 'T') THEN
C                RANGE, MIN, MAX, OR TOP-HAT
d699 1
a699 1
                 VOC     = VIN(IX,IY,IZ)    
d715 2
a716 1
                       VALT = (VOK * VKERNAL(MX,MY,MZ)) ** 2
d763 4
d773 1
a773 1
C          OUTPUT IMAGE
d795 6
d805 7
a811 2
              IF (MODE(1:1) .EQ. 'R' .OR. MODE(1:1) .EQ. 'M' .or.
     &            MODE(1:1) .EQ. 'T') THEN
d829 2
a830 1
                       VALT = (VOK * VKERNAL(MX,MY)) ** 2
d878 4
d887 1
a887 1
C          OUTPUT IMAGE
@


1.23
log
@some bug fixes for hurst, tophat & frei
@
text
@d441 1
a441 1
        CALL REDVOL(LUN1,NSAM,NROW,NSLICE,VIN,IRTFLG)
@


1.22
log
@ce lahe fixec
@
text
@d27 1
d29 3
a31 2
C                          V : VARIANCE  - RECTILINEAR NEIGHBORHOOD
C                          R : RANGE     - RECTILINEAR NEIGHBORHOOD
d33 3
a35 2
C                          MA: MAXIMUM   - RECTILINEAR NEIGHBORHOOD
C                          LA: LAPLACIAN - RECTILINEAR NEIGHBORHOOD
a36 1
C                          p:  PREWITT   - 3x3 NEIGHBORHOOD
d38 1
a38 3
C                          F:  FREI-CHEN - 3x3 NEIGHBORHOOD
C                          RI: RIDGE FOLLOWING
C                          LH: LOCAL AREA HISTOGRAM EQUALIZATION
d239 2
a240 2
        IF (MODE(1:1) .EQ. 'T' .OR. MODE(1:1) .EQ. 'H') THEN
C          TOP-HAT, HURST OVER SPECIFIED NEIGHBORHOOD
d242 2
a243 1
11         CALL RDPRI1S(IDIAM,NOT_USED,'DIAMETER',IRTFLG)
d246 3
a248 2
           IF (IDIAM .LT. 1 .OR. MOD(IDIAM,2) .EQ. 0) THEN
              CALL ERRT(101,'DIAMETER MUST BE ODD  AND > 0',IDUM) 
d252 13
a264 10
           IF (MODE(1:1) .EQ. 'T') THEN
C             TOP-HAT
         
              IRADIN  = IDIAM / 2
              LX      = IDIAM * 2 + 1
              LY      = LX
              LZ      = LX
              IRADOUT = LX    / 2
              NEIGH   = LX ** 2
              IF (THREED) NEIGH = LX ** 3
d266 2
a267 8
           ELSE
C             HURST OVER SPECIFIED DIAMETER
              IF (THREED) THEN
                 WRITE(NOUT,*) 'THIS FILTER IS NOT IMPLEMENTED IN 3D!' 
                 WRITE(NOUT,*) 'VOLUME WILL BE PROCESSED SLICE-BY-SLICE' 
                 THREED = .FALSE.
                 LZ     = 1
              ENDIF
d269 12
a280 2
              LX      = IDIAM 
              NEIGH   = LX ** 2
d418 3
a420 1
	   CALL FILTER_HAT(IRADIN,IRADOUT,LXD2,NEIGH,VKERNAL,THREED)
d581 6
a586 1
                 VOUT(IX) = COS(SQRT(VAL1/VAL2))
d873 2
a874 1
	SUBROUTINE FILTER_HAT(IRADIN,IRADOUT,LXD2,NEIGH,VKERNAL,THREED)
d883 2
a884 2
        IF (THREED) THEN
           DO MZ=-LXD2,LXD2
d890 1
a890 1
                 IF (DIST  .LE. (IRADIN+EPS)) THEN
d894 1
a894 1
                 ELSEIF (DIST  .LE. (IRADOUT+EPS)) THEN
d904 1
a904 1
           ENDDO
d906 1
a906 13
        ELSE
           DO MY=-LXD2,LXD2
              DO MX=-LXD2,LXD2
                 DIST = SQRT(FLOAT(MX)**2 + FLOAT(MY)**2)
                 ILOC = ILOC + 1

                 IF (DIST  .LE. (IRADIN+EPS)) THEN
C                   INNER REGION
                    VKERNAL(ILOC) = 2

                 ELSEIF (DIST  .LE. (IRADOUT+EPS)) THEN
C                   INNER REGION
                    VKERNAL(ILOC) = 1
a907 7
                 ELSE
C                   BORDER REGION
                    VKERNAL(ILOC) = 0
                 ENDIF
              ENDDO
           ENDDO
        ENDIF
a908 1
        END
d983 2
a984 2
        INTEGER, DIMENSION(3 * (LXD2**2)):: IDIST
        LOGICAL :: THREED
d986 2
a987 2
C       ZERO IDIST ARRAY
        IDIST = 0
d989 1
a989 10
C       FIND DISTANCES**2 TO EACH KERNAL ELEMENT
        DO MZ=-LXD2,LXD2
           DO MY=-LXD2,LXD2
              DO MX=-LXD2,LXD2
                 IVAL = MX**2 + MY**2 
                 IF (THREED) IVAL = IVAL + MZ **2
                 IDIST(IVAL) = IVAL
              ENDDO
           ENDDO
        ENDDO
d991 1
a991 3
C       NUMBER THE DISTANCE CATEGORIES
        LEND = 2 * (LXD2**2)
        IF (THREED) LEND = 3 * (LXD2**2)
a992 9
        DO I = 1,LEND
           IF (IDIST(I) .GT. 0) THEN
              ICAT           = ICAT + 1
              VLOGDIST(ICAT) = LOG(SQRT(FLOAT(IDIST(I))))
              IDIST(I)       = ICAT
           ENDIF
        ENDDO

C       PUT CATEGORIZED DISTANCES IN KERNAL LOCATIONS 
d994 11
a1004 7
        IF (THREED) THEN
           DO MZ=-LXD2,LXD2
              DO MY=-LXD2,LXD2
                 DO MX=-LXD2,LXD2
                    IVAL          = MX**2 + MY**2 + MZ **2
                    ILOC          = ILOC + 1
                    VKERNAL(ILOC) = IDIST(IVAL)
d1006 5
a1010 1
              ENDDO
d1012 15
a1026 6
        ELSE
           DO MY=-LXD2,LXD2
              DO MX=-LXD2,LXD2
                 IVAL          = MX**2 + MY**2 
                 ILOC          = ILOC + 1
                 VKERNAL(ILOC) = IDIST(IVAL)
d1029 1
a1029 3
        ENDIF

        VKERNAL(NEIGH/2 + 1) =  0.0
@


1.21
log
@lahe
@
text
@d3 7
a9 7
C FILTER                  CREATED             MAR 2001 ARDEAN LEITH                  * 
C                         ADDED OPERATIONS    MAY 2001 ARDEAN LEITH         *
C                         3D FIXED           JUNE 2001 ARDEAN LEITH              *
C                         TOP HAD NEIGH FIXED APR 2002 ArDean Leith                                            *
C                         PRE & SOBEL 3D BUG  APR 2002 ArDean Leith
C                         LAHE                APR 2002 ArDean Leith
C    
d430 2
a431 5
        LOC = 1
        DO K = 1,NSLICE*NROW
           CALL REDLIN(LUN1,VIN(LOC),NSAM,K)
           LOC = LOC + NSAM
        ENDDO
d438 1
a438 1
90      FORMAT(' NEIGHBORHOOD: ',I3)
d1067 2
a1068 1
C       C     A REAL ARRAY CONTAINING THE NORD+1 COEFFICIENTS OF THEC               POLYNOMIAL IN INCREASING ORDER
d1088 1
a1088 1
	CHARACTER(LEN=2)      :: MODE 
d1091 2
a1092 3
        RANGE     = FMAXT - FMINT
        FF        = (NBINS - 1) / RANGE
        NBD_RANGE = NEIGH / RANGE 
a1095 1
                    
d1111 1
a1111 1
                          IBIN       = (VOK - FMINT) * FF + 1.5
d1118 2
a1119 2
                 ITARG = (VIN(IX,IY,IZ) - FMINT) * NBD_RANGE

d1122 1
a1122 1
                 DO I = 1,NBINS
a1123 1
                    IF (IGOT .GE. ITARG) EXIT
d1125 4
a1128 1
                 VOUT(IX) = FF * (I - 1) + FMINT
d1131 1
a1131 1
C             OUTPUT IMAGE
@


1.20
log
@sobel bug in 3d fixed
@
text
@d8 2
a9 1
C                                            *
d38 1
d45 1
a45 1
	SUBROUTINE FILTER(LUN1,LUN2,NSAM,NROW,NSLICE,MODE,FMINT)
d276 3
a278 2
     &          MODE(1:1) .EQ. '-'  .OR. MODE(1:1) .EQ. '-') THEN
C          RANGE, MAX, MIN, LAPLACIAN, VARIANCE 
d296 1
d299 8
d422 1
d443 6
a448 1
        IF ((NK .GT. 1) .AND. THREED) THEN
d1078 62
@


1.19
log
@top hat idiam wrong
@
text
@d7 2
d51 1
a51 1
	REAL, DIMENSION(9) ::  SOBX,SOBY,PREX,PREY
d233 2
@


1.18
log
@nloop,iloop_removed
@
text
@d3 4
a6 4
C FILTER                  CREATED MAR 01 ARDEAN LEITH                  * 
C                         ADDED OPERATIONS MAY 01 ARDEAN LEITH         *
C                         3D FIXED JUNE 2001 ARDEAN LEITH              *
C                                                                      *
d9 1
a9 1
C * COPYRIGHT (C)1985, 2001. HEALTH RESEARCH INCORPORATED (HRI),       *
d248 1
a248 1
              LX      = IDIAM + 6
d251 1
a251 1
              IRADOUT = LX / 2
@


1.17
log
@wrong number of args. on filter2 & filter3 calls
@
text
@d236 1
a236 1
11         CALL RDPRI1S(IDIAM,NLOOP,ILOOP,'DIAMETER',IRTFLG)
d275 1
a275 1
              CALL RDPRI3S(LX,LY,LZ,NLOOP,ILOOP,
d278 1
a278 1
              CALL RDPRIS(LX,LY,NLOOP,ILOOP,'NEIGHBORHOOD X & Y',IRTFLG)
@


1.16
log
@fixed gradients
@
text
@d442 1
a442 1
     &                  NEIGH,MODE,LUN2,FMINT,ICAT)
d449 1
a449 1
     &                  NEIGH,MODE,LUN2,FMINT,ICAT,ISLICE)
@


1.15
log
@iloc wrong
@
text
@d312 1
a312 1
              VKERNAL = GRAD3X
a315 1
           VKERNAL(NEIGH/2 + 1) = - (NEIGH - 1)
d320 1
a320 1
              VKERNAL = GRAD3Y
a323 1
           VKERNAL(NEIGH/2 + 1) = - (NEIGH - 1)
d327 1
a327 2
           VKERNAL = GRAD3Z
           VKERNAL(NEIGH/2 + 1) = - (NEIGH - 1)
d424 1
a424 1
90      FORMAT(' NUMBER OF NEIGHBORS: ',I3)
@


1.14
log
@*** empty log message ***
@
text
@d65 1
a65 1
C       SIMPLE 3X3 LAPLACIAN
d75 3
a77 3
        DATA GRAD2 / .7071, 1.0,  .7071,   
     &              1.0,   -1.0, 1.0,  
     &               .7071, 1.0,  .7071/
d80 3
a82 3
        DATA GRAD2X/ -.7071, 0.0,  .7071,  
     &              -1.0,    0.0, 1.0,  
     &               -.7071, 0.0,  .7071/
d85 2
a86 2
        DATA GRAD2Y/ .7071, 1.0,  .7071,  
     &              0.0,    0.0, 0.0,  
d437 1
a437 1
              ILOC = (ISLICE - 1) * NSLICE * NROW + 1
d450 1
a450 1
              ILOC = (ISLICE - 1) * NSLICE * NROW + 1
d648 1
a648 3
	REAL, DIMENSION(NSAM)      :: VOUT

	CHARACTER(LEN=2) ::           MODE 
d650 1
a650 1
        FCON = 1.0 / (NEIGH - 1)
@


1.13
log
@bad dimensions on sobx,soby,prex,prey
@
text
@d5 1
d256 7
a262 1
C             HURST OVER SPECIFIED NEIGHBORHOOD
d264 1
a264 1
              LX      = IDIAM * 2 + 1
a265 1
              IF (THREED) NEIGH = LX ** 3
d292 1
a292 2
C          RANGE, MAX, MIN, LAPLACIAN, OR VARIANCE 
C          FREI- CHEN FILTER OVER 3x3 NEIGHBORHOOD
d294 5
a298 2
              CALL ERRT(101,'VOLUMES NOT SUPPORTED, ONLY 2D',IDUM) 
              RETURN
d435 6
a440 3
C          USES MULTIPLE KERNALS ON IMAGE
           CALL FILTER2M(VIN,NSAM,NROW,NSLICE,VKERNAL,LXD2,LYD2,1,
     &                  NEIGH,MODE,NK,LUN2,ICAT)
d448 6
a453 3
C          IMAGE
           CALL FILTER2(VIN,NSAM,NROW,VKERNAL,LXD2,LYD2,NEIGH,MODE,
     &                  LUN2,FMINT,ICAT)
d465 1
a465 1
     &                     NEIGH,MODE,NKT,LUN2,ICAT)
d561 2
a562 1
           CALL WRTLIN(LUN2,VOUT,NSAM,IY)
d632 2
a633 1
           CALL WRTLIN(LUN2,VOUT,NSAM,IY)
d735 2
a736 1
           CALL WRTLIN(LUN2,VOUT,NSAM,IY)
d745 2
a746 2
	SUBROUTINE FILTER2(VIN,NSAM,NROW,VKERNAL,LXD2,LYD2,NEIGH,
     &                      MODE,LUN2,FMINT)
d833 2
a834 1
           CALL WRTLIN(LUN2,VOUT,NSAM,IY)
@


1.12
log
@ce hurst
@
text
@d48 1
a48 1
	REAL, DIMENSION(27) ::  SOBX,SOBY,PREX,PREY
@


1.11
log
@ce ridge
@
text
@d4 1
a4 1
C                         ADDED OPERATIONS MAY 01 ARDEAN LEITH
d223 5
a227 1
        NK = 1
d229 1
a229 1
     &      MODE(1:1) .EQ. '*') NK = 2
d232 2
a233 2
        IF (MODE(1:1) .EQ. 'T') THEN
C          TOP-HAT OVER SPECIFIED NEIGHBORHOOD
d242 19
a260 8
  
           IRADIN  = IDIAM / 2
           LX      = IDIAM + 6
           LY      = LX
           LZ      = LX
           IRADOUT = LX / 2
           NEIGH   = LX ** 2
           IF (THREED) NEIGH = LX ** 3
d263 3
a265 2
     &          MODE(1:1) .EQ. 'L'  .OR. MODE(1:1) .EQ. 'V') THEN
C          RANGE, MAX, MIN, LAPLACIAN, OR VARIANCE 
d294 1
a294 1

d390 6
d403 1
a403 1
           CALL ERRT(46,'CE, VIN3 & VK',IER)
d424 1
a424 1
     &                  NEIGH,MODE,NK,LUN2)
d429 1
a429 1
     &                  NEIGH,MODE,NK,LUN2)
d434 1
a434 1
     &                  NEIGH,MODE,LUN2,FMINT)
d439 1
a439 1
     &                  LUN2,FMINT)
d451 1
a451 1
     &                     NEIGH,MODE,NK,LUN2)
d454 1
a454 1
	REAL, DIMENSION(-LXD2:LXD2,-LYD2:LYD2,NK) :: VKERNAL
d457 4
a460 1
	REAL, DIMENSION(NSAM)      :: VOUT
d462 2
a463 1
	CHARACTER(LEN=2) ::           MODE 
d474 6
d496 11
a506 1
                       VALT = VALT + VOK * VKERNAL(MX,MY,KER)
d514 1
a514 1
C                   SOBAL OR PREWITT
d530 1
a530 1
C                SOBAL OR PREWITT
d532 7
a538 1
              ELSEIF (MODE(1:1) .EQ. 'F') THEN
d555 1
a555 1
     &                     NEIGH,MODE,NK,LUN2)
d558 1
a558 1
	REAL, DIMENSION(-LXD2:LXD2,-LYD2:LYD2,-LZD2:LZD2,NK) :: VKERNAL
d565 3
d601 1
a601 1
C                   SOBAL OR PREWITT
d609 1
a609 1
C                SOBAL OR PREWITT
d779 1
d946 97
@


1.10
log
@frei-chen bug fixed
@
text
@d22 1
d33 1
d40 1
a40 1
	SUBROUTINE FILTER(LUN1,LUN2,NSAM,NROW,NSLICE,MODE)
d247 2
a248 2
        ELSEIF (MODE(1:1) .EQ. 'R' .OR. MODE(1:1) .EQ. 'M' .OR.
     &          MODE(1:1) .EQ. 'L' .OR. MODE(1:1) .EQ. 'V') THEN
d326 1
a326 1
C          RANGE, MAX. OR MIN. OVER A RECTILINEAR NEIGHBORHOOD
d330 1
a330 1
           VKERNAL(NEIGH/2 + 1)   = 0.0
d412 1
a412 1
     &                  NEIGH,MODE,LUN2)
d416 2
a417 1
           CALL FILTER2(VIN,NSAM,NROW,VKERNAL,LXD2,LYD2,NEIGH,MODE,LUN2)
d447 1
d575 1
a575 1
     &                     NEIGH,MODE,LUN2)
d598 1
d618 1
a618 1
C                      RANGE, MIN., OR MAX.
d638 1
a638 1
              IF (MODE(1:1) .EQ. 'R') THEN
d642 7
d678 1
a678 1
     &                      MODE,LUN2)
d694 1
a694 1
C                RANGE, MIN, MAX, OR TOP-HAT
d698 1
d715 1
a715 1
C                      RANGE, MIN., OR MAX.
d722 1
d725 1
d729 1
a729 1
C                      USE SUM OF KERNAL PRODUCTS
d735 1
a735 1
              IF (MODE(1:1) .EQ. 'R') THEN
d739 7
@


1.9
log
@*** empty log message ***
@
text
@d439 1
a439 1
              VALT = 0.0
d444 4
a447 1
                 VALMAX = -VALMIN
d452 1
d470 8
d488 1
a488 1
                 VOUT(IX) = COS(SQRT(VALT))
@


1.8
log
@added sobel + prewitt
@
text
@d22 10
a31 6
C                          G : GRADIENT OVER 3x3 NEIGHBORHOOD
C                          V : VARIANCE OVER RECTILINEAR NEIGHBORHOOD
C                          R : RANGE OVER    RECTILINEAR NEIGHBORHOOD
C                          MI: MINIMUM OVER  RECTILINEAR NEIGHBORHOOD
C                          MA: MAXIMUM OVER  RECTILINEAR NEIGHBORHOOD
C                          LA: LAPLACIAN OVER RECTILINEAR NEIGHBORHOOD
d35 1
a35 1
C                                                                     *
d46 1
d48 1
a48 1
	REAL, DIMENSION(27) ::  SOBX,SOBY,SOBz,prex,prey,prez
d88 1
a88 1
     &       .57735,.7071,.57735, .7071,1.0,.7071, .57735,.7071,.57735,
d90 1
a90 1
     &       .57735,.7071,.57735, .7071,1.0,.7071, .57735,.7071,.57735/
d114 7
a120 2
     &        0, 0, 0, 
     &        0, 0, 0, 
d122 6
d129 1
d132 3
a134 3
     &        0, 0, 0, 
     &        0, 0, 0, 
     &        0, 0, 0/
d136 3
a138 4
C       SOBEL Y MASK
        DATA SOBY/
     &        0, 0, 0, 
     &        0, 0, 0, 
d140 1
d146 9
a154 9
     &        0, 0, 0, 
     &        0, 0, 0, 
     &        0, 0, 0/

C       SOBEL Z MASK
         DATA SOBZ/
     &        0, 1, 0, 
     &        0, 2, 0, 
     &        0, 1, 0,
d160 3
a162 3
     &        0,-1, 0, 
     &        0,-2, 0, 
     &        0,-1, 0/
d166 7
a172 2
     &        0, 0, 0, 
     &        0, 0, 0, 
d174 8
d185 2
a186 3
     &        0, 0, 0, 
     &        0, 0, 0, 
     &        0, 0, 0/
d188 6
a193 4
C       PREWITT Y MASK
        DATA PREY/
     &        0, 0, 0, 
     &        0, 0, 0, 
d195 1
d198 6
a204 9
     &        0, 0, 0, 
     &        0, 0, 0, 
     &        0, 0, 0/

C       PREWITT Z MASK
         DATA PREZ/
     &        0, 1, 0, 
     &        0, 1, 0, 
     &        0, 1, 0,
d208 3
a210 3
     &        0,-1, 0, 
     &        0,-1, 0, 
     &        0,-1, 0/
d219 2
d222 22
a243 1
        IF (MODE(1:1) .EQ. 's' .OR. MODE(1:1) .EQ. 'P') NK = 2
d245 1
a245 1
        IF (MODE(1:1) .EQ. 'R' .OR. MODE(1:1) .EQ. 'M' .OR.
d265 9
a275 1
        NEIGH = LX * LY * LZ
d337 1
a337 1
        ELSEIF (MODE(1:2) .EQ. 'S') THEN
d339 36
a374 5
           DO I = 1, NEIGH
              VKERNAL(I)       = SOBX(I)
              VKERNAL(I+NEIGH) = SOBY(I)
              IF (THREED) VKERNAL(I+2*NEIGH) = SOBZ(I)
           ENDDO
d395 1
a395 1
90      FORMAT('Number of neighbors: ',I3)
d397 2
a398 1
        IF (MODE .eq. 'S') THEN
d402 5
d423 65
a500 2
        FCON = 1.0 / (NEIGH - 1)

d511 1
a511 1
                 VALMAX = -TINY(VALMIN)
d571 1
a571 1
        DO IZ=1,NCLICE
d576 6
a581 4
              IF (MODE(1:1) .EQ. 'R' .OR. MODE(1:1) .EQ. 'M') THEN
C                RANGE
                 VALMIN = HUGE(VALMIN)
                 VALMAX = -TINY
d605 8
d614 1
d633 4
d656 2
a657 2
	REAL, DIMENSION(NSAM,NROW) :: VIN
	REAL, DIMENSION(-LXD2:LXD2,-LYD2:LYD2)     :: VKERNAL
a663 2
        FCON = 1.0 / (NEIGH - 1)

d668 6
a673 4
              IF (MODE(1:1) .EQ. 'R' .OR. MODE(1:1) .EQ. 'M') THEN
C                RANGE
                 VALMIN = HUGE(VALMIN)
                 VALMAX = -TINY
d694 7
d720 4
d734 126
@


1.7
log
@tiny was bad
@
text
@d43 1
d107 75
d190 2
d193 3
a195 16

        IF (MODE(1:1) .EQ. 'V') THEN
C          VARIANCE OVER A RECTILINEAR NEIGHBORHOOD

           IF (THREED) THEN
              CALL RDPRI3S(LX,LY,LZ,NLOOP,ILOOP,
     &           'NEIGHBORHOOD X, Y, & Z',IRTFLG)
           ELSE
              CALL RDPRIS(LX,LY,NLOOP,ILOOP,'NEIGHBORHOOD X & Y',IRTFLG)
              LZ = 1
           ENDIF
           IF (IRTFLG .NE. 0) GOTO 9999

        ELSEIF (MODE(1:1) .EQ. 'R' .OR. MODE(1:1) .EQ. 'M' .OR.
     &          MODE(1:1) .EQ. 'L') THEN
C          RANGE, MAX, MIN & LAPLACIAN 
d217 1
a217 1
 	ALLOCATE(VKERNAL(NEIGH),STAT=IRTFLG)
d262 2
a263 2
        ELSEIF ((MODE(1:1) .EQ. 'V'  .OR. MODE(1:1) .EQ. 'R' .or.
     &          (MODE(1:2) .EQ. 'MA' .OR. MODE(1:2) .EQ. 'MI')) THEN
a275 1
       ENDIF
d277 8
d303 8
a310 1
        IF (THREED) THEN
d325 72
a396 1
C       ------------------------- FILTER2 -----------------------------
d398 2
a399 2
	SUBROUTINE FILTER2(VIN,NSAM,NROW,VKERNAL,LXD2,LYD2,NEIGH,
     &                      MODE,LUN2)
d401 2
a402 2
	REAL, DIMENSION(NSAM,NROW) :: VIN
	REAL, DIMENSION(-LXD2:LXD2,-LYD2:LYD2)     :: VKERNAL
d411 1
d418 2
a419 2
                 VALMIN =  HUGE(VALMIN)
                 VALMAX = -TINY(VALMIN)
d422 4
a425 4
C             FIND CURRENT CENTRAL VALUE * CENTRAL KERNAL VALUE
              VOC  = VIN(IX,IY) * VKERNAL(0, 0)

C             APPLY KERNAL 
d431 1
a431 1
                    VOK = VIN(MOD(IX+MX+NSAM-1,NSAM)+1,IYT)
d435 1
a435 1
                       VALT = (VOK * VKERNAL(MX,MY)) ** 2
d444 1
a444 2
C                      USE SUM OF KERNAL PRODUCTS
                       VALT = VALT + VOK * VKERNAL(MX,MY)
d448 1
d465 2
a466 1
           ENDDO
d471 1
d475 2
a476 1
C       ------------------------- FILTER3 -----------------------------
d478 2
a479 2
	SUBROUTINE FILTER3(VIN,NSAM,NROW,NSLICE,VKERNAL,LXD2,LYD2,LZD2,
     &                     NEIGH,MODE,LUN2)
d481 2
a482 2
	REAL, DIMENSION(NSAM,NROW,NSLICE) :: VIN
	REAL, DIMENSION(-LXD2:LXD2,-LYD2:LYD2,-LZD2:LZD2) :: VKERNAL
a490 1
        DO IZ=1,NSLICE
d497 2
a498 2
                 VALMIN =  HUGE(VALMIN)
                 VALMAX = -TINY(VALMIN)
d501 1
a501 7
C             FIND CURRENT CENTRAL VALUE * CENTRAL KERNAL VALUE
              VOC  = VIN(IX,IY,IZ) * VKERNAL(0, 0, 0)

C             APPLY KERNAL
              DO MZ=-LZD2,LZD2
              IZT = MOD(IZ+MZ+NSLICE-1,NSLICE)+1 
 
d507 1
a507 1
                    VOK = VIN(MOD(IX+MX+NSAM-1,NSAM)+1,IYT,IZT)
d511 1
a511 1
                       VALT = (VOK * VKERNAL(MX,MY,MZ)) ** 2
d520 2
a521 1
                       VALT = VALT + VOK * VKERNAL(MX,MY,MZ)
a524 1
              ENDDO
d541 1
a541 2
 
          ENDDO
a545 1
         ENDDO
a547 2


@


1.6
log
@slice bug
@
text
@d267 2
a268 2
                 VALMIN = HUGE(VALMIN)
                 VALMAX = -TINY
d344 2
a345 2
                 VALMIN = HUGE(VALMIN)
                 VALMAX = -TINY
@


1.5
log
@*** empty log message ***
@
text
@d337 1
a337 1
        DO IZ=1,NCLICE
@


1.4
log
@added min, max & laplacian
@
text
@d5 1
a5 1
C                                             *
d22 6
a27 6
C                          G : GRADIENT OVER A 3x3 NEIGHBORHOOD
C                          V : VARIANCE OVER A RECTILINEAR NEIGHBORHOOD
C                          R : RANGE OVER A RECTILINEAR NEIGHBORHOOD
C                          MI: MINIMUM OVER A RECTILINEAR NEIGHBORHOOD
C                          MA: MAXIMUM OVER A RECTILINEAR NEIGHBORHOOD
C                          LA: LAPLACIAN OVER A 3x3 NEIGHBORHOOD
a28 1
C
d41 2
a42 2
	REAL, DIMENSION(9)  ::  GRAD2,GRAD2X,GRAD2Y,VARA2,lapl2
	REAL, DIMENSION(27) ::  GRAD3,GRAD3X,GRAD3Y,GRAD3Z,VARA3,lapl3
a114 3
        IF (MODE(1:1) .EQ. 'G') THEN
C          GRADIENT OVER A 3x3 NEIGHBORHOOD
           CONTINUE
d116 1
a116 1
        ELSEIF (MODE(1:1) .EQ. 'V') THEN
d128 5
a132 2
        ELSEIF (MODE(1:1) .EQ. 'R' .OR. MODE(1:1) .EQ. 'M') THEN
C          RANGE FILTER OVER SPECIFIED NEIGHBORHOOD
d206 6
a211 7
C          LAPLACIAN  OVER A RECTILINE3X3AR NEIGHBORHOOD
           IF (THREED) THEN
              VKERNAL = LAPL2
           ELSE
              VKERNAL = LAPL3
           ENDIF
        ENDIF
@


1.3
log
@added range
@
text
@d4 2
a5 1
C                                                                      *
d8 1
a8 1
C * COPYRIGHT (C)1985, 1999. HEALTH RESEARCH INCORPORATED (HRI),       *
d17 6
a22 2
C  PARAMETERS:
C              MODE        G : GRADIENT OVER A 3x3 NEIGHBORHOOD
d25 3
d30 2
a31 2
C  PURPOSE: ALTER CONTRAST IN AN IMAGE OR VOLUME USING VARIANCE
C           OR GRADIENT FILTERS
d42 2
a43 2
	REAL, DIMENSION(9)  ::  GRAD2,GRAD2X,GRAD2Y,VARA2
	REAL, DIMENSION(27) ::  GRAD3,GRAD3X,GRAD3Y,GRAD3Z,VARA3
d57 23
a79 1
        DATA GRAD2 / .7071,1.0,.7071,   1.0,-1.0,1.0,  .7071,1.0,.7071/
d81 1
a81 5
        DATA GRAD2X/-.7071,0.0,.7071,  -1.0,0.0,1.0,  -.7071,0.0,.7071/

        DATA GRAD2Y/ .7071,1.0,.7071,   0.0,0.0,0.0,  
     &              -.7071,-1.0,-.7071/

d84 1
a84 1
     &              .7071,1.0,.7071, 1.0,1.0,1.0, .7071,1.0,.7071,
d87 1
a87 1

d89 3
a91 3
     &         -.57735,0.0,.57735, -.7071,0.0,.7071, -.57735,0.0,.57735,
     &         -.7071,0.0,.7071, -1.0,0.0,1.0, -.7071,0.0,.7071,
     &         -.57735,0.0,.57735, -.7071,0.0,.7071, -.57735,0.0,.57735/
d93 1
d95 3
a97 3
     &         .57735,.7071,.57735, 0.0,0.0,0.0, -.57735,-.7071,-.57735,
     &         .7071,1.0,.7071, 0.0,0.0,0.0, -.7071,-1.0,-.7071,
     &         .57735,.7071,.57735, 0.0,0.0,0.0, -.57735,-.7071,-.57735/
d99 1
d132 1
a132 1
        ELSEIF (MODE .EQ. 'R') THEN
d198 3
a200 2
        ELSEIF (MODE(1:1) .EQ. 'V' .OR. MODE(1:1) .EQ. 'R') THEN
C          RANGE OVER A RECTILINEAR NEIGHBORHOOD
d205 8
d267 1
a267 1
              IF (MODE(1:1) .EQ. 'R') THEN
d288 3
a290 2
                    ELSEIF (MODE(1:1) .EQ. 'R') THEN
C                      RANGE
d300 1
d304 9
d344 1
a344 1
              IF (MODE(1:1) .EQ. 'R') THEN
d368 3
a370 2
                    ELSEIF (MODE(1:1) .EQ. 'R') THEN
C                      RANGE
d384 9
d394 1
a394 1
                 VOUT(IX) = VALT  
d396 2
a397 1
           ENDDO
@


1.2
log
@3d
@
text
@d19 1
d82 1
d85 2
a86 1
        LZ = 3
d90 1
a90 6
           LX = 3
           LY = 3
           LZ = 1
           IF (THREED) THEN
              LZ = 3
           ENDIF
d104 6
a109 3
        ELSEIF (MODE .EQ. ' ') THEN
C          FILTER OVER SPECIFIED NEIGHBORHOOD
10         IF (.NOT. THREED) THEN
d111 1
a111 3
           ELSE
              CALL RDPRI3S(LX,LY,LZ,NLOOP,ILOOP,
     &          'NEIGHBORHOOD X, Y, & Z',IRTFLG)
d113 2
a114 1
           IF (IRTFLG .NE. 0) RETURN
d116 2
a117 2
     &         LY .LT. 3 .OR. MOD(LY,2) .EQ. 0 .OR. 
     &         LY .LT. 3 .OR. MOD(LY,2) .EQ. 0) THEN
d169 7
d230 5
d250 6
d262 6
a267 3

              VOUT(IX) = VALT

d296 5
d319 6
d332 3
a334 3
              IF (MODE(1:1) .EQ. 'V') THEN
C                USE SQ. FOR VARIANCE
                 VOUT(IX) = VALT
@


1.1
log
@Initial revision
@
text
@d239 1
d245 2
a246 6
              IF (MODE(1:1) .EQ. 'V') THEN
C                USE SQ. FOR VARIANCE
                 VOUT(IX) = VALT
              ELSE
                 VOUT(IX) = VALT  
              ENDIF
d257 2
a258 2
	SUBROUTINE FILTER3(VIN,NSAM,NROW,NSLICE,VKERNAL,LX,LY,LZ,
     &                     MODE,LUN2)
d261 4
a264 1
	REAL, DIMENSION(LX,LY,LZ) :: VKERNAL
d266 1
a266 2
C       LOCAL AUTOMATIC ARRAY
	REAL, DIMENSION(NSAM) :: VOUT
d268 1
a268 1
	CHARACTER(LEN=2) ::   MODE 
d270 29
a298 15
        DO N=1,NSLICE                    
           DO J=1,NROW                      
              DO I=1,NSAM
                 VALT = 0.0
                 DO MN=-LZ,LZ
                     MNM = MOD(N+MN+NSLICE-1,NSLICE)+1
                     DO MJ=-LY,LY
                        MJM = MOD(J+MJ+NROW-1,NROW)+1
                        DO MI=-LX,LX
                           VIM  = VIN(MOD(I+MI+NSAM-1,NSAM)+1,MJM,MNM)
                           VALT = VALT + VIM * VKERNAL(MI,MJ,MN)
                        ENDDO
                     ENDDO
                  ENDDO
               ENDDO
d300 6
a305 2
C              OUTPUT VOLUME
               CALL WRTLIN(LUN2,Y,NSAM,J+(N-1)*NROW)
d307 8
a314 2
        ENDDO
      END	
@
